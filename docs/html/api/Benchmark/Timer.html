<html><head><title>Benchmark::Timer</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:02 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#LICENSE'>LICENSE</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Benchmark::Timer - Benchmarking with statistical confidence</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  # Non-statistical usage
  use Benchmark::Timer;
  $t = Benchmark::Timer-&#62;new(skip =&#62; 1);

  for(1 .. 1000) {
      $t-&#62;start(&#39;tag&#39;);
      &#38;long_running_operation();
      $t-&#62;stop(&#39;tag&#39;);
  }
  print $t-&#62;report;

  # --------------------------------------------------------------------

  # Statistical usage
  use Benchmark::Timer;
  $t = Benchmark::Timer-&#62;new(skip =&#62; 1, confidence =&#62; 97.5, error =&#62; 2);

  while($t-&#62;need_more_samples(&#39;tag&#39;)) {
      $t-&#62;start(&#39;tag&#39;);
      &#38;long_running_operation();
      $t-&#62;stop(&#39;tag&#39;);
  }
  print $t-&#62;report;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>The Benchmark::Timer class allows you to time portions of code conveniently, as well as benchmark code by allowing timings of repeated trials. It is perfect for when you need more precise information about the running time of portions of your code than the Benchmark module will give you, but don&#39;t want to go all out and profile your code.</p>

<p>The methodology is simple; create a Benchmark::Timer object, and wrap portions of code that you want to benchmark with <code>start()</code> and <code>stop()</code> method calls. You can supply a tag to those methods if you plan to time multiple portions of code. If you provide error and confidence values, you can also use <code>need_more_samples()</code> to determine, statistically, whether you need to collect more data.</p>

<p>After you have run your code, you can obtain information about the running time by calling the <code>results()</code> method, or get a descriptive benchmark report by calling <code>report()</code>. If you run your code over multiple trials, the average time is reported. This is wonderful for benchmarking time-critical portions of code in a rigorous way. You can also optionally choose to skip any number of initial trials to cut down on initial case irregularities.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<p>In all of the following methods, <code>$tag</code> refers to the user-supplied name of the code being timed. Unless otherwise specified, $tag defaults to the tag of the last call to <code>start()</code>, or &#34;_default&#34; if <code>start()</code> was not previously called with a tag.</p>

<dl>
<dt><a name="$t_=_Benchmark::Timer-&#62;new(_[options]_);"
>$t = Benchmark::Timer-&#62;new( [options] );</a></dt>

<dd>
<p>Constructor for the Benchmark::Timer object; returns a reference to a timer object. Takes the following named arguments:</p>

<dl>
<dt><a name="skip"
>skip</a></dt>

<dd>
<p>The number of trials (if any) to skip before recording timing information.</p>

<dt><a name="minimum"
>minimum</a></dt>

<dd>
<p>The minimum number of trials to run.</p>

<dt><a name="error"
>error</a></dt>

<dd>
<p>A percentage between 0 and 100 which indicates how much error you are willing to tolerate in the average time measured by the benchmark. For example, a value of 1 means that you want the reported average time to be within 1% of the real average time. <code>need_more_samples()</code> will use this value to determine when it is okay to stop collecting data.</p>

<p>If you specify an error you must also specify a confidence.</p>

<dt><a name="confidence"
>confidence</a></dt>

<dd>
<p>A percentage between 0 and 100 which indicates how confident you want to be in the error measured by the benchmark. For example, a value of 97.5 means that you want to be 97.5% confident that the real average time is within the error margin you have specified. <code>need_more_samples()</code> will use this value to compute the estimated error for the collected data, so that it can determine when it is okay to stop.</p>

<p>If you specify a confidence you must also specify an error.</p>
</dd>
</dl>

<dt><a name="$t-&#62;reset;"
>$t-&#62;reset;</a></dt>

<dd>
<p>Reset the timer object to the pristine state it started in. Erase all memory of tags and any previously accumulated timings. Returns a reference to the timer object. It takes the same arguments the constructor takes.</p>

<dt><a name="$t-&#62;start($tag);"
>$t-&#62;start($tag);</a></dt>

<dd>
<p>Record the current time so that when <code>stop()</code> is called, we can calculate an elapsed time.</p>

<dt><a name="$t-&#62;stop($tag);"
>$t-&#62;stop($tag);</a></dt>

<dd>
<p>Record timing information. If $tag is supplied, it must correspond to one given to a previously called <code>start()</code> call. It returns the elapsed time in milliseconds. <code>stop()</code> croaks if the timer gets out of sync (e.g. the number of <code>start()</code>s does not match the number of <code>stop()</code>s.)</p>

<dt><a name="$t-&#62;need_more_samples($tag);"
>$t-&#62;need_more_samples($tag);</a></dt>

<dd>
<p>Compute the estimated error in the average of the data collected thus far, and return true if that error exceeds the user-specified error. If a $tag is supplied, it must correspond to one given to a previously called <code>start()</code> call.</p>

<p>This routine assumes that the data are normally distributed.</p>

<dt><a name="$t-&#62;report($tag);"
>$t-&#62;report($tag);</a></dt>

<dd>
<p>Returns a string containing a simple report on the collected timings for $tag. This report contains the number of trials run, the total time taken, and, if more than one trial was run, the average time needed to run one trial and error information. <code>report()</code> will complain (via a warning) if a tag is still active.</p>

<dt><a name="$t-&#62;reports;"
>$t-&#62;reports;</a></dt>

<dd>
<p>In a scalar context, returns a string containing a simple report on the collected timings for all tags. The report is a concatenation of the individual tag reports, in the original tag order. In an list context, returns a hash keyed by tag and containing reports for each tag. The return value is actually an array, so that the original tag order is preserved if you assign to an array instead of a hash. <code>reports()</code> will complain (via a warning) if a tag is still active.</p>

<dt><a name="$t-&#62;result($tag);"
>$t-&#62;result($tag);</a></dt>

<dd>
<p>Return the time it took for $tag to elapse, or the mean time it took for $tag to elapse once, if $tag was used to time code more than once. <code>result()</code> will complain (via a warning) if a tag is still active.</p>

<dt><a name="$t-&#62;results;"
>$t-&#62;results;</a></dt>

<dd>
<p>Returns the timing data as a hash keyed on tags where each value is the time it took to run that code, or the average time it took, if that code ran more than once. In scalar context it returns a reference to that hash. The return value is actually an array, so that the original tag order is preserved if you assign to an array instead of a hash.</p>

<dt><a name="$t-&#62;data($tag),_$t-&#62;data;"
>$t-&#62;data($tag), $t-&#62;data;</a></dt>

<dd>
<p>These methods are useful if you want to recover the full internal timing data to roll your own reports.</p>

<p>If called with a $tag, returns the raw timing data for that $tag as an array (or a reference to an array if called in scalar context). This is useful for feeding to something like the Statistics::Descriptive package.</p>

<p>If called with no arguments, returns the raw timing data as a hash keyed on tags, where the values of the hash are lists of timings for that code. In scalar context, it returns a reference to that hash. As with <code>results()</code>, the data is internally represented as an array so you can recover the original tag order by assigning to an array instead of a hash.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>Benchmarking is an inherently futile activity, fraught with uncertainty not dissimilar to that experienced in quantum mechanics. But things are a little better if you apply statistics.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENSE"
>LICENSE</a></h1>

<p>This code is distributed under the GNU General Public License (GPL). See the file LICENSE in the distribution, http://www.opensource.org/gpl-license.html, and http://www.opensource.org/.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>The original code (written before April 20, 2001) was written by Andrew Ho &#60;andrew@zeuscat.com&#62;, and is copyright (c) 2000-2001 Andrew Ho. Versions up to 0.5 are distributed under the same terms as Perl.</p>

<p>Maintenance of this module is now being done by David Coppit &#60;david@coppit.org&#62;.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../Benchmark.html" class="podlinkpod"
>Benchmark</a>, <a href="../Time/HiRes.html" class="podlinkpod"
>Time::HiRes</a>, <a href="../Time/Stopwatch.html" class="podlinkpod"
>Time::Stopwatch</a>, <a href="../Statistics/Descriptive.html" class="podlinkpod"
>Statistics::Descriptive</a></p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
