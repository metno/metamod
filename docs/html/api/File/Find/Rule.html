<html><head><title>File::Find::Rule</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:17 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Matching_Rules'>Matching Rules</a>
    <li class='indexItem indexItem2'><a href='#Query_Methods'>Query Methods</a>
    <li class='indexItem indexItem2'><a href='#Extensions'>Extensions</a>
    <li class='indexItem indexItem2'><a href='#Further_examples'>Further examples</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#TWO_FOR_THE_PRICE_OF_ONE'>TWO FOR THE PRICE OF ONE</a>
  <li class='indexItem indexItem1'><a href='#EXPORTS'>EXPORTS</a>
  <li class='indexItem indexItem1'><a href='#TAINT_MODE_INTERACTION'>TAINT MODE INTERACTION</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>File::Find::Rule - Alternative interface to File::Find</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use File::Find::Rule;
  # find all the subdirectories of a given directory
  my @subdirs = File::Find::Rule-&#62;directory-&#62;in( $directory );

  # find all the .pm files in @INC
  my @files = File::Find::Rule-&#62;file()
                              -&#62;name( &#39;*.pm&#39; )
                              -&#62;in( @INC );

  # as above, but without method chaining
  my $rule =  File::Find::Rule-&#62;new;
  $rule-&#62;file;
  $rule-&#62;name( &#39;*.pm&#39; );
  my @files = $rule-&#62;in( @INC );</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>File::Find::Rule is a friendlier interface to File::Find. It allows you to build rules which specify the desired files and directories.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<dl>
<dt><a name="new"
><code>new</code></a></dt>

<dd>
<p>A constructor. You need not invoke <code>new</code> manually unless you wish to, as each of the rule-making methods will auto-create a suitable object if called as class methods.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Matching_Rules"
>Matching Rules</a></h2>

<dl>
<dt><a name="name(_@patterns_)"
><code>name( @patterns )</code></a></dt>

<dd>
<p>Specifies names that should match. May be globs or regular expressions.</p>

<pre> $set-&#62;name( &#39;*.mp3&#39;, &#39;*.ogg&#39; ); # mp3s or oggs
 $set-&#62;name( qr/\.(mp3|ogg)$/ ); # the same as a regex
 $set-&#62;name( &#39;foo.bar&#39; );        # just things named foo.bar</pre>

<dt><a name="-X_tests"
>-X tests</a></dt>

<dd>
<p>Synonyms are provided for each of the -X tests. See <a href="../../perlfunc.html#-X" class="podlinkpod"
>&#34;-X&#34; in perlfunc</a> for details. None of these methods take arguments.</p>

<pre>  Test | Method               Test |  Method
 ------|-------------        ------|----------------
   -r  |  readable             -R  |  r_readable
   -w  |  writeable            -W  |  r_writeable
   -w  |  writable             -W  |  r_writable
   -x  |  executable           -X  |  r_executable
   -o  |  owned                -O  |  r_owned
       |                           |
   -e  |  exists               -f  |  file
   -z  |  empty                -d  |  directory
   -s  |  nonempty             -l  |  symlink
       |                       -p  |  fifo
   -u  |  setuid               -S  |  socket
   -g  |  setgid               -b  |  block
   -k  |  sticky               -c  |  character
       |                       -t  |  tty
   -M  |  modified                 |
   -A  |  accessed             -T  |  ascii
   -C  |  changed              -B  |  binary</pre>

<p>Though some tests are fairly meaningless as binary flags (<code>modified</code>, <code>accessed</code>, <code>changed</code>), they have been included for completeness.</p>

<pre> # find nonempty files
 $rule-&#62;file,
      -&#62;nonempty;</pre>

<dt><a name="stat_tests"
>stat tests</a></dt>

<dd>
<p>The following <code>stat</code> based methods are provided: <code>dev</code>, <code>ino</code>, <code>mode</code>, <code>nlink</code>, <code>uid</code>, <code>gid</code>, <code>rdev</code>, <code>size</code>, <code>atime</code>, <code>mtime</code>, <code>ctime</code>, <code>blksize</code>, and <code>blocks</code>. See <a href="../../perlfunc.html#stat" class="podlinkpod"
>&#34;stat&#34; in perlfunc</a> for details.</p>

<p>Each of these can take a number of targets, which will follow <a href="../../Number/Compare.html" class="podlinkpod"
>Number::Compare</a> semantics.</p>

<pre> $rule-&#62;size( 7 );         # exactly 7
 $rule-&#62;size( &#34;&#62;7Ki&#34; );    # larger than 7 * 1024 * 1024 bytes
 $rule-&#62;size( &#34;&#62;=7&#34; )
      -&#62;size( &#34;&#60;=90&#34; );    # between 7 and 90, inclusive
 $rule-&#62;size( 7, 9, 42 );  # 7, 9 or 42</pre>

<dt><a name="any(_@rules_)"
><code>any( @rules )</code></a></dt>

<dd>
<dt><a name="or(_@rules_)"
><code>or( @rules )</code></a></dt>

<dd>
<p>Allows shortcircuiting boolean evaluation as an alternative to the default and-like nature of combined rules. <code>any</code> and <code>or</code> are interchangeable.</p>

<pre> # find avis, movs, things over 200M and empty files
 $rule-&#62;any( File::Find::Rule-&#62;name( &#39;*.avi&#39;, &#39;*.mov&#39; ),
             File::Find::Rule-&#62;size( &#39;&#62;200M&#39; ),
             File::Find::Rule-&#62;file-&#62;empty,
           );</pre>

<dt><a name="none(_@rules_)"
><code>none( @rules )</code></a></dt>

<dd>
<dt><a name="not(_@rules_)"
><code>not( @rules )</code></a></dt>

<dd>
<p>Negates a rule. (The inverse of <code>any</code>.) <code>none</code> and <code>not</code> are interchangeable.</p>

<pre>  # files that aren&#39;t 8.3 safe
  $rule-&#62;file
       -&#62;not( $rule-&#62;new-&#62;name( qr/^[^.]{1,8}(\.[^.]{0,3})?$/ ) );</pre>

<dt><a name="prune"
><code>prune</code></a></dt>

<dd>
<p>Traverse no further. This rule always matches.</p>

<dt><a name="discard"
><code>discard</code></a></dt>

<dd>
<p>Don&#39;t keep this file. This rule always matches.</p>

<dt><a name="exec(_\&#38;subroutine(_$shortname,_$path,_$fullname_)_)"
><code>exec( \&#38;subroutine( $shortname, $path, $fullname ) )</code></a></dt>

<dd>
<p>Allows user-defined rules. Your subroutine will be invoked with <code>$_</code> set to the current short name, and with parameters of the name, the path you&#39;re in, and the full relative filename.</p>

<p>Return a true value if your rule matched.</p>

<pre> # get things with long names
 $rules-&#62;exec( sub { length &#62; 20 } );</pre>

<dt><a name="grep(_@specifiers_)"
><code>grep( @specifiers )</code></a></dt>

<dd>
<p>Opens a file and tests it each line at a time.</p>

<p>For each line it evaluates each of the specifiers, stopping at the first successful match. A specifier may be a regular expression or a subroutine. The subroutine will be invoked with the same parameters as an -&#62;exec subroutine.</p>

<p>It is possible to provide a set of negative specifiers by enclosing them in anonymous arrays. Should a negative specifier match the iteration is aborted and the clause is failed. For example:</p>

<pre> $rule-&#62;grep( qr/^#!.*\bperl/, [ sub { 1 } ] );</pre>

<p>Is a passing clause if the first line of a file looks like a perl shebang line.</p>

<dt><a name="maxdepth(_$level_)"
><code>maxdepth( $level )</code></a></dt>

<dd>
<p>Descend at most <code>$level</code> (a non-negative integer) levels of directories below the starting point.</p>

<p>May be invoked many times per rule, but only the most recent value is used.</p>

<dt><a name="mindepth(_$level_)"
><code>mindepth( $level )</code></a></dt>

<dd>
<p>Do not apply any tests at levels less than <code>$level</code> (a non-negative integer).</p>

<dt><a name="extras(_\%extras_)"
><code>extras( \%extras )</code></a></dt>

<dd>
<p>Specifies extra values to pass through to <code>File::File::find</code> as part of the options hash.</p>

<p>For example this allows you to specify following of symlinks like so:</p>

<pre> my $rule = File::Find::Rule-&#62;extras({ follow =&#62; 1 });</pre>

<p>May be invoked many times per rule, but only the most recent value is used.</p>

<dt><a name="relative"
><code>relative</code></a></dt>

<dd>
<p>Trim the leading portion of any path found</p>

<dt><a name="not_*"
><code>not_*</code></a></dt>

<dd>
<p>Negated version of the rule. An effective shortand related to ! in the procedural interface.</p>

<pre> $foo-&#62;not_name(&#39;*.pl&#39;);

 $foo-&#62;not( $foo-&#62;new-&#62;name(&#39;*.pl&#39; ) );</pre>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Query_Methods"
>Query Methods</a></h2>

<dl>
<dt><a name="in(_@directories_)"
><code>in( @directories )</code></a></dt>

<dd>
<p>Evaluates the rule, returns a list of paths to matching files and directories.</p>

<dt><a name="start(_@directories_)"
><code>start( @directories )</code></a></dt>

<dd>
<p>Starts a find across the specified directories. Matching items may then be queried using <a href="#match" class="podlinkpod"
>&#34;match&#34;</a>. This allows you to use a rule as an iterator.</p>

<pre> my $rule = File::Find::Rule-&#62;file-&#62;name(&#34;*.jpeg&#34;)-&#62;start( &#34;/web&#34; );
 while ( defined ( my $image = $rule-&#62;match ) ) {
     ...
 }</pre>

<dt><a name="match"
><code>match</code></a></dt>

<dd>
<p>Returns the next file which matches, false if there are no more.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Extensions"
>Extensions</a></h2>

<p>Extension modules are available from CPAN in the File::Find::Rule namespace. In order to use these extensions either use them directly:</p>

<pre> use File::Find::Rule::ImageSize;
 use File::Find::Rule::MMagic;

 # now your rules can use the clauses supplied by the ImageSize and
 # MMagic extension</pre>

<p>or, specify that File::Find::Rule should load them for you:</p>

<pre> use File::Find::Rule qw( :ImageSize :MMagic );</pre>

<p>For notes on implementing your own extensions, consult <a href="../../File/Find/Rule/Extending.html" class="podlinkpod"
>File::Find::Rule::Extending</a></p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Further_examples"
>Further examples</a></h2>

<dl>
<dt><a name="Finding_perl_scripts"
>Finding perl scripts</a></dt>

<dd>
<pre> my $finder = File::Find::Rule-&#62;or
  (
   File::Find::Rule-&#62;name( &#39;*.pl&#39; ),
   File::Find::Rule-&#62;exec(
                          sub {
                              if (open my $fh, $_) {
                                  my $shebang = &#60;$fh&#62;;
                                  close $fh;
                                  return $shebang =~ /^#!.*\bperl/;
                              }
                              return 0;
                          } ),
  );</pre>

<p>Based upon this message http://use.perl.org/comments.pl?sid=7052&#38;cid=10842</p>

<dt><a name="ignore_CVS_directories"
>ignore CVS directories</a></dt>

<dd>
<pre> my $rule = File::Find::Rule-&#62;new;
 $rule-&#62;or($rule-&#62;new
                -&#62;directory
                -&#62;name(&#39;CVS&#39;)
                -&#62;prune
                -&#62;discard,
           $rule-&#62;new);</pre>

<p>Note here the use of a null rule. Null rules match anything they see, so the effect is to match (and discard) directories called &#39;CVS&#39; or to match anything.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TWO_FOR_THE_PRICE_OF_ONE"
>TWO FOR THE PRICE OF ONE</a></h1>

<p>File::Find::Rule also gives you a procedural interface. This is documented in <a href="../../File/Find/Rule/Procedural.html" class="podlinkpod"
>File::Find::Rule::Procedural</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXPORTS"
>EXPORTS</a></h1>

<p><a href="#find" class="podlinkpod"
>&#34;find&#34;</a>, <a href="#rule" class="podlinkpod"
>&#34;rule&#34;</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TAINT_MODE_INTERACTION"
>TAINT MODE INTERACTION</a></h1>

<p>As of 0.32 File::Find::Rule doesn&#39;t capture the current working directory in a taint-unsafe manner. File::Find itself still does operations that the taint system will flag as insecure but you can use the <a href="#extras" class="podlinkpod"
>&#34;extras&#34;</a> feature to ask <a href="../../File/Find.html" class="podlinkpod"
>File::Find</a> to internally <code>untaint</code> file paths with a regex like so:</p>

<pre>    my $rule = File::Find::Rule-&#62;extras({ untaint =&#62; 1 });</pre>

<p>Please consult <a href="../../File/Find.html" class="podlinkpod"
>File::Find</a>&#39;s documentation for <code>untaint</code>, <code>untaint_pattern</code>, and <code>untaint_skip</code> for more information.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>The code makes use of the <code>our</code> keyword and as such requires perl version 5.6.0 or newer.</p>

<p>Currently it isn&#39;t possible to remove a clause from a rule object. If this becomes a significant issue it will be addressed.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Richard Clamp &#60;richardc@unixbeard.net&#62; with input gained from this use.perl discussion: http://use.perl.org/~richardc/journal/6467</p>

<p>Additional proofreading and input provided by Kake, Greg McCarroll, and Andy Lester andy@petdance.com.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright (C) 2002, 2003, 2004, 2006, 2009, 2011 Richard Clamp. All Rights Reserved.</p>

<p>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../../File/Find.html" class="podlinkpod"
>File::Find</a>, <a href="../../Text/Glob.html" class="podlinkpod"
>Text::Glob</a>, <a href="../../Number/Compare.html" class="podlinkpod"
>Number::Compare</a>, find(1)</p>

<p>If you want to know about the procedural interface, see <a href="../../File/Find/Rule/Procedural.html" class="podlinkpod"
>File::Find::Rule::Procedural</a>, and if you have an idea for a neat extension <a href="../../File/Find/Rule/Extending.html" class="podlinkpod"
>File::Find::Rule::Extending</a></p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
