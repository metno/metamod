<html><head><title>Template::Manual::Views</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:27 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#Overview'>Overview</a>
  <li class='indexItem indexItem1'><a href='#Views_as_Template_Collectors%2FProviders'>Views as Template Collectors/Providers</a>
  <li class='indexItem indexItem1'><a href='#Local_BLOCK_Definitions'>Local BLOCK Definitions</a>
  <li class='indexItem indexItem1'><a href='#Preserving_Variable_State_within_Views'>Preserving Variable State within Views</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Inheritance%2C_Delegation_and_Reuse'>Inheritance, Delegation and Reuse</a>
    <li class='indexItem indexItem2'><a href='#Self-Reference'>Self-Reference</a>
    <li class='indexItem indexItem2'><a href='#Saving_References_to_External_Views'>Saving References to External Views</a>
    <li class='indexItem indexItem2'><a href='#Views_as_Data_Presenters'>Views as Data Presenters</a>
  </ul>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Template::Manual::Views - Template Toolkit views (experimental)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Overview"
>Overview</a></h1>

<p>A view is effectively a collection of templates and/or variable definitions which can be passed around as a self-contained unit.
This then represents a particular interface or presentation style for other objects or items of data.</p>

<p>You can use views to implement custom &#34;skins&#34; for an application or content set.
You can use them to help simplify the presentation of common objects or data types.
You can even use then to automate the presentation of complex data structures such as that generated in an <code>XML::DOM</code> tree or similar.
You let an iterator do the walking,
and the view does the talking (or in this case,
the presenting).
Voila - you have view independant,
structure shy traversal using templates.</p>

<p>In general,
views can be used in a number of different ways to achieve several different things.
They elegantly solve some problems which were otherwise difficult or complicated,
and make easy some things that were previously hard.</p>

<p>At the moment,
they&#39;re still very experimental.
The directive syntax and underlying API are likely to change quite considerably over the next version or two.
Please be very wary about building your multi-million dollar e-commerce solutions based around this feature.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Views_as_Template_Collectors/Providers"
>Views as Template Collectors/Providers</a></h1>

<p>The <code>VIEW</code> directive starts a view definition and includes a name by which the view can be referenced.
The view definition continues up to the matching <code>END</code> directive.</p>

<pre>    [% VIEW myview %]
       ...
    [% END %]</pre>

<p>The first role of a view is to act as a collector and provider of templates. The <code>include()</code> method can be called on a view to effectively do the same thing as the <code>INCLUDE</code> directive. The template name is passed as the first argument, followed by any local variable definitions for the template.</p>

<pre>    [% myview.include(&#39;header&#39;, title=&#39;The Title&#39;) %]
    
    # equivalent to
    [% INCLUDE header  title=&#39;The Title&#39; %] </pre>

<p>Views accept a number of configuration options which can be used to control different aspects of their behaviour. The &#39;<code>prefix</code>&#39; and &#39;<code>suffix</code>&#39; options can be specified to add a fixed prefix and/or suffix to the name of each template.</p>

<pre>    [% VIEW myview 
         prefix = &#39;my/&#39;
         suffix = &#39;.tt2&#39; ;
       END
    %]</pre>

<p>Now the call</p>

<pre>    [% myview.include(&#39;header&#39;, title=&#39;The Title&#39;) %]</pre>

<p>is equivalent to</p>

<pre>    [% INCLUDE my/header.tt2  title=&#39;The Title&#39; %]</pre>

<p>Views provide an <code>AUTOLOAD</code> method which maps method names to the <code>include()</code> method. Thus, the following are all equivalent:</p>

<pre>    [% myview.include(&#39;header&#39;, title=&#39;Hello World&#39;) %]
    [% myview.include_header(title=&#39;Hello World&#39;) %]
    [% myview.header(title=&#39;Hello World&#39;) %]</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Local_BLOCK_Definitions"
>Local BLOCK Definitions</a></h1>

<p>A <code>VIEW</code> definition can include <code>BLOCK</code> definitions which remain local to the view. A request for a particular template will return a <code>BLOCK</code>, if defined, in preference to any other template of the same name.</p>

<pre>    [% BLOCK foo %]
       public foo block
    [% END %]
    
    [% VIEW plain %]
       [% BLOCK foo %]
       plain foo block
       [% END %]
    [% END %]
    
    [% VIEW fancy %]
       [% BLOCK foo %]
       fancy foo block
       [% END %]
    [% END %]
    
    [% INCLUDE foo %]       # public foo block
    [% plain.foo %]         # plain foo block 
    [% fancy.foo %]         # fancy foo block </pre>

<p>In addition to <code>BLOCK</code> definitions, a <code>VIEW</code> can contain any other template directives. The entire <code>VIEW</code> definition block is processed to initialise the view but no output is generated (this may change RSN - and get stored as &#39;<code>output</code>&#39; item, subsequently accessible as <code>[% view.output %]</code>). However, directives that have side-effects, such as those that update a variable, will have noticable consequences.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Preserving_Variable_State_within_Views"
>Preserving Variable State within Views</a></h1>

<p>Views can also be used to save the values of any existing variables, or to create new ones at the point at which the view is defined. Unlike simple template metadata (<code>META</code>) which can only contain static string values, the view initialisation block can contain any template directives and generate any kind of dynamic output and/or data items.</p>

<pre>    [% VIEW my_web_site %]
       [% view.title   = title or &#39;My Cool Web Site&#39; %]
       [% view.author  = &#34;$abw.name, $abw.email&#34; %]
       [% view.sidebar = INCLUDE my/sidebar.tt2 %]
    [% END %]</pre>

<p>Note that additional data items can be specified as arguments to the <code>VIEW</code> directive. Anything that doesn&#39;t look like a configuration parameter is assumed to be a data item. This can be a little hazardous, of course, because you never know when a new configuration item might get added which interferes with your data.</p>

<pre>    [% VIEW my_web_site
            # config options
            prefix = &#39;my/&#39;
            # misc data
            title   = title or &#39;My Cool Web Site&#39;
            author  = &#34;$abw.name, $abw.email&#34;
            sidebar = INCLUDE my/sidebar.tt2 
    %]
       ...
    [% END %]</pre>

<p>Outside of the view definition you can access the view variables as, for example:</p>

<pre>    [% my_web_site.title %]</pre>

<p>One important feature is the equivalence of simple variables and templates. You can implement the view item &#39;<code>title</code>&#39; as a simple variable, a template defined in an external file, possibly with a prefix/suffix automatically appended, or as a local <code>BLOCK</code> definition within the <code>[% VIEW %] ... [% END %]</code> definition. If you use the syntax above then the view will Do The Right Thing to return the appropriate output.</p>

<p>At the <code>END</code> of the <code>VIEW</code> definition the view is &#34;sealed&#34; to prevent you from accidentally updating any variable values. If you attempt to change the value of a variable after the <code>END</code> of the <code>VIEW</code> definition block then a <code>view</code> error will be thrown.</p>

<pre>    [% TRY; 
         my_web_site.title = &#39;New Title&#39;;
       CATCH;
         error;
       END
    %]</pre>

<p>The error above will be reported as:</p>

<pre>    view error - cannot update item in sealed view: title</pre>

<p>The same is true if you pass a parameter to a view variable. This is interpreted as an attempt to update the variable and will raise the same warning.</p>

<pre>    [% my_web_site.title(&#39;New Title&#39;) %]    # view error!</pre>

<p>You can set the <code>silent</code> parameter to have the view ignore these parameters and simply return the variable value.</p>

<pre>    [% VIEW my_web_site
            silent = 1
            title  = title or &#39;My Cool Web Site&#39;
            # ... ;
       END
    %]
    
    [% my_web_site.title(&#39;Blah Blah&#39;) %]   # My Cool Web Site</pre>

<p>Alternately, you can specify that a view is unsealed allowing existing variables to be updated and new variables defined.</p>

<pre>    [% VIEW my_web_site
            sealed = 0
            title  = title or &#39;My Cool Web Site&#39;
            # ... ;
       END
    %]
    
    [% my_web_site.title(&#39;Blah Blah&#39;) %]   # Blah Blah
    [% my_web_site.title %]                # Blah Blah</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Inheritance,_Delegation_and_Reuse"
>Inheritance, Delegation and Reuse</a></h2>

<p>Views can be inherited from previously defined views by use of the <code>base</code> parameter. This example shows how a base class view is defined which applies a <code>view/default/</code> prefix to all template names.</p>

<pre>    [% VIEW my.view.default
            prefix = &#39;view/default/&#39;;
       END
    %]</pre>

<p>Thus the directive:</p>

<pre>    [% my.view.default.header(title=&#39;Hello World&#39;) %]</pre>

<p>is now equivalent to:</p>

<pre>    [% INCLUDE view/default/header title=&#39;Hello World&#39; %]</pre>

<p>A second view can be defined which specifies the default view as a base.</p>

<pre>    [% VIEW my.view.fancy
            base   = my.view.default
            prefix = &#39;view/fancy/&#39;;
       END
    %]</pre>

<p>Now the directive:</p>

<pre>    [% my.view.fancy.header(title=&#39;Hello World&#39;) %]</pre>

<p>will resolve to:</p>

<pre>    [% INCLUDE view/fancy/header title=&#39;Hello World&#39; %]</pre>

<p>or if that doesn&#39;t exist, it will be handled by the base view as:</p>

<pre>    [% INCLUDE view/default/header title=&#39;Hello World&#39; %]</pre>

<p>When a parent view is specified via the <code>base</code> parameter, the delegation of a view to its parent for fetching templates and accessing user defined variables is automatic. You can also implement your own inheritance, delegation or other reuse patterns by explicitly delegating to other views.</p>

<pre>    [% BLOCK foo %]
       public foo block
    [% END %]
    
    [% VIEW plain %]
       [% BLOCK foo %]
       &#60;plain&#62;[% PROCESS foo %]&#60;/plain&#62;
       [% END %]
    [% END %]
    
    [% VIEW fancy %]
       [% BLOCK foo %]
       [% plain.foo | replace(&#39;plain&#39;, &#39;fancy&#39;) %]
       [% END %]
    [% END %]

    [% plain.foo %]     # &#60;plain&#62;public foo block&#60;/plain&#62;
    [% fancy.foo %]     # &#60;fancy&#62;public foo block&#60;/fancy&#62;</pre>

<p>Note that the regular <code>INCLUDE/PROCESS/WRAPPER</code> directives work entirely independantly of views and will always get the original, unaltered template name rather than any local per-view definition.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Self-Reference"
>Self-Reference</a></h2>

<p>A reference to the view object under definition is available with the <code>VIEW ... END</code> block by its specified name and also by the special name &#39;<code>view</code>&#39; (similar to the <code>my $self = shift;</code> in a Perl method or the &#39;<code>this</code>&#39; pointer in C++, etc). The view is initially unsealed allowing any data items to be defined and updated within the <code>VIEW ... END</code> block. The view is automatically sealed at the end of the definition block, preventing any view data from being subsequently changed.</p>

<p>(NOTE: sealing should be optional. As well as sealing a view to prevent updates (<code>SEALED</code>), it should be possible to set an option in the view to allow external contexts to update existing variables (<code>UPDATE</code>) or even create totally new view variables (<code>CREATE</code>)).</p>

<pre>    [% VIEW fancy %]
       [% fancy.title  = &#39;My Fancy Title&#39; %]
       [% fancy.author = &#39;Frank Open&#39; %]
       [% fancy.col    = { bg =&#62; &#39;#ffffff&#39;, bar =&#62; &#39;#a0a0ff&#39; } %]
    [% END %]</pre>

<p>or</p>

<pre>    [% VIEW fancy %]
       [% view.title  = &#39;My Fancy Title&#39; %]
       [% view.author = &#39;Frank Open&#39; %]
       [% view.col    = { bg =&#62; &#39;#ffffff&#39;, bar =&#62; &#39;#a0a0ff&#39; } %]
    [% END %]</pre>

<p>It makes no real difference in this case if you refer to the view by its name, &#39;<code>fancy</code>&#39;, or by the general name, &#39;<code>view</code>&#39;. Outside of the view block, however, you should always use the given name, &#39;<code>fancy</code>&#39;:</p>

<pre>    [% fancy.title  %]
    [% fancy.author %]
    [% fancy.col.bg %]</pre>

<p>The choice of given name or &#39;<code>view</code>&#39; is much more important when it comes to <code>BLOCK</code> definitions within a <code>VIEW</code>. It is generally recommended that you use &#39;<code>view</code>&#39; inside a <code>VIEW</code> definition because this is guaranteed to be correctly defined at any point in the future when the block gets called. The original name of the view might have long since been changed or reused but the self-reference via &#39;<code>view</code>&#39; should always be intact and valid.</p>

<p>Take the following VIEW as an example:</p>

<pre>    [% VIEW foo %]
       [% view.title = &#39;Hello World&#39; %]
       [% BLOCK header %]
       Title: [% view.title %]
       [% END %]
    [% END %]</pre>

<p>Even if we rename the view, or create a new <code>foo</code> variable, the header block still correctly accesses the <code>title</code> attribute of the view to which it belongs. Whenever a view <code>BLOCK</code> is processed, the <code>view</code> variable is always updated to contain the correct reference to the view object to which it belongs.</p>

<pre>    [% bar = foo %]
    [% foo = { title =&#62; &#34;New Foo&#34; } %]  # no problem
    [% bar.header %]                    # =&#62; Title: Hello World</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Saving_References_to_External_Views"
>Saving References to External Views</a></h2>

<p>When it comes to view inheritance, it&#39;s always a good idea to take a local copy of a parent or delegate view and store it as an attribute within the view for later use. This ensures that the correct view reference is always available, even if the external name of a view has been changed.</p>

<pre>    [% VIEW plain %]
       ...
    [% END %]
    
    [% VIEW fancy %]
       [% view.plain = plain %]
       [% BLOCK foo %]
       [% view.plain.foo | replace(&#39;plain&#39;, &#39;fancy&#39;) %]
       [% END %]
    [% END %]
    
    [% plain.foo %]         # =&#62; &#60;plain&#62;public foo block&#60;/plain&#62;
    [% plain = &#39;blah&#39; %]    # no problem
    [% fancy.foo %]         # =&#62; &#60;fancy&#62;public foo block&#60;/fancy&#62;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Views_as_Data_Presenters"
>Views as Data Presenters</a></h2>

<p>Another key role of a view is to act as a dispatcher to automatically apply the correct template to present a particular object or data item. This is handled via the <code>print()</code> method.</p>

<p>Here&#39;s an example:</p>

<pre>    [% VIEW foo %]
    
       [% BLOCK text %]
          Some text: [% item %]
       [% END %]
       
       [% BLOCK hash %]
          a hash:
          [% FOREACH key = item.keys.sort -%]
             [% key %] =&#62; [% item.$key %]
          [% END -%]
       [% END %]
       
       [% BLOCK list %]
          a list: [% item.sort.join(&#39;, &#39;) %]
       [% END %]
       
    [% END %]</pre>

<p>We can now use the view to print text, hashes or lists. The <code>print()</code> method includes the right template depending on the typing of the argument (or arguments) passed.</p>

<pre>    [% some_text = &#39;I read the news today, oh boy.&#39; %]
    [% a_hash    = { house =&#62; &#39;Lords&#39;, hall =&#62; &#39;Albert&#39; } %]
    [% a_list    = [ &#39;sure&#39;, &#39;Nobody&#39;, &#39;really&#39; ] %]
    
    [% view.print(some_text) %]
                        # Some text: I read the news today, oh boy.
                        
    [% view.print(a_hash) %]
                        # a hash:
                             hall =&#62; Albert
                             house =&#62; Lords
    [% view.print(a_list) %]
                        # a list: Nobody, really, sure</pre>

<p>You can also provide templates to print objects of any other class. The class name is mapped to a template name with all non-word character sequences such as &#39;<code>::</code>&#39; converted to a single &#39;<code>_</code>&#39;.</p>

<pre>    [% VIEW foo %]
       [% BLOCK Foo_Bar %]
          a Foo::Bar object: 
              thingies: [% view.print(item.thingies) %]
               doodahs: [% view.print(item.doodahs)  %]
       [% END %]
    [% END %]
    
    [% USE fubar = Foo::Bar(...) %]
    
    [% foo.print(fubar) %]</pre>

<p>Note how we use the view object to display various items within the objects (&#39;<code>thingies</code>&#39; and &#39;<code>doodahs</code>&#39;). We don&#39;t need to worry what kind of data these represent (text, list, hash, etc) because we can let the view worry about it, automatically mapping the data type to the correct template.</p>

<p>Views may define their own type =&#62; template map.</p>

<pre>    [% VIEW foo 
         map = { TEXT  =&#62; &#39;plain_text&#39;,
                 ARRAY =&#62; &#39;show_list&#39;, 
                 HASH  =&#62; &#39;show_hash&#39;,
                 My::Module =&#62; &#39;template_name&#39;
                 default    =&#62; &#39;any_old_data&#39;
               }
    %]
        [% BLOCK plain_text %]
           ...
        [% END %]
       
        ...
    [% END %]</pre>

<p>They can also provide a <code>default</code> map entry, specified as part of the <code>map</code> hash or as a parameter by itself.</p>

<pre>    [% VIEW foo 
         map     = { ... },
         default = &#39;whatever&#39;
    %]
       ...
    [% END %]</pre>

<p>or</p>

<pre>    [% VIEW foo %]
       [% view.map     = { ... }
          view.default = &#39;whatever&#39;
       %]
       ...
    [% END %]</pre>

<p>The <code>print()</code> method provides one more piece of magic. If you pass it a reference to an object which provides a <code>present()</code> method, then the method will be called passing the view as an argument. This then gives any object a chance to determine how it should be presented via the view.</p>

<pre>    package Foo::Bar;
    ...
    sub present {
        my ($self, $view) = @_;
        return &#34;a Foo::Bar object:\n&#34;
             . &#34;thingies: &#34; . $view-&#62;print($self-&#62;{ _THINGIES }) . &#34;\n&#34;
             . &#34;doodahs: &#34; . $view-&#62;print($self-&#62;{ _DOODAHS }) . &#34;\n&#34;;
    }</pre>

<p>The object is free to delve deeply into its innards and mess around with its own private data, before presenting the relevant data via the view. In a more complex example, a <code>present()</code> method might walk part of a tree making calls back against the view to present different nodes within the tree. We may not want to expose the internal structure of the tree (because that would break encapsulation and make our presentation code dependant on it) but we want to have some way of walking the tree and presenting items found in a particular manner.</p>

<p>This is known as <i>Structure Shy Traversal</i>. Our view object doesn&#39;t require prior knowledge about the internal structure of any data set to be able to traverse it and present the data contained therein. The data items themselves, via the <code>present()</code> method, can implement the internal iterators to guide the view along the right path to presentation happiness.</p>

<p>The upshot is that you can use views to greatly simplify the display of data structures like <code>XML::DOM</code> trees. The documentation for the <code>Template::Plugin::XML::DOM</code> module contains an example of this. In essence, it looks something like this:</p>

<p>XML source:</p>

<pre>    &#60;user name=&#34;Andy Wardley&#34;&#62;
        &#60;project id=&#34;iCan&#34; title=&#34;iCan, but theyCan&#39;t&#34;/&#62;
        &#60;project id=&#34;p45&#34;  title=&#34;iDid, but theyDidn&#39;t&#34;/&#62;
    &#60;/user&#62;</pre>

<p>TT View:</p>

<pre>    [% VIEW fancy %]
       [% BLOCK user %]
          User: [% item.name %]
                [% item.content(myview) %]
       [% END %]
       
       [% BLOCK project %]
            Project: [% project.id %] - [% project.name %]
       [% END %]
    [% END %]</pre>

<p>Generate view:</p>

<pre>    [% USE dom = XML.DOM %]
    [% fancy.print(dom.parse(xml_source)) %]</pre>

<p>Output:</p>

<pre>          User: Andy Wardley
            Project: iCan - iCan, but theyCan&#39;t
            Project: p45 - iDid, but theyDidn&#39;t</pre>

<p>The same approach can be applied to many other areas. Here&#39;s an example from the <code>File</code>/<code>Directory</code> plugins.</p>

<pre>    [% VIEW myview %]
       [% BLOCK file %]
          - [% item.name %]
       [% END %]
        
       [% BLOCK directory %]
          * [% item.name %]
            [% item.content(myview) FILTER indent %]
       [% END %]
    [% END %]
    
    [% USE dir = Directory(dirpath) %]
    [% myview.print(dir) %]</pre>

<p>And here&#39;s the same approach use to convert POD documentation to any other format via template.</p>

<pre>    [%  # load Pod plugin and parse source file into Pod Object Model
        USE Pod;
        pom = Pod.parse_file(my_pod_file);
        
        # define view to map all Pod elements to &#34;pod/html/xxx&#34; templates
        VIEW pod2html
            prefix=&#39;pod/html&#39;;
        END;
        
        # now print document via view (i.e. as HTML)
        pod2html.print(pom) 
    %]</pre>

<p>Here we simply define a template prefix for the view which causes the view to look for <code>pod/html/head1</code>, <code>pod/html/head2</code>, <code>pod/html/over</code> as templates to present the different sections of the parsed Pod document.</p>

<p>There are some examples in the Template Toolkit test suite: <em>t/pod.t</em> and <em>t/view.t</em> which may shed some more light on this. See the distribution sub-directory <em>examples/pod/html</em> for examples of Pod -&#62; HTML templates.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
