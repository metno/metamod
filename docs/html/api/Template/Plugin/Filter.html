<html><head><title>Template::Plugin::Filter</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:27 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#EXAMPLE'>EXAMPLE</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Template::Plugin::Filter - Base class for plugin filters</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    package MyOrg::Template::Plugin::MyFilter;
    
    use Template::Plugin::Filter;
    use base qw( Template::Plugin::Filter );
    
    sub filter {
        my ($self, $text) = @_;
        
        # ...mungify $text...
        
        return $text;
    }

    # now load it...
    [% USE MyFilter %]
    
    # ...and use the returned object as a filter
    [% FILTER $MyFilter %]
      ...
    [% END %]</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This module implements a base class for plugin filters. It hides the underlying complexity involved in creating and using filters that get defined and made available by loading a plugin.</p>

<p>To use the module, simply create your own plugin module that is inherited from the <code>Template::Plugin::Filter</code> class.</p>

<pre>    package MyOrg::Template::Plugin::MyFilter;
    
    use Template::Plugin::Filter;
    use base qw( Template::Plugin::Filter );</pre>

<p>Then simply define your <code>filter()</code> method. When called, you get passed a reference to your plugin object (<code>$self</code>) and the text to be filtered.</p>

<pre>    sub filter {
        my ($self, $text) = @_;
        
        # ...mungify $text...
        
        return $text;
    }</pre>

<p>To use your custom plugin, you have to make sure that the Template Toolkit knows about your plugin namespace.</p>

<pre>    my $tt2 = Template-&#62;new({
        PLUGIN_BASE =&#62; &#39;MyOrg::Template::Plugin&#39;,
    });</pre>

<p>Or for individual plugins you can do it like this:</p>

<pre>    my $tt2 = Template-&#62;new({
        PLUGINS =&#62; {
            MyFilter =&#62; &#39;MyOrg::Template::Plugin::MyFilter&#39;,
        },
    });</pre>

<p>Then you <code>USE</code> your plugin in the normal way.</p>

<pre>    [% USE MyFilter %]</pre>

<p>The object returned is stored in the variable of the same name, &#39;<code>MyFilter</code>&#39;. When you come to use it as a <code>FILTER</code>, you should add a dollar prefix. This indicates that you want to use the filter stored in the variable &#39;<code>MyFilter</code>&#39; rather than the filter named &#39;<code>MyFilter</code>&#39;, which is an entirely different thing (see later for information on defining filters by name).</p>

<pre>    [% FILTER $MyFilter %]
       ...text to be filtered...
    [% END %]</pre>

<p>You can, of course, assign it to a different variable.</p>

<pre>    [% USE blat = MyFilter %]
    
    [% FILTER $blat %]
       ...text to be filtered...
    [% END %]</pre>

<p>Any configuration parameters passed to the plugin constructor from the <code>USE</code> directive are stored internally in the object for inspection by the <code>filter()</code> method (or indeed any other method). Positional arguments are stored as a reference to a list in the <code>_ARGS</code> item while named configuration parameters are stored as a reference to a hash array in the <code>_CONFIG</code> item.</p>

<p>For example, loading a plugin as shown here:</p>

<pre>    [% USE blat = MyFilter &#39;foo&#39; &#39;bar&#39; baz = &#39;blam&#39; %]</pre>

<p>would allow the <code>filter()</code> method to do something like this:</p>

<pre>    sub filter {
        my ($self, $text) = @_;
        
        my $args = $self-&#62;{ _ARGS   };  # [ &#39;foo&#39;, &#39;bar&#39; ]
        my $conf = $self-&#62;{ _CONFIG };  # { baz =&#62; &#39;blam&#39; }
        
        # ...munge $text...
        
        return $text;
    }</pre>

<p>By default, plugins derived from this module will create static filters. A static filter is created once when the plugin gets loaded via the <code>USE</code> directive and re-used for all subsequent <code>FILTER</code> operations. That means that any argument specified with the <code>FILTER</code> directive are ignored.</p>

<p>Dynamic filters, on the other hand, are re-created each time they are used by a <code>FILTER</code> directive. This allows them to act on any parameters passed from the <code>FILTER</code> directive and modify their behaviour accordingly.</p>

<p>There are two ways to create a dynamic filter. The first is to define a <code>$DYNAMIC</code> class variable set to a true value.</p>

<pre>    package MyOrg::Template::Plugin::MyFilter;
    use base &#39;Template::Plugin::Filter&#39;;
    our $DYNAMIC = 1;</pre>

<p>The other way is to set the internal <code>_DYNAMIC</code> value within the <code>init()</code> method which gets called by the <code>new()</code> constructor.</p>

<pre>    sub init {
        my $self = shift;
        $self-&#62;{ _DYNAMIC } = 1;
        return $self;
    }</pre>

<p>When this is set to a true value, the plugin will automatically create a dynamic filter. The outcome is that the <code>filter()</code> method will now also get passed a reference to an array of postional arguments and a reference to a hash array of named parameters.</p>

<p>So, using a plugin filter like this:</p>

<pre>    [% FILTER $blat &#39;foo&#39; &#39;bar&#39; baz = &#39;blam&#39; %]</pre>

<p>would allow the <code>filter()</code> method to work like this:</p>

<pre>    sub filter {
        my ($self, $text, $args, $conf) = @_;
        
        # $args = [ &#39;foo&#39;, &#39;bar&#39; ]
        # $conf = { baz =&#62; &#39;blam&#39; }
    }</pre>

<p>In this case can pass parameters to both the USE and FILTER directives, so your filter() method should probably take that into account.</p>

<pre>    [% USE MyFilter &#39;foo&#39; wiz =&#62; &#39;waz&#39; %]
    
    [% FILTER $MyFilter &#39;bar&#39; biz =&#62; &#39;baz&#39; %]
       ...
    [% END %]</pre>

<p>You can use the <code>merge_args()</code> and <code>merge_config()</code> methods to do a quick and easy job of merging the local (e.g. <code>FILTER</code>) parameters with the internal (e.g. <code>USE</code>) values and returning new sets of conglomerated data.</p>

<pre>    sub filter {
        my ($self, $text, $args, $conf) = @_;
        
        $args = $self-&#62;merge_args($args); 
        $conf = $self-&#62;merge_config($conf);
        
        # $args = [ &#39;foo&#39;, &#39;bar&#39; ]      
        # $conf = { wiz =&#62; &#39;waz&#39;, biz =&#62; &#39;baz&#39; }        
        ...
    }</pre>

<p>You can also have your plugin install itself as a named filter by calling the <code>install_filter()</code> method from the <code>init()</code> method. You should provide a name for the filter, something that you might like to make a configuration option.</p>

<pre>    sub init {
        my $self = shift;
        my $name = $self-&#62;{ _CONFIG }-&#62;{ name } || &#39;myfilter&#39;;
        $self-&#62;install_filter($name);
        return $self;
    }</pre>

<p>This allows the plugin filter to be used as follows:</p>

<pre>    [% USE MyFilter %]
    
    [% FILTER myfilter %] 
       ... 
    [% END %]</pre>

<p>or</p>

<pre>    [% USE MyFilter name = &#39;swipe&#39; %]
        
    [% FILTER swipe %] 
       ... 
    [% END %]</pre>

<p>Alternately, you can allow a filter name to be specified as the first positional argument.</p>

<pre>    sub init {
        my $self = shift;
        my $name = $self-&#62;{ _ARGS }-&#62;[0] || &#39;myfilter&#39;;
        $self-&#62;install_filter($name);
        return $self;
    }

    [% USE MyFilter &#39;swipe&#39; %]
    
    [% FILTER swipe %]
       ...
    [% END %]</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXAMPLE"
>EXAMPLE</a></h1>

<p>Here&#39;s a complete example of a plugin filter module.</p>

<pre>    package My::Template::Plugin::Change;
    use Template::Plugin::Filter;
    use base qw( Template::Plugin::Filter );
    
    sub init {
        my $self = shift;
        
        $self-&#62;{ _DYNAMIC } = 1;
        
        # first arg can specify filter name
        $self-&#62;install_filter($self-&#62;{ _ARGS }-&#62;[0] || &#39;change&#39;);
        
        return $self;
    }
    
    sub filter {
        my ($self, $text, $args, $config) = @_;
        
        $config = $self-&#62;merge_config($config);
        my $regex = join(&#39;|&#39;, keys %$config);
        
        $text =~ s/($regex)/$config-&#62;{ $1 }/ge;
        
        return $text;
    }
    
    1;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Andy Wardley &#60;abw@wardley.org&#62; <a href="http://wardley.org/" class="podlinkurl"
>http://wardley.org/</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright (C) 1996-2007 Andy Wardley. All Rights Reserved.</p>

<p>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../../Template/Plugin.html" class="podlinkpod"
>Template::Plugin</a>, <a href="../../Template/Filters.html" class="podlinkpod"
>Template::Filters</a>, <a href="../../Template/Manual/Filters.html" class="podlinkpod"
>Template::Manual::Filters</a></p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
