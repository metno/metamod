<html><head><title>Template::Plugin</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:27 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#load(%24context)'>load($context)</a>
    <li class='indexItem indexItem2'><a href='#new(%24context%2C_%40params)'>new($context, @params)</a>
    <li class='indexItem indexItem2'><a href='#error(%24error)'>error($error)</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#DEEPER_MAGIC'>DEEPER MAGIC</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Template::Plugin - Base class for Template Toolkit plugins</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    package MyOrg::Template::Plugin::MyPlugin;
    use base qw( Template::Plugin );
    use Template::Plugin;
    use MyModule;
    
    sub new {
        my $class   = shift;
        my $context = shift;
        bless {
            ...
        }, $class;
    }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>A &#34;plugin&#34; for the Template Toolkit is simply a Perl module which exists in a known package location (e.g. <code>Template::Plugin::*</code>) and conforms to a regular standard, allowing it to be loaded and used automatically.</p>

<p>The <code>Template::Plugin</code> module defines a base class from which other plugin modules can be derived. A plugin does not have to be derived from Template::Plugin but should at least conform to its object-oriented interface.</p>

<p>It is recommended that you create plugins in your own package namespace to avoid conflict with toolkit plugins. e.g.</p>

<pre>    package MyOrg::Template::Plugin::FooBar;</pre>

<p>Use the <a href="../Template/Manual/Config%23PLUGIN_BASE.html" class="podlinkpod"
>PLUGIN_BASE</a> option to specify the namespace that you use. e.g.</p>

<pre>    use Template;
    my $template = Template-&#62;new({ 
        PLUGIN_BASE =&#62; &#39;MyOrg::Template::Plugin&#39;,
    });</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<p>The following methods form the basic interface between the Template Toolkit and plugin modules.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="load($context)"
>load($context)</a></h2>

<p>This method is called by the Template Toolkit when the plugin module is first loaded. It is called as a package method and thus implicitly receives the package name as the first parameter. A reference to the <a href="../Template/Context.html" class="podlinkpod"
>Template::Context</a> object loading the plugin is also passed. The default behaviour for the <code>load()</code> method is to simply return the class name. The calling context then uses this class name to call the <code>new()</code> package method.</p>

<pre>    package MyPlugin;
    
    sub load {               # called as MyPlugin-&#62;load($context)
        my ($class, $context) = @_;
        return $class;       # returns &#39;MyPlugin&#39;
    }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="new($context,_@params)"
>new($context, @params)</a></h2>

<p>This method is called to instantiate a new plugin object for the <code>USE</code> directive. It is called as a package method against the class name returned by <a href="../load().html" class="podlinkpod"
>load()</a>. A reference to the <a href="../Template/Context.html" class="podlinkpod"
>Template::Context</a> object creating the plugin is passed, along with any additional parameters specified in the <code>USE</code> directive.</p>

<pre>    sub new {                # called as MyPlugin-&#62;new($context)
        my ($class, $context, @params) = @_;
        bless {
            _CONTEXT =&#62; $context,
        }, $class;           # returns blessed MyPlugin object
    }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="error($error)"
>error($error)</a></h2>

<p>This method, inherited from the <a href="../Template/Base.html" class="podlinkpod"
>Template::Base</a> module, is used for reporting and returning errors. It can be called as a package method to set/return the <code>$ERROR</code> package variable, or as an object method to set/return the object <code>_ERROR</code> member. When called with an argument, it sets the relevant variable and returns <code>undef.</code> When called without an argument, it returns the value of the variable.</p>

<pre>    package MyPlugin;
    use base &#39;Template::Plugin&#39;;
    
    sub new {
        my ($class, $context, $dsn) = @_;
        
        return $class-&#62;error(&#39;No data source specified&#39;)
            unless $dsn;
        
        bless {
            _DSN =&#62; $dsn,
        }, $class;
    }

    package main;
    
    my $something = MyPlugin-&#62;new()
        || die MyPlugin-&#62;error(), &#34;\n&#34;;
        
    $something-&#62;do_something()
        || die $something-&#62;error(), &#34;\n&#34;;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DEEPER_MAGIC"
>DEEPER MAGIC</a></h1>

<p>The <a href="../Template/Context.html" class="podlinkpod"
>Template::Context</a> object that handles the loading and use of plugins calls the <a href="../new().html" class="podlinkpod"
>new()</a> and <a href="../error().html" class="podlinkpod"
>error()</a> methods against the package name returned by the <a href="../load().html" class="podlinkpod"
>load()</a> method. In pseudo-code terms looks something like this:</p>

<pre>    $class  = MyPlugin-&#62;load($context);       # returns &#39;MyPlugin&#39;
    
    $object = $class-&#62;new($context, @params)  # MyPlugin-&#62;new(...)
        || die $class-&#62;error();               # MyPlugin-&#62;error()</pre>

<p>The <a href="../load().html" class="podlinkpod"
>load()</a> method may alterately return a blessed reference to an object instance. In this case, <a href="../new().html" class="podlinkpod"
>new()</a> and <a href="../error().html" class="podlinkpod"
>error()</a> are then called as <i>object</i> methods against that prototype instance.</p>

<pre>    package YourPlugin;
    
    sub load {
        my ($class, $context) = @_;
        bless {
            _CONTEXT =&#62; $context,
        }, $class;
    }
    
    sub new {
        my ($self, $context, @params) = @_;
        return $self;
    }</pre>

<p>In this example, we have implemented a &#39;Singleton&#39; plugin. One object gets created when <a href="../load().html" class="podlinkpod"
>load()</a> is called and this simply returns itself for each call to <a href="../new()..html" class="podlinkpod"
>new().</a></p>

<p>Another implementation might require individual objects to be created for every call to <a href="../new()%2C.html" class="podlinkpod"
>new(),</a> but with each object sharing a reference to some other object to maintain cached data, database handles, etc. This pseudo-code example demonstrates the principle.</p>

<pre>    package MyServer;
    
    sub load {
        my ($class, $context) = @_;
        bless {
            _CONTEXT =&#62; $context,
            _CACHE   =&#62; { },
        }, $class;
    }
    
    sub new {
        my ($self, $context, @params) = @_;
        MyClient-&#62;new($self, @params);
    }
    
    sub add_to_cache   { ... }
    
    sub get_from_cache { ... }

    package MyClient;
    
    sub new {
        my ($class, $server, $blah) = @_;
        bless {
            _SERVER =&#62; $server,
            _BLAH   =&#62; $blah,
        }, $class;
    }
    
    sub get {
        my $self = shift;
        $self-&#62;{ _SERVER }-&#62;get_from_cache(@_);
    }
    
    sub put {
        my $self = shift;
        $self-&#62;{ _SERVER }-&#62;add_to_cache(@_);
    }</pre>

<p>When the plugin is loaded, a <code>MyServer</code> instance is created. The <a href="../new().html" class="podlinkpod"
>new()</a> method is called against this object which instantiates and returns a <code>MyClient</code> object, primed to communicate with the creating <code>MyServer</code>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Andy Wardley &#60;abw@wardley.org&#62; <a href="http://wardley.org/" class="podlinkurl"
>http://wardley.org/</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright (C) 1996-2007 Andy Wardley. All Rights Reserved.</p>

<p>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../Template.html" class="podlinkpod"
>Template</a>, <a href="../Template/Plugins.html" class="podlinkpod"
>Template::Plugins</a>, <a href="../Template/Context.html" class="podlinkpod"
>Template::Context</a></p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
