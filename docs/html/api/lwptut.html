<html><head><title>lwptut</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="_grygrnw.css" media="all" >

<script type="text/javascript" src="_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:20 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Getting_documents_with_LWP%3A%3ASimple'>Getting documents with LWP::Simple</a>
    <li class='indexItem indexItem2'><a href='#The_Basics_of_the_LWP_Class_Model'>The Basics of the LWP Class Model</a>
    <li class='indexItem indexItem2'><a href='#Adding_Other_HTTP_Request_Headers'>Adding Other HTTP Request Headers</a>
    <li class='indexItem indexItem2'><a href='#Enabling_Cookies'>Enabling Cookies</a>
    <li class='indexItem indexItem2'><a href='#Posting_Form_Data'>Posting Form Data</a>
    <li class='indexItem indexItem2'><a href='#Sending_GET_Form_Data'>Sending GET Form Data</a>
    <li class='indexItem indexItem2'><a href='#Absolutizing_URLs'>Absolutizing URLs</a>
    <li class='indexItem indexItem2'><a href='#Other_Browser_Attributes'>Other Browser Attributes</a>
    <li class='indexItem indexItem2'><a href='#Writing_Polite_Robots'>Writing Polite Robots</a>
    <li class='indexItem indexItem2'><a href='#Using_Proxies'>Using Proxies</a>
    <li class='indexItem indexItem2'><a href='#HTTP_Authentication'>HTTP Authentication</a>
    <li class='indexItem indexItem2'><a href='#Accessing_HTTPS_URLs'>Accessing HTTPS URLs</a>
    <li class='indexItem indexItem2'><a href='#Getting_Large_Documents'>Getting Large Documents</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>lwptut -- An LWP Tutorial</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>LWP (short for &#34;Library for WWW in Perl&#34;) is a very popular group of Perl modules for accessing data on the Web.
Like most Perl module-distributions,
each of LWP&#39;s component modules comes with documentation that is a complete reference to its interface.
However,
there are so many modules in LWP that it&#39;s hard to know where to start looking for information on how to do even the simplest most common things.</p>

<p>Really introducing you to using LWP would require a whole book -- a book that just happens to exist,
called <i>Perl &#38; LWP</i>.
But this article should give you a taste of how you can go about some common tasks with LWP.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Getting_documents_with_LWP::Simple"
>Getting documents with LWP::Simple</a></h2>

<p>If you just want to get what&#39;s at a particular URL,
the simplest way to do it is LWP::Simple&#39;s functions.</p>

<p>In a Perl program,
you can call its <code>get($url)</code> function.
It will try getting that URL&#39;s content.
If it works,
then it&#39;ll return the content; but if there&#39;s some error,
it&#39;ll return undef.</p>

<pre>  my $url = &#39;http://www.npr.org/programs/fa/?todayDate=current&#39;;
    # Just an example: the URL for the most recent /Fresh Air/ show

  use LWP::Simple;
  my $content = get $url;
  die &#34;Couldn&#39;t get $url&#34; unless defined $content;

  # Then go do things with $content, like this:

  if($content =~ m/jazz/i) {
    print &#34;They&#39;re talking about jazz today on Fresh Air!\n&#34;;
  }
  else {
    print &#34;Fresh Air is apparently jazzless today.\n&#34;;
  }</pre>

<p>The handiest variant on <code>get</code> is <code>getprint</code>, which is useful in Perl one-liners. If it can get the page whose URL you provide, it sends it to STDOUT; otherwise it complains to STDERR.</p>

<pre>  % perl -MLWP::Simple -e &#34;getprint &#39;http://www.cpan.org/RECENT&#39;&#34;</pre>

<p>That is the URL of a plain text file that lists new files in CPAN in the past two weeks. You can easily make it part of a tidy little shell command, like this one that mails you the list of new <code>Acme::</code> modules:</p>

<pre>  % perl -MLWP::Simple -e &#34;getprint &#39;http://www.cpan.org/RECENT&#39;&#34;  \
     | grep &#34;/by-module/Acme&#34; | mail -s &#34;New Acme modules! Joy!&#34; $USER</pre>

<p>There are other useful functions in LWP::Simple, including one function for running a HEAD request on a URL (useful for checking links, or getting the last-revised time of a URL), and two functions for saving/mirroring a URL to a local file. See <a href="./LWP/Simple.html" class="podlinkpod"
>the LWP::Simple documentation</a> for the full details, or chapter 2 of <i>Perl &#38; LWP</i> for more examples.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_Basics_of_the_LWP_Class_Model"
>The Basics of the LWP Class Model</a></h2>

<p>LWP::Simple&#39;s functions are handy for simple cases, but its functions don&#39;t support cookies or authorization, don&#39;t support setting header lines in the HTTP request, generally don&#39;t support reading header lines in the HTTP response (notably the full HTTP error message, in case of an error). To get at all those features, you&#39;ll have to use the full LWP class model.</p>

<p>While LWP consists of dozens of classes, the main two that you have to understand are <a href="./LWP/UserAgent.html" class="podlinkpod"
>LWP::UserAgent</a> and <a href="./HTTP/Response.html" class="podlinkpod"
>HTTP::Response</a>. LWP::UserAgent is a class for &#34;virtual browsers&#34; which you use for performing requests, and <a href="./HTTP/Response.html" class="podlinkpod"
>HTTP::Response</a> is a class for the responses (or error messages) that you get back from those requests.</p>

<p>The basic idiom is <code>$response = $browser-&#62;get($url)</code>, or more fully illustrated:</p>

<pre>  # Early in your program:
  
  use LWP 5.64; # Loads all important LWP classes, and makes
                #  sure your version is reasonably recent.

  my $browser = LWP::UserAgent-&#62;new;
  
  ...
  
  # Then later, whenever you need to make a get request:
  my $url = &#39;http://www.npr.org/programs/fa/?todayDate=current&#39;;
  
  my $response = $browser-&#62;get( $url );
  die &#34;Can&#39;t get $url -- &#34;, $response-&#62;status_line
   unless $response-&#62;is_success;

  die &#34;Hey, I was expecting HTML, not &#34;, $response-&#62;content_type
   unless $response-&#62;content_type eq &#39;text/html&#39;;
     # or whatever content-type you&#39;re equipped to deal with

  # Otherwise, process the content somehow:
  
  if($response-&#62;decoded_content =~ m/jazz/i) {
    print &#34;They&#39;re talking about jazz today on Fresh Air!\n&#34;;
  }
  else {
    print &#34;Fresh Air is apparently jazzless today.\n&#34;;
  }</pre>

<p>There are two objects involved: <code>$browser</code>, which holds an object of class LWP::UserAgent, and then the <code>$response</code> object, which is of class HTTP::Response. You really need only one browser object per program; but every time you make a request, you get back a new HTTP::Response object, which will have some interesting attributes:</p>

<ul>
<li>A status code indicating success or failure (which you can test with <code>$response-&#62;is_success</code>).</li>

<li>An HTTP status line that is hopefully informative if there&#39;s failure (which you can see with <code>$response-&#62;status_line</code>, returning something like &#34;404 Not Found&#34;).</li>

<li>A MIME content-type like &#34;text/html&#34;, &#34;image/gif&#34;, &#34;application/xml&#34;, etc., which you can see with <code>$response-&#62;content_type</code></li>

<li>The actual content of the response, in <code>$response-&#62;decoded_content</code>. If the response is HTML, that&#39;s where the HTML source will be; if it&#39;s a GIF, then <code>$response-&#62;decoded_content</code> will be the binary GIF data.</li>

<li>And dozens of other convenient and more specific methods that are documented in the docs for <a href="./HTTP/Response.html" class="podlinkpod"
>HTTP::Response</a>, and its superclasses <a href="./HTTP/Message.html" class="podlinkpod"
>HTTP::Message</a> and <a href="./HTTP/Headers.html" class="podlinkpod"
>HTTP::Headers</a>.</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Adding_Other_HTTP_Request_Headers"
>Adding Other HTTP Request Headers</a></h2>

<p>The most commonly used syntax for requests is <code>$response = $browser-&#62;get($url)</code>, but in truth, you can add extra HTTP header lines to the request by adding a list of key-value pairs after the URL, like so:</p>

<pre>  $response = $browser-&#62;get( $url, $key1, $value1, $key2, $value2, ... );</pre>

<p>For example, here&#39;s how to send some more Netscape-like headers, in case you&#39;re dealing with a site that would otherwise reject your request:</p>

<pre>  my @ns_headers = (
   &#39;User-Agent&#39; =&#62; &#39;Mozilla/4.76 [en] (Win98; U)&#39;,
   &#39;Accept&#39; =&#62; &#39;image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*&#39;,
   &#39;Accept-Charset&#39; =&#62; &#39;iso-8859-1,*,utf-8&#39;,
   &#39;Accept-Language&#39; =&#62; &#39;en-US&#39;,
  );

  ...
  
  $response = $browser-&#62;get($url, @ns_headers);</pre>

<p>If you weren&#39;t reusing that array, you could just go ahead and do this:</p>

<pre>  $response = $browser-&#62;get($url,
   &#39;User-Agent&#39; =&#62; &#39;Mozilla/4.76 [en] (Win98; U)&#39;,
   &#39;Accept&#39; =&#62; &#39;image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*&#39;,
   &#39;Accept-Charset&#39; =&#62; &#39;iso-8859-1,*,utf-8&#39;,
   &#39;Accept-Language&#39; =&#62; &#39;en-US&#39;,
  );</pre>

<p>If you were only ever changing the &#39;User-Agent&#39; line, you could just change the <code>$browser</code> object&#39;s default line from &#34;libwww-perl/5.65&#34; (or the like) to whatever you like, using the LWP::UserAgent <code>agent</code> method:</p>

<pre>   $browser-&#62;agent(&#39;Mozilla/4.76 [en] (Win98; U)&#39;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Enabling_Cookies"
>Enabling Cookies</a></h2>

<p>A default LWP::UserAgent object acts like a browser with its cookies support turned off. There are various ways of turning it on, by setting its <code>cookie_jar</code> attribute. A &#34;cookie jar&#34; is an object representing a little database of all the HTTP cookies that a browser can know about. It can correspond to a file on disk (the way Netscape uses its <em>cookies.txt</em> file), or it can be just an in-memory object that starts out empty, and whose collection of cookies will disappear once the program is finished running.</p>

<p>To give a browser an in-memory empty cookie jar, you set its <code>cookie_jar</code> attribute like so:</p>

<pre>  $browser-&#62;cookie_jar({});</pre>

<p>To give it a copy that will be read from a file on disk, and will be saved to it when the program is finished running, set the <code>cookie_jar</code> attribute like this:</p>

<pre>  use HTTP::Cookies;
  $browser-&#62;cookie_jar( HTTP::Cookies-&#62;new(
    &#39;file&#39; =&#62; &#39;/some/where/cookies.lwp&#39;,
        # where to read/write cookies
    &#39;autosave&#39; =&#62; 1,
        # save it to disk when done
  ));</pre>

<p>That file will be an LWP-specific format. If you want to be access the cookies in your Netscape cookies file, you can use the HTTP::Cookies::Netscape class:</p>

<pre>  use HTTP::Cookies;
    # yes, loads HTTP::Cookies::Netscape too
  
  $browser-&#62;cookie_jar( HTTP::Cookies::Netscape-&#62;new(
    &#39;file&#39; =&#62; &#39;c:/Program Files/Netscape/Users/DIR-NAME-HERE/cookies.txt&#39;,
        # where to read cookies
  ));</pre>

<p>You could add an <code>&#39;autosave&#39; =&#62; 1</code> line as further above, but at time of writing, it&#39;s uncertain whether Netscape might discard some of the cookies you could be writing back to disk.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Posting_Form_Data"
>Posting Form Data</a></h2>

<p>Many HTML forms send data to their server using an HTTP POST request, which you can send with this syntax:</p>

<pre> $response = $browser-&#62;post( $url,
   [
     formkey1 =&#62; value1, 
     formkey2 =&#62; value2, 
     ...
   ],
 );</pre>

<p>Or if you need to send HTTP headers:</p>

<pre> $response = $browser-&#62;post( $url,
   [
     formkey1 =&#62; value1, 
     formkey2 =&#62; value2, 
     ...
   ],
   headerkey1 =&#62; value1, 
   headerkey2 =&#62; value2, 
 );</pre>

<p>For example, the following program makes a search request to AltaVista (by sending some form data via an HTTP POST request), and extracts from the HTML the report of the number of matches:</p>

<pre>  use strict;
  use warnings;
  use LWP 5.64;
  my $browser = LWP::UserAgent-&#62;new;

  my $word = &#39;tarragon&#39;;

  my $url = &#39;http://search.yahoo.com/yhs/search&#39;;
  my $response = $browser-&#62;post( $url,
    [ &#39;q&#39; =&#62; $word,  # the Altavista query string
      &#39;fr&#39; =&#62; &#39;altavista&#39;, &#39;pg&#39; =&#62; &#39;q&#39;, &#39;avkw&#39; =&#62; &#39;tgz&#39;, &#39;kl&#39; =&#62; &#39;XX&#39;,
    ]
  );
  die &#34;$url error: &#34;, $response-&#62;status_line
   unless $response-&#62;is_success;
  die &#34;Weird content type at $url -- &#34;, $response-&#62;content_type
   unless $response-&#62;content_is_html;

  if( $response-&#62;decoded_content =~ m{([0-9,]+)(?:&#60;.*?&#62;)? results for} ) {
    # The substring will be like &#34;996,000&#60;/strong&#62; results for&#34;
    print &#34;$word: $1\n&#34;;
  }
  else {
    print &#34;Couldn&#39;t find the match-string in the response\n&#34;;
  }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Sending_GET_Form_Data"
>Sending GET Form Data</a></h2>

<p>Some HTML forms convey their form data not by sending the data in an HTTP POST request, but by making a normal GET request with the data stuck on the end of the URL. For example, if you went to <code>www.imdb.com</code> and ran a search on &#34;Blade Runner&#34;, the URL you&#39;d see in your browser window would be:</p>

<pre>  http://www.imdb.com/find?s=all&#38;q=Blade+Runner</pre>

<p>To run the same search with LWP, you&#39;d use this idiom, which involves the URI class:</p>

<pre>  use URI;
  my $url = URI-&#62;new( &#39;http://www.imdb.com/find&#39; );
    # makes an object representing the URL

  $url-&#62;query_form(  # And here the form data pairs:
    &#39;q&#39; =&#62; &#39;Blade Runner&#39;,
    &#39;s&#39; =&#62; &#39;all&#39;,
  );

  my $response = $browser-&#62;get($url);</pre>

<p>See chapter 5 of <i>Perl &#38; LWP</i> for a longer discussion of HTML forms and of form data, and chapters 6 through 9 for a longer discussion of extracting data from HTML.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Absolutizing_URLs"
>Absolutizing URLs</a></h2>

<p>The URI class that we just mentioned above provides all sorts of methods for accessing and modifying parts of URLs (such as asking sort of URL it is with <code>$url-&#62;scheme</code>, and asking what host it refers to with <code>$url-&#62;host</code>, and so on, as described in <a href="./URI.html" class="podlinkpod"
>the docs for the URI class</a>. However, the methods of most immediate interest are the <code>query_form</code> method seen above, and now the <code>new_abs</code> method for taking a probably-relative URL string (like &#34;../foo.html&#34;) and getting back an absolute URL (like &#34;http://www.perl.com/stuff/foo.html&#34;), as shown here:</p>

<pre>  use URI;
  $abs = URI-&#62;new_abs($maybe_relative, $base);</pre>

<p>For example, consider this program that matches URLs in the HTML list of new modules in CPAN:</p>

<pre>  use strict;
  use warnings;
  use LWP;
  my $browser = LWP::UserAgent-&#62;new;
  
  my $url = &#39;http://www.cpan.org/RECENT.html&#39;;
  my $response = $browser-&#62;get($url);
  die &#34;Can&#39;t get $url -- &#34;, $response-&#62;status_line
   unless $response-&#62;is_success;
  
  my $html = $response-&#62;decoded_content;
  while( $html =~ m/&#60;A HREF=\&#34;(.*?)\&#34;/g ) {
    print &#34;$1\n&#34;;
  }</pre>

<p>When run, it emits output that starts out something like this:</p>

<pre>  MIRRORING.FROM
  RECENT
  RECENT.html
  authors/00whois.html
  authors/01mailrc.txt.gz
  authors/id/A/AA/AASSAD/CHECKSUMS
  ...</pre>

<p>However, if you actually want to have those be absolute URLs, you can use the URI module&#39;s <code>new_abs</code> method, by changing the <code>while</code> loop to this:</p>

<pre>  while( $html =~ m/&#60;A HREF=\&#34;(.*?)\&#34;/g ) {
    print URI-&#62;new_abs( $1, $response-&#62;base ) ,&#34;\n&#34;;
  }</pre>

<p>(The <code>$response-&#62;base</code> method from <a href="./HTTP/Message.html" class="podlinkpod"
>HTTP::Message</a> is for returning what URL should be used for resolving relative URLs -- it&#39;s usually just the same as the URL that you requested.)</p>

<p>That program then emits nicely absolute URLs:</p>

<pre>  http://www.cpan.org/MIRRORING.FROM
  http://www.cpan.org/RECENT
  http://www.cpan.org/RECENT.html
  http://www.cpan.org/authors/00whois.html
  http://www.cpan.org/authors/01mailrc.txt.gz
  http://www.cpan.org/authors/id/A/AA/AASSAD/CHECKSUMS
  ...</pre>

<p>See chapter 4 of <i>Perl &#38; LWP</i> for a longer discussion of URI objects.</p>

<p>Of course, using a regexp to match hrefs is a bit simplistic, and for more robust programs, you&#39;ll probably want to use an HTML-parsing module like <a href="./HTML/LinkExtor.html" class="podlinkpod"
>HTML::LinkExtor</a> or <a href="./HTML/TokeParser.html" class="podlinkpod"
>HTML::TokeParser</a> or even maybe <a href="./HTML/TreeBuilder.html" class="podlinkpod"
>HTML::TreeBuilder</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Other_Browser_Attributes"
>Other Browser Attributes</a></h2>

<p>LWP::UserAgent objects have many attributes for controlling how they work. Here are a few notable ones:</p>

<ul>
<li><code>$browser-&#62;timeout(15);</code>
<p>This sets this browser object to give up on requests that don&#39;t answer within 15 seconds.</p>
</li>

<li><code>$browser-&#62;protocols_allowed( [ &#39;http&#39;, &#39;gopher&#39;] );</code>
<p>This sets this browser object to not speak any protocols other than HTTP and gopher. If it tries accessing any other kind of URL (like an &#34;ftp:&#34; or &#34;mailto:&#34; or &#34;news:&#34; URL), then it won&#39;t actually try connecting, but instead will immediately return an error code 500, with a message like &#34;Access to &#39;ftp&#39; URIs has been disabled&#34;.</p>
</li>

<li><code>use LWP::ConnCache; $browser-&#62;conn_cache(LWP::ConnCache-&#62;new());</code>
<p>This tells the browser object to try using the HTTP/1.1 &#34;Keep-Alive&#34; feature, which speeds up requests by reusing the same socket connection for multiple requests to the same server.</p>
</li>

<li><code>$browser-&#62;agent( &#39;SomeName/1.23 (more info here maybe)&#39; )</code>
<p>This changes how the browser object will identify itself in the default &#34;User-Agent&#34; line is its HTTP requests. By default, it&#39;ll send &#34;libwww-perl/<i>versionnumber</i>&#34;, like &#34;libwww-perl/5.65&#34;. You can change that to something more descriptive like this:</p>

<pre>  $browser-&#62;agent( &#39;SomeName/3.14 (contact@robotplexus.int)&#39; );</pre>

<p>Or if need be, you can go in disguise, like this:</p>

<pre>  $browser-&#62;agent( &#39;Mozilla/4.0 (compatible; MSIE 5.12; Mac_PowerPC)&#39; );</pre>
</li>

<li><code>push @{ $ua-&#62;requests_redirectable }, &#39;POST&#39;;</code>
<p>This tells this browser to obey redirection responses to POST requests (like most modern interactive browsers), even though the HTTP RFC says that should not normally be done.</p>
</li>
</ul>

<p>For more options and information, see <a href="./LWP/UserAgent.html" class="podlinkpod"
>the full documentation for LWP::UserAgent</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Writing_Polite_Robots"
>Writing Polite Robots</a></h2>

<p>If you want to make sure that your LWP-based program respects <em>robots.txt</em> files and doesn&#39;t make too many requests too fast, you can use the LWP::RobotUA class instead of the LWP::UserAgent class.</p>

<p>LWP::RobotUA class is just like LWP::UserAgent, and you can use it like so:</p>

<pre>  use LWP::RobotUA;
  my $browser = LWP::RobotUA-&#62;new(&#39;YourSuperBot/1.34&#39;, &#39;you@yoursite.com&#39;);
    # Your bot&#39;s name and your email address

  my $response = $browser-&#62;get($url);</pre>

<p>But HTTP::RobotUA adds these features:</p>

<ul>
<li>If the <em>robots.txt</em> on <code>$url</code>&#39;s server forbids you from accessing <code>$url</code>, then the <code>$browser</code> object (assuming it&#39;s of class LWP::RobotUA) won&#39;t actually request it, but instead will give you back (in <code>$response</code>) a 403 error with a message &#34;Forbidden by robots.txt&#34;. That is, if you have this line:
<pre>  die &#34;$url -- &#34;, $response-&#62;status_line, &#34;\nAborted&#34;
   unless $response-&#62;is_success;</pre>

<p>then the program would die with an error message like this:</p>

<pre>  http://whatever.site.int/pith/x.html -- 403 Forbidden by robots.txt
  Aborted at whateverprogram.pl line 1234</pre>
</li>

<li>If this <code>$browser</code> object sees that the last time it talked to <code>$url</code>&#39;s server was too recently, then it will pause (via <code>sleep</code>) to avoid making too many requests too often. How long it will pause for, is by default one minute -- but you can control it with the <code>$browser-&#62;delay( <i>minutes</i> )</code> attribute.
<p>For example, this code:</p>

<pre>  $browser-&#62;delay( 7/60 );</pre>

<p>...means that this browser will pause when it needs to avoid talking to any given server more than once every 7 seconds.</p>
</li>
</ul>

<p>For more options and information, see <a href="./LWP/RobotUA.html" class="podlinkpod"
>the full documentation for LWP::RobotUA</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Using_Proxies"
>Using Proxies</a></h2>

<p>In some cases, you will want to (or will have to) use proxies for accessing certain sites and/or using certain protocols. This is most commonly the case when your LWP program is running (or could be running) on a machine that is behind a firewall.</p>

<p>To make a browser object use proxies that are defined in the usual environment variables (<code>HTTP_PROXY</code>, etc.), just call the <code>env_proxy</code> on a user-agent object before you go making any requests on it. Specifically:</p>

<pre>  use LWP::UserAgent;
  my $browser = LWP::UserAgent-&#62;new;
  
  # And before you go making any requests:
  $browser-&#62;env_proxy;</pre>

<p>For more information on proxy parameters, see <a href="./LWP/UserAgent.html" class="podlinkpod"
>the LWP::UserAgent documentation</a>, specifically the <code>proxy</code>, <code>env_proxy</code>, and <code>no_proxy</code> methods.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="HTTP_Authentication"
>HTTP Authentication</a></h2>

<p>Many web sites restrict access to documents by using &#34;HTTP Authentication&#34;. This isn&#39;t just any form of &#34;enter your password&#34; restriction, but is a specific mechanism where the HTTP server sends the browser an HTTP code that says &#34;That document is part of a protected &#39;realm&#39;, and you can access it only if you re-request it and add some special authorization headers to your request&#34;.</p>

<p>For example, the Unicode.org admins stop email-harvesting bots from harvesting the contents of their mailing list archives, by protecting them with HTTP Authentication, and then publicly stating the username and password (at <code>http://www.unicode.org/mail-arch/</code>) -- namely username &#34;unicode-ml&#34; and password &#34;unicode&#34;.</p>

<p>For example, consider this URL, which is part of the protected area of the web site:</p>

<pre>  http://www.unicode.org/mail-arch/unicode-ml/y2002-m08/0067.html</pre>

<p>If you access that with a browser, you&#39;ll get a prompt like &#34;Enter username and password for &#39;Unicode-MailList-Archives&#39; at server &#39;www.unicode.org&#39;&#34;.</p>

<p>In LWP, if you just request that URL, like this:</p>

<pre>  use LWP;
  my $browser = LWP::UserAgent-&#62;new;

  my $url =
   &#39;http://www.unicode.org/mail-arch/unicode-ml/y2002-m08/0067.html&#39;;
  my $response = $browser-&#62;get($url);

  die &#34;Error: &#34;, $response-&#62;header(&#39;WWW-Authenticate&#39;) || &#39;Error accessing&#39;,
    #  (&#39;WWW-Authenticate&#39; is the realm-name)
    &#34;\n &#34;, $response-&#62;status_line, &#34;\n at $url\n Aborting&#34;
   unless $response-&#62;is_success;</pre>

<p>Then you&#39;ll get this error:</p>

<pre>  Error: Basic realm=&#34;Unicode-MailList-Archives&#34;
   401 Authorization Required
   at http://www.unicode.org/mail-arch/unicode-ml/y2002-m08/0067.html
   Aborting at auth1.pl line 9.  [or wherever]</pre>

<p>...because the <code>$browser</code> doesn&#39;t know any the username and password for that realm (&#34;Unicode-MailList-Archives&#34;) at that host (&#34;www.unicode.org&#34;). The simplest way to let the browser know about this is to use the <code>credentials</code> method to let it know about a username and password that it can try using for that realm at that host. The syntax is:</p>

<pre>  $browser-&#62;credentials(
    &#39;servername:portnumber&#39;,
    &#39;realm-name&#39;,
   &#39;username&#39; =&#62; &#39;password&#39;
  );</pre>

<p>In most cases, the port number is 80, the default TCP/IP port for HTTP; and you usually call the <code>credentials</code> method before you make any requests. For example:</p>

<pre>  $browser-&#62;credentials(
    &#39;reports.mybazouki.com:80&#39;,
    &#39;web_server_usage_reports&#39;,
    &#39;plinky&#39; =&#62; &#39;banjo123&#39;
  );</pre>

<p>So if we add the following to the program above, right after the <code>$browser = LWP::UserAgent-&#62;new;</code> line...</p>

<pre>  $browser-&#62;credentials(  # add this to our $browser &#39;s &#34;key ring&#34;
    &#39;www.unicode.org:80&#39;,
    &#39;Unicode-MailList-Archives&#39;,
    &#39;unicode-ml&#39; =&#62; &#39;unicode&#39;
  );</pre>

<p>...then when we run it, the request succeeds, instead of causing the <code>die</code> to be called.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Accessing_HTTPS_URLs"
>Accessing HTTPS URLs</a></h2>

<p>When you access an HTTPS URL, it&#39;ll work for you just like an HTTP URL would -- if your LWP installation has HTTPS support (via an appropriate Secure Sockets Layer library). For example:</p>

<pre>  use LWP;
  my $url = &#39;https://www.paypal.com/&#39;;   # Yes, HTTPS!
  my $browser = LWP::UserAgent-&#62;new;
  my $response = $browser-&#62;get($url);
  die &#34;Error at $url\n &#34;, $response-&#62;status_line, &#34;\n Aborting&#34;
   unless $response-&#62;is_success;
  print &#34;Whee, it worked!  I got that &#34;,
   $response-&#62;content_type, &#34; document!\n&#34;;</pre>

<p>If your LWP installation doesn&#39;t have HTTPS support set up, then the response will be unsuccessful, and you&#39;ll get this error message:</p>

<pre>  Error at https://www.paypal.com/
   501 Protocol scheme &#39;https&#39; is not supported
   Aborting at paypal.pl line 7.   [or whatever program and line]</pre>

<p>If your LWP installation <i>does</i> have HTTPS support installed, then the response should be successful, and you should be able to consult <code>$response</code> just like with any normal HTTP response.</p>

<p>For information about installing HTTPS support for your LWP installation, see the helpful <em>README.SSL</em> file that comes in the libwww-perl distribution.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Getting_Large_Documents"
>Getting Large Documents</a></h2>

<p>When you&#39;re requesting a large (or at least potentially large) document, a problem with the normal way of using the request methods (like <code>$response = $browser-&#62;get($url)</code>) is that the response object in memory will have to hold the whole document -- <i>in memory</i>. If the response is a thirty megabyte file, this is likely to be quite an imposition on this process&#39;s memory usage.</p>

<p>A notable alternative is to have LWP save the content to a file on disk, instead of saving it up in memory. This is the syntax to use:</p>

<pre>  $response = $ua-&#62;get($url,
                         &#39;:content_file&#39; =&#62; $filespec,
                      );</pre>

<p>For example,</p>

<pre>  $response = $ua-&#62;get(&#39;http://search.cpan.org/&#39;,
                         &#39;:content_file&#39; =&#62; &#39;/tmp/sco.html&#39;
                      );</pre>

<p>When you use this <code>:content_file</code> option, the <code>$response</code> will have all the normal header lines, but <code>$response-&#62;content</code> will be empty.</p>

<p>Note that this &#34;:content_file&#34; option isn&#39;t supported under older versions of LWP, so you should consider adding <code>use LWP 5.66;</code> to check the LWP version, if you think your program might run on systems with older versions.</p>

<p>If you need to be compatible with older LWP versions, then use this syntax, which does the same thing:</p>

<pre>  use HTTP::Request::Common;
  $response = $ua-&#62;request( GET($url), $filespec );</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>Remember, this article is just the most rudimentary introduction to LWP -- to learn more about LWP and LWP-related tasks, you really must read from the following:</p>

<ul>
<li><a href="./LWP/Simple.html" class="podlinkpod"
>LWP::Simple</a> -- simple functions for getting/heading/mirroring URLs</li>

<li><a href="./LWP.html" class="podlinkpod"
>LWP</a> -- overview of the libwww-perl modules</li>

<li><a href="./LWP/UserAgent.html" class="podlinkpod"
>LWP::UserAgent</a> -- the class for objects that represent &#34;virtual browsers&#34;</li>

<li><a href="./HTTP/Response.html" class="podlinkpod"
>HTTP::Response</a> -- the class for objects that represent the response to a LWP response, as in <code>$response = $browser-&#62;get(...)</code></li>

<li><a href="./HTTP/Message.html" class="podlinkpod"
>HTTP::Message</a> and <a href="./HTTP/Headers.html" class="podlinkpod"
>HTTP::Headers</a> -- classes that provide more methods to HTTP::Response.</li>

<li><a href="./URI.html" class="podlinkpod"
>URI</a> -- class for objects that represent absolute or relative URLs</li>

<li><a href="./URI/Escape.html" class="podlinkpod"
>URI::Escape</a> -- functions for URL-escaping and URL-unescaping strings (like turning &#34;this &#38; that&#34; to and from &#34;this%20%26%20that&#34;).</li>

<li><a href="./HTML/Entities.html" class="podlinkpod"
>HTML::Entities</a> -- functions for HTML-escaping and HTML-unescaping strings (like turning &#34;C. &#38; E. Bront&#235;&#34; to and from &#34;C. &#38;amp; E. Bront&#38;euml;&#34;)</li>

<li><a href="./HTML/TokeParser.html" class="podlinkpod"
>HTML::TokeParser</a> and <a href="./HTML/TreeBuilder.html" class="podlinkpod"
>HTML::TreeBuilder</a> -- classes for parsing HTML</li>

<li><a href="./HTML/LinkExtor.html" class="podlinkpod"
>HTML::LinkExtor</a> -- class for finding links in HTML documents</li>

<li>The book <i>Perl &#38; LWP</i> by Sean M. Burke. O&#39;Reilly &#38; Associates, 2002. ISBN: 0-596-00178-9, <a href="http://oreilly.com/catalog/perllwp/" class="podlinkurl"
>http://oreilly.com/catalog/perllwp/</a>. The whole book is also available free online: <a href="http://lwp.interglacial.com" class="podlinkurl"
>http://lwp.interglacial.com</a>.</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright 2002, Sean M. Burke. You can redistribute this document and/or modify it, but only under the same terms as Perl itself.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Sean M. Burke <code>sburke@cpan.org</code></p>
<p class="backlinkbottom"><b><a name="___bottom" href="index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
