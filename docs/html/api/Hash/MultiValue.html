<html><head><title>Hash::MultiValue</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:17 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#RATIONALE'>RATIONALE</a>
  <li class='indexItem indexItem1'><a href='#HOW_THIS_WORKS'>HOW THIS WORKS</a>
  <li class='indexItem indexItem1'><a href='#UPDATING_CONTENTS'>UPDATING CONTENTS</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <li class='indexItem indexItem1'><a href='#WHY_LAST_NOT_FIRST%3F'>WHY LAST NOT FIRST?</a>
  <li class='indexItem indexItem1'><a href='#NOTES_ON_ref'>NOTES ON ref</a>
  <li class='indexItem indexItem1'><a href='#THREAD_SAFETY'>THREAD SAFETY</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#LICENSE'>LICENSE</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Hash::MultiValue - Store multiple values per key</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use Hash::MultiValue;

  my $hash = Hash::MultiValue-&#62;new(
      foo =&#62; &#39;a&#39;,
      foo =&#62; &#39;b&#39;,
      bar =&#62; &#39;baz&#39;,
  );

  # $hash is an object, but can be used as a hashref and DWIMs!
  my $foo = $hash-&#62;{foo};         # &#39;b&#39; (the last entry)
  my $foo = $hash-&#62;get(&#39;foo&#39;);    # &#39;b&#39; (always, regardless of context)
  my @foo = $hash-&#62;get_all(&#39;foo&#39;); # (&#39;a&#39;, &#39;b&#39;)

  keys %$hash; # (&#39;foo&#39;, &#39;bar&#39;)    not guaranteed to be ordered
  $hash-&#62;keys; # (&#39;foo&#39;, &#39;foo&#39;, &#39;bar&#39;) guaranteed to be ordered</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Hash::MultiValue is an object (and a plain hash reference) that may contain multiple values per key, inspired by MultiDict of WebOb.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="RATIONALE"
>RATIONALE</a></h1>

<p>In a typical web application, the request parameters (a.k.a CGI parameters) can be single value or multi values. Using CGI.pm style <code>param</code> is one way to deal with this problem (and it is good, as long as you&#39;re aware of its list context gotcha), but there&#39;s another approach to convert parameters into a hash reference, like Catalyst&#39;s <code>$c-&#62;req-&#62;parameters</code> does, and it <b>sucks</b>.</p>

<p>Why? Because the value could be just a scalar if there is one value and an array ref if there are multiple, depending on <i>user input</i> rather than <i>how you code it</i>. So your code should always be like this to be defensive:</p>

<pre>  my $p = $c-&#62;req-&#62;parameters;
  my @maybe_multi = ref $p-&#62;{m} eq &#39;ARRAY&#39; ? @{$p-&#62;{m}} : ($p-&#62;{m});
  my $must_single = ref $p-&#62;{m} eq &#39;ARRAY&#39; ? $p-&#62;{m}-&#62;[0] : $p-&#62;{m};</pre>

<p>Otherwise you&#39;ll get a random runtime exception of <i>Can&#39;t use string as an ARRAY ref</i> or get stringified array <i>ARRAY(0xXXXXXXXXX)</i> as a string, <i>depending on user input</i> and that is miserable and insecure.</p>

<p>This module provides a solution to this by making it behave like a single value hash reference, but also has an API to get multiple values on demand, explicitly.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="HOW_THIS_WORKS"
>HOW THIS WORKS</a></h1>

<p>The object returned by <code>new</code> is a blessed hash reference that contains the last entry of the same key if there are multiple values, but it also keeps the original pair state in the object tracker (a.k.a inside out objects) and allows you to access the original pairs and multiple values via the method calls, such as <code>get_all</code> or <code>flatten</code>.</p>

<p>This module does not use <code>tie</code> or <a href="../overload.html" class="podlinkpod"
>overload</a> and is quite fast.</p>

<p>Yes, there is <a href="../Tie/Hash/MultiValue.html" class="podlinkpod"
>Tie::Hash::MultiValue</a> and this module tries to solve exactly the same problem, but using a different implementation.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="UPDATING_CONTENTS"
>UPDATING CONTENTS</a></h1>

<p>When you update the content of the hash, <b>DO NOT UPDATE</b> using the hash reference interface: this won&#39;t write through to the tracking object.</p>

<pre>  my $hash = Hash::MultiValue-&#62;new(...);

  # WRONG
  $hash-&#62;{foo} = &#39;bar&#39;;
  delete $hash-&#62;{foo};

  # Correct
  $hash-&#62;add(foo =&#62; &#39;bar&#39;);
  $hash-&#62;remove(&#39;foo&#39;);</pre>

<p>See below for the list of updating methods.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<dl>
<dt><a name="new"
>new</a></dt>

<dd>
<pre>  $hash = Hash::MultiValue-&#62;new(@pairs);</pre>

<p>Creates a new object that can be treated as a plain hash reference as well.</p>

<dt><a name="get"
>get</a></dt>

<dd>
<pre>  $value = $hash-&#62;get($key);
  $value = $hash-&#62;{$key};</pre>

<p>Returns a single value for the given <code>$key</code>. If there are multiple values, the last one (not first one) is returned. See below for why.</p>

<p>Note that this <b>always</b> returns the single element as a scalar, regardless of its context, unlike CGI.pm&#39;s <code>param</code> method etc.</p>

<dt><a name="get_one"
>get_one</a></dt>

<dd>
<pre>  $value = $hash-&#62;get_one($key);</pre>

<p>Returns a single value for the given <code>$key</code>. This method <b>croaks</b> if there is no value or multiple values associated with the key, so you should wrap it with eval or modules like <a href="../Try/Tiny.html" class="podlinkpod"
>Try::Tiny</a>.</p>

<dt><a name="get_all"
>get_all</a></dt>

<dd>
<pre>  @values = $hash-&#62;get_all($key);</pre>

<p>Returns a list of values for the given <code>$key</code>. This method <b>always</b> returns a list regardless of its context. If there is no value attached, the result will be an empty list.</p>

<dt><a name="keys"
>keys</a></dt>

<dd>
<pre>  @keys = $hash-&#62;keys;</pre>

<p>Returns a list of all keys, including duplicates (see the example in the <a href="#SYNOPSIS" class="podlinkpod"
>&#34;SYNOPSIS&#34;</a>).</p>

<p>If you want only unique keys, use <code>keys %$hash</code>, as normal.</p>

<dt><a name="values"
>values</a></dt>

<dd>
<pre>  @values = $hash-&#62;values;</pre>

<p>Returns a list of all values, in the same order as <code>$hash-&#62;keys</code>.</p>

<dt><a name="set"
>set</a></dt>

<dd>
<pre>  $hash-&#62;set($key [, $value ... ]);</pre>

<p>Changes the stored value(s) of the given <code>$key</code>. This removes or adds pairs as necessary to store the new list but otherwise preserves order of existing pairs. <code>$hash-&#62;{$key}</code> is updated to point to the last value.</p>

<dt><a name="add"
>add</a></dt>

<dd>
<pre>  $hash-&#62;add($key, $value [, $value ... ]);</pre>

<p>Appends a new value to the given <code>$key</code>. This updates the value of <code>$hash-&#62;{$key}</code> as well so it always points to the last value.</p>

<dt><a name="remove"
>remove</a></dt>

<dd>
<pre>  $hash-&#62;remove($key);</pre>

<p>Removes a key and associated values for the given <code>$key</code>.</p>

<dt><a name="clear"
>clear</a></dt>

<dd>
<pre>  $hash-&#62;clear;</pre>

<p>Clears the hash to be an empty hash reference.</p>

<dt><a name="flatten"
>flatten</a></dt>

<dd>
<pre>  @pairs = $hash-&#62;flatten;</pre>

<p>Gets pairs of keys and values. This should be exactly the same pairs which are given to <code>new</code> method unless you updated the data.</p>

<dt><a name="each"
>each</a></dt>

<dd>
<pre>  $hash-&#62;each($code);

  # e.g.
  $hash-&#62;each(sub { print &#34;$_[0] = $_[1]\n&#34; });</pre>

<p>Calls <code>$code</code> once for each <code>($key, $value)</code> pair. This is a more convenient alternative to calling <code>flatten</code> and then iterating over it two items at a time.</p>

<p>Inside <code>$code</code>, <code>$_</code> contains the current iteration through the loop, starting at 0. For example:</p>

<pre>  $hash = Hash::MultiValue-&#62;new(a =&#62; 1, b =&#62; 2, c =&#62; 3, a =&#62; 4);

  $hash-&#62;each(sub { print &#34;$_: $_[0] = $_[1]\n&#34; });
  # 0: a = 1
  # 1: b = 2
  # 2: c = 3
  # 3: a = 4</pre>

<p>Be careful <b>not</b> to change <code>@_</code> inside your coderef! It will update the tracking object but not the plain hash. In the future, this limitation <i>may</i> be removed.</p>

<dt><a name="clone"
>clone</a></dt>

<dd>
<pre>  $new = $hash-&#62;clone;</pre>

<p>Creates a new Hash::MultiValue object that represents the same data, but obviously not sharing the reference. It&#39;s identical to:</p>

<pre>  $new = Hash::MultiValue-&#62;new($hash-&#62;flatten);</pre>

<dt><a name="as_hashref"
>as_hashref</a></dt>

<dd>
<pre>  $copy = $hash-&#62;as_hashref;</pre>

<p>Creates a new plain (unblessed) hash reference where a value is a single scalar. It&#39;s identical to:</p>

<pre>  $copy = +{%$hash};</pre>

<dt><a name="as_hashref_mixed,_mixed"
>as_hashref_mixed, mixed</a></dt>

<dd>
<pre>  $mixed = $hash-&#62;as_hashref_mixed;
  $mixed = $hash-&#62;mixed;</pre>

<p>Creates a new plain (unblessed) hash reference where the value is a single scalar, or an array ref when there are multiple values for a same key. Handy to create a hash reference that is often used in web application frameworks request objects such as <a href="../Catalyst.html" class="podlinkpod"
>Catalyst</a>. Ths method does exactly the opposite of <code>from_mixed</code>.</p>

<dt><a name="as_hashref_multi,_multi"
>as_hashref_multi, multi</a></dt>

<dd>
<pre>  $multi = $hash-&#62;as_hashref_multi;
  $multi = $hash-&#62;multi;</pre>

<p>Creates a new plain (unblessed) hash reference where values are all array references, regardless of there are single or multiple values for a same key.</p>

<dt><a name="from_mixed"
>from_mixed</a></dt>

<dd>
<pre>  $hash = Hash::MultiValue-&#62;from_mixed({
      foo =&#62; [ &#39;a&#39;, &#39;b&#39; ],
      bar =&#62; &#39;c&#39;,
  });</pre>

<p>Creates a new object out of a hash reference where the value is single or an array ref depending on the number of elements. Handy to convert from those request objects used in web frameworks such as <a href="../Catalyst.html" class="podlinkpod"
>Catalyst</a>. This method does exactly the opposite of <code>as_hashref_mixed</code>.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="WHY_LAST_NOT_FIRST?"
>WHY LAST NOT FIRST?</a></h1>

<p>You might wonder why this module uses the <i>last</i> value of the same key instead of <i>first</i>. There&#39;s no strong reasoning on this decision since one is as arbitrary as the other, but this is more consistent to what Perl does:</p>

<pre>  sub x {
      return (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;);
  }

  my $x = x(); # $x = &#39;c&#39;

  my %a = ( a =&#62; 1 );
  my %b = ( a =&#62; 2 );

  my %m = (%a, %b); # $m{a} = 2</pre>

<p>When perl gets a list in a scalar context it gets the last entry. Also if you merge hashes having a same key, the last one wins.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NOTES_ON_ref"
>NOTES ON ref</a></h1>

<p>If you pass this MultiValue hash object to some upstream functions that you can&#39;t control and does things like:</p>

<pre>  if (ref $args eq &#39;HASH&#39;) {
      ...
  }</pre>

<p>because this is a blessed hash reference it doesn&#39;t match and would fail. To avoid that you should call <code>as_hashref</code> to get a <i>finalized</i> (= non-blessed) hash reference.</p>

<p>You can also use UNIVERSAL::ref to make it work magically:</p>

<pre>  use UNIVERSAL::ref;    # before loading Hash::MultiValue
  use Hash::MultiValue;</pre>

<p>and then all <code>ref</code> calls to Hash::MultiValue objects will return <i>HASH</i>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="THREAD_SAFETY"
>THREAD SAFETY</a></h1>

<p>Prior to version 0.09, this module wasn&#39;t safe in a threaded environment, including win32 fork() emulation. Versions newer than 0.09 is considered thread safe.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Tatsuhiko Miyagawa &#60;miyagawa@bulknews.net&#62;</p>

<p>Aristotle Pagaltzis</p>

<p>Hans Dieter Pearcey</p>

<p>Thanks to Michael Peters for the suggestion to use inside-out objects instead of tie.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENSE"
>LICENSE</a></h1>

<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<ul>
<li><a href="http://pythonpaste.org/webob/#multidict" class="podlinkurl"
>http://pythonpaste.org/webob/#multidict</a></li>

<li><a href="../Tie/Hash/MultiValue.html" class="podlinkpod"
>Tie::Hash::MultiValue</a></li>
</ul>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
