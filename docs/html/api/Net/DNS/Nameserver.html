<html><head><title>Net::DNS::Nameserver</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:22 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#new'>new</a>
    <li class='indexItem indexItem2'><a href='#main_loop'>main_loop</a>
    <li class='indexItem indexItem2'><a href='#loop_once'>loop_once</a>
    <li class='indexItem indexItem2'><a href='#get_open_tcp'>get_open_tcp</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#EXAMPLE'>EXAMPLE</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Net::DNS::Nameserver - DNS server class</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    use Net::DNS::Nameserver;

    $nameserver = new Net::DNS::Nameserver(
        LocalAddr        =&#62; [&#39;::1&#39; , &#39;127.0.0.1&#39; ],
        LocalPort        =&#62; &#34;5353&#34;,
        ReplyHandler =&#62; \&#38;reply_handler,
        Verbose          =&#62; 1,
        Truncate         =&#62; 0
    );</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Instances of the <code>Net::DNS::Nameserver</code> class represent DNS server objects. See <a href="#EXAMPLE" class="podlinkpod"
>&#34;EXAMPLE&#34;</a> for an example.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="new"
>new</a></h2>

<pre>    my $ns = new Net::DNS::Nameserver(
        LocalAddr       =&#62; &#34;10.1.2.3&#34;,
        LocalPort       =&#62; &#34;5353&#34;,
        ReplyHandler    =&#62; \&#38;reply_handler,
        Verbose         =&#62; 1
        );



    my $ns = new Net::DNS::Nameserver(
        LocalAddr       =&#62; [&#39;::1&#39; , &#39;127.0.0.1&#39; ],
        LocalPort       =&#62; &#34;5353&#34;,
        ReplyHandler    =&#62; \&#38;reply_handler,
        Verbose         =&#62; 1,
        Truncate        =&#62; 0
        );</pre>

<p>Creates a nameserver object. Attributes are:</p>

<pre>    LocalAddr           IP address on which to listen.  Defaults to INADDR_ANY.
    LocalPort           Port on which to listen.        Defaults to 53.
    ReplyHandler        Reference to reply-handling
                        subroutine                      Required.
    NotifyHandler       Reference to reply-handling
                        subroutine for queries with
                        opcode NOTIFY (RFC1996)
    Verbose             Print info about received
                        queries.                        Defaults to 0 (off).
    Truncate            Truncates UDP packets that
                        are too big for the reply       Defaults to 1 (on)
    IdleTimeout         TCP clients are disconnected
                        if they are idle longer than
                        this duration.                  Defaults to 120 (secs)</pre>

<p>The LocalAddr attribute may alternatively be specified as a list of IP addresses to listen to.</p>

<p>If IO::Socket::INET6 and Socket6 are available on the system you can also list IPv6 addresses and the default is &#39;0&#39; (listen on all interfaces on IPv6 and IPv4);</p>

<p>The ReplyHandler subroutine is passed the query name, query class, query type and optionally an argument containing the peerhost, the incoming query, and the name of the incoming socket (sockethost). It must either return the response code and references to the answer, authority, and additional sections of the response, or undef to leave the query unanswered. Common response codes are:</p>

<pre>    NOERROR     No error
    FORMERR     Format error
    SERVFAIL    Server failure
    NXDOMAIN    Non-existent domain (name doesn&#39;t exist)
    NOTIMP      Not implemented
    REFUSED     Query refused</pre>

<p>For advanced usage it may also contain a headermask containing an hashref with the settings for the <code>aa</code>, <code>ra</code>, and <code>ad</code> header bits. The argument is of the form <code>{ ad =&#62; 1, aa =&#62; 0, ra =&#62; 1 }</code>.</p>

<p>See RFC 1035 and the IANA dns-parameters file for more information:</p>

<pre>  ftp://ftp.rfc-editor.org/in-notes/rfc1035.txt
  http://www.isi.edu/in-notes/iana/assignments/dns-parameters</pre>

<p>The nameserver will listen for both UDP and TCP connections. On Unix-like systems, the program will probably have to run as root to listen on the default port, 53. A non-privileged user should be able to listen on ports 1024 and higher.</p>

<p>Packet Truncation is new functionality for $Net::DNS::Nameserver::VERSION&#62;830 and uses the Net::DNS::Packet::truncate method with a size determinde by the advertised EDNS0 size in the query, or 512 if EDNS0 is not advertised in the query. Only UDP replies are truncated. If you want to do packet runcation yourself you should set Truncate to 0 and use the truncate method on the reply packet in the code you use for the ReplyHandler.</p>

<p>Returns a Net::DNS::Nameserver object, or undef if the object couldn&#39;t be created.</p>

<p>See <a href="#EXAMPLE" class="podlinkpod"
>&#34;EXAMPLE&#34;</a> for an example.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="main_loop"
>main_loop</a></h2>

<pre>    $ns-&#62;main_loop;</pre>

<p>Start accepting queries. Calling main_loop never returns.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="loop_once"
>loop_once</a></h2>

<pre>    $ns-&#62;loop_once( [TIMEOUT_IN_SECONDS] );</pre>

<p>Start accepting queries, but returns. If called without a parameter, the call will not return until a request has been received (and replied to). If called with a number, that number specifies how many seconds (even fractional) to maximum wait before returning. If called with 0 it will return immediately unless there&#39;s something to do.</p>

<p>Handling a request and replying obviously depends on the speed of ReplyHandler. Assuming ReplyHandler is super fast, loop_once should spend just a fraction of a second, if called with a timeout value of 0 seconds. One exception is when an AXFR has requested a huge amount of data that the OS is not ready to receive in full. In that case, it will keep running through a loop (while servicing new requests) until the reply has been sent.</p>

<p>In case loop_once accepted a TCP connection it will immediatly check if there is data to be read from the socket. If not it will return and you will have to call loop_once() again to check if there is any data waiting on the socket to be processed. In most cases you will have to count on calling &#34;loop_once&#34; twice.</p>

<p>A code fragment like:</p>

<pre>    $ns-&#62;loop_once(10);
    while( $ns-&#62;get_open_tcp() ){
        $ns-&#62;loop_once(0);
    }</pre>

<p>Would wait for 10 seconds for the initial connection and would then process all TCP sockets until none is left.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_open_tcp"
>get_open_tcp</a></h2>

<p>In scalar context returns the number of TCP connections for which state is maintained. In array context it returns IO::Socket objects, these could be useful for troubleshooting but be careful using them.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXAMPLE"
>EXAMPLE</a></h1>

<p>The following example will listen on port 5353 and respond to all queries for A records with the IP address 10.1.2.3. All other queries will be answered with NXDOMAIN. Authority and additional sections are left empty. The $peerhost variable catches the IP address of the peer host, so that additional filtering on its basis may be applied.</p>

<pre>    #!/usr/bin/perl

    use strict;
    use warnings;
    use Net::DNS::Nameserver;

    sub reply_handler {
        my ($qname, $qclass, $qtype, $peerhost,$query,$conn) = @_;
        my ($rcode, @ans, @auth, @add);

        print &#34;Received query from $peerhost to &#34;. $conn-&#62;{sockhost}. &#34;\n&#34;;
        $query-&#62;print;

        if ($qtype eq &#34;A&#34; &#38;&#38; $qname eq &#34;foo.example.com&#34; ) {
                my ($ttl, $rdata) = (3600, &#34;10.1.2.3&#34;);
                my $rr = new Net::DNS::RR(&#34;$qname $ttl $qclass $qtype $rdata&#34;);
                push @ans, $rr;
                $rcode = &#34;NOERROR&#34;;
        }elsif( $qname eq &#34;foo.example.com&#34; ) {
                $rcode = &#34;NOERROR&#34;;

        }else{
                $rcode = &#34;NXDOMAIN&#34;;
        }

        # mark the answer as authoritive (by setting the &#39;aa&#39; flag
        return ($rcode, \@ans, \@auth, \@add, { aa =&#62; 1 });
    }

    my $ns = new Net::DNS::Nameserver(
        LocalPort    =&#62; 5353,
        ReplyHandler =&#62; \&#38;reply_handler,
        Verbose      =&#62; 1
        ) || die &#34;couldn&#39;t create nameserver object\n&#34;;

    $ns-&#62;main_loop;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>Limitations in perl 5.8.6 makes it impossible to guarantee that replies to UDP queries from Net::DNS::Nameserver are sent from the IP-address they were received on. This is a problem for machines with multiple IP-addresses and causes violation of RFC2181 section 4. Thus a UDP socket created listening to INADDR_ANY (all available IP-addresses) will reply not necessarily with the source address being the one to which the request was sent, but rather with the address that the operating system chooses. This is also often called &#34;the closest address&#34;. This should really only be a problem on a server which has more than one IP-address (besides localhost - any experience with IPv6 complications here, would be nice). If this is a problem for you, a work-around would be to not listen to INADDR_ANY but to specify each address that you want this module to listen on. A separate set of sockets will then be created for each IP-address.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright (c)1997-2002 Michael Fuhr.</p>

<p>Portions Copyright (c)2002-2004 Chris Reinhardt.</p>

<p>Portions Copyright (c)2005-2009 O.M, Kolkman, RIPE NCC.</p>

<p>Portions Copyright (c)2005 Robert Martin-Legene.</p>

<p>All rights reserved.</p>

<p>This program is free software; you may redistribute it and/or modify it under the same terms as Perl itself.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../../perl.html" class="podlinkpod"
>perl</a>, <a href="../../Net/DNS.html" class="podlinkpod"
>Net::DNS</a>, <a href="../../Net/DNS/Resolver.html" class="podlinkpod"
>Net::DNS::Resolver</a>, <a href="../../Net/DNS/Packet.html" class="podlinkpod"
>Net::DNS::Packet</a>, <a href="../../Net/DNS/Update.html" class="podlinkpod"
>Net::DNS::Update</a>, <a href="../../Net/DNS/Header.html" class="podlinkpod"
>Net::DNS::Header</a>, <a href="../../Net/DNS/Question.html" class="podlinkpod"
>Net::DNS::Question</a>, <a href="../../Net/DNS/RR.html" class="podlinkpod"
>Net::DNS::RR</a>, RFC 1035</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
