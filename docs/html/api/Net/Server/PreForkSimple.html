<html><head><title>Net::Server::PreForkSimple</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:23 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#SAMPLE_CODE'>SAMPLE CODE</a>
  <li class='indexItem indexItem1'><a href='#COMMAND_LINE_ARGUMENTS'>COMMAND LINE ARGUMENTS</a>
  <li class='indexItem indexItem1'><a href='#CONFIGURATION_FILE'>CONFIGURATION FILE</a>
  <li class='indexItem indexItem1'><a href='#PROCESS_FLOW'>PROCESS FLOW</a>
  <li class='indexItem indexItem1'><a href='#HOOKS'>HOOKS</a>
  <li class='indexItem indexItem1'><a href='#HOT_DEPLOY'>HOT DEPLOY</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#TO_DO'>TO DO</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#THANKS'>THANKS</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Net::Server::PreForkSimple - Net::Server personality</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    use base qw(Net::Server::PreForkSimple);

    sub process_request {
        #...code...
    }

    __PACKAGE__-&#62;run();</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Please read the pod on Net::Server first. This module is a personality, or extension, or sub class, of the Net::Server module.</p>

<p>This personality binds to one or more ports and then forks <code>max_servers</code> child processes. The server will make sure that at any given time there are always <code>max_servers</code> available to receive a client request. Each of these children will process up to <code>max_requests</code> client connections. This type is good for a heavily hit site that can keep <code>max_servers</code> processes dedicated to the serving. (Multi port accept defaults to using flock to serialize the children).</p>

<p>At this time, it does not appear that this module will pass tests on Win32 systems. Any ideas or patches for making the tests pass would be welcome.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SAMPLE_CODE"
>SAMPLE CODE</a></h1>

<p>Please see the sample listed in Net::Server.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COMMAND_LINE_ARGUMENTS"
>COMMAND LINE ARGUMENTS</a></h1>

<p>In addition to the command line arguments of the Net::Server base class, Net::Server::PreFork contains several other configurable parameters.</p>

<pre>    Key               Value                   Default
    max_servers       \d+                     50
    max_requests      \d+                     1000

    serialize         (flock|semaphore
                       |pipe|none)  undef
    # serialize defaults to flock on multi_port or on Solaris
    lock_file         &#34;filename&#34;              File::Temp::tempfile or POSIX::tmpnam

    check_for_dead    \d+                     30

    max_dequeue       \d+                     undef
    check_for_dequeue \d+                     undef</pre>

<dl>
<dt><a name="max_servers"
>max_servers</a></dt>

<dd>
<p>The maximum number of child servers to start and maintain. This does not apply to dequeue processes.</p>

<dt><a name="max_requests"
>max_requests</a></dt>

<dd>
<p>The number of client connections to receive before a child terminates.</p>

<dt><a name="serialize"
>serialize</a></dt>

<dd>
<p>Determines whether the server serializes child connections. Options are undef, flock, semaphore, pipe, or none. Default is undef. On multi_port servers or on servers running on Solaris, the default is flock. The flock option uses blocking exclusive flock on the file specified in <i>lock_file</i> (see below). The semaphore option uses IPC::Semaphore (thanks to Bennett Todd) for giving some sample code. The pipe option reads on a pipe to choose the next. the flock option should be the most bulletproof while the pipe option should be the most portable. (Flock is able to reliquish the block if the process dies between accept on the socket and reading of the client connection - semaphore and pipe do not). An option of none will not perform any serialization. If &#34;none&#34; is passed and there are multiple ports then a the default serialization will be used insted of &#34;none.&#34;</p>

<dt><a name="lock_file"
>lock_file</a></dt>

<dd>
<p>Filename to use in flock serialized accept in order to serialize the accept sequece between the children. This will default to a generated temporary filename. If default value is used the lock_file will be removed when the server closes.</p>

<dt><a name="check_for_dead"
>check_for_dead</a></dt>

<dd>
<p>Seconds to wait before checking to see if a child died without letting the parent know.</p>

<dt><a name="max_dequeue"
>max_dequeue</a></dt>

<dd>
<p>The maximum number of dequeue processes to start. If a value of zero or undef is given, no dequeue processes will be started. The number of running dequeue processes will be checked by the check_for_dead variable.</p>

<dt><a name="check_for_dequeue"
>check_for_dequeue</a></dt>

<dd>
<p>Seconds to wait before forking off a dequeue process. The run_dequeue hook must be defined when using this setting. It is intended to use the dequeue process to take care of items such as mail queues. If a value of undef is given, no dequeue processes will be started.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CONFIGURATION_FILE"
>CONFIGURATION FILE</a></h1>

<p><code>Net::Server::PreFork</code> allows for the use of a configuration file to read in server parameters. The format of this conf file is simple key value pairs. Comments and white space are ignored.</p>

<pre>    #-------------- file test.conf --------------

    ### server information
    max_servers   80

    max_requests  1000

    ### user and group to become
    user        somebody
    group       everybody

    ### logging ?
    log_file    /var/log/server.log
    log_level   3
    pid_file    /tmp/server.pid

    ### access control
    allow       .+\.(net|com)
    allow       domain\.com
    deny        a.+

    ### background the process?
    background  1

    ### ports to bind
    host        127.0.0.1
    port        localhost:20204
    port        20205

    ### reverse lookups ?
    # reverse_lookups on

    #-------------- file test.conf --------------</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PROCESS_FLOW"
>PROCESS FLOW</a></h1>

<p>Process flow follows Net::Server until the loop phase. At this point <code>max_servers</code> are forked and wait for connections. When a child accepts a connection, finishs processing a client, or exits, it relays that information to the parent, which keeps track and makes sure there are always <code>max_servers</code> running.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="HOOKS"
>HOOKS</a></h1>

<p>The PreForkSimple server has the following hooks in addition to the hooks provided by the Net::Server base class. See <a href="../../Net/Server.html" class="podlinkpod"
>Net::Server</a></p>

<dl>
<dt><a name="$self-&#62;run_n_children_hook()"
><code>$self-&#62;run_n_children_hook()</code></a></dt>

<dd>
<p>This hook occurs at the top of run_n_children which is called each time the server goes to start more child processes. This gives the parent to do a little of its own accountting (as desired). Idea for this hook came from James FitzGibbon.</p>

<dt><a name="$self-&#62;child_init_hook()"
><code>$self-&#62;child_init_hook()</code></a></dt>

<dd>
<p>This hook takes place immeditately after the child process forks from the parent and before the child begins accepting connections. It is intended for any addiotional chrooting or other security measures. It is suggested that all perl modules be used by this point, so that the most shared memory possible is used.</p>

<dt><a name="$self-&#62;child_finish_hook()"
><code>$self-&#62;child_finish_hook()</code></a></dt>

<dd>
<p>This hook takes place immediately before the child tells the parent that it is exiting. It is intended for saving out logged information or other general cleanup.</p>

<dt><a name="$self-&#62;run_dequeue()"
><code>$self-&#62;run_dequeue()</code></a></dt>

<dd>
<p>This hook only gets called in conjunction with the check_for_dequeue setting.</p>

<dt><a name="$self-&#62;idle_loop_hook()"
><code>$self-&#62;idle_loop_hook()</code></a></dt>

<dd>
<p>This hook is called in every pass through the main process wait loop.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="HOT_DEPLOY"
>HOT DEPLOY</a></h1>

<p>Since version 2.000, the PreForkSimple server has accepted the TTIN and TTOU signals. When a TTIN is received, the max_servers is increased by 1. If a TTOU signal is received the max_servers is decreased by 1. This allows for adjusting the number of handling processes without having to restart the server.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>Tests don&#39;t seem to work on Win32. Any ideas or patches would be welcome.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TO_DO"
>TO DO</a></h1>

<p>See <a href="../../Net/Server.html" class="podlinkpod"
>Net::Server</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Paul T. Seamons paul@seamons.com</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="THANKS"
>THANKS</a></h1>

<p>See <a href="../../Net/Server.html" class="podlinkpod"
>Net::Server</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>Please see also <a href="../../Net/Server/Fork.html" class="podlinkpod"
>Net::Server::Fork</a>, <a href="../../Net/Server/INET.html" class="podlinkpod"
>Net::Server::INET</a>, <a href="../../Net/Server/PreFork.html" class="podlinkpod"
>Net::Server::PreFork</a>, <a href="../../Net/Server/MultiType.html" class="podlinkpod"
>Net::Server::MultiType</a>, <a href="../../Net/Server/Single.html" class="podlinkpod"
>Net::Server::Single</a> <a href="../../Net/Server/SIG.html" class="podlinkpod"
>Net::Server::SIG</a> <a href="../../Net/Server/Daemonize.html" class="podlinkpod"
>Net::Server::Daemonize</a> <a href="../../Net/Server/Proto.html" class="podlinkpod"
>Net::Server::Proto</a></p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
