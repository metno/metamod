<html><head><title>Net::Server::PSGI</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:23 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#TEST_ONE_LINER'>TEST ONE LINER</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <li class='indexItem indexItem1'><a href='#OPTIONS'>OPTIONS</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Net::Server::PSGI - basic Net::Server based PSGI HTTP server class</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TEST_ONE_LINER"
>TEST ONE LINER</a></h1>

<pre>    perl -e &#39;use base qw(Net::Server::PSGI); main-&#62;run(port =&#62; 8080, ipv =&#62; &#34;*&#34;)&#39;
    # runs a default echo server</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    use base qw(Net::Server::PSGI);
    __PACKAGE__-&#62;run(app =&#62; \&#38;my_echo_handler); # will bind IPv4 port 80

    sub my_echo_handler {
        my $env = shift;
        my $txt = qq{&#60;form method=&#34;post&#34; action=&#34;/bam&#34;&#62;&#60;input type=&#34;text&#34; name=&#34;foo&#34;&#62;&#60;input type=&#34;submit&#34;&#62;&#60;/form&#62;\n};

        require Data::Dumper;
        local $Data::Dumper::Sortkeys = 1;

        require CGI::PSGI;
        my $form = {};
        my $q = CGI::PSGI-&#62;new($env);
        $form-&#62;{$_} = $q-&#62;param($_) for $q-&#62;param;

        $txt .= &#34;&#60;pre&#62;&#34;.Data::Dumper-&#62;Dump([$env, $form], [&#39;env&#39;, &#39;form&#39;]).&#34;&#60;/pre&#62;&#34;;

        return [200, [&#39;Content-type&#39;, &#39;text/html&#39;], [$txt]];
    }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>If you want a more fully featured PSGI experience, it would be wise to look at the <a href="../../Plack.html" class="podlinkpod"
>Plack</a> and <a href="../../Starman.html" class="podlinkpod"
>Starman</a> set of modules. Net::Server::PSGI is intended as an easy gateway into PSGI. But to get the most out of all that PSGI has to offer, you should review the <a href="../../Plack.html" class="podlinkpod"
>Plack</a> and <a href="../../Plack/Middleware.html" class="podlinkpod"
>Plack::Middleware</a>. If you only need something a little more rudimentary, then Net::Server::PSGI may be good for you.</p>

<p>Net::Server::PSGI takes Net::Server::HTTP one level farther. It begins with base type MultiType defaulting to Net::Server::Fork. It is easy to change it to any of the other Net::Server flavors by passing server_type =&#62; $other_flavor in the server configurtation. The port has also been defaulted to port 80 - but could easily be changed to another through the server configuration. You can also very easily add ssl by including, proto=&#62;&#34;ssl&#34; and provide a SSL_cert_file and SSL_key_file.</p>

<p>For example, here is a basic server that will bind to all interfaces, will speak both HTTP on port 8080 as well as HTTPS on 8443, and will speak both IPv4, as well as IPv6 if it is available.</p>

<pre>    use base qw(Net::Server::PSGI);

    __PACKAGE__-&#62;run(
        port  =&#62; [8080, &#34;8443/ssl&#34;],
        ipv   =&#62; &#39;*&#39;, # IPv6 if available
        SSL_key_file  =&#62; &#39;/my/key&#39;,
        SSL_cert_file =&#62; &#39;/my/cert&#39;,
    );</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<dl>
<dt><a name="process_request"
><code>process_request</code></a></dt>

<dd>
<p>This method has been overridden in Net::Server::PSGI - you should not use it while using Net::Server::PSGI. This overridden method parses the environment and sets up request alarms and handles dying failures. It calls process_psgi_request once the request is ready and headers have been parsed.</p>

<dt><a name="process_psgi_request"
><code>process_psgi_request</code></a></dt>

<dd>
<p>Used when psgi_enabled is true. During this method, find_psgi_handler will be called to return the appropriate psgi response handler. Once finished, print_psgi_headers and print_psgi_body are used to print out the response. See <a href="../../PSGI.html" class="podlinkpod"
>PSGI</a>.</p>

<p>Typically this method should not be overridden. Instead, an appropriate method for finding the app should be given to find_psgi_handler or app.</p>

<dt><a name="find_psgi_handler"
><code>find_psgi_handler</code></a></dt>

<dd>
<p>Used to lookup the appropriate PSGI handler. A reference to the already parsed $env hashref is passed. PATH_INFO will be initialized to the full path portion of the URI. SCRIPT_NAME will be initialized to the empty string. This handler should set the appropriate values for SCRIPT_NAME and PATH_INFO depending upon the path matched. A code reference for the handler should be returned. The default find_psgi_handler will call the <code>app</code> method. If that fails a reference to the psgi_echo_handler is returned as the default application.</p>

<pre>    sub find_psgi_handler {
        my ($self, $env) = @_;

        if ($env-&#62;{&#39;PATH_INFO&#39;} &#38;&#38; $env-&#62;{&#39;PATH_INFO&#39;} =~ s{^ (/foo) (?= $ | /) }{}x) {
            $env-&#62;{&#39;SCRIPT_NAME&#39;} = $1;
            return \&#38;foo_app;
        }

        return $self-&#62;SUPER::find_psgi_handler($env);
    }</pre>

<dt><a name="app"
><code>app</code></a></dt>

<dd>
<p>Return a reference to the application being served. This should be a valid PSGI application. See <a href="../../PSGI.html" class="podlinkpod"
>PSGI</a>. By default it will look at the value of the <code>app</code> configuration option. The <code>app</code> method may also be used to set the <code>app</code> configuration option.</p>

<pre>    package MyApp;
    use base qw(Net::Server::PSGI);

    sub default_server_type { &#39;Prefork&#39; }

    sub my_app {
        my $env = shift;
        return [200, [&#39;Content-type&#39;, &#39;text/html&#39;], [&#34;Hello world&#34;]];
    }


    MyApp-&#62;run(app =&#62; \&#38;my_app);


    # OR
    sub app { \&#38;my_app }
    MyApp-&#62;run;


    # OR
    my $server = MyApp-&#62;new;
    $server-&#62;app(\&#38;my_app);
    $server-&#62;run;</pre>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="OPTIONS"
>OPTIONS</a></h1>

<p>In addition to the command line arguments of the Net::Server::HTTP base classes you can also set the following options.</p>

<dl>
<dt><a name="app"
>app</a></dt>

<dd>
<p>Should return a coderef of the PSGI application. Is returned by the app method.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Paul T. Seamons paul@seamons.com</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>Please see also <a href="../../Plack.html" class="podlinkpod"
>Plack</a>, <a href="../../Starman.html" class="podlinkpod"
>Starman</a>,</p>

<p><a href="../../Net/Server/Fork.html" class="podlinkpod"
>Net::Server::Fork</a>, <a href="../../Net/Server/INET.html" class="podlinkpod"
>Net::Server::INET</a>, <a href="../../Net/Server/PreFork.html" class="podlinkpod"
>Net::Server::PreFork</a>, <a href="../../Net/Server/PreForkSimple.html" class="podlinkpod"
>Net::Server::PreForkSimple</a>, <a href="../../Net/Server/MultiType.html" class="podlinkpod"
>Net::Server::MultiType</a>, <a href="../../Net/Server/Single.html" class="podlinkpod"
>Net::Server::Single</a> <a href="../../Net/Server/SIG.html" class="podlinkpod"
>Net::Server::SIG</a> <a href="../../Net/Server/Daemonize.html" class="podlinkpod"
>Net::Server::Daemonize</a> <a href="../../Net/Server/Proto.html" class="podlinkpod"
>Net::Server::Proto</a> <a href="../../Net/Server/HTTP.html" class="podlinkpod"
>Net::Server::HTTP</a></p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
