<html><head><title>Net::Server::Multiplex</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:23 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#PROCESS_FLOW'>PROCESS FLOW</a>
  <li class='indexItem indexItem1'><a href='#CLIENT_PROCESSING'>CLIENT PROCESSING</a>
  <li class='indexItem indexItem1'><a href='#HOOKS'>HOOKS</a>
  <li class='indexItem indexItem1'><a href='#TIMEOUTS'>TIMEOUTS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#set_timeout'>set_timeout</a>
    <li class='indexItem indexItem2'><a href='#mux_timeout'>mux_timeout</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#CALLBACK_INTERFACE'>CALLBACK INTERFACE</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#mux_connection_(%24mux%2C%24fh)'>mux_connection ($mux,$fh)</a>
    <li class='indexItem indexItem2'><a href='#mux_input_(%24mux%2C%24fh%2C%5C%24data)'>mux_input ($mux,$fh,\$data)</a>
    <li class='indexItem indexItem2'><a href='#mux_eof_(%24mux%2C%24fh%2C%5C%24data)'>mux_eof ($mux,$fh,\$data)</a>
    <li class='indexItem indexItem2'><a href='#mux_close_(%24mux%2C%24fh)'>mux_close ($mux,$fh)</a>
    <li class='indexItem indexItem2'><a href='#mux_timeout_(%24mux%2C%24fh)'>mux_timeout ($mux,$fh)</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#MAINTAINER'>MAINTAINER</a>
  <li class='indexItem indexItem1'><a href='#LICENSE'>LICENSE</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Net::Server::Multiplex - Multiplex several connections within one process</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    package MyPlexer;

    use base qw(Net::Server::Multiplex);

    sub mux_input {
        #...code...
    }

    __PACKAGE__-&#62;run();</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This personality is designed to handle multiple connections all within one process. It should only be used with protocols that are guaranteed to be able to respond quickly on a packet by packet basis. If determining a response could take a while or an unknown period of time, all other connections established will block until the response completes. If this condition might ever occur, this personality should probably not be used.</p>

<p>This takes some nice features of Net::Server (like the server listen socket setup, configuration file processing, safe signal handling, convenient inet style STDIN/STDOUT handling, logging features, deamonization and pid tracking, and restartability -SIGHUP) and some nice features of IO::Multiplex (automatic buffered IO and per-file-handle objects) and combines them for an easy-to-use interace.</p>

<p>See examples/samplechat.pl distributed with Net::Server for a simple chat server that uses several of these features.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PROCESS_FLOW"
>PROCESS FLOW</a></h1>

<p>The process flow is written in an open, easy to override, easy to hook, fashion. The basic flow is shown below.</p>

<pre>    $self-&#62;configure_hook;

    $self-&#62;configure(@_);

    $self-&#62;post_configure;

    $self-&#62;post_configure_hook;

    $self-&#62;pre_bind;

    $self-&#62;bind;

    if (Restarting server) {
        $self-&#62;restart_open_hook();
    }

    $self-&#62;post_bind_hook;

    $self-&#62;post_bind;

    $self-&#62;pre_loop_hook;

    $self-&#62;loop; # This basically just runs IO::Multiplex::loop
    # For routines inside a $self-&#62;loop
    # See CLIENT PROCESSING below

    $self-&#62;pre_server_close_hook;

    $self-&#62;post_child_cleanup_hook;

    $self-&#62;server_close;

    if (Restarting server) {
        $self-&#62;restart_close_hook();
        $self-&#62;hup_server;
        # Redo process again starting with configure_hook
  }</pre>

<p>The server then exits.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CLIENT_PROCESSING"
>CLIENT PROCESSING</a></h1>

<p>The following represents the client processing program flow:</p>

<pre>    $self-&#62;{server}-&#62;{client} = Net::Server::Proto::TCP-&#62;accept();  # NOTE: Multiplexed with mux_input() below

    if (check_for_dequeue seconds have passed) {
        $self-&#62;run_dequeue();
    }

    $self-&#62;get_client_info;

    $self-&#62;post_accept_hook; # Net::Server style

    if ($self-&#62;allow_deny
        &#38;&#38; $self-&#62;allow_deny_hook) {

      # (Net::Server style $self-&#62;process_request() is never called.)

      # A unique client specific object is created
      # for all mux_* methods from this point on.
      $self = __PACKAGE__-&#62;new($self, client);

      $self-&#62;mux_connection; # IO::Multiplex style

      for (every packet received) {
        $self-&#62;mux_input;  # NOTE: Multiplexed with accept() above
      }

    } else {

      $self-&#62;request_denied_hook;

      # Notice that if either allow_deny or allow_deny_hook fails, then
      # new(), mux_connection(), and mux_input() will never be called.
      # mux_eof() and mux_close() will still be called, but using a
      # common listen socket callback object instead of a unique client
      # specific object.

    }

    $self-&#62;mux_eof;

    $self-&#62;post_process_request_hook;

    $self-&#62;mux_close;</pre>

<p>This process then loops multiplexing between the accept() for the next connection and mux_input() when input arrives to avoid blocking either one.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="HOOKS"
>HOOKS</a></h1>

<p>The *_hook methods mentioned above are meant to be overridden with your own subroutines if you desire to provide additional functionality.</p>

<p>The loop() method of Net::Server has been overridden to run the loop routine of IO::Multiplex instead. The Net::Server methods may access the IO::Multiplex object at <code>$self-&#62;{mux}</code> if desired. The IO::Multiplex methods may access the Net::Server object at <code>$self-&#62;{net_server}</code> if desired.</p>

<p>The process_request() method is never used with this personality.</p>

<p>The other Net::Server hooks and methods should work the same.</p>

<dl>
<dt><a name="$self-&#62;run_dequeue()"
><code>$self-&#62;run_dequeue()</code></a></dt>

<dd>
<p>This hook only gets called in conjunction with the check_for_dequeue setting. It will run every check_for_dequeue seconds. Since no forking is done, this hook should run fast in order to prevent blocking the rest of the processing.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TIMEOUTS"
>TIMEOUTS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="set_timeout"
>set_timeout</a></h2>

<p>To utilize the optional timeout feature of IO::Multiplex, you need to specify a timeout by using the set_timeout method.</p>

<p>$self-&#62;{net_server}-&#62;{mux}-&#62;set_timeout($fh, $seconds_from_now);</p>

<p>$fh may be either a client socket or a listen socket file descriptor within the mux. $seconds_from_now may be fractional to achieve more precise timeouts. This is used in conjunction with mux_timeout, which you should define yourself.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="mux_timeout"
>mux_timeout</a></h2>

<p>The main loop() routine will call $obj-&#62;mux_timeout($mux, $fh) when the timeout specified in set_timeout is reached where $fh is the same as the one specified in set_timeout() and $obj is its corresponding object (either the unique client specific object or the main listen callback object) and $mux is the main IO::Multiplex object itself.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CALLBACK_INTERFACE"
>CALLBACK INTERFACE</a></h1>

<p>Callback objects should support the following interface. You do not have to provide all of these methods, just provide the ones you are interested in. These are just like the IO::Multiplex hooks except that STDOUT is tied to the corresponding client socket handle for your convenience and to more closely emulate the Net::Server model. However, unlike some other Net::Server personalities, you should never read directly from STDIN yourself. You should define one or more of the following methods:</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="mux_connection_($mux,$fh)"
>mux_connection ($mux,$fh)</a></h2>

<p>(OPTIONAL) Run once when the client first connects if the allow_deny passes. Note that the <code>$self-&#62;{net_server}-&#62;{server}</code> property hash may be modified by future connections through Net::Server. Any values within it that this object may need to use later should be copied within its own object at this point.</p>

<pre>  Example:
  $self-&#62;{peerport} = $self-&#62;{net_server}-&#62;{server}-&#62;{peerport};</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="mux_input_($mux,$fh,\$data)"
>mux_input ($mux,$fh,\$data)</a></h2>

<p>(REQUIRED) Run each time a packet is read. It should consume $data starting at the left and leave unconsumed data in the scalar for future calls to mux_input.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="mux_eof_($mux,$fh,\$data)"
>mux_eof ($mux,$fh,\$data)</a></h2>

<p>(OPTIONAL) Run once when the client is done writing. It should consume the rest of $data since mux_input() will never be run again.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="mux_close_($mux,$fh)"
>mux_close ($mux,$fh)</a></h2>

<p>(OPTIONAL) Run after the entire client socket has been closed. No more attempts should be made to read or write to the client or to STDOUT.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="mux_timeout_($mux,$fh)"
>mux_timeout ($mux,$fh)</a></h2>

<p>(OPTIONAL) Run once when the set_timeout setting expires as explained above.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>This is only known to work with TCP servers.</p>

<p>If you need to use the IO::Multiplex style set_timeout / mux_timeout interface, you cannot use the Net::Server style check_for_dequeue / run_dequeue interface. It will not work if the check_for_dequeue option is specified. The run_dequeue method is just a compatibility interface to comply with the Net::Server::Fork style run_dequeue but is implemented in terms of the IO::Multiplex style set_timeout and mux_timeout methods.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Rob Brown &#60;bbb@cpan.org&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="MAINTAINER"
>MAINTAINER</a></h1>

<p>Paul Seamons &#60;paul@seamons.com&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENSE"
>LICENSE</a></h1>

<pre>  This package may be distributed under the terms of either the
  GNU General Public License
     or the
  Perl Artistic License

  All rights reserved.</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../../Net/Server.html" class="podlinkpod"
>Net::Server</a> by Paul Seamons &#60;paul@seamons.com&#62;,</p>

<p><a href="../../IO/Multiplex.html" class="podlinkpod"
>IO::Multiplex</a> by Bruce Keeler &#60;bruce@gridpoint.com&#62;.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
