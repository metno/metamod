<html><head><title>Net::Server::HTTP</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:23 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#TEST_ONE_LINER'>TEST ONE LINER</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <li class='indexItem indexItem1'><a href='#OPTIONS'>OPTIONS</a>
  <li class='indexItem indexItem1'><a href='#TODO'>TODO</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#THANKS'>THANKS</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Net::Server::HTTP - very basic Net::Server based HTTP server class</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TEST_ONE_LINER"
>TEST ONE LINER</a></h1>

<pre>    perl -e &#39;use base qw(Net::Server::HTTP); main-&#62;run(port =&#62; 8080)&#39;
    # will start up an echo server</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    use base qw(Net::Server::HTTP);
    __PACKAGE__-&#62;run;

    sub process_http_request {
        my $self = shift;

        print &#34;Content-type: text/html\n\n&#34;;
        print &#34;&#60;form method=post action=/bam&#62;&#60;input type=text name=foo&#62;&#60;input type=submit&#62;&#60;/form&#62;\n&#34;;

        require Data::Dumper;
        local $Data::Dumper::Sortkeys = 1;

        require CGI;
        my $form = {};
        my $q = CGI-&#62;new; $form-&#62;{$_} = $q-&#62;param($_) for $q-&#62;param;

        print &#34;&#60;pre&#62;&#34;.Data::Dumper-&#62;Dump([\%ENV, $form], [&#39;*ENV&#39;, &#39;form&#39;]).&#34;&#60;/pre&#62;&#34;;
    }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Even though Net::Server::HTTP doesn&#39;t fall into the normal parallel of the other Net::Server flavors, handling HTTP requests is an often requested feature and is a standard and simple protocol.</p>

<p>Net::Server::HTTP begins with base type MultiType defaulting to Net::Server::Fork. It is easy to change it to any of the other Net::Server flavors by passing server_type =&#62; $other_flavor in the server configurtation. The port has also been defaulted to port 80 - but could easily be changed to another through the server configuration. You can also very easily add ssl by including, proto=&#62;&#34;ssl&#34; and provide a SSL_cert_file and SSL_key_file.</p>

<p>For example, here is a basic server that will bind to all interfaces, will speak both HTTP on port 8080 as well as HTTPS on 8443, and will speak both IPv4, as well as IPv6 if it is available.</p>

<pre>    use base qw(Net::Server::HTTP);

    __PACKAGE__-&#62;run(
        port  =&#62; [8080, &#34;8443/ssl&#34;],
        ipv   =&#62; &#39;*&#39;, # IPv6 if available
        SSL_key_file  =&#62; &#39;/my/key&#39;,
        SSL_cert_file =&#62; &#39;/my/cert&#39;,
    );</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<dl>
<dt><a name="_init_access_log"
><code>_init_access_log</code></a></dt>

<dd>
<p>Used to open and initialize any requested access_log (see access_log_file and access_log_format).</p>

<dt><a name="_tie_client_stdout"
><code>_tie_client_stdout</code></a></dt>

<dd>
<p>Used to initialize automatic response header parsing.</p>

<dt><a name="process_http_request"
><code>process_http_request</code></a></dt>

<dd>
<p>Will be passed the client handle, and will have STDOUT and STDIN tied to the client.</p>

<p>During this method, the %ENV will have been set to a standard CGI style environment. You will need to be sure to print the Content-type header. This is one change from the other standard Net::Server base classes.</p>

<p>During this method you can read from %ENV and STDIN just like a normal HTTP request in other web servers. You can print to STDOUT and Net::Server will handle the header negotiation for you.</p>

<p>Note: Net::Server::HTTP has no concept of document root or script aliases or default handling of static content. That is up to the consumer of Net::Server::HTTP to work out.</p>

<p>Net::Server::HTTP comes with a basic %ENV display installed as the default process_http_request method.</p>

<dt><a name="process_request"
><code>process_request</code></a></dt>

<dd>
<p>This method has been overridden in Net::Server::HTTP - you should not use it while using Net::Server::HTTP. This overridden method parses the environment and sets up request alarms and handles dying failures. It calls process_http_request once the request is ready and headers have been parsed.</p>

<dt><a name="process_headers"
><code>process_headers</code></a></dt>

<dd>
<p>Used to read in the incoming headers and set the ENV.</p>

<dt><a name="_init_http_request_info"
><code>_init_http_request_info</code></a></dt>

<dd>
<p>Called at the end of process_headers. Initializes the contents of http_request_info.</p>

<dt><a name="http_request_info"
><code>http_request_info</code></a></dt>

<dd>
<p>Returns a hashref of information specific to the current request. This information will be used for logging later on.</p>

<dt><a name="send_status"
><code>send_status</code></a></dt>

<dd>
<p>Takes an HTTP status and a message. Sends out the correct headers.</p>

<dt><a name="send_500"
><code>send_500</code></a></dt>

<dd>
<p>Calls send_status with 500 and the argument passed to send_500.</p>

<dt><a name="c&#60;log_http_request&#62;"
>c&#60;log_http_request&#62;</a></dt>

<dd>
<p>Called at the end of post_process_request. The default method looks for the default access_log_format and checks if logging was initilized during _init_access_log. If both of these exist, the http_request_info is formatted using http_log_format and the result is logged.</p>

<dt><a name="http_log_format"
><code>http_log_format</code></a></dt>

<dd>
<p>Takes a format string, and request_info and returns a formatted string. The format should follow the apache mod_log_config specification. As in the mod_log_config specification, backslashes, quotes should be escaped with backslashes and you may also include \n and \t characters as well.</p>

<p>The following is a listing of the available parameters as well as sample output based on a very basic HTTP server.</p>

<pre>    %%                %                 # a percent
    %a                ::1               # remote ip
    %A                ::1               # local ip
    %b                83                # response size (- if 0) Common Log Format
    %B                83                # response size
    %{bar}C           baz               # value of cookie by that name
    %D                916               # elapsed in microseconds
    %{HTTP_COOKIE}e   bar=baz           # value of %ENV by that name
    %f                -                 # filename - unused
    %h                ::1               # remote host if lookups are on, remote ip otherwise
    %H                http              # request protocol
    %{Host}i          localhost:8080    # request header by that name
    %I                336               # bytes received including headers
    %l                -                 # remote logname - unsused
    %m                GET               # request method
    %n                Just a note       # http_note by that name
    %{Content-type}o  text/html         # output header by that name
    %O                189               # response size including headers
    %p                8080              # server port
    %P                22999             # pid - does not support %{tid}P
    q                 ?hello=there      # query_string including ? (- otherwise)
    r                 GET /bam?hello=there HTTP/1.1      # the first line of the request
    %s                200               # response status
    %u                -                 # remote user - unused
    %U                /bam              # request path (no query string)
    %t                [06/Jun/2012:12:14:21 -0600]       # http_log_time standard format
    %t{%F %T %z}t     [2012-06-06 12:14:21 -0600]        # http_log_time with format
    %T                0                 # elapsed time in seconds
    %v                localhost:8080    # http_log_vhost - partial implementation
    %V                localhost:8080    # http_log_vhost - partial implementation
    %X                -                 # Connection completed and is &#39;close&#39; (-)</pre>

<p>Additionally, the log parsing allows for the following formats.</p>

<pre>    %&#62;s               200               # status of last request
    %&#60;s               200               # status of original request
    %400a             -                 # remote ip if status is 400
    %!400a            ::1               # remote ip if status is not 400
    %!200a            -                 # remote ip if status is not 200</pre>

<p>There are few bits not completely implemented:</p>

<pre>    &#62; and &#60;    # There is no internal redirection
    %I         # The answer to this is based on header size and Content-length
                 instead of the more correct actual number of bytes read though
                 in common cases those would be the same.
    %X         # There is no Connection keepalive in the default server.
    %v and %V  # There are no virtual hosts in the default HTTP server.
    %{tid}P    # The default servers are not threaded.</pre>

<p>See the <code>access_log_format</code> option for how to set a different format as well as to see the default string.</p>

<dt><a name="exec_cgi"
><code>exec_cgi</code></a></dt>

<dd>
<p>Allow for calling an external script as a CGI. This will use IPC::Open3 to fork a new process and read/write from it.</p>

<pre>    use base qw(Net::Server::HTTP);
    __PACKAGE__-&#62;run;

    sub process_http_request {
        my $self = shift;

        if ($ENV{&#39;PATH_INFO&#39;} &#38;&#38; $ENV{&#39;PATH_INFO&#39;} =~ s{^ (/foo) (?= $ | /) }{}x) {
           $ENV{&#39;SCRIPT_NAME&#39;} = $1;
           my $file = &#34;/var/www/cgi-bin/foo&#34;; # assuming this exists
           return $self-&#62;exec_cgi($file);
        }

        print &#34;Content-type: text/html\n\n&#34;;
        print &#34;&#60;a href=/foo&#62;Foo&#60;/a&#62;&#34;;
    }</pre>

<p>At this first release, the parent server is not tracking the child script which may cause issues if the script is running when a HUP is received.</p>

<dt><a name="http_log_time"
><code>http_log_time</code></a></dt>

<dd>
<p>Used to implement the %t format.</p>

<dt><a name="http_log_env"
><code>http_log_env</code></a></dt>

<dd>
<p>Used to implement the %e format.</p>

<dt><a name="http_log_cookie"
><code>http_log_cookie</code></a></dt>

<dd>
<p>Used to implement the %C format.</p>

<dt><a name="http_log_header_in"
><code>http_log_header_in</code></a></dt>

<dd>
<p>used to implement the %i format.</p>

<dt><a name="http_log_note"
><code>http_log_note</code></a></dt>

<dd>
<p>Used to implement the %n format.</p>

<dt><a name="http_note"
><code>http_note</code></a></dt>

<dd>
<p>Takes a key and an optional value. If passed a key and value, sets the note for that key. Always returns the value. These notes currently only are used for %{key}n output format.</p>

<dt><a name="http_log_header_out"
><code>http_log_header_out</code></a></dt>

<dd>
<p>Used to implement the %o format.</p>

<dt><a name="http_log_pid"
><code>http_log_pid</code></a></dt>

<dd>
<p>Used to implement the %P format.</p>

<dt><a name="http_log_vhost"
><code>http_log_vhost</code></a></dt>

<dd>
<p>Used to implement the %v and %V formats.</p>

<dt><a name="http_log_constat"
><code>http_log_constat</code></a></dt>

<dd>
<p>Used to implement the %X format.</p>

<dt><a name="exec_trusted_perl"
><code>exec_trusted_perl</code></a></dt>

<dd>
<p>Allow for calling an external perl script. This method will still fork, but instead of using IPC::Open3, it simply requires the perl script. That means that the running script will be able to make use of any shared memory. It also means that the STDIN/STDOUT/STDERR handles the script is using are those directly bound by the server process.</p>

<pre>    use base qw(Net::Server::HTTP);
    __PACKAGE__-&#62;run;

    sub process_http_request {
        my $self = shift;

        if ($ENV{&#39;PATH_INFO&#39;} &#38;&#38; $ENV{&#39;PATH_INFO&#39;} =~ s{^ (/foo) (?= $ | /) }{}x) {
           $ENV{&#39;SCRIPT_NAME&#39;} = $1;
           my $file = &#34;/var/www/cgi-bin/foo&#34;; # assuming this exists
           return $self-&#62;exec_trusted_perl($file);
        }

        print &#34;Content-type: text/html\n\n&#34;;
        print &#34;&#60;a href=/foo&#62;Foo&#60;/a&#62;&#34;;
    }</pre>

<p>At this first release, the parent server is not tracking the child script which may cause issues if the script is running when a HUP is received.</p>

<dt><a name="exec_fork_hook"
><code>exec_fork_hook</code></a></dt>

<dd>
<p>This method is called after the fork of exec_trusted_perl and exec_cgi hooks. It is passed the pid (0 if the child) and the file being ran. Note, that the hook will not be called from the child during exec_cgi.</p>

<dt><a name="http_dispatch"
><code>http_dispatch</code></a></dt>

<dd>
<p>Called if the default process_http_request and process_request methods have not been overridden and <code>app</code> configuration parameters have been passed. In this case this replaces the default echo server. You can also enable this subsystem for your own direct use by setting enable_dispatch to true during configuration. See the <code>app</code> configuration item. It will be passed a dispatch qr (regular expression) generated during _check_dispatch, and a dispatch table. The qr will be applied to path_info. This mechanism could be used to augment Net::Server::HTTP with document root and virtual host capabilities.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="OPTIONS"
>OPTIONS</a></h1>

<p>In addition to the command line arguments of the Net::Server base classes you can also set the following options.</p>

<dl>
<dt><a name="max_header_size"
>max_header_size</a></dt>

<dd>
<p>Defaults to 100_000. Maximum number of bytes to read while parsing headers.</p>

<dt><a name="server_revision"
>server_revision</a></dt>

<dd>
<p>Defaults to Net::Server::HTTP/$Net::Server::VERSION.</p>

<dt><a name="timeout_header"
>timeout_header</a></dt>

<dd>
<p>Defaults to 15 - number of seconds to wait for parsing headers.</p>

<dt><a name="timeout_idle"
>timeout_idle</a></dt>

<dd>
<p>Defaults to 60 - number of seconds a request can be idle before the request is closed.</p>

<dt><a name="access_log_file"
>access_log_file</a></dt>

<dd>
<p>Defaults to undef. If true, this represents the location of where the access log should be written to. If a special value of STDERR is passed, the access log entry will be writing to the same location as the ERROR log.</p>

<dt><a name="access_log_format"
>access_log_format</a></dt>

<dd>
<p>Should be a valid apache log format that will be passed to http_log_format. See the http_log_format method for more information.</p>

<p>The default value is the NCSA extended/combined log format:</p>

<pre>    &#39;%h %l %u %t \&#34;%r\&#34; %&#62;s %b \&#34;%{Referer}i\&#34; \&#34;%{User-Agent}i\&#34;&#39;</pre>

<dt><a name="app"
>app</a></dt>

<dd>
<p>Takes one or more items and registers them for dispatch. Arguments may be supplied as an arrayref containing a location/target pairs, a hashref containing a location/target pairs, a bare code ref that will use &#34;/&#34; as the location and the codref as the target, a string with a space indicating &#34;location target&#34;, a string containing &#34;location=target&#34;, or finally a string that will be used as both location and target. For items passed as an arrayref or hashref, the target may be a coderef which will be called and should handle the request. In all other cases the target should be a valid executable suitable for passing to exec_cgi.</p>

<p>The locations will be added in the order that they are configured. They will be added to a regular expression which will be applied to the incoming PATH_INFO string. If the match is successful, the $ENV{&#39;SCRIPT_NAME&#39;} will be set to the matched portion and the matched portion will be removed from $ENV{&#39;PATH_INFO&#39;}.</p>

<p>Once an app has been passed, it is necessary for the server to listen on /. Therefore if &#34;/&#34; has not been specifically configured for dispatch, the first found dispatch target will also be used to handle &#34;/&#34;.</p>

<p>For convenience, if the log_level is 2 or greater, the dispatch table is output to the log.</p>

<p>This mechanism is left as a generic mechanism suitable for overriding by servers meant to handle more complex dispatch. At the moment there is no handling of virtual hosts. At some point we will add in the default ability to play static content and likely for the ability to configure virtual hosts - or that may have to wait for a third party module.</p>

<pre>    app =&#62; &#34;/home/paul/foo.cgi&#34;,
      # Dispatch: /home/paul/foo.cgi =&#62; home/paul/foo.cgi
      # Dispatch: / =&#62; home/paul/foo.cgi (default)


    app =&#62; &#34;../../foo.cgi&#34;,
    app =&#62; &#34;./bar.cgi&#34;,
    app =&#62; &#34;baz ./bar.cgi&#34;,
    app =&#62; &#34;bim=./bar.cgi&#34;,
      # Dispatch: /foo.cgi =&#62; ../../foo.cgi
      # Dispatch: /bar.cgi =&#62; ./bar.cgi
      # Dispatch: /baz =&#62; ./bar.cgi
      # Dispatch: /bim =&#62; ./bar.cgi
      # Dispatch: / =&#62; ../../foo.cgi (default)


    app =&#62; &#34;../../foo.cgi&#34;,
    app =&#62; &#34;/=./bar.cgi&#34;,
      # Dispatch: /foo.cgi =&#62; ../../foo.cgi
      # Dispatch: / =&#62; ./bar.cgi

    # you could also do this on the commandline
    net-server HTTP app ../../foo.cgi app /=./bar.cgi

    # extended options when configured from code

    Net::Server::HTTP-&#62;run(app =&#62; { # loses order of matching
      &#39;/&#39; =&#62; sub { ... },
      &#39;/foo&#39; =&#62; sub { ... },
      &#39;/bar&#39; =&#62; &#39;/path/to/some.cgi&#39;,
    });

    Net::Server::HTTP-&#62;run(app =&#62; [
      &#39;/&#39; =&#62; sub { ... },
      &#39;/foo&#39; =&#62; sub { ... },
      &#39;/bar&#39; =&#62; &#39;/path/to/some.cgi&#39;,
    ]);</pre>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TODO"
>TODO</a></h1>

<p>Add support for writing out HTTP/1.1.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Paul T. Seamons paul@seamons.com</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="THANKS"
>THANKS</a></h1>

<p>See <a href="../../Net/Server.html" class="podlinkpod"
>Net::Server</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>Please see also <a href="../../Net/Server/Fork.html" class="podlinkpod"
>Net::Server::Fork</a>, <a href="../../Net/Server/INET.html" class="podlinkpod"
>Net::Server::INET</a>, <a href="../../Net/Server/PreFork.html" class="podlinkpod"
>Net::Server::PreFork</a>, <a href="../../Net/Server/PreForkSimple.html" class="podlinkpod"
>Net::Server::PreForkSimple</a>, <a href="../../Net/Server/MultiType.html" class="podlinkpod"
>Net::Server::MultiType</a>, <a href="../../Net/Server/Single.html" class="podlinkpod"
>Net::Server::Single</a> <a href="../../Net/Server/SIG.html" class="podlinkpod"
>Net::Server::SIG</a> <a href="../../Net/Server/Daemonize.html" class="podlinkpod"
>Net::Server::Daemonize</a> <a href="../../Net/Server/Proto.html" class="podlinkpod"
>Net::Server::Proto</a></p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
