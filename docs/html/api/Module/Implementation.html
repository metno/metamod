<html><head><title>Module::Implementation</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:21 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#API'>API</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Module%3A%3AImplementation%3A%3A%3Cbuild_loader_sub(...)'>Module::Implementation::&#60;build_loader_sub(...)</a>
    <li class='indexItem indexItem2'><a href='#Module%3A%3AImplementation%3A%3Aimplementation_for(%24package)'>Module::Implementation::implementation_for($package)</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#HOW_THE_IMPLEMENTATION_LOADER_WORKS'>HOW THE IMPLEMENTATION LOADER WORKS</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Module::Implementation - Loads one of several alternate underlying implementations for a module</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>version 0.06</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  package Foo::Bar;

  use Module::Implementation;

  BEGIN {
      my $loader = Module::Implementation::build_loader_sub(
          implementations =&#62; [ &#39;XS&#39;,  &#39;PurePerl&#39; ],
          symbols         =&#62; [ &#39;run&#39;, &#39;check&#39; ],
      );

      $loader-&#62;();
  }

  package Consumer;

  # loads the first viable implementation
  use Foo::Bar;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This module abstracts out the process of choosing one of several underlying implementations for a module. This can be used to provide XS and pure Perl implementations of a module, or it could be used to load an implementation for a given OS or any other case of needing to provide multiple implementations.</p>

<p>This module is only useful when you know all the implementations ahead of time. If you want to load arbitrary implementations then you probably want something like a plugin system, not this module.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="API"
>API</a></h1>

<p>This module provides two subroutines, neither of which are exported.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Module::Implementation::&#60;build_loader_sub(...)"
>Module::Implementation::&#60;build_loader_sub(...)</a></h2>

<p>This subroutine takes the following arguments.</p>

<ul>
<li>implementations
<p>This should be an array reference of implementation names. Each name should correspond to a module in the caller&#39;s namespace.</p>

<p>In other words, using the example in the <a href="#SYNOPSIS" class="podlinkpod"
>&#34;SYNOPSIS&#34;</a>, this module will look for the <code>Foo::Bar::XS</code> and <code>Foo::Bar::PurePerl</code> modules will be installed</p>

<p>This argument is required.</p>
</li>

<li>symbols
<p>A list of symbols to copy from the implementation package to the calling package.</p>

<p>These can be prefixed with a variable type: <code>$</code>, <code>@</code>, <code>%</code>, <code>&#38;</code>, or <code>*)</code>. If no prefix is given, the symbol is assumed to be a subroutine.</p>

<p>This argument is optional.</p>
</li>
</ul>

<p>This subroutine <i>returns</i> the implementation loader as a sub reference.</p>

<p>It is up to you to call this loader sub in your code.</p>

<p>I recommend that you <i>do not</i> call this loader in an <code>import()</code> sub. If a caller explicitly requests no imports, your <code>import()</code> sub will not be run at all, which can cause weird breakage.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Module::Implementation::implementation_for($package)"
>Module::Implementation::implementation_for($package)</a></h2>

<p>Given a package name, this subroutine returns the implementation that was loaded for the package. This is not a full package name, just the suffix that identifies the implementation. For the <a href="#SYNOPSIS" class="podlinkpod"
>&#34;SYNOPSIS&#34;</a> example, this subroutine would be called as <code>Module::Implementation::implementation_for(&#39;Foo::Bar&#39;)</code>, and it would return &#34;XS&#34; or &#34;PurePerl&#34;.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="HOW_THE_IMPLEMENTATION_LOADER_WORKS"
>HOW THE IMPLEMENTATION LOADER WORKS</a></h1>

<p>The implementation loader works like this ...</p>

<p>First, it checks for an <code>%ENV</code> var specifying the implementation to load. The env var is based on the package name which loads the implementations. The <code>::</code> package separator is replaced with <code>_</code>, and made entirely upper-case. Finally, we append &#34;_IMPLEMENTATION&#34; to this name.</p>

<p>So in our <a href="#SYNOPSIS" class="podlinkpod"
>&#34;SYNOPSIS&#34;</a> example, the corresponding <code>%ENV</code> key would be <code>FOO_BAR_IMPLEMENTATION</code>.</p>

<p>If this is set, then the loader will <b>only</b> try to load this one implementation.</p>

<p>If the env var requests an implementation which doesn&#39;t match one of the implementations specified when the loader was created, an error is thrown.</p>

<p>If this one implementation fails to load then loader throws an error. This is useful for testing. You can request a specific implementation in a test file by writing something like this:</p>

<pre>  BEGIN { $ENV{FOO_BAR_IMPLEMENTATION} = &#39;XS&#39; }
  use Foo::Bar;</pre>

<p>If the environment variable is <i>not</i> set, then the loader simply tries the implementations originally passed to <code>Module::Implementation</code>. The implementations are tried in the order in which they were originally passed.</p>

<p>The loader will use the first implementation that loads without an error. It will copy any requested symbols from this implementation.</p>

<p>If none of the implementations can be loaded, then the loader throws an exception.</p>

<p>The loader returns the name of the package it loaded.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Dave Rolsky &#60;autarch@urth.org&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>This software is Copyright (c) 2012 by Dave Rolsky.</p>

<p>This is free software, licensed under:</p>

<pre>  The Artistic License 2.0 (GPL Compatible)</pre>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
