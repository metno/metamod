<html><head><title>Module::Compile</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:21 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#EXAMPLE'>EXAMPLE</a>
  <li class='indexItem indexItem1'><a href='#BENEFITS'>BENEFITS</a>
  <li class='indexItem indexItem1'><a href='#PARSING_AND_DISPATCH'>PARSING AND DISPATCH</a>
  <li class='indexItem indexItem1'><a href='#DISTRIBUTION_SUPPORT'>DISTRIBUTION SUPPORT</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    package Foo;
    use Module::Compile -base;

    sub pmc_compile {
        my ($class, $source) = @_;
        # Convert $source into (most likely Perl 5) $compiled_output
        return $compiled_output;
    }</pre>

<p>In <em>Bar.pm</em>:</p>

<pre>    package Bar;
    
    use Foo;
    ...
    no Foo</pre>

<p>or (implied &#34;no Foo;&#34;):</p>

<pre>    package Bar;
    
    {
        use Foo;
        ...
    }</pre>

<p>To compile <em>Bar.pm</em> into <em>Bar.pmc</em>:</p>

<pre>    perl -c Bar.pm</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This module provides a system for writing modules that <i>compile</i> other Perl modules.</p>

<p>Modules that use these compilation modules get compiled into some altered form the first time they are run. The result is cached into <code>.pmc</code> files.</p>

<p>Perl has native support for <code>.pmc</code> files. It always checks for them, before loading a <code>.pm</code> file.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXAMPLE"
>EXAMPLE</a></h1>

<p>You can declare a <code>v6.pm</code> compiler with:</p>

<pre>    package v6;
    use Module::Compile -base;
    
    sub pmc_compile {
        my ($class, $source) = @_;
        # ... some way to invoke pugs and give p5 code back ...
    }</pre>

<p>and use it like:</p>

<pre>    # MyModule.pm
    use v6-pugs;
    module MyModule;
    # ...some p6 code here...
    no v6;
    # ...back to p5 land...</pre>

<p>On the first time this module is loaded, it will compile Perl 6 blocks into Perl 5 (as soon as the <code>no v6</code> line is seen), and merge it with the Perl 5 blocks, saving the result into a <em>MyModule.pmc</em> file.</p>

<p>The next time around, Perl 5 will automatically load <em>MyModule.pmc</em> when someone says <code>use MyModule</code>. On the other hand, Perl 6 can run MyModule.pm s a Perl 6 module just fine, as <code>use v6-pugs</code> and <code>no v6</code> both works in a Perl 6 setting.</p>

<p>The <b>v6.pm</b> module will also check if <em>MyModule.pmc</em> is up to date. If it is, then it will touch its timestamp so the <code>.pmc</code> is loaded on the next time.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BENEFITS"
>BENEFITS</a></h1>

<p>Module::Compile compilers gives you the following benefits:</p>

<ul>
<li>Ability to mix many source filterish modules in a much more sane manner. Module::Compile controls the compilation process, calling each compiler at the right time with the right data.</li>

<li>Ability to ship precompiled modules without shipping Module::Compile and the compiler modules themselves.</li>

<li>Easier debugging of compiled/filtered code. The <code>.pmc</code> has the real code you want to see.</li>

<li>Zero additional runtime penalty after compilation, because <code>perl</code> has already been doing the <code>.pmc</code> check on every module load since 1999!</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PARSING_AND_DISPATCH"
>PARSING AND DISPATCH</a></h1>

<p>NOTE: *** NOT FULLY IMPLEMENTED YET ***</p>

<p>Module::Compile attempts to make source filtering a sane process, by parsing up your module&#39;s source code into various blocks; so that by the time a compiler is called it only gets the source code that it should be looking at.</p>

<p>This section describes the rather complex algorithm that Module::Compile uses.</p>

<p>First, the source module is preprocessed to hide heredocs, since the content inside heredocs can possibly confuse further parsing.</p>

<p>Next, the source module is divided into a shallow tree of blocks:</p>

<pre>    PREAMBLE:
        (SUBROUTINE | BAREBLOCK | POD | PLAIN)S
    PACKAGES:
        PREFACE
        (SUBROUTINE | BAREBLOCK | POD | PLAIN)S
    DATA</pre>

<p>All of these blocks begin and end on line boundaries. They are described as follows:</p>

<pre>    PREAMBLE - Lines before the first C&#60;package&#62; statement.
    PACKAGES - Lines beginning with a C&#60;package statement and continuing
        until the next C&#60;package&#62; or C&#60;DATA&#62; section.
    DATA - The DATA section. Begins with the line C&#60;__DATA__&#62; or
        C&#60;__END__&#62;.
    SUBROUTINE - A top level (not nested) subroutine. Ending &#39;}&#39; must be
        on its own line in the first column.
    BAREBLOCK - A top level (not nested) code block. Ending &#39;}&#39; must be
        on its own line in the first column.
    POD - Pod sections beginning with C&#60;^=\w+&#62; and ending with C&#60;=cut&#62;.
    PLAIN - Lines not in SUBROUTINE, BAREBLOCK or POD.
    PREFACE - Lines before the first block in a package.</pre>

<p>Next, all the blocks are scanned for lines like:</p>

<pre>    use Foo qw&#39;x y z&#39;;
    no Foo;</pre>

<p>Where Foo is a Module::Compile subclass.</p>

<p>The lines within a given block between a <code>use</code> and <code>no</code> statement are marked to be passed to that compiler. The end of an inner block effectively acts as a <code>no</code> statement for any compile sections in that block. <code>use</code> statements in a PREFACE apply to all the code in a PACKAGE. <code>use</code> statements in a PREAMBLE apply to all the code in all PACKAGES.</p>

<p>After all the code has been parsed into blocks and the blocks have been marked for various compilers, Module::Compile dispatches the code blocks to the compilers. It does so in a most specific to most general order. So inner blocks get compiled first, then outer blocks.</p>

<p>A compiler may choose to declare that its result not be recompiled by some other containing parser. In this case the result of the compilation is replaced by a single line containing the hexadecimal digest of the result in double quotes followed by a semicolon. Like:</p>

<pre>    &#34;f1d2d2f924e986ac86fdf7b36c94bcdf32beec15&#34;;</pre>

<p>The rationale of this is that randoms strings are usally left alone by compilers. After all the compilers have finished, the digest lines will be expanded again.</p>

<p>Every bit of the default process described above is overridable by various methods.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DISTRIBUTION_SUPPORT"
>DISTRIBUTION SUPPORT</a></h1>

<p>Module::Install makes it terribly easy to prepare a module distribution with compiled .pmc files. Module::Compile installs a Module::Install::PMC plugin. All you need to do is add this line to your Makefile.PL:</p>

<pre>    pmc_support;</pre>

<p>Any of your distrbution&#39;s modules that use Module::Compile based modules will automatically be compiled into .pmc files and shipped with your distribtution precompiled. This means that people who install your module distribtution do not need to have the compilers installed themselves. So you don&#39;t need to make the compiler modules be prerequisites.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>Module::Install</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
