<html><head><title>Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:21 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#CONCLUSION'>CONCLUSION</a>
  <li class='indexItem indexItem1'><a href='#FOOTNOTES'>FOOTNOTES</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Moose::Cookbook::Basics::HTTP_SubtypesAndCoercion - Demonstrates subtypes and coercion use HTTP-related classes (Request,
Protocol,
etc.)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>version 2.0604</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  package Request;
  use Moose;
  use Moose::Util::TypeConstraints;

  use HTTP::Headers  ();
  use Params::Coerce ();
  use URI            ();

  subtype &#39;My::Types::HTTP::Headers&#39; =&#62; as class_type(&#39;HTTP::Headers&#39;);

  coerce &#39;My::Types::HTTP::Headers&#39;
      =&#62; from &#39;ArrayRef&#39;
          =&#62; via { HTTP::Headers-&#62;new( @{$_} ) }
      =&#62; from &#39;HashRef&#39;
          =&#62; via { HTTP::Headers-&#62;new( %{$_} ) };

  subtype &#39;My::Types::URI&#39; =&#62; as class_type(&#39;URI&#39;);

  coerce &#39;My::Types::URI&#39;
      =&#62; from &#39;Object&#39;
          =&#62; via { $_-&#62;isa(&#39;URI&#39;)
                   ? $_
                   : Params::Coerce::coerce( &#39;URI&#39;, $_ ); }
      =&#62; from &#39;Str&#39;
          =&#62; via { URI-&#62;new( $_, &#39;http&#39; ) };

  subtype &#39;Protocol&#39;
      =&#62; as &#39;Str&#39;
      =&#62; where { /^HTTP\/[0-9]\.[0-9]$/ };

  has &#39;base&#39; =&#62; ( is =&#62; &#39;rw&#39;, isa =&#62; &#39;My::Types::URI&#39;, coerce =&#62; 1 );
  has &#39;uri&#39;  =&#62; ( is =&#62; &#39;rw&#39;, isa =&#62; &#39;My::Types::URI&#39;, coerce =&#62; 1 );
  has &#39;method&#39;   =&#62; ( is =&#62; &#39;rw&#39;, isa =&#62; &#39;Str&#39; );
  has &#39;protocol&#39; =&#62; ( is =&#62; &#39;rw&#39;, isa =&#62; &#39;Protocol&#39; );
  has &#39;headers&#39;  =&#62; (
      is      =&#62; &#39;rw&#39;,
      isa     =&#62; &#39;My::Types::HTTP::Headers&#39;,
      coerce  =&#62; 1,
      default =&#62; sub { HTTP::Headers-&#62;new }
  );</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This recipe introduces type coercions, which are defined with the <code>coerce</code> sugar function. Coercions are attached to existing type constraints, and define a (one-way) transformation from one type to another.</p>

<p>This is very powerful, but it can also have unexpected consequences, so you have to explicitly ask for an attribute to be coerced. To do this, you must set the <code>coerce</code> attribute option to a true value.</p>

<p>First, we create the subtype to which we will coerce the other types:</p>

<pre>  subtype &#39;My::Types::HTTP::Headers&#39; =&#62; as class_type(&#39;HTTP::Headers&#39;);</pre>

<p>We are creating a subtype rather than using <code>HTTP::Headers</code> as a type directly. The reason we do this is that coercions are global, and a coercion defined for <code>HTTP::Headers</code> in our <code>Request</code> class would then be defined for <i>all</i> Moose-using classes in the current Perl interpreter. It&#39;s a <a href="../../../Moose/Manual/BestPractices.html" class="podlinkpod"
>best practice</a> to avoid this sort of namespace pollution.</p>

<p>The <code>class_type</code> sugar function is simply a shortcut for this:</p>

<pre>  subtype &#39;HTTP::Headers&#39;
      =&#62; as &#39;Object&#39;
      =&#62; where { $_-&#62;isa(&#39;HTTP::Headers&#39;) };</pre>

<p>Internally, Moose creates a type constraint for each Moose-using class, but for non-Moose classes, the type must be declared explicitly.</p>

<p>We could go ahead and use this new type directly:</p>

<pre>  has &#39;headers&#39; =&#62; (
      is      =&#62; &#39;rw&#39;,
      isa     =&#62; &#39;My::Types::HTTP::Headers&#39;,
      default =&#62; sub { HTTP::Headers-&#62;new }
  );</pre>

<p>This creates a simple attribute which defaults to an empty instance of <a href="../../../HTTP/Headers.html" class="podlinkpod"
>HTTP::Headers</a>.</p>

<p>The constructor for <a href="../../../HTTP/Headers.html" class="podlinkpod"
>HTTP::Headers</a> accepts a list of key-value pairs representing the HTTP header fields. In Perl, such a list could be stored in an ARRAY or HASH reference. We want our <code>headers</code> attribute to accept those data structures instead of an <b>HTTP::Headers</b> instance, and just do the right thing. This is exactly what coercion is for:</p>

<pre>  coerce &#39;My::Types::HTTP::Headers&#39;
      =&#62; from &#39;ArrayRef&#39;
          =&#62; via { HTTP::Headers-&#62;new( @{$_} ) }
      =&#62; from &#39;HashRef&#39;
          =&#62; via { HTTP::Headers-&#62;new( %{$_} ) };</pre>

<p>The first argument to <code>coerce</code> is the type <i>to</i> which we are coercing. Then we give it a set of <code>from</code>/<code>via</code> clauses. The <code>from</code> function takes some other type name and <code>via</code> takes a subroutine reference which actually does the coercion.</p>

<p>However, defining the coercion doesn&#39;t do anything until we tell Moose we want a particular attribute to be coerced:</p>

<pre>  has &#39;headers&#39; =&#62; (
      is      =&#62; &#39;rw&#39;,
      isa     =&#62; &#39;My::Types::HTTP::Headers&#39;,
      coerce  =&#62; 1,
      default =&#62; sub { HTTP::Headers-&#62;new }
  );</pre>

<p>Now, if we use an <code>ArrayRef</code> or <code>HashRef</code> to populate <code>headers</code>, it will be coerced into a new <a href="../../../HTTP/Headers.html" class="podlinkpod"
>HTTP::Headers</a> instance. With the coercion in place, the following lines of code are all equivalent:</p>

<pre>  $foo-&#62;headers( HTTP::Headers-&#62;new( bar =&#62; 1, baz =&#62; 2 ) );
  $foo-&#62;headers( [ &#39;bar&#39;, 1, &#39;baz&#39;, 2 ] );
  $foo-&#62;headers( { bar =&#62; 1, baz =&#62; 2 } );</pre>

<p>As you can see, careful use of coercions can produce a very open interface for your class, while still retaining the &#34;safety&#34; of your type constraint checks. (1)</p>

<p>Our next coercion shows how we can leverage existing CPAN modules to help implement coercions. In this case we use <a href="../../../Params/Coerce.html" class="podlinkpod"
>Params::Coerce</a>.</p>

<p>Once again, we need to declare a class type for our non-Moose <a href="../../../URI.html" class="podlinkpod"
>URI</a> class:</p>

<pre>  subtype &#39;My::Types::URI&#39; =&#62; as class_type(&#39;URI&#39;);</pre>

<p>Then we define the coercion:</p>

<pre>  coerce &#39;My::Types::URI&#39;
      =&#62; from &#39;Object&#39;
          =&#62; via { $_-&#62;isa(&#39;URI&#39;)
                   ? $_
                   : Params::Coerce::coerce( &#39;URI&#39;, $_ ); }
      =&#62; from &#39;Str&#39;
          =&#62; via { URI-&#62;new( $_, &#39;http&#39; ) };</pre>

<p>The first coercion takes any object and makes it a <code>URI</code> object. The coercion system isn&#39;t that smart, and does not check if the object is already a <a href="../../../URI.html" class="podlinkpod"
>URI</a>, so we check for that ourselves. If it&#39;s not a <a href="../../../URI.html" class="podlinkpod"
>URI</a> already, we let <a href="../../../Params/Coerce.html" class="podlinkpod"
>Params::Coerce</a> do its magic, and we just use its return value.</p>

<p>If <a href="../../../Params/Coerce.html" class="podlinkpod"
>Params::Coerce</a> didn&#39;t return a <a href="../../../URI.html" class="podlinkpod"
>URI</a> object (for whatever reason), Moose would throw a type constraint error.</p>

<p>The other coercion takes a string and converts it to a <a href="../../../URI.html" class="podlinkpod"
>URI</a>. In this case, we are using the coercion to apply a default behavior, where a string is assumed to be an <code>http</code> URI.</p>

<p>Finally, we need to make sure our attributes enable coercion.</p>

<pre>  has &#39;base&#39; =&#62; ( is =&#62; &#39;rw&#39;, isa =&#62; &#39;My::Types::URI&#39;, coerce =&#62; 1 );
  has &#39;uri&#39;  =&#62; ( is =&#62; &#39;rw&#39;, isa =&#62; &#39;My::Types::URI&#39;, coerce =&#62; 1 );</pre>

<p>Re-using the coercion lets us enforce a consistent API across multiple attributes.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CONCLUSION"
>CONCLUSION</a></h1>

<p>This recipe showed the use of coercions to create a more flexible and DWIM-y API. Like any powerful feature, we recommend some caution. Sometimes it&#39;s better to reject a value than just guess at how to DWIM.</p>

<p>We also showed the use of the <code>class_type</code> sugar function as a shortcut for defining a new subtype of <code>Object</code>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FOOTNOTES"
>FOOTNOTES</a></h1>

<dl>
<dt><a name="(1)"
>(1)</a></dt>

<dd>
<p>This particular example could be safer. Really we only want to coerce an array with an <i>even</i> number of elements. We could create a new <code>EvenElementArrayRef</code> type, and then coerce from that type, as opposed to a plain <code>ArrayRef</code></p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Moose is maintained by the Moose Cabal, along with the help of many contributors. See <a href="../../../Moose.html#CABAL" class="podlinkpod"
>&#34;CABAL&#34; in Moose</a> and <a href="../../../Moose.html#CONTRIBUTORS" class="podlinkpod"
>&#34;CONTRIBUTORS&#34; in Moose</a> for details.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>This software is copyright (c) 2012 by Infinity Interactive, Inc..</p>

<p>This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
