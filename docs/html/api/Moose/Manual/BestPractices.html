<html><head><title>Moose::Manual::BestPractices</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:21 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#RECOMMENDATIONS'>RECOMMENDATIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#namespace%3A%3Aautoclean_and_immutabilize'>namespace::autoclean and immutabilize</a>
    <li class='indexItem indexItem2'><a href='#Never_override_new'>Never override new</a>
    <li class='indexItem indexItem2'><a href='#Always_call_the_original%2Fparent_BUILDARGS'>Always call the original/parent BUILDARGS</a>
    <li class='indexItem indexItem2'><a href='#Provide_defaults_whenever_possible%2C_otherwise_use_required'>Provide defaults whenever possible, otherwise use required</a>
    <li class='indexItem indexItem2'><a href='#Use_builder_instead_of_default_most_of_the_time'>Use builder instead of default most of the time</a>
    <li class='indexItem indexItem2'><a href='#Be_lazy'>Be lazy</a>
    <li class='indexItem indexItem2'><a href='#Consider_keeping_clearers_and_predicates_private'>Consider keeping clearers and predicates private</a>
    <li class='indexItem indexItem2'><a href='#Avoid_lazy_build'>Avoid lazy_build</a>
    <li class='indexItem indexItem2'><a href='#Default_to_read-only%2C_and_consider_keeping_writers_private'>Default to read-only, and consider keeping writers private</a>
    <li class='indexItem indexItem2'><a href='#Think_twice_before_changing_an_attribute%27s_type_in_a_subclass'>Think twice before changing an attribute&#39;s type in a subclass</a>
    <li class='indexItem indexItem2'><a href='#Don%27t_use_the_initializer_feature'>Don&#39;t use the initializer feature</a>
    <li class='indexItem indexItem2'><a href='#Use_Moose%3A%3AMeta%3A%3AAttribute%3A%3ANative_traits_instead_of_auto_deref'>Use Moose::Meta::Attribute::Native traits instead of auto_deref</a>
    <li class='indexItem indexItem2'><a href='#Always_call_inner_in_the_most_specific_subclass'>Always call inner in the most specific subclass</a>
    <li class='indexItem indexItem2'><a href='#Namespace_your_types'>Namespace your types</a>
    <li class='indexItem indexItem2'><a href='#Do_not_coerce_Moose_built-ins_directly'>Do not coerce Moose built-ins directly</a>
    <li class='indexItem indexItem2'><a href='#Do_not_coerce_class_names_directly'>Do not coerce class names directly</a>
    <li class='indexItem indexItem2'><a href='#Use_coercion_instead_of_unions'>Use coercion instead of unions</a>
    <li class='indexItem indexItem2'><a href='#Define_all_your_types_in_one_module'>Define all your types in one module</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#BENEFITS_OF_BEST_PRACTICES'>BENEFITS OF BEST PRACTICES</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Moose::Manual::BestPractices - Get the most out of Moose</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>version 2.0604</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="RECOMMENDATIONS"
>RECOMMENDATIONS</a></h1>

<p>Moose has a lot of features,
and there&#39;s definitely more than one way to do it.
However,
we think that picking a subset of these features and using them consistently makes everyone&#39;s life easier.</p>

<p>Of course,
as with any list of &#34;best practices&#34;,
these are really just opinions.
Feel free to ignore us.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="namespace::autoclean_and_immutabilize"
><code>namespace::autoclean</code> and immutabilize</a></h2>

<p>We recommend that you remove the Moose sugar and end your Moose class definitions by making your class immutable.</p>

<pre>  package Person;

  use Moose;
  use namespace::autoclean;

  # extends, roles, attributes, etc.

  # methods

  __PACKAGE__-&#62;meta-&#62;make_immutable;

  1;</pre>

<p>The <code>use namespace::autoclean</code> bit is simply good code hygiene, as it removes imported symbols from your class&#39;s namespace at the end of your package&#39;s compile cycle, including Moose keywords. Once the class has been built, these keywords are not needed. (This is preferred to placing <code>no Moose</code> at the end of your package).</p>

<p>The <code>make_immutable</code> call allows Moose to speed up a lot of things, most notably object construction. The trade-off is that you can no longer change the class definition.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Never_override_new"
>Never override <code>new</code></a></h2>

<p>Overriding <code>new</code> is a very bad practice. Instead, you should use a <code>BUILD</code> or <code>BUILDARGS</code> methods to do the same thing. When you override <code>new</code>, Moose can no longer inline a constructor when your class is immutabilized.</p>

<p>There are two good reasons to override <code>new</code>. One, you are writing a MooseX extension that provides its own <a href="../../Moose/Object.html" class="podlinkpod"
>Moose::Object</a> subclass <i>and</i> a subclass of <a href="../../Moose/Meta/Method/Constructor.html" class="podlinkpod"
>Moose::Meta::Method::Constructor</a> to inline the constructor. Two, you are subclassing a non-Moose parent.</p>

<p>If you know how to do that, you know when to ignore this best practice ;)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Always_call_the_original/parent_BUILDARGS"
>Always call the original/parent <code>BUILDARGS</code></a></h2>

<p>If you <code>override</code> the <code>BUILDARGS</code> method in your class, make sure to play nice and call <code>super()</code> to handle cases you&#39;re not checking for explicitly.</p>

<p>The default <code>BUILDARGS</code> method in <a href="../../Moose/Object.html" class="podlinkpod"
>Moose::Object</a> handles both a list and hashref of named parameters correctly, and also checks for a <i>non-hashref</i> single argument.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Provide_defaults_whenever_possible,_otherwise_use_required"
>Provide defaults whenever possible, otherwise use <code>required</code></a></h2>

<p>When your class provides defaults, this makes constructing new objects simpler. If you cannot provide a default, consider making the attribute <code>required</code>.</p>

<p>If you don&#39;t do either, an attribute can simply be left unset, increasing the complexity of your object, because it has more possible states that you or the user of your class must account for.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Use_builder_instead_of_default_most_of_the_time"
>Use <code>builder</code> instead of <code>default</code> most of the time</a></h2>

<p>Builders can be inherited, they have explicit names, and they&#39;re just plain cleaner.</p>

<p>However, <i>do</i> use a default when the default is a non-reference, <i>or</i> when the default is simply an empty reference of some sort.</p>

<p>Also, keep your builder methods private.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Be_lazy"
>Be <code>lazy</code></a></h2>

<p>Lazy is good, and often solves initialization ordering problems. It&#39;s also good for deferring work that may never have to be done. Make your attributes <code>lazy</code> unless they&#39;re <code>required</code> or have trivial defaults.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Consider_keeping_clearers_and_predicates_private"
>Consider keeping clearers and predicates private</a></h2>

<p>Does everyone <i>really</i> need to be able to clear an attribute? Probably not. Don&#39;t expose this functionality outside your class by default.</p>

<p>Predicates are less problematic, but there&#39;s no reason to make your public API bigger than it has to be.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Avoid_lazy_build"
>Avoid <code>lazy_build</code></a></h2>

<p>As described above, you rarely actually need a clearer or a predicate. <code>lazy_build</code> adds both to your public API, which exposes you to use cases that you must now test for. It&#39;s much better to avoid adding them until you really need them - use explicit <code>lazy</code> and <code>builder</code> options instead.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Default_to_read-only,_and_consider_keeping_writers_private"
>Default to read-only, and consider keeping writers private</a></h2>

<p>Making attributes mutable just means more complexity to account for in your program. The alternative to mutable state is to encourage users of your class to simply make new objects as needed.</p>

<p>If you <i>must</i> make an attribute read-write, consider making the writer a separate private method. Narrower APIs are easy to maintain, and mutable state is trouble.</p>

<p>In order to declare such attributes, provide a private <code>writer</code> parameter:</p>

<pre>    has pizza =&#62; (
        is     =&#62; &#39;ro&#39;,
        isa    =&#62; &#39;Pizza&#39;,
        writer =&#62; &#39;_pizza&#39;,
    );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Think_twice_before_changing_an_attribute&#39;s_type_in_a_subclass"
>Think twice before changing an attribute&#39;s type in a subclass</a></h2>

<p>Down this path lies great confusion. If the attribute is an object itself, at least make sure that it has the same interface as the type of object in the parent class.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Don&#39;t_use_the_initializer_feature"
>Don&#39;t use the <code>initializer</code> feature</a></h2>

<p>Don&#39;t know what we&#39;re talking about? That&#39;s fine.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Use_Moose::Meta::Attribute::Native_traits_instead_of_auto_deref"
>Use <a href="../../Moose/Meta/Attribute/Native.html" class="podlinkpod"
>Moose::Meta::Attribute::Native</a> traits instead of <code>auto_deref</code></a></h2>

<p>The <code>auto_deref</code> feature is a bit troublesome. Directly exposing a complex attribute is ugly. Instead, consider using <a href="../../Moose/Meta/Attribute/Native.html" class="podlinkpod"
>Moose::Meta::Attribute::Native</a> traits to define an API that only exposes the necessary pieces of functionality.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Always_call_inner_in_the_most_specific_subclass"
>Always call <code>inner</code> in the most specific subclass</a></h2>

<p>When using <code>augment</code> and <code>inner</code>, we recommend that you call <code>inner</code> in the most specific subclass of your hierarchy. This makes it possible to subclass further and extend the hierarchy without changing the parents.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Namespace_your_types"
>Namespace your types</a></h2>

<p>Use some sort of namespacing convention for type names. We recommend something like &#34;MyApp::Type::Foo&#34;. We also recommend considering <a href="../../MooseX/Types.html" class="podlinkpod"
>MooseX::Types</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Do_not_coerce_Moose_built-ins_directly"
>Do not coerce Moose built-ins directly</a></h2>

<p>If you define a coercion for a Moose built-in like <code>ArrayRef</code>, this will affect every application in the Perl interpreter that uses this type.</p>

<pre>    # very naughty!
    coerce &#39;ArrayRef&#39;
        =&#62; from Str
        =&#62; via { [ split /,/ ] };</pre>

<p>Instead, create a subtype and coerce that:</p>

<pre>    subtype &#39;My::ArrayRef&#39; =&#62; as &#39;ArrayRef&#39;;

    coerce &#39;My::ArrayRef&#39;
        =&#62; from &#39;Str&#39;
        =&#62; via { [ split /,/ ] };</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Do_not_coerce_class_names_directly"
>Do not coerce class names directly</a></h2>

<p>Just as with Moose built-in types, a class type is global for the entire interpreter. If you add a coercion for that class name, it can have magical side effects elsewhere:</p>

<pre>    # also very naughty!
    coerce &#39;HTTP::Headers&#39;
        =&#62; from &#39;HashRef&#39;
        =&#62; via { HTTP::Headers-&#62;new( %{$_} ) };</pre>

<p>Instead, we can create an &#34;empty&#34; subtype for the coercion:</p>

<pre>    subtype &#39;My::HTTP::Headers&#39; =&#62; as class_type(&#39;HTTP::Headers&#39;);

    coerce &#39;My::HTTP::Headers&#39;
        =&#62; from &#39;HashRef&#39;
        =&#62; via { HTTP::Headers-&#62;new( %{$_} ) };</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Use_coercion_instead_of_unions"
>Use coercion instead of unions</a></h2>

<p>Consider using a type coercion instead of a type union. This was covered in <a href="../../Moose/Manual/Types.html" class="podlinkpod"
>Moose::Manual::Types</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Define_all_your_types_in_one_module"
>Define all your types in one module</a></h2>

<p>Define all your types and coercions in one module. This was also covered in <a href="../../Moose/Manual/Types.html" class="podlinkpod"
>Moose::Manual::Types</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BENEFITS_OF_BEST_PRACTICES"
>BENEFITS OF BEST PRACTICES</a></h1>

<p>Following these practices has a number of benefits.</p>

<p>It helps ensure that your code will play nice with others, making it more reusable and easier to extend.</p>

<p>Following an accepted set of idioms will make maintenance easier, especially when someone else has to maintain your code. It will also make it easier to get support from other Moose users, since your code will be easier to digest quickly.</p>

<p>Some of these practices are designed to help Moose do the right thing, especially when it comes to immutabilization. This means your code will be faster when immutabilized.</p>

<p>Many of these practices also help get the most out of meta programming. If you used an overridden <code>new</code> to do type coercion by hand, rather than defining a real coercion, there is no introspectable metadata. This sort of thing is particularly problematic for MooseX extensions which rely on introspection to do the right thing.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Moose is maintained by the Moose Cabal, along with the help of many contributors. See <a href="../../Moose.html#CABAL" class="podlinkpod"
>&#34;CABAL&#34; in Moose</a> and <a href="../../Moose.html#CONTRIBUTORS" class="podlinkpod"
>&#34;CONTRIBUTORS&#34; in Moose</a> for details.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>This software is copyright (c) 2012 by Infinity Interactive, Inc..</p>

<p>This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
