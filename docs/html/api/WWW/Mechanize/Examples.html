<html><head><title>WWW::Mechanize::Examples</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:28 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Starbucks_Density_Calculator%2C_by_Nat_Torkington'>Starbucks Density Calculator, by Nat Torkington</a>
    <li class='indexItem indexItem2'><a href='#pb-upload%2C_by_John_Beppu'>pb-upload, by John Beppu</a>
    <li class='indexItem indexItem2'><a href='#listmod%2C_by_Ian_Langworth'>listmod, by Ian Langworth</a>
    <li class='indexItem indexItem2'><a href='#ccdl%2C_by_Andy_Lester'>ccdl, by Andy Lester</a>
    <li class='indexItem indexItem2'><a href='#quotes.pl%2C_by_Andy_Lester'>quotes.pl, by Andy Lester</a>
    <li class='indexItem indexItem2'><a href='#cpansearch.pl%2C_by_Ed_Silva'>cpansearch.pl, by Ed Silva</a>
    <li class='indexItem indexItem2'><a href='#lj_friends.cgi%2C_by_Matt_Cashner'>lj_friends.cgi, by Matt Cashner</a>
    <li class='indexItem indexItem2'><a href='#Hacking_Movable_Type%2C_by_Dan_Rinzel'>Hacking Movable Type, by Dan Rinzel</a>
    <li class='indexItem indexItem2'><a href='#get-despair%2C_by_Randal_Schwartz'>get-despair, by Randal Schwartz</a>
  </ul>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>WWW::Mechanize::Examples - Sample programs that use WWW::Mechanize</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<p>Plenty of people have learned WWW::Mechanize,
and now,
you can too!</p>

<p>Following are user-supplied samples of WWW::Mechanize in action.
If you have samples you&#39;d like to contribute,
please send &#39;em to <code>&#60;andy@petdance.com&#62;</code>.</p>

<p>You can also look at the <em>t/*.t</em> files in the distribution.</p>

<p>Please note that these examples are not intended to do any specific task.
For all I know,
they&#39;re no longer functional because the sites they hit have changed.
They&#39;re here to give examples of how people have used WWW::Mechanize.</p>

<p>Note that the examples are in reverse order of my having received them,
so the freshest examples are always at the top.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Starbucks_Density_Calculator,_by_Nat_Torkington"
>Starbucks Density Calculator,
by Nat Torkington</a></h2>

<p>Here&#39;s a pair of programs from Nat Torkington,
editor for O&#39;Reilly Media and co-author of the <i>Perl Cookbook</i>.</p>

<blockquote>
<p>Rael [Dornfest] discovered that you can easily find out how many Starbucks there are in an area by searching for &#34;Starbucks&#34;.
So I wrote a silly scraper for some old census data and came up with some Starbucks density figures.
There&#39;s no meaning to these numbers thanks to errors from using old census data coupled with false positives in Yahoo search (e.g.,
&#34;Dodie Starbuck-Your Style Desgn&#34; in Portland OR).
But it was fun to waste a night on.</p>

<p>Here are the top twenty cities in descending order of population,
with the amount of territory each Starbucks has.
E.g.,
A New York NY Starbucks covers 1.7 square miles of ground.</p>

<pre>    New York, NY        1.7
    Los Angeles, CA     1.2
    Chicago, IL         1.0
    Houston, TX         4.6
    Philadelphia, PA    6.8
    San Diego, CA       2.7
    Detroit, MI        19.9
    Dallas, TX          2.7
    Phoenix, AZ         4.1
    San Antonio, TX    12.3
    San Jose, CA        1.1
    Baltimore, MD       3.9
    Indianapolis, IN   12.1
    San Francisco, CA   0.5
    Jacksonville, FL   39.9
    Columbus, OH        7.3
    Milwaukee, WI       5.1
    Memphis, TN        15.1
    Washington, DC      1.4
    Boston, MA          0.5</pre>
</blockquote>

<p><code>get_pop_data</code></p>

<pre>    #!/usr/bin/perl -w

    use WWW::Mechanize;
    use Storable;

    $url = &#39;http://www.census.gov/population/www/documentation/twps0027.html&#39;;
    $m = WWW::Mechanize-&#62;new();
    $m-&#62;get($url);

    $c = $m-&#62;content;

    $c =~ m{&#60;A NAME=.tabA.&#62;(.*?)&#60;/TABLE&#62;}s
      or die &#34;Can&#39;t find the population table\n&#34;;
    $t = $1;
    @outer = $t =~ m{&#60;TR.*?&#62;(.*?)&#60;/TR&#62;}gs;
    shift @outer;
    foreach $r (@outer) {
      @bits = $r =~ m{&#60;TD.*?&#62;(.*?)&#60;/TD&#62;}gs;
      for ($x = 0; $x &#60; @bits; $x++) {
        $b = $bits[$x];
        @v = split /\s*&#60;BR&#62;\s*/, $b;
        foreach (@v) { s/^\s+//; s/\s+$// }
        push @{$data[$x]}, @v;
      }
    }

    for ($y = 0; $y &#60; @{$data[0]}; $y++) {
        $data{$data[1][$y]} = {
            NAME =&#62; $data[1][$y],
            RANK =&#62; $data[0][$y],
            POP  =&#62; comma_free($data[2][$y]),
            AREA =&#62; comma_free($data[3][$y]),
            DENS =&#62; comma_free($data[4][$y]),
        };
    }

    store(\%data, &#34;cities.dat&#34;);

    sub comma_free {
      my $n = shift;
      $n =~ s/,//;
      return $n;
    }</pre>

<p><code>plague_of_coffee</code></p>

<pre>    #!/usr/bin/perl -w

    use WWW::Mechanize;
    use strict;
    use Storable;

    $SIG{__WARN__} = sub {} ;  # ssssssh

    my $Cities = retrieve(&#34;cities.dat&#34;);

    my $m = WWW::Mechanize-&#62;new();
    $m-&#62;get(&#34;http://local.yahoo.com/&#34;);

    my @cities = sort { $Cities-&#62;{$a}{RANK} &#60;=&#62; $Cities-&#62;{$b}{RANK} } keys %$Cities;
    foreach my $c ( @cities ) {
      my $fields = {
        &#39;stx&#39; =&#62; &#34;starbucks&#34;,
        &#39;csz&#39; =&#62; $c,
      };

      my $r = $m-&#62;submit_form(form_number =&#62; 2,
                              fields =&#62; $fields);
      die &#34;Couldn&#39;t submit form&#34; unless $r-&#62;is_success;

      my $hits = number_of_hits($r);
      #  my $ppl  = sprintf(&#34;%d&#34;, 1000 * $Cities-&#62;{$c}{POP} / $hits);
      #  print &#34;$c has $hits Starbucks.  That&#39;s one for every $ppl people.\n&#34;;
      my $density = sprintf(&#34;%.1f&#34;, $Cities-&#62;{$c}{AREA} / $hits);
      print &#34;$c : $density\n&#34;;
    }

    sub number_of_hits {
      my $r = shift;
      my $c = $r-&#62;content;
      if ($c =~ m{\d+ out of &#60;b&#62;(\d+)&#60;/b&#62; total results for}) {
        return $1;
      }
      if ($c =~ m{Sorry, no .*? found in or near}) {
        return 0;
      }
      if ($c =~ m{Your search matched multiple cities}) {
        warn &#34;Your search matched multiple cities\n&#34;;
        return 0;
      }
      if ($c =~ m{Sorry we couldn.t find that location}) {
        warn &#34;No cities\n&#34;;
        return 0;
      }
      if ($c =~ m{Could not find.*?, showing results for}) {
        warn &#34;No matches\n&#34;;
        return 0;
      }
      die &#34;Unknown response\n$c\n&#34;;
    }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="pb-upload,_by_John_Beppu"
>pb-upload, by John Beppu</a></h2>

<p>This program takes filenames of images from the command line and uploads them to a www.photobucket.com folder. John Beppu, the author, says:</p>

<blockquote>
<p>I had 92 pictures I wanted to upload, and doing it through a browser would&#39;ve been torture. But thanks to mech, all I had to do was `./pb.upload *.jpg` and watch it do its thing. It felt good. If I had more time, I&#39;d implement WWW::Photobucket on top of WWW::Mechanize.</p>
</blockquote>

<pre>    #!/usr/bin/perl -w -T

    use strict;
    use WWW::Mechanize;

    my $login    = &#34;login_name&#34;;
    my $password = &#34;password&#34;;
    my $folder   = &#34;folder&#34;;

    my $url = &#34;http://img78.photobucket.com/albums/v281/$login/$folder/&#34;;

    # login to your photobucket.com account
    my $mech = WWW::Mechanize-&#62;new();
    $mech-&#62;get($url);
    $mech-&#62;submit_form(
        form_number =&#62; 1,
        fields      =&#62; { password =&#62; $password },
    );
    die unless ($mech-&#62;success);

    # upload image files specified on command line
    foreach (@ARGV) {
        print &#34;$_\n&#34;;
        $mech-&#62;form_number(2);
        $mech-&#62;field(&#39;the_file[]&#39; =&#62; $_);
        $mech-&#62;submit();
    }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="listmod,_by_Ian_Langworth"
>listmod, by Ian Langworth</a></h2>

<p>Ian Langworth contributes this little gem that will bring joy to beleaguered mailing list admins. It discards spam messages through mailman&#39;s web interface.</p>

<pre>    #!/arch/unix/bin/perl
    use strict;
    use warnings;
    #
    # listmod - fast alternative to mailman list interface
    #
    # usage: listmod crew XXXXXXXX
    # 

    die &#34;usage: $0 &#60;listname&#62; &#60;password&#62;\n&#34; unless @ARGV == 2;
    my ($listname, $password) = @ARGV;

    use CGI qw(unescape);

    use WWW::Mechanize;
    my $m = WWW::Mechanize-&#62;new( autocheck =&#62; 1 );

    use Term::ReadLine;
    my $term = Term::ReadLine-&#62;new($0);

    # submit the form, get the cookie, go to the list admin page
    $m-&#62;get(&#34;https://lists.ccs.neu.edu/bin/admindb/$listname&#34;);
    $m-&#62;set_visible( $password );
    $m-&#62;click;

    # exit if nothing to do
    print &#34;There are no pending requests.\n&#34; and exit
        if $m-&#62;content =~ /There are no pending requests/;

    # select the first form and examine its contents
    $m-&#62;form_number(1);
    my $f = $m-&#62;current_form or die &#34;Couldn&#39;t get first form!\n&#34;;

    # get me the base form element for each email item
    my @items = map {m/^.+?-(.+)/} grep {m/senderbanp/} $f-&#62;param
        or die &#34;Couldn&#39;t get items in first form!\n&#34;;

    # iterate through items, prompt user, commit actions
    foreach my $item (@items) {

        # show item info
        my $sender = unescape($item);
        my ($subject) = [$f-&#62;find_input(&#34;senderbanp-$item&#34;)-&#62;value_names]-&#62;[1] 
            =~ /Subject:\s+(.+?)\s+Size:/g;

        # prompt user
        my $choice = &#39;&#39;;
        while ( $choice !~ /^[DAX]$/ ) {
            print &#34;$sender\: &#39;$subject&#39;\n&#34;;
            $choice = uc $term-&#62;readline(&#34;Action: defer/accept/discard [dax]: &#34;);
            print &#34;\n\n&#34;;
        }

        # set button
        $m-&#62;field(&#34;senderaction-$item&#34; =&#62; {D=&#62;0,A=&#62;1,X=&#62;3}-&#62;{$choice});
    }

    # submit actions
    $m-&#62;click;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ccdl,_by_Andy_Lester"
>ccdl, by Andy Lester</a></h2>

<p>Steve McConnell, author of the landmark <i>Code Complete</i> has put up the chapters for the 2nd edition in PDF format on his website. I needed to download them to take to Kinko&#39;s to have printed. This little program did it for me.</p>

<pre>    #!/usr/bin/perl -w

    use strict;
    use WWW::Mechanize;

    my $start = &#34;http://www.stevemcconnell.com/cc2/cc.htm&#34;;

    my $mech = WWW::Mechanize-&#62;new( autocheck =&#62; 1 );
    $mech-&#62;get( $start );

    my @links = $mech-&#62;find_all_links( url_regex =&#62; qr/\d+.+\.pdf$/ );

    for my $link ( @links ) {
        my $url = $link-&#62;url_abs;
        my $filename = $url;
        $filename =~ s[^.+/][];

        print &#34;Fetching $url&#34;;
        $mech-&#62;get( $url, &#39;:content_file&#39; =&#62; $filename );

        print &#34;   &#34;, -s $filename, &#34; bytes\n&#34;;
    }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="quotes.pl,_by_Andy_Lester"
>quotes.pl, by Andy Lester</a></h2>

<p>This was a program that was going to get a hack in <i>Spidering Hacks</i>, but got cut at the last minute, probably because it&#39;s against IMDB&#39;s TOS to scrape from it. I present it here as an example, not a suggestion that you break their TOS.</p>

<p>Last I checked, it didn&#39;t work because their HTML didn&#39;t match, but it&#39;s still good as sample code.</p>

<pre>    #!/usr/bin/perl -w
    
    use strict;
    
    use WWW::Mechanize;
    use Getopt::Long;
    use Text::Wrap;
    
    my $match = undef;
    my $random = undef;
    GetOptions(
        &#34;match=s&#34; =&#62; \$match,
        &#34;random&#34; =&#62; \$random,
    ) or exit 1;

    my $movie = shift @ARGV or die &#34;Must specify a movie\n&#34;;

    my $quotes_page = get_quotes_page( $movie );
    my @quotes = extract_quotes( $quotes_page );

    if ( $match ) {
        $match = quotemeta($match);
        @quotes = grep /$match/i, @quotes;
    }

    if ( $random ) {
        print $quotes[rand @quotes];
    }
    else {
        print join( &#34;\n&#34;, @quotes );
    }


    sub get_quotes_page {
        my $movie = shift;

        my $mech = WWW::Mechanize-&#62;new;
        $mech-&#62;get( &#34;http://www.imdb.com/search&#34; );
        $mech-&#62;success or die &#34;Can&#39;t get the search page&#34;;

        $mech-&#62;submit_form(
            form_number =&#62; 2,
            fields =&#62; {
                title   =&#62; $movie,
                restrict    =&#62; &#34;Movies only&#34;,
            },
        );

        my @links = $mech-&#62;find_all_links( url_regex =&#62; qr[^/Title] )
            or die &#34;No matches for \&#34;$movie\&#34; were found.\n&#34;;

        # Use the first link
        my ( $url, $title ) = @{$links[0]};

        warn &#34;Checking $title...\n&#34;;

        $mech-&#62;get( $url );
        my $link = $mech-&#62;find_link( text_regex =&#62; qr/Memorable Quotes/i )
            or die qq{&#34;$title&#34; has no quotes in IMDB!\n};

        warn &#34;Fetching quotes...\n\n&#34;;
        $mech-&#62;get( $link-&#62;[0] );

        return $mech-&#62;content;
    }


    sub extract_quotes {
        my $page = shift;

        # Nibble away at the unwanted HTML at the beginnning...
        $page =~ s/.+Memorable Quotes//si;
        $page =~ s/.+?(&#60;a name)/$1/si;

        # ... and the end of the page
        $page =~ s/Browse titles in the movie quotes.+$//si;
        $page =~ s/&#60;p.+$//g;

        # Quotes separated by an &#60;HR&#62; tag
        my @quotes = split( /&#60;hr.+?&#62;/, $page );

        for my $quote ( @quotes ) {
            my @lines = split( /&#60;br&#62;/, $quote );
            for ( @lines ) {
                s/&#60;[^&#62;]+&#62;//g;   # Strip HTML tags
                s/\s+/ /g;          # Squash whitespace
                s/^ //;     # Strip leading space
                s/ $//;     # Strip trailing space
                s/&#38;#34;/&#34;/g;    # Replace HTML entity quotes

                # Word-wrap to fit in 72 columns
                $Text::Wrap::columns = 72;
                $_ = wrap( &#39;&#39;, &#39;    &#39;, $_ );
            }
            $quote = join( &#34;\n&#34;, @lines );
        }

        return @quotes;
    }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="cpansearch.pl,_by_Ed_Silva"
>cpansearch.pl, by Ed Silva</a></h2>

<p>A quick little utility to search the CPAN and fire up a browser with a results page.</p>

<pre>    #!/usr/bin/perl

    # turn on perl&#39;s safety features
    use strict;
    use warnings;

    # work out the name of the module we&#39;re looking for
    my $module_name = $ARGV[0]
      or die &#34;Must specify module name on command line&#34;;

    # create a new browser
    use WWW::Mechanize;
    my $browser = WWW::Mechanize-&#62;new();

    # tell it to get the main page
    $browser-&#62;get(&#34;http://search.cpan.org/&#34;);

    # okay, fill in the box with the name of the
    # module we want to look up
    $browser-&#62;form_number(1);
    $browser-&#62;field(&#34;query&#34;, $module_name);
    $browser-&#62;click();

    # click on the link that matches the module name
    $browser-&#62;follow_link( text_regex =&#62; $module_name );

    my $url = $browser-&#62;uri;

    # launch a browser...
    system(&#39;galeon&#39;, $url);

    exit(0);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="lj_friends.cgi,_by_Matt_Cashner"
>lj_friends.cgi, by Matt Cashner</a></h2>

<pre>    #!/usr/bin/perl

    # Provides an rss feed of a paid user&#39;s LiveJournal friends list
    # Full entries, protected entries, etc.
    # Add to your favorite rss reader as
    # http://your.site.com/cgi-bin/lj_friends.cgi?user=USER&#38;password=PASSWORD

    use warnings;
    use strict;

    use WWW::Mechanize;
    use CGI;

    my $cgi = CGI-&#62;new();
    my $form = $cgi-&#62;Vars;

    my $agent = WWW::Mechanize-&#62;new();

    $agent-&#62;get(&#39;http://www.livejournal.com/login.bml&#39;);
    $agent-&#62;form_number(&#39;3&#39;);
    $agent-&#62;field(&#39;user&#39;,$form-&#62;{user});
    $agent-&#62;field(&#39;password&#39;,$form-&#62;{password});
    $agent-&#62;submit();
    $agent-&#62;get(&#39;http://www.livejournal.com/customview.cgi?user=&#39;.$form-&#62;{user}.&#39;&#38;styleid=225596&#38;checkcookies=1&#39;);
    print &#34;Content-type: text/plain\n\n&#34;;
    print $agent-&#62;content();</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Hacking_Movable_Type,_by_Dan_Rinzel"
>Hacking Movable Type, by Dan Rinzel</a></h2>

<pre>    use strict;
    use WWW::Mechanize;

    # a tool to automatically post entries to a moveable type weblog, and set arbitrary creation dates

    my $mech = WWW::Mechanize-&#62;new();
    my $entry;
    $entry-&#62;{title} = &#34;Test AutoEntry Title&#34;;
    $entry-&#62;{btext} = &#34;Test AutoEntry Body&#34;;
    $entry-&#62;{date} = &#39;2002-04-15 14:18:00&#39;;
    my $start = qq|http://my.blog.site/mt.cgi|;

    $mech-&#62;get($start);
    $mech-&#62;field(&#39;username&#39;,&#39;und3f1n3d&#39;);
    $mech-&#62;field(&#39;password&#39;,&#39;obscur3d&#39;);
    $mech-&#62;submit(); # to get login cookie
    $mech-&#62;get(qq|$start?__mode=view&#38;_type=entry&#38;blog_id=1|);
    $mech-&#62;form_name(&#39;entry_form&#39;);
    $mech-&#62;field(&#39;title&#39;,$entry-&#62;{title});
    $mech-&#62;field(&#39;category_id&#39;,1); # adjust as needed
    $mech-&#62;field(&#39;text&#39;,$entry-&#62;{btext});
    $mech-&#62;field(&#39;status&#39;,2); # publish, or 1 = draft
    $results = $mech-&#62;submit(); 

    # if we&#39;re ok with this entry being datestamped &#34;NOW&#34; (no {date} in %entry)
    # we&#39;re done. Otherwise, time to be tricksy
    # MT returns a 302 redirect from this form. the redirect itself contains a &#60;body onload=&#34;&#34;&#62; handler
    # which takes the user to an editable version of the form where the create date can be edited       
    # MT date format of YYYY-MM-DD HH:MI:SS is the only one that won&#39;t error out

    if ($entry-&#62;{date} &#38;&#38; $entry-&#62;{date} =~ /^\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2}/) {
        # travel the redirect
        $results = $mech-&#62;get($results-&#62;{_headers}-&#62;{location});
        $results-&#62;{_content} =~ /&#60;body onLoad=&#34;([^\&#34;]+)&#34;/is;
        my $js = $1;
        $js =~ /\&#39;([^&#39;]+)\&#39;/;
        $results = $mech-&#62;get($start.$1);
        $mech-&#62;form_name(&#39;entry_form&#39;);
        $mech-&#62;field(&#39;created_on_manual&#39;,$entry-&#62;{date});
        $mech-&#62;submit();
    }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get-despair,_by_Randal_Schwartz"
>get-despair, by Randal Schwartz</a></h2>

<p>Randal submitted this bot that walks the despair.com site sucking down all the pictures.</p>

<pre>    use strict; 
    $|++;

    use WWW::Mechanize;
    use File::Basename; 

    my $m = WWW::Mechanize-&#62;new;

    $m-&#62;get(&#34;http://www.despair.com/indem.html&#34;);

    my @top_links = @{$m-&#62;links};

    for my $top_link_num (0..$#top_links) {
        next unless $top_links[$top_link_num][0] =~ /^http:/; 

        $m-&#62;follow_link( n=&#62;$top_link_num ) or die &#34;can&#39;t follow $top_link_num&#34;;

        print $m-&#62;uri, &#34;\n&#34;;
        for my $image (grep m{^http://store4}, map $_-&#62;[0], @{$m-&#62;links}) { 
            my $local = basename $image;
            print &#34; $image...&#34;, $m-&#62;mirror($image, $local)-&#62;message, &#34;\n&#34;
        }

        $m-&#62;back or die &#34;can&#39;t go back&#34;;
    }</pre>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
