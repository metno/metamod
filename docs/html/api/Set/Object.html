<html><head><title>Set::Object</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:26 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#CONSTRUCTORS'>CONSTRUCTORS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Set%3A%3AObject-%3Enew(_%5Blist%5D_)'>Set::Object-&#62;new( [list] )</a>
    <li class='indexItem indexItem2'><a href='#set(%40members)'>set(@members)</a>
    <li class='indexItem indexItem2'><a href='#weak_set()'>weak_set()</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#INSTANCE_METHODS'>INSTANCE METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#insert(_%5Blist%5D_)'>insert( [list] )</a>
    <li class='indexItem indexItem2'><a href='#includes(_%5Blist%5D_)'>includes( [list] )</a>
    <li class='indexItem indexItem2'><a href='#has(_%5Blist%5D_)'>has( [list] )</a>
    <li class='indexItem indexItem2'><a href='#contains(_%5Blist%5D_)'>contains( [list] )</a>
    <li class='indexItem indexItem2'><a href='#member(_%5Bitem%5D_)'>member( [item] )</a>
    <li class='indexItem indexItem2'><a href='#element(_%5Bitem%5D_)'>element( [item] )</a>
    <li class='indexItem indexItem2'><a href='#members'>members</a>
    <li class='indexItem indexItem2'><a href='#elements'>elements</a>
    <li class='indexItem indexItem2'><a href='#size'>size</a>
    <li class='indexItem indexItem2'><a href='#remove(_%5Blist%5D_)'>remove( [list] )</a>
    <li class='indexItem indexItem2'><a href='#delete(_%5Blist%5D_)'>delete( [list] )</a>
    <li class='indexItem indexItem2'><a href='#weaken'>weaken</a>
    <li class='indexItem indexItem2'><a href='#is_weak'>is_weak</a>
    <li class='indexItem indexItem2'><a href='#strengthen'>strengthen</a>
    <li class='indexItem indexItem2'><a href='#invert(_%5Blist%5D_)'>invert( [list] )</a>
    <li class='indexItem indexItem2'><a href='#clear'>clear</a>
    <li class='indexItem indexItem2'><a href='#as_string'>as_string</a>
    <li class='indexItem indexItem2'><a href='#equal(_set_)'>equal( set )</a>
    <li class='indexItem indexItem2'><a href='#not_equal(_set_)'>not_equal( set )</a>
    <li class='indexItem indexItem2'><a href='#intersection(_%5Blist%5D_)'>intersection( [list] )</a>
    <li class='indexItem indexItem2'><a href='#union(_%5Blist%5D_)'>union( [list] )</a>
    <li class='indexItem indexItem2'><a href='#difference_(_set_)'>difference ( set )</a>
    <li class='indexItem indexItem2'><a href='#unique_(_set_)'>unique ( set )</a>
    <li class='indexItem indexItem2'><a href='#symmetric_difference_(_set_)'>symmetric_difference ( set )</a>
    <li class='indexItem indexItem2'><a href='#subset(_set_)'>subset( set )</a>
    <li class='indexItem indexItem2'><a href='#proper_subset(_set_)'>proper_subset( set )</a>
    <li class='indexItem indexItem2'><a href='#superset(_set_)'>superset( set )</a>
    <li class='indexItem indexItem2'><a href='#proper_superset(_set_)'>proper_superset( set )</a>
    <li class='indexItem indexItem2'><a href='#is_null(_set_)'>is_null( set )</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Set%3A%3AScalar_compatibility_methods'>Set::Scalar compatibility methods</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#compare(_set_)'>compare( set )</a>
    <li class='indexItem indexItem2'><a href='#is_disjoint(_set_)'>is_disjoint( set )</a>
    <li class='indexItem indexItem2'><a href='#as_string_callback(_set_)'>as_string_callback( set )</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#FUNCTIONS'>FUNCTIONS</a>
  <li class='indexItem indexItem1'><a href='#CLASS_METHODS'>CLASS METHODS</a>
  <li class='indexItem indexItem1'><a href='#SERIALIZATION'>SERIALIZATION</a>
  <li class='indexItem indexItem1'><a href='#PERFORMANCE'>PERFORMANCE</a>
  <li class='indexItem indexItem1'><a href='#THREAD_SAFETY'>THREAD SAFETY</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#LICENCE'>LICENCE</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Set::Object - set of objects and strings</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use Set::Object;

  my $set = set();            # or Set::Object-&#62;new()

  $set-&#62;insert(@thingies);
  $set-&#62;remove(@thingies);

  @items = @$set;             # or $set-&#62;members;

  $union = $set1 + $set2;
  $intersection = $set1 * $set2;
  $difference = $set1 - $set2;
  $symmetric_difference = $set1 % $set2;

  print &#34;set1 is a proper subset of set2&#34;
      if $set1 &#60; $set2;

  print &#34;set1 is a subset of set2&#34;
      if $set1 &#60;= $set2;

  # common idiom - iterate over any pure Perl structure
  use Set::Object qw(reftype);
  my @stack = $root;
  my $seen = Set::Object-&#62;new(@stack);
  while (my $object = pop @stack) {
      if (reftype $object eq &#34;HASH&#34;) {
          # do something with hash members

          # add the new nodes to the stack
          push @stack, grep { ref $_ &#38;&#38; $seen-&#62;insert($_) }
              values %$object;
      }
      elsif (reftype $object eq &#34;ARRAY&#34;) {
          # do something with array members

          # add the new nodes to the stack
          push @stack, grep { ref $_ &#38;&#38; $seen-&#62;insert($_) }
              @$object;

      }
      elsif (reftype $object =~ /SCALAR|REF/) {
          push @stack, $$object
              if ref $$object &#38;&#38; $seen-&#62;insert($$object);
      }
  }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This modules implements a set of objects, that is, an unordered collection of objects without duplication.</p>

<p>The term <i>objects</i> is applied loosely - for the sake of <a href="../Set/Object.html" class="podlinkpod"
>Set::Object</a>, anything that is a reference is considered an object.</p>

<p><a href="../Set/Object.html" class="podlinkpod"
>Set::Object</a> 1.09 and later includes support for inserting scalars (including the empty string, but excluding <code>undef</code>) as well as objects. This can be thought of as (and is currently implemented as) a degenerate hash that only has keys and no values. Unlike objects placed into a Set::Object, scalars that are inserted will be flattened into strings, so will lose any magic (eg, tie) or other special bits that they went in with; only strings come out.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CONSTRUCTORS"
>CONSTRUCTORS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Set::Object-&#62;new(_[list]_)"
>Set::Object-&#62;new( [<i>list</i>] )</a></h2>

<p>Return a new <code>Set::Object</code> containing the elements passed in <i>list</i>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="set(@members)"
><code>set(@members)</code></a></h2>

<p>Return a new <code>Set::Object</code> filled with <code>@members</code>. You have to explicitly import this method.</p>

<p><b>New in Set::Object 1.22</b>: this function is now called as a method to return new sets the various methods that return a new set, such as <code>-&#62;intersection</code>, <code>-&#62;union</code>, etc and their overloaded counterparts. The default method always returns <code>Set::Object</code> objects, preserving previous behaviour and not second guessing the nature of your derived <a href="../Set/Object.html" class="podlinkpod"
>Set::Object</a> class.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="weak_set()"
><code>weak_set()</code></a></h2>

<p>Return a new <code>Set::Object::Weak</code>, filled with <code>@members</code>. You have to explicitly import this method.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="INSTANCE_METHODS"
>INSTANCE METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="insert(_[list]_)"
>insert( [<i>list</i>] )</a></h2>

<p>Add items to the <code>Set::Object</code>.</p>

<p>Adding the same object several times is not an error, but any <code>Set::Object</code> will contain at most one occurence of the same object.</p>

<p>Returns the number of elements that were actually added. As of Set::Object 1.23, <code>undef</code> will not insert.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="includes(_[list]_)"
>includes( [<i>list</i>] )</a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="has(_[list]_)"
>has( [<i>list</i>] )</a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="contains(_[list]_)"
>contains( [<i>list</i>] )</a></h2>

<p>Return <code>true</code> if <b>all</b> the objects in <i>list</i> are members of the <code>Set::Object</code>. <i>list</i> may be empty, in which case <code>true</code> is always returned.</p>

<p>As of Set::Object 1.23, <code>undef</code> will never appear to be present in any set (even if the set contains the empty string). Prior to 1.23, there would have been a run-time warning.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="member(_[item]_)"
>member( [<i>item</i>] )</a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="element(_[item]_)"
>element( [<i>item</i>] )</a></h2>

<p>Like <code>includes</code>, but takes a single item to check and returns that item if the value is found, rather than just a true value.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="members"
>members</a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="elements"
>elements</a></h2>

<p>Return the objects contained in the <code>Set::Object</code> in random (hash) order.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="size"
>size</a></h2>

<p>Return the number of elements in the <code>Set::Object</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="remove(_[list]_)"
>remove( [<i>list</i>] )</a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="delete(_[list]_)"
>delete( [<i>list</i>] )</a></h2>

<p>Remove objects from a <code>Set::Object</code>.</p>

<p>Removing the same object more than once, or removing an object absent from the <code>Set::Object</code> is not an error.</p>

<p>Returns the number of elements that were actually removed.</p>

<p>As of Set::Object 1.23, removing <code>undef</code> is safe (but having an <code>undef</code> in the passed in list does not increase the return value, because it could never be in the set)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="weaken"
>weaken</a></h2>

<p>Makes all the references in the set &#34;weak&#34; - that is, they do not increase the reference count of the object they point to, just like <a href="../Scalar/Util.html" class="podlinkpod"
>Scalar::Util</a>&#39;s <code>weaken</code> function.</p>

<p>This was introduced with Set::Object 1.16, and uses a brand new type of magic. <b>Use with caution</b>. If you get segfaults when you use <code>weaken</code>, please reduce your problem to a test script before submission.</p>

<p><b>New:</b> as of Set::Object 1.19, you may use the <code>weak_set</code> function to make weak sets, or <code>Set::Object::Weak-&#62;new</code>, or import the <code>set</code> constructor from <code>Set::Object::Weak</code> instead. See <a href="../Set/Object/Weak.html" class="podlinkpod"
>Set::Object::Weak</a> for more.</p>

<p><b>Note to people sub-classing <code>Set::Object</code>:</b> this method re-blesses the invocant to <code>Set::Object::Weak</code>. Override the method <code>weak_pkg</code> in your sub-class to control this behaviour.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="is_weak"
>is_weak</a></h2>

<p>Returns a true value if this set is a weak set.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="strengthen"
>strengthen</a></h2>

<p>Turns a weak set back into a normal one.</p>

<p><b>Note to people sub-classing <code>Set::Object</code>:</b> this method re-blesses the invocant to <code>Set::Object</code>. Override the method <code>strong_pkg</code> in your sub-class to control this behaviour.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="invert(_[list]_)"
>invert( [<i>list</i>] )</a></h2>

<p>For each item in <i>list</i>, it either removes it or adds it to the set, so that a change is always made.</p>

<p>Also available as the overloaded operator <code>/</code>, in which case it expects another set (or a single scalar element), and returns a new set that is the original set with all the second set&#39;s items inverted.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="clear"
>clear</a></h2>

<p>Empty this <code>Set::Object</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="as_string"
>as_string</a></h2>

<p>Return a textual Smalltalk-ish representation of the <code>Set::Object</code>. Also available as overloaded operator &#34;&#34;.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="equal(_set_)"
>equal( <i>set</i> )</a></h2>

<p>Returns a true value if <i>set</i> contains exactly the same members as the invocant.</p>

<p>Also available as overloaded operator <code>==</code> (or <code>eq</code>).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="not_equal(_set_)"
>not_equal( <i>set</i> )</a></h2>

<p>Returns a false value if <i>set</i> contains exactly the same members as the invocant.</p>

<p>Also available as overloaded operator <code>!=</code> (or <code>ne</code>).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="intersection(_[list]_)"
>intersection( [<i>list</i>] )</a></h2>

<p>Return a new <code>Set::Object</code> containing the intersection of the <code>Set::Object</code>s passed as arguments.</p>

<p>Also available as overloaded operator <code>*</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="union(_[list]_)"
>union( [<i>list</i>] )</a></h2>

<p>Return a new <code>Set::Object</code> containing the union of the <code>Set::Object</code>s passed as arguments.</p>

<p>Also available as overloaded operator <code>+</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="difference_(_set_)"
>difference ( <i>set</i> )</a></h2>

<p>Return a new <code>Set::Object</code> containing the members of the first (invocant) set with the passed <code>Set::Object</code>s&#39; elements removed.</p>

<p>Also available as overloaded operator <code>-</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="unique_(_set_)"
>unique ( <i>set</i> )</a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="symmetric_difference_(_set_)"
>symmetric_difference ( <i>set</i> )</a></h2>

<p>Return a new <code>Set::Object</code> containing the members of all passed sets (including the invocant), with common elements removed. This will be the opposite (complement) of the <i>intersection</i> of the two sets.</p>

<p>Also available as overloaded operator <code>%</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="subset(_set_)"
>subset( <i>set</i> )</a></h2>

<p>Return <code>true</code> if this <code>Set::Object</code> is a subset of <i>set</i>.</p>

<p>Also available as operator <code>&#60;=</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="proper_subset(_set_)"
>proper_subset( <i>set</i> )</a></h2>

<p>Return <code>true</code> if this <code>Set::Object</code> is a proper subset of <i>set</i> Also available as operator <code>&#60;</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="superset(_set_)"
>superset( <i>set</i> )</a></h2>

<p>Return <code>true</code> if this <code>Set::Object</code> is a superset of <i>set</i>. Also available as operator <code>&#62;=</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="proper_superset(_set_)"
>proper_superset( <i>set</i> )</a></h2>

<p>Return <code>true</code> if this <code>Set::Object</code> is a proper superset of <i>set</i> Also available as operator <code>&#62;</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="is_null(_set_)"
>is_null( <i>set</i> )</a></h2>

<p>Returns a true value if this set does not contain any members, that is, if its size is zero.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Set::Scalar_compatibility_methods"
>Set::Scalar compatibility methods</a></h1>

<p>By and large, <a href="../Set/Object.html" class="podlinkpod"
>Set::Object</a> is not and probably never will be feature-compatible with <a href="../Set/Scalar.html" class="podlinkpod"
>Set::Scalar</a>; however the following functions are provided anyway.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="compare(_set_)"
>compare( <i>set</i> )</a></h2>

<p>returns one of:</p>

<pre>  &#34;proper intersect&#34;
  &#34;proper subset&#34;
  &#34;proper superset&#34;
  &#34;equal&#34;
  &#34;disjoint&#34;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="is_disjoint(_set_)"
>is_disjoint( <i>set</i> )</a></h2>

<p>Returns a true value if the two sets have no common items.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="as_string_callback(_set_)"
>as_string_callback( <i>set</i> )</a></h2>

<p>Allows you to define a custom stringify function. This is only a class method. If you want anything fancier than this, you should sub-class Set::Object.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FUNCTIONS"
>FUNCTIONS</a></h1>

<p>The following functions are defined by the Set::Object XS code for convenience; they are largely identical to the versions in the Scalar::Util module, but there are a couple that provide functions not catered to by that module.</p>

<p>Please use the versions in <a href="../Scalar/Util.html" class="podlinkpod"
>Scalar::Util</a> in preference to these functions. In fact, if you use these functions in your production code then you may have to rewrite it some day. They are retained only because they are &#34;mostly harmless&#34;.</p>

<dl>
<dt><a name="blessed"
><b>blessed</b></a></dt>

<dd>
<p><b>Do not use in production code</b></p>

<p>Returns a true value if the passed reference (RV) is blessed. See also <a href="../Acme/Holy.html" class="podlinkpod"
>Acme::Holy</a>.</p>

<dt><a name="reftype"
><b>reftype</b></a></dt>

<dd>
<p><b>Do not use in production code</b></p>

<p>A bit like the perl built-in <code>ref</code> function, but returns the <i>type</i> of reference; ie, if the reference is blessed then it returns what <code>ref</code> would have if it were not blessed. Useful for &#34;seeing through&#34; blessed references.</p>

<dt><a name="refaddr"
><b>refaddr</b></a></dt>

<dd>
<p><b>Do not use in production code</b></p>

<p>Returns the memory address of a scalar. <b>Warning</b>: this is <i>not</i> guaranteed to be unique for scalars created in a program; memory might get re-used!</p>

<dt><a name="is_int,_is_string,_is_double"
><b>is_int</b>, <b>is_string</b>, <b>is_double</b></a></dt>

<dd>
<p><b>Do not use in production code</b></p>

<p>A quick way of checking the three bits on scalars - IOK (is_int), NOK (is_double) and POK (is_string). Note that the exact behaviour of when these bits get set is not defined by the perl API.</p>

<p>This function returns the &#34;p&#34; versions of the macro (SvIOKp, etc); use with caution.</p>

<dt><a name="is_overloaded"
><b>is_overloaded</b></a></dt>

<dd>
<p><b>Do not use in production code</b></p>

<p>A quick way to check if an object has overload magic on it.</p>

<dt><a name="ish_int"
><b>ish_int</b></a></dt>

<dd>
<p><b>Deprecated and will be removed in 2014</b></p>

<p>This function returns true, if the value it is passed looks like it <i>already is</i> a representation of an <i>integer</i>. This is so that you can decide whether the value passed is a hash key or an array index.</p>

<dt><a name="is_key"
><b>is_key</b></a></dt>

<dd>
<p><b>Deprecated and will be removed in 2014</b></p>

<p>This function returns true, if the value it is passed looks more like an <i>index</i> to a collection than a <i>value</i> of a collection. Similar to the looks_like_number internal function, but weird. Avoid.</p>

<dt><a name="get_magic"
><b>get_magic</b></a></dt>

<dd>
<p><b>Do not use in production code</b></p>

<p>Pass to a scalar, and get the magick wand (<code>mg_obj</code>) used by the weak set implementation. The return will be a list of integers which are pointers to the actual <code>ISET</code> structure. Whatever you do don&#39;t change the array :). This is used only by the test suite, and if you find it useful for something then you should probably conjure up a test suite and send it to me, otherwise it could get pulled.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CLASS_METHODS"
>CLASS METHODS</a></h1>

<p>These class methods are probably only interesting to those sub-classing <code>Set::Object</code>.</p>

<dl>
<dt><a name="strong_pkg"
>strong_pkg</a></dt>

<dd>
<p>When a set that was already weak is strengthened using <code>-&#62;strengthen</code>, it gets re-blessed into this package.</p>

<dt><a name="weak_pkg"
>weak_pkg</a></dt>

<dd>
<p>When a set that was NOT already weak is weakened using <code>-&#62;weaken</code>, it gets re-blessed into this package.</p>

<dt><a name="tie_array_pkg"
>tie_array_pkg</a></dt>

<dd>
<p>When the object is accessed as an array, tie the array into this package.</p>

<dt><a name="tie_hash_pkg"
>tie_hash_pkg</a></dt>

<dd>
<p>When the object is accessed as a hash, tie the hash into this package.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SERIALIZATION"
>SERIALIZATION</a></h1>

<p>It is possible to serialize <code>Set::Object</code> objects via <a href="../Storable.html" class="podlinkpod"
>Storable</a> and duplicate via <code>dclone</code>; such support was added in release 1.04. As of <code>Set::Object</code> version 1.15, it is possible to freeze scalar items, too.</p>

<p>However, the support for freezing scalar items introduced a backwards incompatibility. Earlier versions than 1.15 will <code>thaw</code> sets frozen using Set::Object 1.15 and later as a set with one item - an array that contains the actual members.</p>

<p>Additionally, version 1.15 had a bug that meant that it would not detect <code>freeze</code> protocol upgrades, instead reverting to pre-1.15 behaviour.</p>

<p><code>Set::Object</code> 1.16 and above are capable of dealing correctly with all serialized forms, as well as correctly aborting if a &#34;newer&#34; <code>freeze</code> protocol is detected during <code>thaw</code>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PERFORMANCE"
>PERFORMANCE</a></h1>

<p>The following benchmark compares <code>Set::Object</code> with using a hash to emulate a set-like collection (this is an old benchmark, but still holds true):</p>

<pre>   use Set::Object;

   package Obj;
   sub new { bless { } }

   @els = map { Obj-&#62;new() } 1..1000;

   require Benchmark;

   Benchmark::timethese(100, {
      &#39;Control&#39; =&#62; sub { },
      &#39;H insert&#39; =&#62; sub { my %h = (); @h{@els} = @els; },
      &#39;S insert&#39; =&#62; sub { my $s = Set::Object-&#62;new(); $s-&#62;insert(@els) },
      } );

   %gh = ();
   @gh{@els} = @els;

   $gs = Set::Object-&#62;new(@els);
   $el = $els[33];

   Benchmark::timethese(100_000, {
           &#39;H lookup&#39; =&#62; sub { exists $gh{33} },
           &#39;S lookup&#39; =&#62; sub { $gs-&#62;includes($el) }
      } );</pre>

<p>On my computer the results are:</p>

<pre>   Benchmark: timing 100 iterations of Control, H insert, S insert...
      Control:  0 secs ( 0.01 usr  0.00 sys =  0.01 cpu)
               (warning: too few iterations for a reliable count)
     H insert: 68 secs (67.81 usr  0.00 sys = 67.81 cpu)
     S insert:  9 secs ( 8.81 usr  0.00 sys =  8.81 cpu)
   Benchmark: timing 100000 iterations of H lookup, S lookup...
     H lookup:  7 secs ( 7.14 usr  0.00 sys =  7.14 cpu)
     S lookup:  6 secs ( 5.94 usr  0.00 sys =  5.94 cpu)</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="THREAD_SAFETY"
>THREAD SAFETY</a></h1>

<p>This module is not thread-safe.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Original Set::Object module by Jean-Louis Leroy, &#60;jll@skynet.be&#62;</p>

<p>Set::Scalar compatibility, XS debugging, weak references support courtesy of Sam Vilain, &#60;samv@cpan.org&#62;.</p>

<p>New maintainer is Reini Urban &#60;rurban@cpan.org&#62;. Patches against <a href="https://github.com/rurban/Set-Object/" class="podlinkurl"
>https://github.com/rurban/Set-Object/</a> please. Tickets at RT <a href="https://rt.cpan.org/Public/Dist/Display.html?Name=Set-Object" class="podlinkurl"
>https://rt.cpan.org/Public/Dist/Display.html?Name=Set-Object</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENCE"
>LICENCE</a></h1>

<p>Copyright (c) 1998-1999, Jean-Louis Leroy. All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the terms of the Perl Artistic License</p>

<p>Portions Copyright (c) 2003 - 2005, Sam Vilain. Same license.</p>

<p>Portions Copyright (c) 2006, 2007, Catalyst IT (NZ) Limited. Same license.</p>

<p>Portions Copyright (c) 2013, cPanel. Same license.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>perl(1), perltie(1), <a href="../Set/Scalar.html" class="podlinkpod"
>Set::Scalar</a>, overload.pm</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
