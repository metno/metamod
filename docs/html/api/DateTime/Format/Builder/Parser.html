<html><head><title>DateTime::Format::Builder::Parser</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:04 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#CONSTRUCTORS'>CONSTRUCTORS</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Parameter_Handling_(implementations)'>Parameter Handling (implementations)</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Common_parameters'>Common parameters</a>
      <li class='indexItem indexItem3'><a href='#params'>params</a>
      <li class='indexItem indexItem3'><a href='#params_all'>params_all</a>
      <li class='indexItem indexItem3'><a href='#valid_params'>valid_params</a>
      <li class='indexItem indexItem3'><a href='#whose_params'>whose_params</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Organising_and_Creating_Parsers'>Organising and Creating Parsers</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#create_single_parser'>create_single_parser</a>
      <li class='indexItem indexItem3'><a href='#merge_callbacks'>merge_callbacks</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#create_multiple_parsers'>create_multiple_parsers</a>
    <li class='indexItem indexItem2'><a href='#sort_parsers'>sort_parsers</a>
    <li class='indexItem indexItem2'><a href='#create_parser'>create_parser</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#FINDING_IMPLEMENTATIONS'>FINDING IMPLEMENTATIONS</a>
  <li class='indexItem indexItem1'><a href='#WRITING_A_PARSER_IMPLEMENTATION'>WRITING A PARSER IMPLEMENTATION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Naming_your_parser'>Naming your parser</a>
    <li class='indexItem indexItem2'><a href='#Declaring_specification_arguments'>Declaring specification arguments</a>
    <li class='indexItem indexItem2'><a href='#Define_create_parser'>Define create_parser</a>
    <li class='indexItem indexItem2'><a href='#Callbacks'>Callbacks</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SUPPORT'>SUPPORT</a>
  <li class='indexItem indexItem1'><a href='#THANKS'>THANKS</a>
  <li class='indexItem indexItem1'><a href='#LICENCE_AND_COPYRIGHT'>LICENCE AND COPYRIGHT</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>DateTime::Format::Builder::Parser - Parser creation</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    my $class = &#39;DateTime::Format::Builder::Parser&#39;;
    my $parser = $class-&#62;create_single_parser( %specs );</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This is a utility class for <a href="../../../DateTime/Format/Builder.html" class="podlinkpod"
>DateTime::Format::Builder</a> that handles creation of parsers. It is to here that <code>Builder</code> delegates most of its responsibilities.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CONSTRUCTORS"
>CONSTRUCTORS</a></h1>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<p>There are two sorts of methods in this class. Those used by parser implementations and those used by <code>Builder</code>. It is generally unlikely the user will want to use any of them.</p>

<p>They are presented, grouped according to use.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Parameter_Handling_(implementations)"
>Parameter Handling (implementations)</a></h2>

<p>These methods allow implementations to have validation of their arguments in a standard manner and due to <code>Parser</code>&#39;s impelementation, these methods also allow <code>Parser</code> to determine which implementation to use.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Common_parameters"
>Common parameters</a></h3>

<p>These parameters appear for all parser implementations. These are primarily documented in <a href="../../../DateTime/Format/Builder.html#SINGLE_SPECIFICATIONS" class="podlinkpod"
>the main docs</a>.</p>

<ul>
<li><b>on_match</b></li>

<li><b>on_fail</b></li>

<li><b>postprocess</b></li>

<li><b>preprocess</b></li>

<li><b>label</b></li>

<li><b>length</b> may be a number or an arrayref of numbers indicating the length of the input. This lets us optimise in the case of static length input. If supplying an arrayref of numbers, please keep the number of numbers to a minimum.</li>
</ul>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="params"
>params</a></h3>

<pre>    my $params = $self-&#62;params();
    validate( @_, $params );</pre>

<p>Returns declared parameters and <code>common</code> parameters in a hashref suitable for handing to <a href="../../../Params/Validate.html" class="podlinkpod"
>Params::Validate</a>&#39;s <code>validate</code> function.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="params_all"
>params_all</a></h3>

<pre>    my $all_params = $self-&#62;params_all();</pre>

<p>Returns a hash of all the valid options. Not recommended for general use.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="valid_params"
>valid_params</a></h3>

<pre>    __PACKAGE__-&#62;valid_params( %params );</pre>

<p>Arguments are as per <a href="../../../Params/Validate.html" class="podlinkpod"
>Params::Validate</a>&#39;s <code>validate</code> function. This method is used to declare what your valid arguments are in a parser specification.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="whose_params"
>whose_params</a></h3>

<pre>    my $class = whose_params( $key );</pre>

<p>Internal function which merely returns to which class a parameter is unique. If not unique, returns <code>undef</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Organising_and_Creating_Parsers"
>Organising and Creating Parsers</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="create_single_parser"
>create_single_parser</a></h3>

<p>This takes a single specification and returns a coderef that is a parser that suits that specification. This is the end of the line for all the parser creation methods. It delegates no further.</p>

<p>If a coderef is specified, then that coderef is immediately returned (it is assumed to be appropriate).</p>

<p>The single specification (if not a coderef) can be either a hashref or a hash. The keys and values must be as per the <a href="#SINGLE_SPECIFICATIONS" class="podlinkpod"
>specification</a>.</p>

<p>It is here that any arrays of callbacks are unified. It is also here that any parser implementations are used. With the spec that&#39;s given, the keys are looked at and whichever module is the first to have a unique key in the spec is the one to whom the spec is given.</p>

<p><b>Note</b>: please declare a <code>valid_params</code> argument with an uppercase letter. For example, if you&#39;re writing <code>DateTime::Format::Builder::Parser::Fnord</code>, declare a parameter called <code>Fnord</code>. Similarly, <code>DTFBP::Strptime</code> should have <code>Strptime</code> and <code>DTFBP::Regex</code> should have <code>Regex</code>. These latter two don&#39;t for backwards compatibility reasons.</p>

<p>The returned parser will return either a <code>DateTime</code> object or <code>undef</code>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="merge_callbacks"
>merge_callbacks</a></h3>

<p>Produce either undef or a single coderef from either undef, an empty array, a single coderef or an array of coderefs</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="create_multiple_parsers"
>create_multiple_parsers</a></h2>

<p>Given the options block (as made from <code>create_parser()</code>) and a list of single parser specifications, this returns a coderef that returns either the resultant <code>DateTime</code> object or <code>undef</code>.</p>

<p>It first sorts the specifications using <code>sort_parsers()</code> and then creates the function based on what that returned.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="sort_parsers"
>sort_parsers</a></h2>

<p>This takes the list of specifications and sorts them while turning the specifications into parsers. It returns two values: the first is a hashref containing all the length based parsers. The second is an array containing all the other parsers.</p>

<p>If any of the specs are not code or hash references, then it will call <code>croak()</code>.</p>

<p>Code references are put directly into the &#39;other&#39; array. Any hash references without <i>length</i> keys are run through <code>create_single_parser()</code> and the resultant parser is placed in the &#39;other&#39; array.</p>

<p>Hash references <b>with</b> <i>length</i> keys are run through <code>create_single_parser()</code>, but the resultant parser is used as the value in the length hashref with the length being the key. If two or more parsers have the same <i>length</i> specified then an error is thrown.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="create_parser"
>create_parser</a></h2>

<p><code>create_class()</code> is mostly a wrapper around <code>create_parser()</code> that does loops and stuff and calls <code>create_parser()</code> to create the actual parsers.</p>

<p><code>create_parser()</code> takes the parser specifications (be they single specifications or multiple specifications) and returns an anonymous coderef that is suitable for use as a method. The coderef will call <code>croak()</code> in the event of being unable to parse the single string it expects as input.</p>

<p>The simplest input is that of a single specification, presented just as a plain hash, not a hashref. This is passed directly to <code>create_single_parser()</code> with the return value from that being wrapped in a function that lets it <code>croak()</code> on failure, with that wrapper being returned.</p>

<p>If the first argument to <code>create_parser()</code> is an arrayref, then that is taken to be an options block (as per the multiple parser specification documented earlier).</p>

<p>Any further arguments should be either hashrefs or coderefs. If the first argument after the optional arrayref is not a hashref or coderef then that argument and all remaining arguments are passed off to <code>create_single_parser()</code> directly. If the first argument is a hashref or coderef, then it and the remaining arguments are passed to <code>create_multiple_parsers()</code>.</p>

<p>The resultant coderef from calling either of the creation methods is then wrapped in a function that calls <code>croak()</code> in event of failure or the <code>DateTime</code> object in event of success.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FINDING_IMPLEMENTATIONS"
>FINDING IMPLEMENTATIONS</a></h1>

<p><code>Parser</code> automatically loads any parser classes in <code>@INC</code>.</p>

<p>To be loaded automatically, you must be a <code>DateTime::Format::Builder::Parser::XXX</code> module.</p>

<p>To be invisible, and not loaded, start your class with a lower class letter. These are ignored.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="WRITING_A_PARSER_IMPLEMENTATION"
>WRITING A PARSER IMPLEMENTATION</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Naming_your_parser"
>Naming your parser</a></h2>

<p>Create a module and name it in the form <code>DateTime::Format::Builder::Parser::XXX</code> where <i>XXX</i> is whatever you like, so long as it doesn&#39;t start with a lower case letter.</p>

<p>Alternatively, call it something completely different if you don&#39;t mind the users explicitly loading your module.</p>

<p>I&#39;d recommend keeping within the <code>DateTime::Format::Builder</code> namespace though --- at the time of writing I&#39;ve not given thought to what non-auto loaded ones should be called. Any ideas, please email me.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Declaring_specification_arguments"
>Declaring specification arguments</a></h2>

<p>Call <code>&#60;DateTime::Format::Builder::Parser-</code>valid_params()&#62;&#62; with <code>Params::Validate</code> style arguments. For example:</p>

<pre>   DateTime::Format::Builder::Parser-&#62;valid_params(
       params =&#62; { type =&#62; ARRAYREF },
       Regex  =&#62; { type =&#62; SCALARREF, callbacks =&#62; {
          &#39;is a regex&#39; =&#62; sub { ref(shift) eq &#39;Regexp&#39; }
       }}
   );</pre>

<p>Start one of the key names with a capital letter. Ideally that key should match the <i>XXX</i> from earlier. This will be used to help identify which module a parser specification should be given to.</p>

<p>The key names <i>on_match</i>, <i>on_fail</i>, <i>postprocess</i>, <i>preprocess</i>, <i>label</i> and <i>length</i> are predefined. You are recommended to make use of them. You may ignore <i>length</i> as <code>sort_parsers</code> takes care of that.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Define_create_parser"
>Define create_parser</a></h2>

<p>A class method of the name <code>create_parser</code> that does the following:</p>

<p>Its arguments are as for a normal method (i.e. class as first argument). The other arguments are the result from a call to <code>Params::Validate</code> according to your specification (the <code>valid_params</code> earlier), i.e. a hash of argument name and value.</p>

<p>The return value should be a coderef that takes a date string as its first argument and returns either a <code>DateTime</code> object or <code>undef</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Callbacks"
>Callbacks</a></h2>

<p>It is preferred that you support some callbacks to your parsers. In particular, <code>preprocess</code>, <code>on_match</code>, <code>on_fail</code> and <code>postprocess</code>. See the <a href="../../../DateTime/Format/Builder.html" class="podlinkpod"
>main Builder</a> docs for the appropriate placing of calls to the callbacks.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SUPPORT"
>SUPPORT</a></h1>

<p>Support for this module is provided via the datetime@perl.org email list. See http://lists.perl.org/ for more details.</p>

<p>Alternatively, log them via the CPAN RT system via the web or email:</p>

<pre>    http://perl.dellah.org/rt/dtbuilder
    bug-datetime-format-builder@rt.cpan.org</pre>

<p>This makes it much easier for me to track things and thus means your problem is less likely to be neglected.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="THANKS"
>THANKS</a></h1>

<p>See <a href="../../../DateTime/Format/Builder.html" class="podlinkpod"
>DateTime::Format::Builder</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENCE_AND_COPYRIGHT"
>LICENCE AND COPYRIGHT</a></h1>

<p>Copyright &#169; Iain Truskett, 2003. All rights reserved.</p>

<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself, either Perl version 5.000 or, at your option, any later version of Perl 5 you may have available.</p>

<p>The full text of the licences can be found in the <em>Artistic</em> and <em>COPYING</em> files included with this module, or in <a href="../../../perlartistic.html" class="podlinkpod"
>perlartistic</a> and <a href="../../../perlgpl.html" class="podlinkpod"
>perlgpl</a> as supplied with Perl 5.8.1 and later.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Iain Truskett &#60;spoon@cpan.org&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><code>datetime@perl.org</code> mailing list.</p>

<p>http://datetime.perl.org/</p>

<p><a href="../../../perl.html" class="podlinkpod"
>perl</a>, <a href="../../../DateTime.html" class="podlinkpod"
>DateTime</a>, <a href="../../../DateTime/Format/Builder.html" class="podlinkpod"
>DateTime::Format::Builder</a>.</p>

<p><a href="../../../Params/Validate.html" class="podlinkpod"
>Params::Validate</a>.</p>

<p><a href="../../../DateTime/Format/Builder/Parser/generic.html" class="podlinkpod"
>DateTime::Format::Builder::Parser::generic</a>, <a href="../../../DateTime/Format/Builder/Parser/Dispatch.html" class="podlinkpod"
>DateTime::Format::Builder::Parser::Dispatch</a>, <a href="../../../DateTime/Format/Builder/Parser/Quick.html" class="podlinkpod"
>DateTime::Format::Builder::Parser::Quick</a>, <a href="../../../DateTime/Format/Builder/Parser/Regex.html" class="podlinkpod"
>DateTime::Format::Builder::Parser::Regex</a>, <a href="../../../DateTime/Format/Builder/Parser/Strptime.html" class="podlinkpod"
>DateTime::Format::Builder::Parser::Strptime</a>.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
