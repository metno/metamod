<html><head><title>DateTime::SpanSet</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:14 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <li class='indexItem indexItem1'><a href='#SUPPORT'>SUPPORT</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>DateTime::SpanSet - set of DateTime spans</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    $spanset = DateTime::SpanSet-&#62;from_spans( spans =&#62; [ $dt_span, $dt_span ] );

    $set = $spanset-&#62;union( $set2 );         # like &#34;OR&#34;, &#34;insert&#34;, &#34;both&#34;
    $set = $spanset-&#62;complement( $set2 );    # like &#34;delete&#34;, &#34;remove&#34;
    $set = $spanset-&#62;intersection( $set2 );  # like &#34;AND&#34;, &#34;while&#34;
    $set = $spanset-&#62;complement;             # like &#34;NOT&#34;, &#34;negate&#34;, &#34;invert&#34;

    if ( $spanset-&#62;intersects( $set2 ) ) { ...  # like &#34;touches&#34;, &#34;interferes&#34;
    if ( $spanset-&#62;contains( $set2 ) ) { ...    # like &#34;is-fully-inside&#34;

    # data extraction 
    $date = $spanset-&#62;min;           # first date of the set
    $date = $spanset-&#62;max;           # last date of the set

    $iter = $spanset-&#62;iterator;
    while ( $dt = $iter-&#62;next ) {
        # $dt is a DateTime::Span
        print $dt-&#62;start-&#62;ymd;   # first date of span
        print $dt-&#62;end-&#62;ymd;     # last date of span
    };</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p><code>DateTime::SpanSet</code> is a class that represents sets of datetime spans. An example would be a recurring meeting that occurs from 13:00-15:00 every Friday.</p>

<p>This is different from a <code>DateTime::Set</code>, which is made of individual datetime points as opposed to ranges.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<ul>
<li>from_spans
<p>Creates a new span set from one or more <code>DateTime::Span</code> objects.</p>

<pre>   $spanset = DateTime::SpanSet-&#62;from_spans( spans =&#62; [ $dt_span ] );</pre>
</li>

<li>from_set_and_duration
<p>Creates a new span set from one or more <code>DateTime::Set</code> objects and a duration.</p>

<p>The duration can be a <code>DateTime::Duration</code> object, or the parameters to create a new <code>DateTime::Duration</code> object, such as &#34;days&#34;, &#34;months&#34;, etc.</p>

<pre>   $spanset =
       DateTime::SpanSet-&#62;from_set_and_duration
           ( set =&#62; $dt_set, days =&#62; 1 );</pre>
</li>

<li>from_sets
<p>Creates a new span set from two <code>DateTime::Set</code> objects.</p>

<p>One set defines the <i>starting dates</i>, and the other defines the <i>end dates</i>.</p>

<pre>   $spanset =
       DateTime::SpanSet-&#62;from_sets
           ( start_set =&#62; $dt_set1, end_set =&#62; $dt_set2 );</pre>

<p>The spans have the starting date <code>closed</code>, and the end date <code>open</code>, like in <code>[$dt1, $dt2)</code>.</p>

<p>If an end date comes without a starting date before it, then it defines a span like <code>(-inf, $dt)</code>.</p>

<p>If a starting date comes without an end date after it, then it defines a span like <code>[$dt, inf)</code>.</p>
</li>

<li>empty_set
<p>Creates a new empty set.</p>
</li>

<li>is_empty_set
<p>Returns true is the set is empty; false otherwise.</p>

<pre>    print &#34;nothing&#34; if $set-&#62;is_empty_set;</pre>
</li>

<li>clone
<p>This object method returns a replica of the given object.</p>
</li>

<li>set_time_zone( $tz )
<p>This method accepts either a time zone object or a string that can be passed as the &#34;name&#34; parameter to <code>DateTime::TimeZone-&#62;new()</code>. If the new time zone&#39;s offset is different from the old time zone, then the <i>local</i> time is adjusted accordingly.</p>

<p>If the old time zone was a floating time zone, then no adjustments to the local time are made, except to account for leap seconds. If the new time zone is floating, then the <i>UTC</i> time is adjusted in order to leave the local time untouched.</p>
</li>

<li>min</li>

<li>max
<p>First or last dates in the set. These methods may return <code>undef</code> if the set is empty. It is also possible that these methods may return a scalar containing infinity or negative infinity.</p>
</li>

<li>duration
<p>The total size of the set, as a <code>DateTime::Duration</code> object.</p>

<p>The duration may be infinite.</p>

<p>Also available as <code>size()</code>.</p>
</li>

<li>span
<p>The total span of the set, as a <code>DateTime::Span</code> object.</p>
</li>

<li>next
<pre>  my $span = $set-&#62;next( $dt );</pre>

<p>This method is used to find the next span in the set, after a given datetime or span.</p>

<p>The return value is a <code>DateTime::Span</code>, or <code>undef</code> if there is no matching span in the set.</p>
</li>

<li>previous
<pre>  my $span = $set-&#62;previous( $dt );</pre>

<p>This method is used to find the previous span in the set, before a given datetime or span.</p>

<p>The return value is a <code>DateTime::Span</code>, or <code>undef</code> if there is no matching span in the set.</p>
</li>

<li>current
<pre>  my $span = $set-&#62;current( $dt );</pre>

<p>This method is used to find the &#34;current&#34; span in the set, that intersects a given datetime or span. If no current span is found, then the &#34;previous&#34; span is returned.</p>

<p>The return value is a <code>DateTime::SpanSet</code>, or <code>undef</code> if there is no matching span in the set.</p>

<p>If a span parameter is given, it may happen that &#34;current&#34; returns more than one span.</p>

<p>See also: <code>intersected_spans()</code> method.</p>
</li>

<li>closest
<pre>  my $span = $set-&#62;closest( $dt );</pre>

<p>This method is used to find the &#34;closest&#34; span in the set, given a datetime or span.</p>

<p>The return value is a <code>DateTime::SpanSet</code>, or <code>undef</code> if the set is empty.</p>

<p>If a span parameter is given, it may happen that &#34;closest&#34; returns more than one span.</p>
</li>

<li>as_list
<p>Returns a list of <code>DateTime::Span</code> objects.</p>

<pre>  my @dt_span = $set-&#62;as_list( span =&#62; $span );</pre>

<p>Just as with the <code>iterator()</code> method, the <code>as_list()</code> method can be limited by a span.</p>

<p>Applying <code>as_list()</code> to a large recurring spanset is a very expensive operation, both in CPU time and in the memory used.</p>

<p>For this reason, when <code>as_list()</code> operates on large recurrence sets, it will return at most approximately 200 spans. For larger sets, and for <i>infinite</i> sets, <code>as_list()</code> will return <code>undef</code>.</p>

<p>Please note that this is explicitly not an empty list, since an empty list is a valid return value for empty sets!</p>

<p>If you <i>really</i> need to extract spans from a large set, you can:</p>

<p>- limit the set with a shorter span:</p>

<pre>    my @short_list = $large_set-&#62;as_list( span =&#62; $short_span );</pre>

<p>- use an iterator:</p>

<pre>    my @large_list;
    my $iter = $large_set-&#62;iterator;
    push @large_list, $dt while $dt = $iter-&#62;next;</pre>
</li>

<li>union</li>

<li>intersection</li>

<li>complement
<p>Set operations may be performed not only with <code>DateTime::SpanSet</code> objects, but also with <code>DateTime</code>, <code>DateTime::Set</code> and <code>DateTime::Span</code> objects. These set operations always return a <code>DateTime::SpanSet</code> object.</p>

<pre>    $set = $spanset-&#62;union( $set2 );         # like &#34;OR&#34;, &#34;insert&#34;, &#34;both&#34;
    $set = $spanset-&#62;complement( $set2 );    # like &#34;delete&#34;, &#34;remove&#34;
    $set = $spanset-&#62;intersection( $set2 );  # like &#34;AND&#34;, &#34;while&#34;
    $set = $spanset-&#62;complement;             # like &#34;NOT&#34;, &#34;negate&#34;, &#34;invert&#34;</pre>
</li>

<li>intersected_spans
<p>This method can accept a <code>DateTime</code> list, a <code>DateTime::Set</code>, a <code>DateTime::Span</code>, or a <code>DateTime::SpanSet</code> object as an argument.</p>

<pre>    $set = $set1-&#62;intersected_spans( $set2 );</pre>

<p>The method always returns a <code>DateTime::SpanSet</code> object, containing all spans that are intersected by the given set.</p>

<p>Unlike the <code>intersection</code> method, the spans are not modified. See diagram below:</p>

<pre>               set1   [....]   [....]   [....]   [....]
               set2      [................]

       intersection      [.]   [....]   [.]

  intersected_spans   [....]   [....]   [....]</pre>
</li>

<li>intersects</li>

<li>contains
<p>These set functions return a boolean value.</p>

<pre>    if ( $spanset-&#62;intersects( $set2 ) ) { ...  # like &#34;touches&#34;, &#34;interferes&#34;
    if ( $spanset-&#62;contains( $dt ) ) { ...    # like &#34;is-fully-inside&#34;</pre>

<p>These methods can accept a <code>DateTime</code>, <code>DateTime::Set</code>, <code>DateTime::Span</code>, or <code>DateTime::SpanSet</code> object as an argument.</p>
</li>

<li>iterator / next / previous
<p>This method can be used to iterate over the spans in a set.</p>

<pre>    $iter = $spanset-&#62;iterator;
    while ( $dt = $iter-&#62;next ) {
        # $dt is a DateTime::Span
        print $dt-&#62;min-&#62;ymd;   # first date of span
        print $dt-&#62;max-&#62;ymd;   # last date of span
    }</pre>

<p>The boundaries of the iterator can be limited by passing it a <code>span</code> parameter. This should be a <code>DateTime::Span</code> object which delimits the iterator&#39;s boundaries. Optionally, instead of passing an object, you can pass any parameters that would work for one of the <code>DateTime::Span</code> class&#39;s constructors, and an object will be created for you.</p>

<p>Obviously, if the span you specify does is not restricted both at the start and end, then your iterator may iterate forever, depending on the nature of your set. User beware!</p>

<p>The <code>next()</code> or <code>previous()</code> methods will return <code>undef</code> when there are no more spans in the iterator.</p>
</li>

<li>start_set</li>

<li>end_set
<p>These methods do the inverse of the <code>from_sets</code> method:</p>

<p><code>start_set</code> retrieves a DateTime::Set with the start datetime of each span.</p>

<p><code>end_set</code> retrieves a DateTime::Set with the end datetime of each span.</p>
</li>

<li>map ( sub { ... } )
<pre>    # example: enlarge the spans
    $set = $set2-&#62;map( 
        sub {
            my $start = $_-&#62;start;
            my $end = $_-&#62;end;
            return DateTime::Span-&#62;from_datetimes(
                start =&#62; $start,
                before =&#62; $end,
            );
        }
    );</pre>

<p>This method is the &#34;set&#34; version of Perl &#34;map&#34;.</p>

<p>It evaluates a subroutine for each element of the set (locally setting &#34;$_&#34; to each DateTime::Span) and returns the set composed of the results of each such evaluation.</p>

<p>Like Perl &#34;map&#34;, each element of the set may produce zero, one, or more elements in the returned value.</p>

<p>Unlike Perl &#34;map&#34;, changing &#34;$_&#34; does not change the original set. This means that calling map in void context has no effect.</p>

<p>The callback subroutine may not be called immediately. Don&#39;t count on subroutine side-effects. For example, a <code>print</code> inside the subroutine may happen later than you expect.</p>

<p>The callback return value is expected to be within the span of the <code>previous</code> and the <code>next</code> element in the original set.</p>

<p>For example: given the set <code>[ 2001, 2010, 2015 ]</code>, the callback result for the value <code>2010</code> is expected to be within the span <code>[ 2001 .. 2015 ]</code>.</p>
</li>

<li>grep ( sub { ... } )
<pre>    # example: filter out all spans happening today
    my $today = DateTime-&#62;today;
    $set = $set2-&#62;grep( 
        sub {
            return ( ! $_-&#62;contains( $today ) );
        }
    );</pre>

<p>This method is the &#34;set&#34; version of Perl &#34;grep&#34;.</p>

<p>It evaluates a subroutine for each element of the set (locally setting &#34;$_&#34; to each DateTime::Span) and returns the set consisting of those elements for which the expression evaluated to true.</p>

<p>Unlike Perl &#34;grep&#34;, changing &#34;$_&#34; does not change the original set. This means that calling grep in void context has no effect.</p>

<p>Changing &#34;$_&#34; does change the resulting set.</p>

<p>The callback subroutine may not be called immediately. Don&#39;t count on subroutine side-effects. For example, a <code>print</code> inside the subroutine may happen later than you expect.</p>
</li>

<li>iterate
<p><i>Internal method - use &#34;map&#34; or &#34;grep&#34; instead.</i></p>

<p>This function apply a callback subroutine to all elements of a set and returns the resulting set.</p>

<p>The parameter <code>$_[0]</code> to the callback subroutine is a <code>DateTime::Span</code> object.</p>

<p>If the callback returns <code>undef</code>, the datetime is removed from the set:</p>

<pre>    sub remove_sundays {
        $_[0] unless $_[0]-&#62;start-&#62;day_of_week == 7;
    }</pre>

<p>The callback return value is expected to be within the span of the <code>previous</code> and the <code>next</code> element in the original set.</p>

<p>For example: given the set <code>[ 2001, 2010, 2015 ]</code>, the callback result for the value <code>2010</code> is expected to be within the span <code>[ 2001 .. 2015 ]</code>.</p>

<p>The callback subroutine may not be called immediately. Don&#39;t count on subroutine side-effects. For example, a <code>print</code> inside the subroutine may happen later than you expect.</p>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SUPPORT"
>SUPPORT</a></h1>

<p>Support is offered through the <code>datetime@perl.org</code> mailing list.</p>

<p>Please report bugs using rt.cpan.org</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Flavio Soibelmann Glock &#60;fglock@gmail.com&#62;</p>

<p>The API was developed together with Dave Rolsky and the DateTime Community.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright (c) 2003 Flavio Soibelmann Glock. All rights reserved. This program is free software; you can distribute it and/or modify it under the same terms as Perl itself.</p>

<p>The full text of the license can be found in the LICENSE file included with this module.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>Set::Infinite</p>

<p>For details on the Perl DateTime Suite project please see <a href="http://datetime.perl.org" class="podlinkurl"
>http://datetime.perl.org</a>.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
