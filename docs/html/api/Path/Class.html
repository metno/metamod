<html><head><title>Path::Class</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:23 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#EXPORT'>EXPORT</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Notes_on_Cross-Platform_Compatibility'>Notes on Cross-Platform Compatibility</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Path::Class - Cross-platform path specification manipulation</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>version 0.31</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use Path::Class;
  
  my $dir  = dir(&#39;foo&#39;, &#39;bar&#39;);       # Path::Class::Dir object
  my $file = file(&#39;bob&#39;, &#39;file.txt&#39;); # Path::Class::File object
  
  # Stringifies to &#39;foo/bar&#39; on Unix, &#39;foo\bar&#39; on Windows, etc.
  print &#34;dir: $dir\n&#34;;
  
  # Stringifies to &#39;bob/file.txt&#39; on Unix, &#39;bob\file.txt&#39; on Windows
  print &#34;file: $file\n&#34;;
  
  my $subdir  = $dir-&#62;subdir(&#39;baz&#39;);  # foo/bar/baz
  my $parent  = $subdir-&#62;parent;      # foo/bar
  my $parent2 = $parent-&#62;parent;      # foo
  
  my $dir2 = $file-&#62;dir;              # bob

  # Work with foreign paths
  use Path::Class qw(foreign_file foreign_dir);
  my $file = foreign_file(&#39;Mac&#39;, &#39;:foo:file.txt&#39;);
  print $file-&#62;dir;                   # :foo:
  print $file-&#62;as_foreign(&#39;Win32&#39;);   # foo\file.txt
  
  # Interact with the underlying filesystem:
  
  # $dir_handle is an IO::Dir object
  my $dir_handle = $dir-&#62;open or die &#34;Can&#39;t read $dir: $!&#34;;
  
  # $file_handle is an IO::File object
  my $file_handle = $file-&#62;open($mode) or die &#34;Can&#39;t read $file: $!&#34;;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p><code>Path::Class</code> is a module for manipulation of file and directory specifications (strings describing their locations, like <code>&#39;/home/ken/foo.txt&#39;</code> or <code>&#39;C:\Windows\Foo.txt&#39;</code>) in a cross-platform manner. It supports pretty much every platform Perl runs on, including Unix, Windows, Mac, VMS, Epoc, Cygwin, OS/2, and NetWare.</p>

<p>The well-known module <a href="../File/Spec.html" class="podlinkpod"
>File::Spec</a> also provides this service, but it&#39;s sort of awkward to use well, so people sometimes avoid it, or use it in a way that won&#39;t actually work properly on platforms significantly different than the ones they&#39;ve tested their code on.</p>

<p>In fact, <code>Path::Class</code> uses <code>File::Spec</code> internally, wrapping all the unsightly details so you can concentrate on your application code. Whereas <code>File::Spec</code> provides functions for some common path manipulations, <code>Path::Class</code> provides an object-oriented model of the world of path specifications and their underlying semantics. <code>File::Spec</code> doesn&#39;t create any objects, and its classes represent the different ways in which paths must be manipulated on various platforms (not a very intuitive concept). <code>Path::Class</code> creates objects representing files and directories, and provides methods that relate them to each other. For instance, the following <code>File::Spec</code> code:</p>

<pre> my $absolute = File::Spec-&#62;file_name_is_absolute(
                  File::Spec-&#62;catfile( @dirs, $file )
                );</pre>

<p>can be written using <code>Path::Class</code> as</p>

<pre> my $absolute = Path::Class::File-&#62;new( @dirs, $file )-&#62;is_absolute;</pre>

<p>or even as</p>

<pre> my $absolute = file( @dirs, $file )-&#62;is_absolute;</pre>

<p>Similar readability improvements should happen all over the place when using <code>Path::Class</code>.</p>

<p>Using <code>Path::Class</code> can help solve real problems in your code too - for instance, how many people actually take the &#34;volume&#34; (like <code>C:</code> on Windows) into account when writing <code>File::Spec</code>-using code? I thought not. But if you use <code>Path::Class</code>, your file and directory objects will know what volumes they refer to and do the right thing.</p>

<p>The guts of the <code>Path::Class</code> code live in the <a href="../Path/Class/File.html" class="podlinkpod"
>Path::Class::File</a> and <a href="../Path/Class/Dir.html" class="podlinkpod"
>Path::Class::Dir</a> modules, so please see those modules&#39; documentation for more details about how to use them.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="EXPORT"
>EXPORT</a></h2>

<p>The following functions are exported by default.</p>

<dl>
<dt><a name="file"
>file</a></dt>

<dd>
<p>A synonym for <code>Path::Class::File-&#62;new</code>.</p>

<dt><a name="dir"
>dir</a></dt>

<dd>
<p>A synonym for <code>Path::Class::Dir-&#62;new</code>.</p>
</dd>
</dl>

<p>If you would like to prevent their export, you may explicitly pass an empty list to perl&#39;s <code>use</code>, i.e. <code>use Path::Class ()</code>.</p>

<p>The following are exported only on demand.</p>

<dl>
<dt><a name="foreign_file"
>foreign_file</a></dt>

<dd>
<p>A synonym for <code>Path::Class::File-&#62;new_foreign</code>.</p>

<dt><a name="foreign_dir"
>foreign_dir</a></dt>

<dd>
<p>A synonym for <code>Path::Class::Dir-&#62;new_foreign</code>.</p>

<dt><a name="tempdir"
>tempdir</a></dt>

<dd>
<p>Create a new Path::Class::Dir instance pointed to temporary directory.</p>

<pre>  my $temp = Path::Class::tempdir(CLEANUP =&#62; 1);</pre>

<p>A synonym for <code>Path::Class::Dir-&#62;new(File::Temp::tempdir(@_))</code>.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Notes_on_Cross-Platform_Compatibility"
>Notes on Cross-Platform Compatibility</a></h1>

<p>Although it is much easier to write cross-platform-friendly code with this module than with <code>File::Spec</code>, there are still some issues to be aware of.</p>

<ul>
<li>On some platforms, notably VMS and some older versions of DOS (I think), all filenames must have an extension. Thus if you create a file called <em>foo/bar</em> and then ask for a list of files in the directory <em>foo</em>, you may find a file called <em>bar.</em> instead of the <em>bar</em> you were expecting. Thus it might be a good idea to use an extension in the first place.</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Ken Williams, KWILLIAMS@cpan.org</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright (c) Ken Williams. All rights reserved.</p>

<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../Path/Class/Dir.html" class="podlinkpod"
>Path::Class::Dir</a>, <a href="../Path/Class/File.html" class="podlinkpod"
>Path::Class::File</a>, <a href="../File/Spec.html" class="podlinkpod"
>File::Spec</a></p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
