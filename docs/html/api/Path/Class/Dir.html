<html><head><title>Path::Class::Dir</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:23 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#POD_ERRORS'>POD ERRORS</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Path::Class::Dir - Objects representing directories</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>version 0.31</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use Path::Class qw(dir);  # Export a short constructor
  
  my $dir = dir(&#39;foo&#39;, &#39;bar&#39;);       # Path::Class::Dir object
  my $dir = Path::Class::Dir-&#62;new(&#39;foo&#39;, &#39;bar&#39;);  # Same thing
  
  # Stringifies to &#39;foo/bar&#39; on Unix, &#39;foo\bar&#39; on Windows, etc.
  print &#34;dir: $dir\n&#34;;
  
  if ($dir-&#62;is_absolute) { ... }
  if ($dir-&#62;is_relative) { ... }
  
  my $v = $dir-&#62;volume; # Could be &#39;C:&#39; on Windows, empty string
                        # on Unix, &#39;Macintosh HD:&#39; on Mac OS
  
  $dir-&#62;cleanup; # Perform logical cleanup of pathname
  $dir-&#62;resolve; # Perform physical cleanup of pathname
  
  my $file = $dir-&#62;file(&#39;file.txt&#39;); # A file in this directory
  my $subdir = $dir-&#62;subdir(&#39;george&#39;); # A subdirectory
  my $parent = $dir-&#62;parent; # The parent directory, &#39;foo&#39;
  
  my $abs = $dir-&#62;absolute; # Transform to absolute path
  my $rel = $abs-&#62;relative; # Transform to relative path
  my $rel = $abs-&#62;relative(&#39;/foo&#39;); # Relative to /foo
  
  print $dir-&#62;as_foreign(&#39;Mac&#39;);   # :foo:bar:
  print $dir-&#62;as_foreign(&#39;Win32&#39;); #  foo\bar

  # Iterate with IO::Dir methods:
  my $handle = $dir-&#62;open;
  while (my $file = $handle-&#62;read) {
    $file = $dir-&#62;file($file);  # Turn into Path::Class::File object
    ...
  }
  
  # Iterate with Path::Class methods:
  while (my $file = $dir-&#62;next) {
    # $file is a Path::Class::File or Path::Class::Dir object
    ...
  }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>The <code>Path::Class::Dir</code> class contains functionality for manipulating directory names in a cross-platform way.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<dl>
<dt><a name="$dir_=_Path::Class::Dir-&#62;new(_&#60;dir1&#62;,_&#60;dir2&#62;,_..._)"
>$dir = Path::Class::Dir-&#62;new( &#60;dir1&#62;, &#60;dir2&#62;, ... )</a></dt>

<dd>
<dt><a name="$dir_=_dir(_&#60;dir1&#62;,_&#60;dir2&#62;,_..._)"
>$dir = dir( &#60;dir1&#62;, &#60;dir2&#62;, ... )</a></dt>

<dd>
<p>Creates a new <code>Path::Class::Dir</code> object and returns it. The arguments specify names of directories which will be joined to create a single directory object. A volume may also be specified as the first argument, or as part of the first argument. You can use platform-neutral syntax:</p>

<pre>  my $dir = dir( &#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39; );</pre>

<p>or platform-native syntax:</p>

<pre>  my $dir = dir( &#39;foo/bar/baz&#39; );</pre>

<p>or a mixture of the two:</p>

<pre>  my $dir = dir( &#39;foo/bar&#39;, &#39;baz&#39; );</pre>

<p>All three of the above examples create relative paths. To create an absolute path, either use the platform native syntax for doing so:</p>

<pre>  my $dir = dir( &#39;/var/tmp&#39; );</pre>

<p>or use an empty string as the first argument:</p>

<pre>  my $dir = dir( &#39;&#39;, &#39;var&#39;, &#39;tmp&#39; );</pre>

<p>If the second form seems awkward, that&#39;s somewhat intentional - paths like <code>/var/tmp</code> or <code>\Windows</code> aren&#39;t cross-platform concepts in the first place (many non-Unix platforms don&#39;t have a notion of a &#34;root directory&#34;), so they probably shouldn&#39;t appear in your code if you&#39;re trying to be cross-platform. The first form is perfectly natural, because paths like this may come from config files, user input, or whatever.</p>

<p>As a special case, since it doesn&#39;t otherwise mean anything useful and it&#39;s convenient to define this way, <code>Path::Class::Dir-&#62;new()</code> (or <code>dir()</code>) refers to the current directory (<code>File::Spec-&#62;curdir</code>). To get the current directory as an absolute path, do <code>dir()-&#62;absolute</code>.</p>

<p>Finally, as another special case <code>dir(undef)</code> will return undef, since that&#39;s usually an accident on the part of the caller, and returning the root directory would be a nasty surprise just asking for trouble a few lines later.</p>

<dt><a name="$dir-&#62;stringify"
>$dir-&#62;stringify</a></dt>

<dd>
<p>This method is called internally when a <code>Path::Class::Dir</code> object is used in a string context, so the following are equivalent:</p>

<pre>  $string = $dir-&#62;stringify;
  $string = &#34;$dir&#34;;</pre>

<dt><a name="$dir-&#62;volume"
>$dir-&#62;volume</a></dt>

<dd>
<p>Returns the volume (e.g. <code>C:</code> on Windows, <code>Macintosh HD:</code> on Mac OS, etc.) of the directory object, if any. Otherwise, returns the empty string.</p>

<dt><a name="$dir-&#62;basename"
>$dir-&#62;basename</a></dt>

<dd>
<p>Returns the last directory name of the path as a string.</p>

<dt><a name="$dir-&#62;is_dir"
>$dir-&#62;is_dir</a></dt>

<dd>
<p>Returns a boolean value indicating whether this object represents a directory. Not surprisingly, <a href="../../Path/Class/File.html" class="podlinkpod"
>Path::Class::File</a> objects always return false, and <code>Path::Class::Dir</code> objects always return true.</p>

<dt><a name="$dir-&#62;is_absolute"
>$dir-&#62;is_absolute</a></dt>

<dd>
<p>Returns true or false depending on whether the directory refers to an absolute path specifier (like <code>/usr/local</code> or <code>\Windows</code>).</p>

<dt><a name="$dir-&#62;is_relative"
>$dir-&#62;is_relative</a></dt>

<dd>
<p>Returns true or false depending on whether the directory refers to a relative path specifier (like <code>lib/foo</code> or <code>./dir</code>).</p>

<dt><a name="$dir-&#62;cleanup"
>$dir-&#62;cleanup</a></dt>

<dd>
<p>Performs a logical cleanup of the file path. For instance:</p>

<pre>  my $dir = dir(&#39;/foo//baz/./foo&#39;)-&#62;cleanup;
  # $dir now represents &#39;/foo/baz/foo&#39;;</pre>

<dt><a name="$dir-&#62;resolve"
>$dir-&#62;resolve</a></dt>

<dd>
<p>Performs a physical cleanup of the file path. For instance:</p>

<pre>  my $dir = dir(&#39;/foo//baz/../foo&#39;)-&#62;resolve;
  # $dir now represents &#39;/foo/foo&#39;, assuming no symlinks</pre>

<p>This actually consults the filesystem to verify the validity of the path.</p>

<dt><a name="$file_=_$dir-&#62;file(_&#60;dir1&#62;,_&#60;dir2&#62;,_...,_&#60;file&#62;_)"
>$file = $dir-&#62;file( &#60;dir1&#62;, &#60;dir2&#62;, ..., &#60;file&#62; )</a></dt>

<dd>
<p>Returns a <a href="../../Path/Class/File.html" class="podlinkpod"
>Path::Class::File</a> object representing an entry in <code>$dir</code> or one of its subdirectories. Internally, this just calls <code>Path::Class::File-&#62;new( @_ )</code>.</p>

<dt><a name="$subdir_=_$dir-&#62;subdir(_&#60;dir1&#62;,_&#60;dir2&#62;,_..._)"
>$subdir = $dir-&#62;subdir( &#60;dir1&#62;, &#60;dir2&#62;, ... )</a></dt>

<dd>
<p>Returns a new <code>Path::Class::Dir</code> object representing a subdirectory of <code>$dir</code>.</p>

<dt><a name="$parent_=_$dir-&#62;parent"
>$parent = $dir-&#62;parent</a></dt>

<dd>
<p>Returns the parent directory of <code>$dir</code>. Note that this is the <i>logical</i> parent, not necessarily the physical parent. It really means we just chop off entries from the end of the directory list until we cain&#39;t chop no more. If the directory is relative, we start using the relative forms of parent directories.</p>

<p>The following code demonstrates the behavior on absolute and relative directories:</p>

<pre>  $dir = dir(&#39;/foo/bar&#39;);
  for (1..6) {
    print &#34;Absolute: $dir\n&#34;;
    $dir = $dir-&#62;parent;
  }
  
  $dir = dir(&#39;foo/bar&#39;);
  for (1..6) {
    print &#34;Relative: $dir\n&#34;;
    $dir = $dir-&#62;parent;
  }
  
  ########### Output on Unix ################
  Absolute: /foo/bar
  Absolute: /foo
  Absolute: /
  Absolute: /
  Absolute: /
  Absolute: /
  Relative: foo/bar
  Relative: foo
  Relative: .
  Relative: ..
  Relative: ../..
  Relative: ../../..</pre>

<dt><a name="@list_=_$dir-&#62;children"
>@list = $dir-&#62;children</a></dt>

<dd>
<p>Returns a list of <a href="../../Path/Class/File.html" class="podlinkpod"
>Path::Class::File</a> and/or <code>Path::Class::Dir</code> objects listed in this directory, or in scalar context the number of such objects. Obviously, it is necessary for <code>$dir</code> to exist and be readable in order to find its children.</p>

<p>Note that the children are returned as subdirectories of <code>$dir</code>, i.e. the children of <em>foo</em> will be <em>foo/bar</em> and <em>foo/baz</em>, not <em>bar</em> and <em>baz</em>.</p>

<p>Ordinarily <code>children()</code> will not include the <i>self</i> and <i>parent</i> entries <code>.</code> and <code>..</code> (or their equivalents on non-Unix systems), because that&#39;s like I&#39;m-my-own-grandpa business. If you do want all directory entries including these special ones, pass a true value for the <code>all</code> parameter:</p>

<pre>  @c = $dir-&#62;children(); # Just the children
  @c = $dir-&#62;children(all =&#62; 1); # All entries</pre>

<p>In addition, there&#39;s a <code>no_hidden</code> parameter that will exclude all normally &#34;hidden&#34; entries - on Unix this means excluding all entries that begin with a dot (<code>.</code>):</p>

<pre>  @c = $dir-&#62;children(no_hidden =&#62; 1); # Just normally-visible entries</pre>

<dt><a name="$abs_=_$dir-&#62;absolute"
>$abs = $dir-&#62;absolute</a></dt>

<dd>
<p>Returns a <code>Path::Class::Dir</code> object representing <code>$dir</code> as an absolute path. An optional argument, given as either a string or a <code>Path::Class::Dir</code> object, specifies the directory to use as the base of relativity - otherwise the current working directory will be used.</p>

<dt><a name="$rel_=_$dir-&#62;relative"
>$rel = $dir-&#62;relative</a></dt>

<dd>
<p>Returns a <code>Path::Class::Dir</code> object representing <code>$dir</code> as a relative path. An optional argument, given as either a string or a <code>Path::Class::Dir</code> object, specifies the directory to use as the base of relativity - otherwise the current working directory will be used.</p>

<dt><a name="$boolean_=_$dir-&#62;subsumes($other)"
>$boolean = $dir-&#62;subsumes($other)</a></dt>

<dd>
<p>Returns true if this directory spec subsumes the other spec, and false otherwise. Think of &#34;subsumes&#34; as &#34;contains&#34;, but we only look at the <i>specs</i>, not whether <code>$dir</code> actually contains <code>$other</code> on the filesystem.</p>

<p>The <code>$other</code> argument may be a <code>Path::Class::Dir</code> object, a <a href="../../Path/Class/File.html" class="podlinkpod"
>Path::Class::File</a> object, or a string. In the latter case, we assume it&#39;s a directory.</p>

<pre>  # Examples:
  dir(&#39;foo/bar&#39; )-&#62;subsumes(dir(&#39;foo/bar/baz&#39;))  # True
  dir(&#39;/foo/bar&#39;)-&#62;subsumes(dir(&#39;/foo/bar/baz&#39;)) # True
  dir(&#39;foo/bar&#39; )-&#62;subsumes(dir(&#39;bar/baz&#39;))      # False
  dir(&#39;/foo/bar&#39;)-&#62;subsumes(dir(&#39;foo/bar&#39;))      # False</pre>

<dt><a name="$boolean_=_$dir-&#62;contains($other)"
>$boolean = $dir-&#62;contains($other)</a></dt>

<dd>
<p>Returns true if this directory actually contains <code>$other</code> on the filesystem. <code>$other</code> doesn&#39;t have to be a direct child of <code>$dir</code>, it just has to be subsumed.</p>

<dt><a name="$foreign_=_$dir-&#62;as_foreign($type)"
>$foreign = $dir-&#62;as_foreign($type)</a></dt>

<dd>
<p>Returns a <code>Path::Class::Dir</code> object representing <code>$dir</code> as it would be specified on a system of type <code>$type</code>. Known types include <code>Unix</code>, <code>Win32</code>, <code>Mac</code>, <code>VMS</code>, and <code>OS2</code>, i.e. anything for which there is a subclass of <code>File::Spec</code>.</p>

<p>Any generated objects (subdirectories, files, parents, etc.) will also retain this type.</p>

<dt><a name="$foreign_=_Path::Class::Dir-&#62;new_foreign($type,_@args)"
>$foreign = Path::Class::Dir-&#62;new_foreign($type, @args)</a></dt>

<dd>
<p>Returns a <code>Path::Class::Dir</code> object representing <code>$dir</code> as it would be specified on a system of type <code>$type</code>. Known types include <code>Unix</code>, <code>Win32</code>, <code>Mac</code>, <code>VMS</code>, and <code>OS2</code>, i.e. anything for which there is a subclass of <code>File::Spec</code>.</p>

<p>The arguments in <code>@args</code> are the same as they would be specified in <code>new()</code>.</p>

<dt><a name="@list_=_$dir-&#62;dir_list([OFFSET,_[LENGTH]])"
>@list = $dir-&#62;dir_list([OFFSET, [LENGTH]])</a></dt>

<dd>
<p>Returns the list of strings internally representing this directory structure. Each successive member of the list is understood to be an entry in its predecessor&#39;s directory list. By contract, <code>Path::Class-&#62;new( $dir-&#62;dir_list )</code> should be equivalent to <code>$dir</code>.</p>

<p>The semantics of this method are similar to Perl&#39;s <code>splice</code> or <code>substr</code> functions; they return <code>LENGTH</code> elements starting at <code>OFFSET</code>. If <code>LENGTH</code> is omitted, returns all the elements starting at <code>OFFSET</code> up to the end of the list. If <code>LENGTH</code> is negative, returns the elements from <code>OFFSET</code> onward except for <code>-LENGTH</code> elements at the end. If <code>OFFSET</code> is negative, it counts backward <code>OFFSET</code> elements from the end of the list. If <code>OFFSET</code> and <code>LENGTH</code> are both omitted, the entire list is returned.</p>

<p>In a scalar context, <code>dir_list()</code> with no arguments returns the number of entries in the directory list; <code>dir_list(OFFSET)</code> returns the single element at that offset; <code>dir_list(OFFSET, LENGTH)</code> returns the final element that would have been returned in a list context.</p>

<dt><a name="$dir-&#62;components"
>$dir-&#62;components</a></dt>

<dd>
<p>Identical to c&#60;dir_list()&#62;. It exists because there&#39;s an analogous method <code>dir_list()</code> in the <code>Path::Class::File</code> class that also returns the basename string, so this method lets someone call <code>components()</code> without caring whether the object is a file or a directory.</p>

<dt><a name="$fh_=_$dir-&#62;open()"
>$fh = $dir-&#62;open()</a></dt>

<dd>
<p>Passes <code>$dir</code> to <code>IO::Dir-&#62;open</code> and returns the result as an <a href="../../IO/Dir.html" class="podlinkpod"
>IO::Dir</a> object. If the opening fails, <code>undef</code> is returned and <code>$!</code> is set.</p>

<dt><a name="$dir-&#62;mkpath($verbose,_$mode)"
>$dir-&#62;mkpath($verbose, $mode)</a></dt>

<dd>
<p>Passes all arguments, including <code>$dir</code>, to <code>File::Path::mkpath()</code> and returns the result (a list of all directories created).</p>

<dt><a name="$dir-&#62;rmtree($verbose,_$cautious)"
>$dir-&#62;rmtree($verbose, $cautious)</a></dt>

<dd>
<p>Passes all arguments, including <code>$dir</code>, to <code>File::Path::rmtree()</code> and returns the result (the number of files successfully deleted).</p>

<dt><a name="$dir-&#62;remove()"
>$dir-&#62;remove()</a></dt>

<dd>
<p>Removes the directory, which must be empty. Returns a boolean value indicating whether or not the directory was successfully removed. This method is mainly provided for consistency with <code>Path::Class::File</code>&#39;s <code>remove()</code> method.</p>

<dt><a name="$dir-&#62;tempfile(...)"
>$dir-&#62;tempfile(...)</a></dt>

<dd>
<p>An interface to <a href="../../File/Temp.html" class="podlinkpod"
>File::Temp</a>&#39;s <code>tempfile()</code> function. Just like that function, if you call this in a scalar context, the return value is the filehandle and the file is <code>unlink</code>ed as soon as possible (which is immediately on Unix-like platforms). If called in a list context, the return values are the filehandle and the filename.</p>

<p>The given directory is passed as the <code>DIR</code> parameter.</p>

<p>Here&#39;s an example of pretty good usage which doesn&#39;t allow race conditions, won&#39;t leave yucky tempfiles around on your filesystem, etc.:</p>

<pre>  my $fh = $dir-&#62;tempfile;
  print $fh &#34;Here&#39;s some data...\n&#34;;
  seek($fh, 0, 0);
  while (&#60;$fh&#62;) { do something... }</pre>

<p>Or in combination with a <code>fork</code>:</p>

<pre>  my $fh = $dir-&#62;tempfile;
  print $fh &#34;Here&#39;s some more data...\n&#34;;
  seek($fh, 0, 0);
  if ($pid=fork()) {
    wait;
  } else {
    something($_) while &#60;$fh&#62;;
  }</pre>

<dt><a name="$dir_or_file_=_$dir-&#62;next()"
>$dir_or_file = $dir-&#62;next()</a></dt>

<dd>
<p>A convenient way to iterate through directory contents. The first time <code>next()</code> is called, it will <code>open()</code> the directory and read the first item from it, returning the result as a <code>Path::Class::Dir</code> or <a href="../../Path/Class/File.html" class="podlinkpod"
>Path::Class::File</a> object (depending, of course, on its actual type). Each subsequent call to <code>next()</code> will simply iterate over the directory&#39;s contents, until there are no more items in the directory, and then the undefined value is returned. For example, to iterate over all the regular files in a directory:</p>

<pre>  while (my $file = $dir-&#62;next) {
    next unless -f $file;
    my $fh = $file-&#62;open(&#39;r&#39;) or die &#34;Can&#39;t read $file: $!&#34;;
    ...
  }</pre>

<p>If an error occurs when opening the directory (for instance, it doesn&#39;t exist or isn&#39;t readable), <code>next()</code> will throw an exception with the value of <code>$!</code>.</p>

<dt><a name="$dir-&#62;traverse(_sub_{_..._},_@args_)"
>$dir-&#62;traverse( sub { ... }, @args )</a></dt>

<dd>
<p>Calls the given callback for the root, passing it a continuation function which, when called, will call this recursively on each of its children. The callback function should be of the form:</p>

<pre>  sub {
    my ($child, $cont, @args) = @_;
    # ...
  }</pre>

<p>For instance, to calculate the number of files in a directory, you can do this:</p>

<pre>  my $nfiles = $dir-&#62;traverse(sub {
    my ($child, $cont) = @_;
    return sum($cont-&#62;(), ($child-&#62;is_dir ? 0 : 1));
  });</pre>

<p>or to calculate the maximum depth of a directory:</p>

<pre>  my $depth = $dir-&#62;traverse(sub {
    my ($child, $cont, $depth) = @_;
    return max($cont-&#62;($depth + 1), $depth);
  }, 0);</pre>

<p>You can also choose not to call the callback in certain situations:</p>

<pre>  $dir-&#62;traverse(sub {
    my ($child, $cont) = @_;
    return if -l $child; # don&#39;t follow symlinks
    # do something with $child
    return $cont-&#62;();
  });</pre>

<dt><a name="$dir-&#62;traverse_if(_sub_{_..._},_sub_{_..._},_@args_)"
>$dir-&#62;traverse_if( sub { ... }, sub { ... }, @args )</a></dt>

<dd>
<p>traverse with additional &#34;should I visit this child&#34; callback. Particularly useful in case examined tree contains inaccessible directories.</p>

<p>Canonical example:</p>

<pre>  $dir-&#62;traverse_if(
    sub {
       my ($child, $cont) = @_;
       # do something with $child
       return $cont-&#62;();
    }, 
    sub {
       my ($child) = @_;
       # Process only readable items
       return -r $child;
    });</pre>

<p>Second callback gets single parameter: child. Only children for which it returns true will be processed by the first callback.</p>

<p>Remaining parameters are interpreted as in traverse, in particular <code>traverse_if(callback, sub { 1 }, @args</code> is equivalent to <code>traverse(callback, @args);</code></p>

<dt><a name="$dir-&#62;recurse(_callback_=&#62;_sub_{...}_)"
>$dir-&#62;recurse( callback =&#62; sub {...} )</a></dt>

<dd>
<p>Iterates through this directory and all of its children, and all of its children&#39;s children, etc., calling the <code>callback</code> subroutine for each entry. This is a lot like what the <a href="../../File/Find.html" class="podlinkpod"
>File::Find</a> module does, and of course <code>File::Find</code> will work fine on <a href="../../Path/Class.html" class="podlinkpod"
>Path::Class</a> objects, but the advantage of the <code>recurse()</code> method is that it will also feed your callback routine <code>Path::Class</code> objects rather than just pathname strings.</p>

<p>The <code>recurse()</code> method requires a <code>callback</code> parameter specifying the subroutine to invoke for each entry. It will be passed the <code>Path::Class</code> object as its first argument.</p>

<p><code>recurse()</code> also accepts two boolean parameters, <code>depthfirst</code> and <code>preorder</code> that control the order of recursion. The default is a preorder, breadth-first search, i.e. <code>depthfirst =&#62; 0, preorder =&#62; 1</code>. At the time of this writing, all combinations of these two parameters are supported <i>except</i> <code>depthfirst =&#62; 0, preorder =&#62; 0</code>.</p>

<p><code>callback</code> is normally not required to return any value. If it returns special constant <code>Path::Class::Entity::PRUNE()</code> (more easily available as <code>$item-</code>PRUNE&#62;), no children of analyzed item will be analyzed (mostly as if you set <code>$File::Find::prune=1</code>). Of course pruning is available only in <code>preorder</code>, in postorder return value has no effect.</p>

<dt><a name="$st_=_$file-&#62;stat()"
>$st = $file-&#62;stat()</a></dt>

<dd>
<p>Invokes <code>File::stat::stat()</code> on this directory and returns a <code>File::stat</code> object representing the result.</p>

<dt><a name="$st_=_$file-&#62;lstat()"
>$st = $file-&#62;lstat()</a></dt>

<dd>
<p>Same as <code>stat()</code>, but if <code>$file</code> is a symbolic link, <code>lstat()</code> stats the link instead of the directory the link points to.</p>

<dt><a name="$class_=_$file-&#62;file_class()"
>$class = $file-&#62;file_class()</a></dt>

<dd>
<p>Returns the class which should be used to create file objects.</p>

<p>Generally overridden whenever this class is subclassed.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Ken Williams, kwilliams@cpan.org</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../../Path/Class.html" class="podlinkpod"
>Path::Class</a>, <a href="../../Path/Class/File.html" class="podlinkpod"
>Path::Class::File</a>, <a href="../../File/Spec.html" class="podlinkpod"
>File::Spec</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="POD_ERRORS"
>POD ERRORS</a></h1>

<p>Hey! <b>The above document had some coding errors, which are explained below:</b></p>

<dl>
<dt><a name="Around_line_773:"
>Around line 773:</a></dt>

<dd>
<p>Unterminated C&#60;...&#62; sequence</p>
</dd>
</dl>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
