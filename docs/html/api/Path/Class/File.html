<html><head><title>Path::Class::File</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:23 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Path::Class::File - Objects representing files</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>version 0.31</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use Path::Class qw(file);  # Export a short constructor
  
  my $file = file(&#39;foo&#39;, &#39;bar.txt&#39;);  # Path::Class::File object
  my $file = Path::Class::File-&#62;new(&#39;foo&#39;, &#39;bar.txt&#39;); # Same thing
  
  # Stringifies to &#39;foo/bar.txt&#39; on Unix, &#39;foo\bar.txt&#39; on Windows, etc.
  print &#34;file: $file\n&#34;;
  
  if ($file-&#62;is_absolute) { ... }
  if ($file-&#62;is_relative) { ... }
  
  my $v = $file-&#62;volume; # Could be &#39;C:&#39; on Windows, empty string
                         # on Unix, &#39;Macintosh HD:&#39; on Mac OS
  
  $file-&#62;cleanup; # Perform logical cleanup of pathname
  $file-&#62;resolve; # Perform physical cleanup of pathname
  
  my $dir = $file-&#62;dir;  # A Path::Class::Dir object
  
  my $abs = $file-&#62;absolute; # Transform to absolute path
  my $rel = $file-&#62;relative; # Transform to relative path</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>The <code>Path::Class::File</code> class contains functionality for manipulating file names in a cross-platform way.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<dl>
<dt><a name="$file_=_Path::Class::File-&#62;new(_&#60;dir1&#62;,_&#60;dir2&#62;,_...,_&#60;file&#62;_)"
>$file = Path::Class::File-&#62;new( &#60;dir1&#62;, &#60;dir2&#62;, ..., &#60;file&#62; )</a></dt>

<dd>
<dt><a name="$file_=_file(_&#60;dir1&#62;,_&#60;dir2&#62;,_...,_&#60;file&#62;_)"
>$file = file( &#60;dir1&#62;, &#60;dir2&#62;, ..., &#60;file&#62; )</a></dt>

<dd>
<p>Creates a new <code>Path::Class::File</code> object and returns it. The arguments specify the path to the file. Any volume may also be specified as the first argument, or as part of the first argument. You can use platform-neutral syntax:</p>

<pre>  my $file = file( &#39;foo&#39;, &#39;bar&#39;, &#39;baz.txt&#39; );</pre>

<p>or platform-native syntax:</p>

<pre>  my $file = file( &#39;foo/bar/baz.txt&#39; );</pre>

<p>or a mixture of the two:</p>

<pre>  my $file = file( &#39;foo/bar&#39;, &#39;baz.txt&#39; );</pre>

<p>All three of the above examples create relative paths. To create an absolute path, either use the platform native syntax for doing so:</p>

<pre>  my $file = file( &#39;/var/tmp/foo.txt&#39; );</pre>

<p>or use an empty string as the first argument:</p>

<pre>  my $file = file( &#39;&#39;, &#39;var&#39;, &#39;tmp&#39;, &#39;foo.txt&#39; );</pre>

<p>If the second form seems awkward, that&#39;s somewhat intentional - paths like <code>/var/tmp</code> or <code>\Windows</code> aren&#39;t cross-platform concepts in the first place, so they probably shouldn&#39;t appear in your code if you&#39;re trying to be cross-platform. The first form is perfectly fine, because paths like this may come from config files, user input, or whatever.</p>

<dt><a name="$file-&#62;stringify"
>$file-&#62;stringify</a></dt>

<dd>
<p>This method is called internally when a <code>Path::Class::File</code> object is used in a string context, so the following are equivalent:</p>

<pre>  $string = $file-&#62;stringify;
  $string = &#34;$file&#34;;</pre>

<dt><a name="$file-&#62;volume"
>$file-&#62;volume</a></dt>

<dd>
<p>Returns the volume (e.g. <code>C:</code> on Windows, <code>Macintosh HD:</code> on Mac OS, etc.) of the object, if any. Otherwise, returns the empty string.</p>

<dt><a name="$file-&#62;basename"
>$file-&#62;basename</a></dt>

<dd>
<p>Returns the name of the file as a string, without the directory portion (if any).</p>

<dt><a name="$file-&#62;components"
>$file-&#62;components</a></dt>

<dd>
<p>Returns a list of the directory components of this file, followed by the basename.</p>

<p>Note: unlike <code>$dir-&#62;components</code>, this method currently does not accept any arguments to select which elements of the list will be returned. It may do so in the future. Currently it throws an exception if such arguments are present.</p>

<dt><a name="$file-&#62;is_dir"
>$file-&#62;is_dir</a></dt>

<dd>
<p>Returns a boolean value indicating whether this object represents a directory. Not surprisingly, <code>Path::Class::File</code> objects always return false, and <a href="../../Path/Class/Dir.html" class="podlinkpod"
>Path::Class::Dir</a> objects always return true.</p>

<dt><a name="$file-&#62;is_absolute"
>$file-&#62;is_absolute</a></dt>

<dd>
<p>Returns true or false depending on whether the file refers to an absolute path specifier (like <code>/usr/local/foo.txt</code> or <code>\Windows\Foo.txt</code>).</p>

<dt><a name="$file-&#62;is_relative"
>$file-&#62;is_relative</a></dt>

<dd>
<p>Returns true or false depending on whether the file refers to a relative path specifier (like <code>lib/foo.txt</code> or <code>.\Foo.txt</code>).</p>

<dt><a name="$file-&#62;cleanup"
>$file-&#62;cleanup</a></dt>

<dd>
<p>Performs a logical cleanup of the file path. For instance:</p>

<pre>  my $file = file(&#39;/foo//baz/./foo.txt&#39;)-&#62;cleanup;
  # $file now represents &#39;/foo/baz/foo.txt&#39;;</pre>

<dt><a name="$dir-&#62;resolve"
>$dir-&#62;resolve</a></dt>

<dd>
<p>Performs a physical cleanup of the file path. For instance:</p>

<pre>  my $file = file(&#39;/foo/baz/../foo.txt&#39;)-&#62;resolve;
  # $file now represents &#39;/foo/foo.txt&#39;, assuming no symlinks</pre>

<p>This actually consults the filesystem to verify the validity of the path.</p>

<dt><a name="$dir_=_$file-&#62;dir"
>$dir = $file-&#62;dir</a></dt>

<dd>
<p>Returns a <code>Path::Class::Dir</code> object representing the directory containing this file.</p>

<dt><a name="$dir_=_$file-&#62;parent"
>$dir = $file-&#62;parent</a></dt>

<dd>
<p>A synonym for the <code>dir()</code> method.</p>

<dt><a name="$abs_=_$file-&#62;absolute"
>$abs = $file-&#62;absolute</a></dt>

<dd>
<p>Returns a <code>Path::Class::File</code> object representing <code>$file</code> as an absolute path. An optional argument, given as either a string or a <a href="../../Path/Class/Dir.html" class="podlinkpod"
>Path::Class::Dir</a> object, specifies the directory to use as the base of relativity - otherwise the current working directory will be used.</p>

<dt><a name="$rel_=_$file-&#62;relative"
>$rel = $file-&#62;relative</a></dt>

<dd>
<p>Returns a <code>Path::Class::File</code> object representing <code>$file</code> as a relative path. An optional argument, given as either a string or a <code>Path::Class::Dir</code> object, specifies the directory to use as the base of relativity - otherwise the current working directory will be used.</p>

<dt><a name="$foreign_=_$file-&#62;as_foreign($type)"
>$foreign = $file-&#62;as_foreign($type)</a></dt>

<dd>
<p>Returns a <code>Path::Class::File</code> object representing <code>$file</code> as it would be specified on a system of type <code>$type</code>. Known types include <code>Unix</code>, <code>Win32</code>, <code>Mac</code>, <code>VMS</code>, and <code>OS2</code>, i.e. anything for which there is a subclass of <code>File::Spec</code>.</p>

<p>Any generated objects (subdirectories, files, parents, etc.) will also retain this type.</p>

<dt><a name="$foreign_=_Path::Class::File-&#62;new_foreign($type,_@args)"
>$foreign = Path::Class::File-&#62;new_foreign($type, @args)</a></dt>

<dd>
<p>Returns a <code>Path::Class::File</code> object representing a file as it would be specified on a system of type <code>$type</code>. Known types include <code>Unix</code>, <code>Win32</code>, <code>Mac</code>, <code>VMS</code>, and <code>OS2</code>, i.e. anything for which there is a subclass of <code>File::Spec</code>.</p>

<p>The arguments in <code>@args</code> are the same as they would be specified in <code>new()</code>.</p>

<dt><a name="$fh_=_$file-&#62;open($mode,_$permissions)"
>$fh = $file-&#62;open($mode, $permissions)</a></dt>

<dd>
<p>Passes the given arguments, including <code>$file</code>, to <code>IO::File-&#62;new</code> (which in turn calls <code>IO::File-&#62;open</code> and returns the result as an <a href="../../IO/File.html" class="podlinkpod"
>IO::File</a> object. If the opening fails, <code>undef</code> is returned and <code>$!</code> is set.</p>

<dt><a name="$fh_=_$file-&#62;openr()"
>$fh = $file-&#62;openr()</a></dt>

<dd>
<p>A shortcut for</p>

<pre> $fh = $file-&#62;open(&#39;r&#39;) or croak &#34;Can&#39;t read $file: $!&#34;;</pre>

<dt><a name="$fh_=_$file-&#62;openw()"
>$fh = $file-&#62;openw()</a></dt>

<dd>
<p>A shortcut for</p>

<pre> $fh = $file-&#62;open(&#39;w&#39;) or croak &#34;Can&#39;t write to $file: $!&#34;;</pre>

<dt><a name="$fh_=_$file-&#62;opena()"
>$fh = $file-&#62;opena()</a></dt>

<dd>
<p>A shortcut for</p>

<pre> $fh = $file-&#62;open(&#39;a&#39;) or croak &#34;Can&#39;t append to $file: $!&#34;;</pre>

<dt><a name="$file-&#62;touch"
>$file-&#62;touch</a></dt>

<dd>
<p>Sets the modification and access time of the given file to right now, if the file exists. If it doesn&#39;t exist, <code>touch()</code> will <i>make</i> it exist, and - YES! - set its modification and access time to now.</p>

<dt><a name="$file-&#62;slurp()"
>$file-&#62;slurp()</a></dt>

<dd>
<p>In a scalar context, returns the contents of <code>$file</code> in a string. In a list context, returns the lines of <code>$file</code> (according to how <code>$/</code> is set) as a list. If the file can&#39;t be read, this method will throw an exception.</p>

<p>If you want <code>chomp()</code> run on each line of the file, pass a true value for the <code>chomp</code> or <code>chomped</code> parameters:</p>

<pre>  my @lines = $file-&#62;slurp(chomp =&#62; 1);</pre>

<p>You may also use the <code>iomode</code> parameter to pass in an IO mode to use when opening the file, usually IO layers (though anything accepted by the MODE argument of <code>open()</code> is accepted here). Just make sure it&#39;s a <i>reading</i> mode.</p>

<pre>  my @lines = $file-&#62;slurp(iomode =&#62; &#39;:crlf&#39;);
  my $lines = $file-&#62;slurp(iomode =&#62; &#39;&#60;:encoding(UTF-8)&#39;);</pre>

<p>The default <code>iomode</code> is <code>r</code>.</p>

<p>Lines can also be automatically splitted, mimicking the perl command-line option <code>-a</code> by using the <code>split</code> parameter. If this parameter is used, each line will be returned as an array ref.</p>

<pre>    my @lines = $file-&#62;slurp( chomp =&#62; 1, split =&#62; qr/\s*,\s*/ );</pre>

<p>The <code>split</code> parameter can only be used in a list context.</p>

<dt><a name="$file-&#62;spew(_$content_);"
>$file-&#62;spew( $content );</a></dt>

<dd>
<p>The opposite of <a href="#slurp" class="podlinkpod"
>&#34;slurp&#34;</a>, this takes a list of strings and prints them to the file in write mode. If the file can&#39;t be written to, this method will throw an exception.</p>

<p>The content to be written can be either an array ref or a plain scalar. If the content is an array ref then each entry in the array will be written to the file.</p>

<p>You may use the <code>iomode</code> parameter to pass in an IO mode to use when opening the file, just like <a href="#slurp" class="podlinkpod"
>&#34;slurp&#34;</a> supports.</p>

<pre>  $file-&#62;spew(iomode =&#62; &#39;&#62;:raw&#39;, $content);</pre>

<p>The default <code>iomode</code> is <code>w</code>.</p>

<dt><a name="$file-&#62;traverse(sub_{_..._},_@args)"
>$file-&#62;traverse(sub { ... }, @args)</a></dt>

<dd>
<p>Calls the given callback on $file. This doesn&#39;t do much on its own, but see the associated documentation in <a href="../../Path/Class/Dir.html" class="podlinkpod"
>Path::Class::Dir</a>.</p>

<dt><a name="$file-&#62;remove()"
>$file-&#62;remove()</a></dt>

<dd>
<p>This method will remove the file in a way that works well on all platforms, and returns a boolean value indicating whether or not the file was successfully removed.</p>

<p><code>remove()</code> is better than simply calling Perl&#39;s <code>unlink()</code> function, because on some platforms (notably VMS) you actually may need to call <code>unlink()</code> several times before all versions of the file are gone - the <code>remove()</code> method handles this process for you.</p>

<dt><a name="$st_=_$file-&#62;stat()"
>$st = $file-&#62;stat()</a></dt>

<dd>
<p>Invokes <code>File::stat::stat()</code> on this file and returns a <a href="../../File/stat.html" class="podlinkpod"
>File::stat</a> object representing the result.</p>

<dt><a name="$st_=_$file-&#62;lstat()"
>$st = $file-&#62;lstat()</a></dt>

<dd>
<p>Same as <code>stat()</code>, but if <code>$file</code> is a symbolic link, <code>lstat()</code> stats the link instead of the file the link points to.</p>

<dt><a name="$class_=_$file-&#62;dir_class()"
>$class = $file-&#62;dir_class()</a></dt>

<dd>
<p>Returns the class which should be used to create directory objects.</p>

<p>Generally overridden whenever this class is subclassed.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Ken Williams, kwilliams@cpan.org</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../../Path/Class.html" class="podlinkpod"
>Path::Class</a>, <a href="../../Path/Class/Dir.html" class="podlinkpod"
>Path::Class::Dir</a>, <a href="../../File/Spec.html" class="podlinkpod"
>File::Spec</a></p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
