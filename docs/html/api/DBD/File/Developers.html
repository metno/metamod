<html><head><title>DBD::File::Developers</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:14 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#CLASSES'>CLASSES</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#DBD%3A%3AFile'>DBD::File</a>
    <li class='indexItem indexItem2'><a href='#DBD%3A%3AFile%3A%3Adr'>DBD::File::dr</a>
    <li class='indexItem indexItem2'><a href='#DBD%3A%3AFile%3A%3Adb'>DBD::File::db</a>
    <li class='indexItem indexItem2'><a href='#DBD%3A%3AFile%3A%3Ast'>DBD::File::st</a>
    <li class='indexItem indexItem2'><a href='#DBD%3A%3AFile%3A%3ATableSource%3A%3AFileSystem'>DBD::File::TableSource::FileSystem</a>
    <li class='indexItem indexItem2'><a href='#DBD%3A%3AFile%3A%3ADataSource%3A%3AStream'>DBD::File::DataSource::Stream</a>
    <li class='indexItem indexItem2'><a href='#DBD%3A%3AFile%3A%3ADataSource%3A%3AFile'>DBD::File::DataSource::File</a>
    <li class='indexItem indexItem2'><a href='#DBD%3A%3AFile%3A%3AStatement'>DBD::File::Statement</a>
    <li class='indexItem indexItem2'><a href='#DBD%3A%3AFile%3A%3ATable'>DBD::File::Table</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>DBD::File::Developers - Developers documentation for DBD::File</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    package DBD::myDriver;

    use base qw( DBD::File );

    sub driver
    {
        ...
        my $drh = $proto-&#62;SUPER::driver ($attr);
        ...
        return $drh-&#62;{class};
        }

    sub CLONE { ... }

    package DBD::myDriver::dr;

    @ISA = qw( DBD::File::dr );

    sub data_sources { ... }
    ...

    package DBD::myDriver::db;

    @ISA = qw( DBD::File::db );

    sub init_valid_attributes { ... }
    sub init_default_attributes { ... }
    sub set_versions { ... }
    sub validate_STORE_attr { my ($dbh, $attrib, $value) = @_; ... }
    sub validate_FETCH_attr { my ($dbh, $attrib) = @_; ... }
    sub get_myd_versions { ... }

    package DBD::myDriver::st;

    @ISA = qw( DBD::File::st );

    sub FETCH { ... }
    sub STORE { ... }

    package DBD::myDriver::Statement;

    @ISA = qw( DBD::File::Statement );

    package DBD::myDriver::Table;

    @ISA = qw( DBD::File::Table );

    my %reset_on_modify = (
        myd_abc =&#62; &#34;myd_foo&#34;,
        myd_mno =&#62; &#34;myd_bar&#34;,
        );
    __PACKAGE__-&#62;register_reset_on_modify (\%reset_on_modify);
    my %compat_map = (
        abc =&#62; &#39;foo_abc&#39;,
        xyz =&#62; &#39;foo_xyz&#39;,
        );
    __PACKAGE__-&#62;register_compat_map (\%compat_map);

    sub bootstrap_table_meta { ... }
    sub init_table_meta { ... }
    sub table_meta_attr_changed { ... }
    sub open_data { ... }

    sub fetch_row { ... }
    sub push_row { ... }
    sub push_names { ... }

    # optimize the SQL engine by add one or more of
    sub update_current_row { ... }
    # or
    sub update_specific_row { ... }
    # or
    sub update_one_row { ... }
    # or
    sub insert_new_row { ... }
    # or
    sub delete_current_row { ... }
    # or
    sub delete_one_row { ... }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This document describes how DBD developers can write DBD::File based DBI drivers. It supplements <a href="../../DBI/DBD.html" class="podlinkpod"
>DBI::DBD</a> and <a href="../../DBI/DBD/SqlEngine/Developers.html" class="podlinkpod"
>DBI::DBD::SqlEngine::Developers</a>, which you should read first.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CLASSES"
>CLASSES</a></h1>

<p>Each DBI driver must provide a package global <code>driver</code> method and three DBI related classes:</p>

<dl>
<dt><a name="DBD::File::dr"
>DBD::File::dr</a></dt>

<dd>
<p>Driver package, contains the methods DBI calls indirectly via DBI interface:</p>

<pre>  DBI-&#62;connect (&#39;DBI:DBM:&#39;, undef, undef, {})

  # invokes
  package DBD::DBM::dr;
  @DBD::DBM::dr::ISA = qw( DBD::File::dr );

  sub connect ($$;$$$)
  {
      ...
      }</pre>

<p>Similar for <code>data_sources</code> and <code>disconnect_all</code>.</p>

<p>Pure Perl DBI drivers derived from DBD::File do not usually need to override any of the methods provided through the DBD::XXX::dr package however if you need additional initialization in the connect method you may need to.</p>

<dt><a name="DBD::File::db"
>DBD::File::db</a></dt>

<dd>
<p>Contains the methods which are called through DBI database handles (<code>$dbh</code>). e.g.,</p>

<pre>  $sth = $dbh-&#62;prepare (&#34;select * from foo&#34;);
  # returns the f_encoding setting for table foo
  $dbh-&#62;csv_get_meta (&#34;foo&#34;, &#34;f_encoding&#34;);</pre>

<p>DBD::File provides the typical methods required here. Developers who write DBI drivers based on DBD::File need to override the methods <code>set_versions</code> and <code>init_valid_attributes</code>.</p>

<dt><a name="DBD::File::st"
>DBD::File::st</a></dt>

<dd>
<p>Contains the methods to deal with prepared statement handles. e.g.,</p>

<pre>  $sth-&#62;execute () or die $sth-&#62;errstr;</pre>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="DBD::File"
>DBD::File</a></h2>

<p>This is the main package containing the routines to initialize DBD::File based DBI drivers. Primarily the <code>DBD::File::driver</code> method is invoked, either directly from DBI when the driver is initialized or from the derived class.</p>

<pre>  package DBD::DBM;

  use base qw( DBD::File );

  sub driver
  {
      my ($class, $attr) = @_;
      ...
      my $drh = $class-&#62;SUPER::driver ($attr);
      ...
      return $drh;
      }</pre>

<p>It is not necessary to implement your own driver method as long as additional initialization (e.g. installing more private driver methods) is not required. You do not need to call <code>setup_driver</code> as DBD::File takes care of it.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="DBD::File::dr"
>DBD::File::dr</a></h2>

<p>The driver package contains the methods DBI calls indirectly via the DBI interface (see <a href="../../DBI.html#DBI_Class_Methods" class="podlinkpod"
>&#34;DBI Class Methods&#34; in DBI</a>).</p>

<p>DBD::File based DBI drivers usually do not need to implement anything here, it is enough to do the basic initialization:</p>

<pre>  package DBD:XXX::dr;

  @DBD::XXX::dr::ISA = qw (DBD::File::dr);
  $DBD::XXX::dr::imp_data_size     = 0;
  $DBD::XXX::dr::data_sources_attr = undef;
  $DBD::XXX::ATTRIBUTION = &#34;DBD::XXX $DBD::XXX::VERSION by Hans Mustermann&#34;;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="DBD::File::db"
>DBD::File::db</a></h2>

<p>This package defines the database methods, which are called via the DBI database handle <code>$dbh</code>.</p>

<p>Methods provided by DBD::File:</p>

<dl>
<dt><a name="ping"
>ping</a></dt>

<dd>
<p>Simply returns the content of the <code>Active</code> attribute. Override when your driver needs more complicated actions here.</p>

<dt><a name="prepare"
>prepare</a></dt>

<dd>
<p>Prepares a new SQL statement to execute. Returns a statement handle, <code>$sth</code> - instance of the DBD:XXX::st. It is neither required nor recommended to override this method.</p>

<dt><a name="FETCH"
>FETCH</a></dt>

<dd>
<p>Fetches an attribute of a DBI database object. Private handle attributes must have a prefix (this is mandatory). If a requested attribute is detected as a private attribute without a valid prefix, the driver prefix (written as <code>$drv_prefix</code>) is added.</p>

<p>The driver prefix is extracted from the attribute name and verified against <code>$dbh-&#62;{$drv_prefix . &#34;valid_attrs&#34;}</code> (when it exists). If the requested attribute value is not listed as a valid attribute, this method croaks. If the attribute is valid and readonly (listed in <code>$dbh-&#62;{ $drv_prefix . &#34;readonly_attrs&#34; }</code> when it exists), a real copy of the attribute value is returned. So it&#39;s not possible to modify <code>f_valid_attrs</code> from outside of DBD::File::db or a derived class.</p>

<dt><a name="STORE"
>STORE</a></dt>

<dd>
<p>Stores a database private attribute. Private handle attributes must have a prefix (this is mandatory). If a requested attribute is detected as a private attribute without a valid prefix, the driver prefix (written as <code>$drv_prefix</code>) is added. If the database handle has an attribute <code>${drv_prefix}_valid_attrs</code> - for attribute names which are not listed in that hash, this method croaks. If the database handle has an attribute <code>${drv_prefix}_readonly_attrs</code>, only attributes which are not listed there can be stored (once they are initialized). Trying to overwrite such an immutable attribute forces this method to croak.</p>

<p>An example of a valid attributes list can be found in <code>DBD::File::db::init_valid_attributes</code>.</p>

<dt><a name="set_versions"
>set_versions</a></dt>

<dd>
<p>This method sets the attribute <code>f_version</code> with the version of DBD::File.</p>

<p>This method is called at the begin of the <code>connect ()</code> phase.</p>

<p>When overriding this method, do not forget to invoke the superior one.</p>

<dt><a name="init_valid_attributes"
>init_valid_attributes</a></dt>

<dd>
<p>This method is called after the database handle is instantiated as the first attribute initialization.</p>

<p><code>DBD::File::db::init_valid_attributes</code> initializes the attributes <code>f_valid_attrs</code> and <code>f_readonly_attrs</code>.</p>

<p>When overriding this method, do not forget to invoke the superior one, preferably before doing anything else. Compatibility table attribute access must be initialized here to allow DBD::File to instantiate the map tie:</p>

<pre>    # for DBD::CSV
    $dbh-&#62;{csv_meta} = &#34;csv_tables&#34;;
    # for DBD::DBM
    $dbh-&#62;{dbm_meta} = &#34;dbm_tables&#34;;
    # for DBD::AnyData
    $dbh-&#62;{ad_meta}  = &#34;ad_tables&#34;;</pre>

<dt><a name="init_default_attributes"
>init_default_attributes</a></dt>

<dd>
<p>This method is called after the database handle is instantiated to initialize the default attributes.</p>

<p><code>DBD::File::db::init_default_attributes</code> initializes the attributes <code>f_dir</code>, <code>f_meta</code>, <code>f_meta_map</code>, <code>f_version</code>.</p>

<p>When the derived implementor class provides the attribute to validate attributes (e.g. <code>$dbh-&#62;{dbm_valid_attrs} = {...};</code>) or the attribute containing the immutable attributes (e.g. <code>$dbh-&#62;{dbm_readonly_attrs} = {...};</code>), the attributes <code>drv_valid_attrs</code>, <code>drv_readonly_attrs</code>, <code>drv_version</code> and <code>drv_meta</code> are added (when available) to the list of valid and immutable attributes (where <code>drv_</code> is interpreted as the driver prefix).</p>

<p>If <code>drv_meta</code> is set, an attribute with the name in <code>drv_meta</code> is initialized providing restricted read/write access to the meta data of the tables using <code>DBD::File::TieTables</code> in the first (table) level and <code>DBD::File::TieMeta</code> for the meta attribute level. <code>DBD::File::TieTables</code> uses <code>DBD::DRV::Table::get_table_meta</code> to initialize the second level tied hash on FETCH/STORE. The <code>DBD::File::TieMeta</code> class uses <code>DBD::DRV::Table::get_table_meta_attr</code> to FETCH attribute values and <code>DBD::DRV::Table::set_table_meta_attr</code> to STORE attribute values. This allows it to map meta attributes for compatibility reasons.</p>

<dt><a name="get_single_table_meta"
>get_single_table_meta</a></dt>

<dd>
<dt><a name="get_file_meta"
>get_file_meta</a></dt>

<dd>
<p>Retrieve an attribute from a table&#39;s meta information. The method signature is <code>get_file_meta ($dbh, $table, $attr)</code>. This method is called by the injected db handle method <code>${drv_prefix}get_meta</code>.</p>

<p>While get_file_meta allows <code>$table</code> or <code>$attr</code> to be a list of tables or attributes to retrieve, get_single_table_meta allows only one table name and only one attribute name. A table name of <code>&#39;.&#39;</code> (single dot) is interpreted as the default table and this will retrieve the appropriate attribute globally from the dbh. This has the same restrictions as <code>$dbh-&#62;{$attrib}</code>.</p>

<p>get_file_meta allows <code>&#39;+&#39;</code> and <code>&#39;*&#39;</code> as wildcards for table names and <code>$table</code> being a regular expression matching against the table names (evaluated without the default table). The table name <code>&#39;*&#39;</code> is <i>all currently known tables, including the default one</i>. The table name <code>&#39;+&#39;</code> is <i>all table names which conform to ANSI file name restrictions</i> (/^[_A-Za-z0-9]+$/).</p>

<p>The table meta information is retrieved using the get_table_meta and get_table_meta_attr methods of the table class of the implementation.</p>

<dt><a name="set_single_table_meta"
>set_single_table_meta</a></dt>

<dd>
<dt><a name="set_file_meta"
>set_file_meta</a></dt>

<dd>
<p>Sets an attribute in a table&#39;s meta information. The method signature is <code>set_file_meta ($dbh, $table, $attr, $value)</code>. This method is called by the injected db handle method <code>${drv_prefix}set_meta</code>.</p>

<p>While set_file_meta allows <code>$table</code> to be a list of tables and <code>$attr</code> to be a hash of several attributes to set, set_single_table_meta allows only one table name and only one attribute name/value pair.</p>

<p>The wildcard characters for the table name are the same as for get_file_meta.</p>

<p>The table meta information is updated using the get_table_meta and set_table_meta_attr methods of the table class of the implementation.</p>

<dt><a name="clear_file_meta"
>clear_file_meta</a></dt>

<dd>
<p>Clears all meta information cached about a table. The method signature is <code>clear_file_meta ($dbh, $table)</code>. This method is called by the injected db handle method <code>${drv_prefix}clear_meta</code>.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="DBD::File::st"
>DBD::File::st</a></h2>

<p>Contains the methods to deal with prepared statement handles:</p>

<dl>
<dt><a name="FETCH"
>FETCH</a></dt>

<dd>
<p>Fetches statement handle attributes. Supported attributes (for full overview see <a href="../../DBI.html#Statement_Handle_Attributes" class="podlinkpod"
>&#34;Statement Handle Attributes&#34; in DBI</a>) are <code>NAME</code>, <code>TYPE</code>, <code>PRECISION</code> and <code>NULLABLE</code> in case that SQL::Statement is used as SQL execution engine and a statement is successful prepared. When SQL::Statement has additional information about a table, those information are returned. Otherwise, the same defaults as in <a href="../../DBI/DBD/SqlEngine.html" class="podlinkpod"
>DBI::DBD::SqlEngine</a> are used.</p>

<p>This method usually requires extending in a derived implementation. See <a href="../../DBD/CSV.html" class="podlinkpod"
>DBD::CSV</a> or <a href="../../DBD/DBM.html" class="podlinkpod"
>DBD::DBM</a> for some example.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="DBD::File::TableSource::FileSystem"
>DBD::File::TableSource::FileSystem</a></h2>

<p>Provides data sources and table information on database driver and database handle level.</p>

<pre>  package DBD::File::TableSource::FileSystem;

  sub data_sources ($;$)
  {
      my ($class, $drh, $attrs) = @_;
      ...
      }

  sub avail_tables
  {
      my ($class, $drh) = @_;
      ...
      }</pre>

<p>The <code>data_sources</code> method is called when the user invokes any of the following:</p>

<pre>  @ary = DBI-&#62;data_sources ($driver);
  @ary = DBI-&#62;data_sources ($driver, \%attr);
  
  @ary = $dbh-&#62;data_sources ();
  @ary = $dbh-&#62;data_sources (\%attr);</pre>

<p>The <code>avail_tables</code> method is called when the user invokes any of the following:</p>

<pre>  @names = $dbh-&#62;tables ($catalog, $schema, $table, $type);
  
  $sth   = $dbh-&#62;table_info ($catalog, $schema, $table, $type);
  $sth   = $dbh-&#62;table_info ($catalog, $schema, $table, $type, \%attr);

  $dbh-&#62;func (&#34;list_tables&#34;);</pre>

<p>Every time where an <code>\%attr</code> argument can be specified, this <code>\%attr</code> object&#39;s <code>sql_table_source</code> attribute is preferred over the <code>$dbh</code> attribute or the driver default.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="DBD::File::DataSource::Stream"
>DBD::File::DataSource::Stream</a></h2>

<pre>  package DBD::File::DataSource::Stream;

  @DBD::File::DataSource::Stream::ISA = &#39;DBI::DBD::SqlEngine::DataSource&#39;;

  sub complete_table_name
  {
      my ($self, $meta, $file, $respect_case) = @_;
      ...
      }</pre>

<p>Clears all meta attributes identifying a file: <code>f_fqfn</code>, <code>f_fqbn</code> and <code>f_fqln</code>. The table name is set according to <code>$respect_case</code> and <code>$meta-&#62;{sql_identifier_case}</code> (SQL_IC_LOWER, SQL_IC_UPPER).</p>

<pre>  package DBD::File::DataSource::Stream;

  sub apply_encoding
  {
      my ($self, $meta, $fn) = @_;
      ...
      }</pre>

<p>Applies the encoding from <i>meta information</i> (<code>$meta-&#62;{f_encoding}</code>) to the file handled opened in <code>open_data</code>.</p>

<pre>  package DBD::File::DataSource::Stream;

  sub open_data
  {
      my ($self, $meta, $attrs, $flags) = @_;
      ...
      }</pre>

<p>Opens (<code>dup (2)</code>) the file handle provided in <code>$meta-&#62;{f_file}</code>.</p>

<pre>  package DBD::File::DataSource::Stream;

  sub can_flock { ... }</pre>

<p>Returns whether <code>flock (2)</code> is available or not (avoids retesting in subclasses).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="DBD::File::DataSource::File"
>DBD::File::DataSource::File</a></h2>

<pre>  package DBD::File::DataSource::File;

  sub complete_table_name ($$;$)
  {
      my ($self, $meta, $table, $respect_case) = @_;
      ...
      }</pre>

<p>The method <code>complete_table_name</code> tries to map a filename to the associated table name. It is called with a partially filled meta structure for the resulting table containing at least the following attributes: <code>f_ext</code>, <code>f_dir</code>, <code>f_lockfile</code> and <code>sql_identifier_case</code>.</p>

<p>If a file/table map can be found then this method sets the <code>f_fqfn</code>, <code>f_fqbn</code>, <code>f_fqln</code> and <code>table_name</code> attributes in the meta structure. If a map cannot be found the table name will be undef.</p>

<pre>  package DBD::File::DataSource::File;

  sub open_data ($)
  {
      my ($self, $meta, $attrs, $flags) = @_;
      ...
      }</pre>

<p>Depending on the attributes set in the table&#39;s meta data, the following steps are performed. Unless <code>f_dontopen</code> is set to a true value, <code>f_fqfn</code> must contain the full qualified file name for the table to work on (file2table ensures this). The encoding in <code>f_encoding</code> is applied if set and the file is opened. If <code>&#60;f_fqln </code>&#62; (full qualified lock name) is set, this file is opened, too. Depending on the value in <code>f_lock</code>, the appropriate lock is set on the opened data file or lock file.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="DBD::File::Statement"
>DBD::File::Statement</a></h2>

<p>Derives from DBI::SQL::Nano::Statement to provide following method:</p>

<dl>
<dt><a name="open_table"
>open_table</a></dt>

<dd>
<p>Implements the open_table method required by <a href="../../SQL/Statement.html" class="podlinkpod"
>SQL::Statement</a> and <a href="../../DBI/SQL/Nano.html" class="podlinkpod"
>DBI::SQL::Nano</a>. All the work for opening the file(s) belonging to the table is handled and parametrized in DBD::File::Table. Unless you intend to add anything to the following implementation, an empty DBD::XXX::Statement package satisfies DBD::File.</p>

<pre>  sub open_table ($$$$$)
  {
      my ($self, $data, $table, $createMode, $lockMode) = @_;

      my $class = ref $self;
      $class =~ s/::Statement/::Table/;

      my $flags = {
          createMode =&#62; $createMode,
          lockMode   =&#62; $lockMode,
          };
      $self-&#62;{command} eq &#34;DROP&#34; and $flags-&#62;{dropMode} = 1;

      return $class-&#62;new ($data, { table =&#62; $table }, $flags);
      } # open_table</pre>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="DBD::File::Table"
>DBD::File::Table</a></h2>

<p>Derives from DBI::SQL::Nano::Table and provides physical file access for the table data which are stored in the files.</p>

<dl>
<dt><a name="bootstrap_table_meta"
>bootstrap_table_meta</a></dt>

<dd>
<p>Initializes a table meta structure. Can be safely overridden in a derived class, as long as the <code>SUPER</code> method is called at the end of the overridden method.</p>

<p>It copies the following attributes from the database into the table meta data <code>f_dir</code>, <code>f_ext</code>, <code>f_encoding</code>, <code>f_lock</code>, <code>f_schema</code> and <code>f_lockfile</code> and makes them sticky to the table.</p>

<p>This method should be called before you attempt to map between file name and table name to ensure the correct directory, extension etc. are used.</p>

<dt><a name="init_table_meta"
>init_table_meta</a></dt>

<dd>
<p>Initializes more attributes of the table meta data - usually more expensive ones (e.g. those which require class instantiations) - when the file name and the table name could mapped.</p>

<dt><a name="get_table_meta"
>get_table_meta</a></dt>

<dd>
<p>Returns the table meta data. If there are none for the required table, a new one is initialized. When it fails, nothing is returned. On success, the name of the table and the meta data structure is returned.</p>

<dt><a name="get_table_meta_attr"
>get_table_meta_attr</a></dt>

<dd>
<p>Returns a single attribute from the table meta data. If the attribute name appears in <code>%compat_map</code>, the attribute name is updated from there.</p>

<dt><a name="set_table_meta_attr"
>set_table_meta_attr</a></dt>

<dd>
<p>Sets a single attribute in the table meta data. If the attribute name appears in <code>%compat_map</code>, the attribute name is updated from there.</p>

<dt><a name="table_meta_attr_changed"
>table_meta_attr_changed</a></dt>

<dd>
<p>Called when an attribute of the meta data is modified.</p>

<p>If the modified attribute requires to reset a calculated attribute, the calculated attribute is reset (deleted from meta data structure) and the <i>initialized</i> flag is removed, too. The decision is made based on <code>%register_reset_on_modify</code>.</p>

<dt><a name="register_reset_on_modify"
>register_reset_on_modify</a></dt>

<dd>
<p>Allows <code>set_table_meta_attr</code> to reset meta attributes when special attributes are modified. For DBD::File, modifying one of <code>f_file</code>, <code>f_dir</code>, <code>f_ext</code> or <code>f_lockfile</code> will reset <code>f_fqfn</code>. DBD::DBM extends the list for <code>dbm_type</code> and <code>dbm_mldbm</code> to reset the value of <code>dbm_tietype</code>.</p>

<p>If your DBD has calculated values in the meta data area, then call <code>register_reset_on_modify</code>:</p>

<pre>  my %reset_on_modify = (xxx_foo =&#62; &#34;xxx_bar&#34;);
  __PACKAGE__-&#62;register_reset_on_modify (\%reset_on_modify);</pre>

<dt><a name="register_compat_map"
>register_compat_map</a></dt>

<dd>
<p>Allows <code>get_table_meta_attr</code> and <code>set_table_meta_attr</code> to update the attribute name to the current favored one:</p>

<pre>  # from DBD::DBM
  my %compat_map = (dbm_ext =&#62; &#34;f_ext&#34;);
  __PACKAGE__-&#62;register_compat_map (\%compat_map);</pre>

<dt><a name="open_file"
>open_file</a></dt>

<dd>
<p>Called to open the table&#39;s data file.</p>

<p>Depending on the attributes set in the table&#39;s meta data, the following steps are performed. Unless <code>f_dontopen</code> is set to a true value, <code>f_fqfn</code> must contain the full qualified file name for the table to work on (file2table ensures this). The encoding in <code>f_encoding</code> is applied if set and the file is opened. If <code>&#60;f_fqln </code>&#62; (full qualified lock name) is set, this file is opened, too. Depending on the value in <code>f_lock</code>, the appropriate lock is set on the opened data file or lock file.</p>

<p>After this is done, a derived class might add more steps in an overridden <code>open_file</code> method.</p>

<dt><a name="new"
>new</a></dt>

<dd>
<p>Instantiates the table. This is done in 3 steps:</p>

<pre> 1. get the table meta data
 2. open the data file
 3. bless the table data structure using inherited constructor new</pre>

<p>It is not recommended to override the constructor of the table class. Find a reasonable place to add you extensions in one of the above four methods.</p>

<dt><a name="drop"
>drop</a></dt>

<dd>
<p>Implements the abstract table method for the <code>DROP</code> command. Discards table meta data after all files belonging to the table are closed and unlinked.</p>

<p>Overriding this method might be reasonable in very rare cases.</p>

<dt><a name="seek"
>seek</a></dt>

<dd>
<p>Implements the abstract table method used when accessing the table from the engine. <code>seek</code> is called every time the engine uses dumb algorithms for iterating over the table content.</p>

<dt><a name="truncate"
>truncate</a></dt>

<dd>
<p>Implements the abstract table method used when dumb table algorithms for <code>UPDATE</code> or <code>DELETE</code> need to truncate the table storage after the last written row.</p>
</dd>
</dl>

<p>You should consult the documentation of <code>SQL::Eval::Table</code> (see <a href="../../SQL/Eval.html" class="podlinkpod"
>SQL::Eval</a>) to get more information about the abstract methods of the table&#39;s base class you have to override and a description of the table meta information expected by the SQL engines.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>The module DBD::File is currently maintained by</p>

<p>H.Merijn Brand &#60; h.m.brand at xs4all.nl &#62; and Jens Rehsack &#60; rehsack at googlemail.com &#62;</p>

<p>The original author is Jochen Wiedmann.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>Copyright (C) 2010-2013 by H.Merijn Brand &#38; Jens Rehsack</p>

<p>All rights reserved.</p>

<p>You may freely distribute and/or modify this module under the terms of either the GNU General Public License (GPL) or the Artistic License, as specified in the Perl README file.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
