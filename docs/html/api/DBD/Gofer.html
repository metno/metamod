<html><head><title>DBD::Gofer</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:14 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Use_Cases'>Use Cases</a>
    <li class='indexItem indexItem2'><a href='#Advantages'>Advantages</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Connection_Pooling_and_Throttling'>Connection Pooling and Throttling</a>
      <li class='indexItem indexItem3'><a href='#Simple_Scaling'>Simple Scaling</a>
      <li class='indexItem indexItem3'><a href='#Caching'>Caching</a>
      <li class='indexItem indexItem3'><a href='#Fewer_Network_Round-trips'>Fewer Network Round-trips</a>
      <li class='indexItem indexItem3'><a href='#Thin_Clients_%2F_Unsupported_Platforms'>Thin Clients / Unsupported Platforms</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#CONSTRAINTS'>CONSTRAINTS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#You_can%27t_change_database_handle_attributes_after_connect()'>You can&#39;t change database handle attributes after connect()</a>
    <li class='indexItem indexItem2'><a href='#You_can%27t_change_statement_handle_attributes_after_prepare()'>You can&#39;t change statement handle attributes after prepare()</a>
    <li class='indexItem indexItem2'><a href='#You_can%27t_use_transactions'>You can&#39;t use transactions</a>
    <li class='indexItem indexItem2'><a href='#You_can%27t_call_driver-private_sth_methods'>You can&#39;t call driver-private sth methods</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#GENERAL_CAVEATS'>GENERAL CAVEATS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Temporary_tables%2C_locks%2C_and_other_per-connection_persistent_state'>Temporary tables, locks, and other per-connection persistent state</a>
    <li class='indexItem indexItem2'><a href='#Driver-private_Database_Handle_Attributes'>Driver-private Database Handle Attributes</a>
    <li class='indexItem indexItem2'><a href='#Driver-private_Statement_Handle_Attributes'>Driver-private Statement Handle Attributes</a>
    <li class='indexItem indexItem2'><a href='#Multiple_Resultsets'>Multiple Resultsets</a>
    <li class='indexItem indexItem2'><a href='#Statement_activity_that_also_updates_dbh_attributes'>Statement activity that also updates dbh attributes</a>
    <li class='indexItem indexItem2'><a href='#Methods_that_report_an_error_always_return_undef'>Methods that report an error always return undef</a>
    <li class='indexItem indexItem2'><a href='#Subclassing_only_applies_to_client-side'>Subclassing only applies to client-side</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#CAVEATS_FOR_SPECIFIC_METHODS'>CAVEATS FOR SPECIFIC METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#last_insert_id'>last_insert_id</a>
    <li class='indexItem indexItem2'><a href='#execute_for_fetch'>execute_for_fetch</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#TRANSPORTS'>TRANSPORTS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Bundled_Transports'>Bundled Transports</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#null'>null</a>
      <li class='indexItem indexItem3'><a href='#pipeone'>pipeone</a>
      <li class='indexItem indexItem3'><a href='#stream'>stream</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Other_Transports'>Other Transports</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#http'>http</a>
      <li class='indexItem indexItem3'><a href='#Gearman'>Gearman</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#CONNECTING'>CONNECTING</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Using_DBI_AUTOPROXY'>Using DBI_AUTOPROXY</a>
    <li class='indexItem indexItem2'><a href='#Connection_Attributes'>Connection Attributes</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#transport'>transport</a>
      <li class='indexItem indexItem3'><a href='#dsn'>dsn</a>
      <li class='indexItem indexItem3'><a href='#url'>url</a>
      <li class='indexItem indexItem3'><a href='#policy'>policy</a>
      <li class='indexItem indexItem3'><a href='#timeout'>timeout</a>
      <li class='indexItem indexItem3'><a href='#retry_limit'>retry_limit</a>
      <li class='indexItem indexItem3'><a href='#retry_hook'>retry_hook</a>
      <li class='indexItem indexItem3'><a href='#cache'>cache</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#CONFIGURING_BEHAVIOUR_POLICY'>CONFIGURING BEHAVIOUR POLICY</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#LICENCE_AND_COPYRIGHT'>LICENCE AND COPYRIGHT</a>
  <li class='indexItem indexItem1'><a href='#ACKNOWLEDGEMENTS'>ACKNOWLEDGEMENTS</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#Caveats_for_specific_drivers'>Caveats for specific drivers</a>
  <li class='indexItem indexItem1'><a href='#TODO'>TODO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>DBD::Gofer - A stateless-proxy driver for communicating with a remote DBI</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use DBI;

  $original_dsn = &#34;dbi:...&#34;; # your original DBI Data Source Name

  $dbh = DBI-&#62;connect(&#34;dbi:Gofer:transport=$transport;...;dsn=$original_dsn&#34;,
                      $user, $passwd, \%attributes);

  ... use $dbh as if it was connected to $original_dsn ...</pre>

<p>The <code>transport=$transport</code> part specifies the name of the module to use to transport the requests to the remote DBI. If $transport doesn&#39;t contain any double colons then it&#39;s prefixed with <code>DBD::Gofer::Transport::</code>.</p>

<p>The <code>dsn=$original_dsn</code> part <i>must be the last element</i> of the DSN because everything after <code>dsn=</code> is assumed to be the DSN that the remote DBI should use.</p>

<p>The <code>...</code> represents attributes that influence the operation of the Gofer driver or transport. These are described below or in the documentation of the transport module being used.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>DBD::Gofer is a DBI database driver that forwards requests to another DBI driver, usually in a separate process, often on a separate machine. It tries to be as transparent as possible so it appears that you are using the remote driver directly.</p>

<p>DBD::Gofer is very similar to DBD::Proxy. The major difference is that with DBD::Gofer no state is maintained on the remote end. That means every request contains all the information needed to create the required state. (So, for example, every request includes the DSN to connect to.) Each request can be sent to any available server. The server executes the request and returns a single response that includes all the data.</p>

<p>This is very similar to the way http works as a stateless protocol for the web. Each request from your web browser can be handled by a different web server process.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Use_Cases"
>Use Cases</a></h2>

<p>This may seem like pointless overhead but there are situations where this is a very good thing. Let&#39;s consider a specific case.</p>

<p>Imagine using DBD::Gofer with an http transport. Your application calls connect(), prepare(&#34;select * from table where foo=?&#34;), bind_param(), and execute(). At this point DBD::Gofer builds a request containing all the information about the method calls. It then uses the httpd transport to send that request to an apache web server.</p>

<p>This &#39;dbi execute&#39; web server executes the request (using DBI::Gofer::Execute and related modules) and builds a response that contains all the rows of data, if the statement returned any, along with all the attributes that describe the results, such as $sth-&#62;{NAME}. This response is sent back to DBD::Gofer which unpacks it and presents it to the application as if it had executed the statement itself.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Advantages"
>Advantages</a></h2>

<p>Okay, but you still don&#39;t see the point? Well let&#39;s consider what we&#39;ve gained:</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Connection_Pooling_and_Throttling"
>Connection Pooling and Throttling</a></h3>

<p>The &#39;dbi execute&#39; web server leverages all the functionality of web infrastructure in terms of load balancing, high-availability, firewalls, access management, proxying, caching.</p>

<p>At its most basic level you get a configurable pool of persistent database connections.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Simple_Scaling"
>Simple Scaling</a></h3>

<p>Got thousands of processes all trying to connect to the database? You can use DBD::Gofer to connect them to your smaller pool of &#39;dbi execute&#39; web servers instead.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Caching"
>Caching</a></h3>

<p>Client-side caching is as simple as adding &#34;<code>cache=1</code>&#34; to the DSN. This feature alone can be worth using DBD::Gofer for.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Fewer_Network_Round-trips"
>Fewer Network Round-trips</a></h3>

<p>DBD::Gofer sends as few requests as possible (dependent on the policy being used).</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Thin_Clients_/_Unsupported_Platforms"
>Thin Clients / Unsupported Platforms</a></h3>

<p>You no longer need drivers for your database on every system. DBD::Gofer is pure perl.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CONSTRAINTS"
>CONSTRAINTS</a></h1>

<p>There are some natural constraints imposed by the DBD::Gofer &#39;stateless&#39; approach. But not many:</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="You_can&#39;t_change_database_handle_attributes_after_connect()"
>You can&#39;t change database handle attributes after connect()</a></h2>

<p>You can&#39;t change database handle attributes after you&#39;ve connected. Use the connect() call to specify all the attribute settings you want.</p>

<p>This is because it&#39;s critical that when a request is complete the database handle is left in the same state it was when first connected.</p>

<p>An exception is made for attributes with names starting &#34;<code>private_</code>&#34;: They can be set after connect() but the change is only applied locally.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="You_can&#39;t_change_statement_handle_attributes_after_prepare()"
>You can&#39;t change statement handle attributes after prepare()</a></h2>

<p>You can&#39;t change statement handle attributes after prepare.</p>

<p>An exception is made for attributes with names starting &#34;<code>private_</code>&#34;: They can be set after prepare() but the change is only applied locally.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="You_can&#39;t_use_transactions"
>You can&#39;t use transactions</a></h2>

<p>AutoCommit only. Transactions aren&#39;t supported.</p>

<p>(In theory transactions could be supported when using a transport that maintains a connection, like <code>stream</code> does. If you&#39;re interested in this please get in touch via dbi-dev@perl.org)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="You_can&#39;t_call_driver-private_sth_methods"
>You can&#39;t call driver-private sth methods</a></h2>

<p>But that&#39;s rarely needed anyway.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="GENERAL_CAVEATS"
>GENERAL CAVEATS</a></h1>

<p>A few important things to keep in mind when using DBD::Gofer:</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Temporary_tables,_locks,_and_other_per-connection_persistent_state"
>Temporary tables, locks, and other per-connection persistent state</a></h2>

<p>You shouldn&#39;t expect any per-session state to persist between requests. This includes locks and temporary tables.</p>

<p>Because the server-side may execute your requests via a different database connections, you can&#39;t rely on any per-connection persistent state, such as temporary tables, being available from one request to the next.</p>

<p>This is an easy trap to fall into. A good way to check for this is to test your code with a Gofer policy package that sets the <code>connect_method</code> policy to &#39;connect&#39; to force a new connection for each request. The <code>pedantic</code> policy does this.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Driver-private_Database_Handle_Attributes"
>Driver-private Database Handle Attributes</a></h2>

<p>Some driver-private dbh attributes may not be available if the driver has not implemented the private_attribute_info() method (added in DBI 1.54).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Driver-private_Statement_Handle_Attributes"
>Driver-private Statement Handle Attributes</a></h2>

<p>Driver-private sth attributes can be set in the prepare() call. TODO</p>

<p>Some driver-private sth attributes may not be available if the driver has not implemented the private_attribute_info() method (added in DBI 1.54).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Multiple_Resultsets"
>Multiple Resultsets</a></h2>

<p>Multiple resultsets are supported only if the driver supports the more_results() method (an exception is made for DBD::Sybase).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Statement_activity_that_also_updates_dbh_attributes"
>Statement activity that also updates dbh attributes</a></h2>

<p>Some drivers may update one or more dbh attributes after performing activity on a child sth. For example, DBD::mysql provides $dbh-&#62;{mysql_insertid} in addition to $sth-&#62;{mysql_insertid}. Currently mysql_insertid is supported via a hack but a more general mechanism is needed for other drivers to use.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Methods_that_report_an_error_always_return_undef"
>Methods that report an error always return undef</a></h2>

<p>With DBD::Gofer, a method that sets an error always return an undef or empty list. That shouldn&#39;t be a problem in practice because the DBI doesn&#39;t define any methods that return meaningful values while also reporting an error.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Subclassing_only_applies_to_client-side"
>Subclassing only applies to client-side</a></h2>

<p>The RootClass and DbTypeSubclass attributes are not passed to the Gofer server.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CAVEATS_FOR_SPECIFIC_METHODS"
>CAVEATS FOR SPECIFIC METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="last_insert_id"
>last_insert_id</a></h2>

<p>To enable use of last_insert_id you need to indicate to DBD::Gofer that you&#39;d like to use it. You do that my adding a <code>go_last_insert_id_args</code> attribute to the do() or prepare() method calls. For example:</p>

<pre>    $dbh-&#62;do($sql, { go_last_insert_id_args =&#62; [...] });</pre>

<p>or</p>

<pre>    $sth = $dbh-&#62;prepare($sql, { go_last_insert_id_args =&#62; [...] });</pre>

<p>The array reference should contains the args that you want passed to the last_insert_id() method.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="execute_for_fetch"
>execute_for_fetch</a></h2>

<p>The array methods bind_param_array() and execute_array() are supported. When execute_array() is called the data is serialized and executed in a single round-trip to the Gofer server. This makes it very fast, but requires enough memory to store all the serialized data.</p>

<p>The execute_for_fetch() method currently isn&#39;t optimised, it uses the DBI fallback behaviour of executing each tuple individually. (It could be implemented as a wrapper for execute_array() - patches welcome.)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TRANSPORTS"
>TRANSPORTS</a></h1>

<p>DBD::Gofer doesn&#39;t concern itself with transporting requests and responses to and fro. For that it uses special Gofer transport modules.</p>

<p>Gofer transport modules usually come in pairs: one for the &#39;client&#39; DBD::Gofer driver to use and one for the remote &#39;server&#39; end. They have very similar names:</p>

<pre>    DBD::Gofer::Transport::&#60;foo&#62;
    DBI::Gofer::Transport::&#60;foo&#62;</pre>

<p>Sometimes the transports on the DBD and DBI sides may have different names. For example DBD::Gofer::Transport::http is typically used with DBI::Gofer::Transport::mod_perl (DBD::Gofer::Transport::http and DBI::Gofer::Transport::mod_perl modules are part of the GoferTransport-http distribution).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Bundled_Transports"
>Bundled Transports</a></h2>

<p>Several transport modules are provided with DBD::Gofer:</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="null"
>null</a></h3>

<p>The null transport is the simplest of them all. It doesn&#39;t actually transport the request anywhere. It just serializes (freezes) the request into a string, then thaws it back into a data structure before passing it to DBI::Gofer::Execute to execute. The same freeze and thaw is applied to the results.</p>

<p>The null transport is the best way to test if your application will work with Gofer. Just set the DBI_AUTOPROXY environment variable to &#34;<code>dbi:Gofer:transport=null;policy=pedantic</code>&#34; (see <a href="#Using_DBI_AUTOPROXY" class="podlinkpod"
>&#34;Using DBI_AUTOPROXY&#34;</a> below) and run your application, or ideally its test suite, as usual.</p>

<p>It doesn&#39;t take any parameters.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="pipeone"
>pipeone</a></h3>

<p>The pipeone transport launches a subprocess for each request. It passes in the request and reads the response.</p>

<p>The fact that a new subprocess is started for each request ensures that the server side is truly stateless. While this does make the transport <i>very</i> slow, it is useful as a way to test that your application doesn&#39;t depend on per-connection state, such as temporary tables, persisting between requests.</p>

<p>It&#39;s also useful both as a proof of concept and as a base class for the stream driver.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="stream"
>stream</a></h3>

<p>The stream driver also launches a subprocess and writes requests and reads responses, like the pipeone transport. In this case, however, the subprocess is expected to handle more that one request. (Though it will be automatically restarted if it exits.)</p>

<p>This is the first transport that is truly useful because it can launch the subprocess on a remote machine using <code>ssh</code>. This means you can now use DBD::Gofer to easily access any databases that&#39;s accessible from any system you can login to. You also get all the benefits of ssh, including encryption and optional compression.</p>

<p>See <a href="#Using_DBI_AUTOPROXY" class="podlinkpod"
>&#34;Using DBI_AUTOPROXY&#34;</a> below for an example.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Other_Transports"
>Other Transports</a></h2>

<p>Implementing a Gofer transport is <i>very</i> simple, and more transports are very welcome. Just take a look at any existing transports that are similar to your needs.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="http"
>http</a></h3>

<p>See the GoferTransport-http distribution on CPAN: http://search.cpan.org/dist/GoferTransport-http/</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Gearman"
>Gearman</a></h3>

<p>I know Ask Bj&#248;rn Hansen has implemented a transport for the <code>gearman</code> distributed job system, though it&#39;s not on CPAN at the time of writing this.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CONNECTING"
>CONNECTING</a></h1>

<p>Simply prefix your existing DSN with &#34;<code>dbi:Gofer:transport=$transport;dsn=</code>&#34; where $transport is the name of the Gofer transport you want to use (see <a href="#TRANSPORTS" class="podlinkpod"
>&#34;TRANSPORTS&#34;</a>). The <code>transport</code> and <code>dsn</code> attributes must be specified and the <code>dsn</code> attributes must be last.</p>

<p>Other attributes can be specified in the DSN to configure DBD::Gofer and/or the Gofer transport module being used. The main attributes after <code>transport</code>, are <code>url</code> and <code>policy</code>. These and other attributes are described below.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Using_DBI_AUTOPROXY"
>Using DBI_AUTOPROXY</a></h2>

<p>The simplest way to try out DBD::Gofer is to set the DBI_AUTOPROXY environment variable. In this case you don&#39;t include the <code>dsn=</code> part. For example:</p>

<pre>    export DBI_AUTOPROXY=&#34;dbi:Gofer:transport=null&#34;</pre>

<p>or, for a more useful example, try:</p>

<pre>    export DBI_AUTOPROXY=&#34;dbi:Gofer:transport=stream;url=ssh:user@example.com&#34;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Connection_Attributes"
>Connection Attributes</a></h2>

<p>These attributes can be specified in the DSN. They can also be passed in the \%attr parameter of the DBI connect method by adding a &#34;<code>go_</code>&#34; prefix to the name.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="transport"
>transport</a></h3>

<p>Specifies the Gofer transport class to use. Required. See <a href="#TRANSPORTS" class="podlinkpod"
>&#34;TRANSPORTS&#34;</a> above.</p>

<p>If the value does not include <code>::</code> then &#34;<code>DBD::Gofer::Transport::</code>&#34; is prefixed.</p>

<p>The transport object can be accessed via $h-&#62;{go_transport}.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="dsn"
>dsn</a></h3>

<p>Specifies the DSN for the remote side to connect to. Required, and must be last.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="url"
>url</a></h3>

<p>Used to tell the transport where to connect to. The exact form of the value depends on the transport used.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="policy"
>policy</a></h3>

<p>Specifies the policy to use. See <a href="#CONFIGURING_BEHAVIOUR_POLICY" class="podlinkpod"
>&#34;CONFIGURING BEHAVIOUR POLICY&#34;</a>.</p>

<p>If the value does not include <code>::</code> then &#34;<code>DBD::Gofer::Policy</code>&#34; is prefixed.</p>

<p>The policy object can be accessed via $h-&#62;{go_policy}.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="timeout"
>timeout</a></h3>

<p>Specifies a timeout, in seconds, to use when waiting for responses from the server side.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="retry_limit"
>retry_limit</a></h3>

<p>Specifies the number of times a failed request will be retried. Default is 0.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="retry_hook"
>retry_hook</a></h3>

<p>Specifies a code reference to be called to decide if a failed request should be retried. The code reference is called like this:</p>

<pre>  $transport = $h-&#62;{go_transport};
  $retry = $transport-&#62;go_retry_hook-&#62;($request, $response, $transport);</pre>

<p>If it returns true then the request will be retried, upto the <code>retry_limit</code>. If it returns a false but defined value then the request will not be retried. If it returns undef then the default behaviour will be used, as if <code>retry_hook</code> had not been specified.</p>

<p>The default behaviour is to retry requests where $request-&#62;is_idempotent is true, or the error message matches <code>/induced by DBI_GOFER_RANDOM/</code>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="cache"
>cache</a></h3>

<p>Specifies that client-side caching should be performed. The value is the name of a cache class to use.</p>

<p>Any class implementing get($key) and set($key, $value) methods can be used. That includes a great many powerful caching classes on CPAN, including the Cache and Cache::Cache distributions.</p>

<p>You can use &#34;<code>cache=1</code>&#34; is a shortcut for &#34;<code>cache=DBI::Util::CacheMemory</code>&#34;. See <a href="../DBI/Util/CacheMemory.html" class="podlinkpod"
>DBI::Util::CacheMemory</a> for a description of this simple fast default cache.</p>

<p>The cache object can be accessed via $h-&#62;go_cache. For example:</p>

<pre>    $dbh-&#62;go_cache-&#62;clear; # free up memory being used by the cache</pre>

<p>The cache keys are the frozen (serialized) requests, and the values are the frozen responses.</p>

<p>The default behaviour is to only use the cache for requests where $request-&#62;is_idempotent is true (i.e., the dbh has the ReadOnly attribute set or the SQL statement is obviously a SELECT without a FOR UPDATE clause.)</p>

<p>For even more control you can use the <code>go_cache</code> attribute to pass in an instantiated cache object. Individual methods, including prepare(), can also specify alternative caches via the <code>go_cache</code> attribute. For example, to specify no caching for a particular query, you could use</p>

<pre>    $sth = $dbh-&#62;prepare( $sql, { go_cache =&#62; 0 } );</pre>

<p>This can be used to implement different caching policies for different statements.</p>

<p>It&#39;s interesting to note that DBD::Gofer can be used to add client-side caching to any (gofer compatible) application, with no code changes and no need for a gofer server. Just set the DBI_AUTOPROXY environment variable like this:</p>

<pre>    DBI_AUTOPROXY=&#39;dbi:Gofer:transport=null;cache=1&#39;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CONFIGURING_BEHAVIOUR_POLICY"
>CONFIGURING BEHAVIOUR POLICY</a></h1>

<p>DBD::Gofer supports a &#39;policy&#39; mechanism that allows you to fine-tune the number of round-trips to the Gofer server. The policies are grouped into classes (which may be subclassed) and referenced by the name of the class.</p>

<p>The <a href="../DBD/Gofer/Policy/Base.html" class="podlinkpod"
>DBD::Gofer::Policy::Base</a> class is the base class for all the policy packages and describes all the available policies.</p>

<p>Three policy packages are supplied with DBD::Gofer:</p>

<p><a href="../DBD/Gofer/Policy/pedantic.html" class="podlinkpod"
>DBD::Gofer::Policy::pedantic</a> is most &#39;transparent&#39; but slowest because it makes more round-trips to the Gofer server.</p>

<p><a href="../DBD/Gofer/Policy/classic.html" class="podlinkpod"
>DBD::Gofer::Policy::classic</a> is a reasonable compromise - it&#39;s the default policy.</p>

<p><a href="../DBD/Gofer/Policy/rush.html" class="podlinkpod"
>DBD::Gofer::Policy::rush</a> is fastest, but may require code changes in your applications.</p>

<p>Generally the default <code>classic</code> policy is fine. When first testing an existing application with Gofer it is a good idea to start with the <code>pedantic</code> policy first and then switch to <code>classic</code> or a custom policy, for final testing.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Tim Bunce, <a href="http://www.tim.bunce.name" class="podlinkurl"
>http://www.tim.bunce.name</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENCE_AND_COPYRIGHT"
>LICENCE AND COPYRIGHT</a></h1>

<p>Copyright (c) 2007, Tim Bunce, Ireland. All rights reserved.</p>

<p>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself. See <a href="../perlartistic.html" class="podlinkpod"
>perlartistic</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ACKNOWLEDGEMENTS"
>ACKNOWLEDGEMENTS</a></h1>

<p>The development of DBD::Gofer and related modules was sponsored by Shopzilla.com (<a href="http://Shopzilla.com" class="podlinkurl"
>http://Shopzilla.com</a>), where I currently work.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../DBI/Gofer/Request.html" class="podlinkpod"
>DBI::Gofer::Request</a>, <a href="../DBI/Gofer/Response.html" class="podlinkpod"
>DBI::Gofer::Response</a>, <a href="../DBI/Gofer/Execute.html" class="podlinkpod"
>DBI::Gofer::Execute</a>.</p>

<p><a href="../DBI/Gofer/Transport/Base.html" class="podlinkpod"
>DBI::Gofer::Transport::Base</a>, <a href="../DBD/Gofer/Policy/Base.html" class="podlinkpod"
>DBD::Gofer::Policy::Base</a>.</p>

<p><a href="../DBI.html" class="podlinkpod"
>DBI</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Caveats_for_specific_drivers"
>Caveats for specific drivers</a></h1>

<p>This section aims to record issues to be aware of when using Gofer with specific drivers. It usually only documents issues that are not natural consequences of the limitations of the Gofer approach - as documented above.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TODO"
>TODO</a></h1>

<p>This is just a random brain dump... (There&#39;s more in the source of the Changes file, not the pod)</p>

<p>Document policy mechanism</p>

<p>Add mechanism for transports to list config params and for Gofer to apply any that match (and warn if any left over?)</p>

<p>Driver-private sth attributes - set via prepare() - change DBI spec</p>

<p>add hooks into transport base class for checking &#38; updating a result set cache ie via a standard cache interface such as: http://search.cpan.org/~robm/Cache-FastMmap/FastMmap.pm http://search.cpan.org/~bradfitz/Cache-Memcached/lib/Cache/Memcached.pm http://search.cpan.org/~dclinton/Cache-Cache/ http://search.cpan.org/~cleishman/Cache/ Also caching instructions could be passed through the httpd transport layer in such a way that appropriate http cache headers are added to the results so that web caches (squid etc) could be used to implement the caching. (MUST require the use of GET rather than POST requests.)</p>

<p>Rework handling of installed_methods to not piggyback on dbh_attributes?</p>

<p>Perhaps support transactions for transports where it&#39;s possible (ie null and stream)? Would make stream transport (ie ssh) more useful to more people.</p>

<p>Make sth_result_attr more like dbh_attributes (using &#39;*&#39; etc)</p>

<p>Add @val = FETCH_many(@names) to DBI in C and use in Gofer/Execute?</p>

<p>Implement _new_sth in C.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
