<html><head><title>Cache::FastMmap</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:02 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#ABSTRACT'>ABSTRACT</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#PERFORMANCE'>PERFORMANCE</a>
  <li class='indexItem indexItem1'><a href='#COMPATIBILITY'>COMPATIBILITY</a>
  <li class='indexItem indexItem1'><a href='#MEMORY_SIZE'>MEMORY SIZE</a>
  <li class='indexItem indexItem1'><a href='#CACHE_FILES_AND_OS_ISSUES'>CACHE FILES AND OS ISSUES</a>
  <li class='indexItem indexItem1'><a href='#PAGE_SIZE_AND_KEY%2FVALUE_LIMITS'>PAGE SIZE AND KEY/VALUE LIMITS</a>
  <li class='indexItem indexItem1'><a href='#USAGE'>USAGE</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <li class='indexItem indexItem1'><a href='#INTERNAL_METHODS'>INTERNAL METHODS</a>
  <li class='indexItem indexItem1'><a href='#INCOMPATIBLE_CHANGES'>INCOMPATIBLE CHANGES</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Cache::FastMmap - Uses an mmap&#39;ed file to act as a shared memory interprocess cache</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use Cache::FastMmap;

  # Uses vaguely sane defaults
  $Cache = Cache::FastMmap-&#62;new();

  # $Value must be a reference...
  $Cache-&#62;set($Key, $Value);
  $Value = $Cache-&#62;get($Key);

  $Cache = Cache::FastMmap-&#62;new(raw_values =&#62; 1);

  # $Value can&#39;t be a reference...
  $Cache-&#62;set($Key, $Value);
  $Value = $Cache-&#62;get($Key);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ABSTRACT"
>ABSTRACT</a></h1>

<p>A shared memory cache through an mmap&#39;ed file. It&#39;s core is written in C for performance. It uses fcntl locking to ensure multiple processes can safely access the cache at the same time. It uses a basic LRU algorithm to keep the most used entries in the cache.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>In multi-process environments (eg mod_perl, forking daemons, etc), it&#39;s common to want to cache information, but have that cache shared between processes. Many solutions already exist, and may suit your situation better:</p>

<ul>
<li><a href="../MLDBM/Sync.html" class="podlinkpod"
>MLDBM::Sync</a> - acts as a database, data is not automatically expired, slow</li>

<li><a href="../IPC/MM.html" class="podlinkpod"
>IPC::MM</a> - hash implementation is broken, data is not automatically expired, slow</li>

<li><a href="../Cache/FileCache.html" class="podlinkpod"
>Cache::FileCache</a> - lots of features, slow</li>

<li><a href="../Cache/SharedMemoryCache.html" class="podlinkpod"
>Cache::SharedMemoryCache</a> - lots of features, VERY slow. Uses IPC::ShareLite which freeze/thaws ALL data at each read/write</li>

<li><a href="../DBI.html" class="podlinkpod"
>DBI</a> - use your favourite RDBMS. can perform well, need a DB server running. very global. socket connection latency</li>

<li><a href="../Cache/Mmap.html" class="podlinkpod"
>Cache::Mmap</a> - similar to this module, in pure perl. slows down with larger pages</li>

<li><a href="../BerkeleyDB.html" class="podlinkpod"
>BerkeleyDB</a> - very fast (data ends up mostly in shared memory cache) but acts as a database overall, so data is not automatically expired</li>
</ul>

<p>In the case I was working on, I needed:</p>

<ul>
<li>Automatic expiry and space management</li>

<li>Very fast access to lots of small items</li>

<li>The ability to fetch/store many items in one go</li>
</ul>

<p>Which is why I developed this module. It tries to be quite efficient through a number of means:</p>

<ul>
<li>Core code is written in C for performance</li>

<li>It uses multiple pages within a file, and uses Fcntl to only lock a page at a time to reduce contention when multiple processes access the cache.</li>

<li>It uses a dual level hashing system (hash to find page, then hash within each page to find a slot) to make most <code>get()</code> calls O(1) and fast</li>

<li>On each <code>set()</code>, if there are slots and page space available, only the slot has to be updated and the data written at the end of the used data space. If either runs out, a re-organisation of the page is performed to create new slots/space which is done in an efficient way</li>
</ul>

<p>The class also supports read-through, and write-back or write-through callbacks to access the real data if it&#39;s not in the cache, meaning that code like this:</p>

<pre>  my $Value = $Cache-&#62;get($Key);
  if (!defined $Value) {
    $Value = $RealDataSource-&#62;get($Key);
    $Cache-&#62;set($Key, $Value)
  }</pre>

<p>Isn&#39;t required, you instead specify in the constructor:</p>

<pre>  Cache::FastMmap-&#62;new(
    ...
    context =&#62; $RealDataSourceHandle,
    read_cb =&#62; sub { $_[0]-&#62;get($_[1]) },
    write_cb =&#62; sub { $_[0]-&#62;set($_[1], $_[2]) },
  );</pre>

<p>And then:</p>

<pre>  my $Value = $Cache-&#62;get($Key);

  $Cache-&#62;set($Key, $NewValue);</pre>

<p>Will just work and will be read/written to the underlying data source as needed automatically.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PERFORMANCE"
>PERFORMANCE</a></h1>

<p>If you&#39;re storing relatively large and complex structures into the cache, then you&#39;re limited by the speed of the Storable module. If you&#39;re storing simple structures, or raw data, then Cache::FastMmap has noticeable performance improvements.</p>

<p>See <a href="http://cpan.robm.fastmail.fm/cache_perf.html" class="podlinkurl"
>http://cpan.robm.fastmail.fm/cache_perf.html</a> for some comparisons to other modules.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COMPATIBILITY"
>COMPATIBILITY</a></h1>

<p>Cache::FastMmap uses mmap to map a file as the shared cache space, and fcntl to do page locking. This means it should work on most UNIX like operating systems.</p>

<p>Ash Berlin has written a Win32 layer using MapViewOfFile et al. to provide support for Win32 platform.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="MEMORY_SIZE"
>MEMORY SIZE</a></h1>

<p>Because Cache::FastMmap mmap&#39;s a shared file into your processes memory space, this can make each process look quite large, even though it&#39;s just mmap&#39;d memory that&#39;s shared between all processes that use the cache, and may even be swapped out if the cache is getting low usage.</p>

<p>However, the OS will think your process is quite large, which might mean you hit some BSD::Resource or &#39;ulimits&#39; you set previously that you thought were sane, but aren&#39;t anymore, so be aware.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CACHE_FILES_AND_OS_ISSUES"
>CACHE FILES AND OS ISSUES</a></h1>

<p>Because Cache::FastMmap uses an mmap&#39;ed file, when you put values into the cache, you are actually &#34;dirtying&#34; pages in memory that belong to the cache file. Your OS will want to write those dirty pages back to the file on the actual physical disk, but the rate it does that at is very OS dependent.</p>

<p>In Linux, you have some control over how the OS writes those pages back using a number of parameters in /proc/sys/vm</p>

<pre>  dirty_background_ratio
  dirty_expire_centisecs
  dirty_ratio
  dirty_writeback_centisecs</pre>

<p>How you tune these depends heavily on your setup.</p>

<p>As an interesting point, if you use a highmem linux kernel, a change between 2.6.16 and 2.6.20 made the kernel flush memory a LOT more. There&#39;s details in this kernel mailing list thread: <a href="http://www.uwsg.iu.edu/hypermail/linux/kernel/0711.3/0804.html" class="podlinkurl"
>http://www.uwsg.iu.edu/hypermail/linux/kernel/0711.3/0804.html</a></p>

<p>In most cases, people are not actually concerned about the persistence of data in the cache, and so are happy to disable writing of any cache data back to disk at all. Baically what they want is an in memory only shared cache. The best way to do that is to use a &#34;tmpfs&#34; filesystem and put all cache files on there.</p>

<p>For instance, all our machines have a /tmpfs mount point that we create in /etc/fstab as:</p>

<pre>  none /tmpfs tmpfs defaults,noatime,size=1000M 0 0</pre>

<p>And we put all our cache files on there. The tmpfs filesystem is smart enough to only use memory as required by files actually on the tmpfs, so making it 1G in size doesn&#39;t actually use 1G of memory, it only uses as much as the cache files we put on it. In all cases, we ensure that we never run out of real memory, so the cache files effectively act just as named access points to shared memory.</p>

<p>Some people have suggested using anonymous mmaped memory. Unfortunately we need a file descriptor to do the fcntl locking on, so we&#39;d have to create a separate file on a filesystem somewhere anyway. It seems easier to just create an explicit &#34;tmpfs&#34; filesystem.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PAGE_SIZE_AND_KEY/VALUE_LIMITS"
>PAGE SIZE AND KEY/VALUE LIMITS</a></h1>

<p>To reduce lock contention, Cache::FastMmap breaks up the file into pages. When you get/set a value, it hashes the key to get a page, then locks that page, and uses a hash table within the page to get/store the actual key/value pair.</p>

<p>One consequence of this is that you cannot store values larger than a page in the cache at all. Attempting to store values larger than a page size will fail (the set() function will return false).</p>

<p>Also keep in mind that each page has it&#39;s own hash table, and that we store the key and value data of each item. So if you are expecting to store large values and/or keys in the cache, you should use page sizes that are definitely larger than your largest key + value size + a few kbytes for the overhead.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="USAGE"
>USAGE</a></h1>

<p>Because the cache uses shared memory through an mmap&#39;d file, you have to make sure each process connects up to the file. There&#39;s probably two main ways to do this:</p>

<ul>
<li>Create the cache in the parent process, and then when it forks, each child will inherit the same file descriptor, mmap&#39;ed memory, etc and just work. This is the recommended way. (BEWARE: This only works under UNIX as Win32 has no concept of forking)</li>

<li>Explicitly connect up in each forked child to the share file. In this case, make sure the file already exists and the children connect with init_file =&#62; 0 to avoid deleting the cache contents and possible race corruption conditions. Also be careful that multiple children may race to create the file at the same time, each overwriting and corrupting content. Use a separate lock file if you must to ensure only one child creates the file. (This is the only possible way under Win32)</li>
</ul>

<p>The first way is usually the easiest. If you&#39;re using the cache in a Net::Server based module, you&#39;ll want to open the cache in the <code>pre_loop_hook</code>, because that&#39;s executed before the fork, but after the process ownership has changed and any chroot has been done.</p>

<p>In mod_perl, just open the cache at the global level in the appropriate module, which is executed as the server is starting and before it starts forking children, but you&#39;ll probably want to chmod or chown the file to the permissions of the apache process.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<dl>
<dt><a name="new(%Opts)"
><i>new(%Opts)</i></a></dt>

<dd>
<p>Create a new Cache::FastMmap object.</p>

<p>Basic global parameters are:</p>

<ul>
<li><b>share_file</b>
<p>File to mmap for sharing of data. default on unix: /tmp/sharefile-$pid-$time-$random default on windows: %TEMP%\sharefile-$pid-$time-$random</p>
</li>

<li><b>init_file</b>
<p>Clear any existing values and re-initialise file. Useful to do in a parent that forks off children to ensure that file is empty at the start (default: 0)</p>

<p><b>Note:</b> This is quite important to do in the parent to ensure a consistent file structure. The shared file is not perfectly transaction safe, and so if a child is killed at the wrong instant, it might leave the the cache file in an inconsistent state.</p>
</li>

<li><b>raw_values</b>
<p>Store values as raw binary data rather than using Storable to free/thaw data structures (default: 0)</p>
</li>

<li><b>compress</b>
<p>Compress the value (but not the key) before storing into the cache. If you set this to 1, the module will attempt to require the Compress::Zlib module and then use the memGzip() function on the value data before storing into the cache, and memGunzip() when retrieving data from the cache. Some initial testing shows that the uncompressing tends to be very fast, though the compressing can be quite slow, so it&#39;s probably best to use this option only if you know values in the cache are long lived and have a high hit rate. (default: 0)</p>
</li>

<li><b>enable_stats</b>
<p>Enable some basic statistics capturing. When enabled, every read to the cache is counted, and every read to the cache that finds a value in the cache is also counted. You can then retrieve these values via the get_statistics() call. This causes every read action to do a write on a page, which can cause some more IO, so it&#39;s disabled by default. (default: 0)</p>
</li>

<li><b>expire_time</b>
<p>Maximum time to hold values in the cache in seconds. A value of 0 means does no explicit expiry time, and values are expired only based on LRU usage. Can be expressed as 1m, 1h, 1d for minutes/hours/days respectively. (default: 0)</p>
</li>
</ul>

<p>You may specify the cache size as:</p>

<ul>
<li><b>cache_size</b>
<p>Size of cache. Can be expresses as 1k, 1m for kilobytes or megabytes respectively. Automatically guesses page size/page count values.</p>
</li>
</ul>

<p>Or specify explicit page size/page count values. If none of these are specified, the values page_size = 64k and num_pages = 89 are used.</p>

<ul>
<li><b>page_size</b>
<p>Size of each page. Must be a power of 2 between 4k and 1024k. If not, is rounded to the nearest value.</p>
</li>

<li><b>num_pages</b>
<p>Number of pages. Should be a prime number for best hashing</p>
</li>
</ul>

<p>The cache allows the use of callbacks for reading/writing data to an underlying data store.</p>

<ul>
<li><b>context</b>
<p>Opaque reference passed as the first parameter to any callback function if specified</p>
</li>

<li><b>read_cb</b>
<p>Callback to read data from the underlying data store. Called as:</p>

<pre>  $read_cb-&#62;($context, $Key)</pre>

<p>Should return the value to use. This value will be saved in the cache for future retrievals. Return undef if there is no value for the given key</p>
</li>

<li><b>write_cb</b>
<p>Callback to write data to the underlying data store. Called as:</p>

<pre>  $write_cb-&#62;($context, $Key, $Value, $ExpiryTime)</pre>

<p>In &#39;write_through&#39; mode, it&#39;s always called as soon as a <i>set(...)</i> is called on the Cache::FastMmap class. In &#39;write_back&#39; mode, it&#39;s called when a value is expunged from the cache if it&#39;s been changed by a <i>set(...)</i> rather than read from the underlying store with the <i>read_cb</i> above.</p>

<p>Note: Expired items do result in the <i>write_cb</i> being called if &#39;write_back&#39; caching is enabled and the item has been changed. You can check the $ExpiryTime against <code>time()</code> if you only want to write back values which aren&#39;t expired.</p>

<p>Also remember that <i>write_cb</i> may be called in a different process to the one that placed the data in the cache in the first place</p>
</li>

<li><b>delete_cb</b>
<p>Callback to delete data from the underlying data store. Called as:</p>

<pre>  $delete_cb-&#62;($context, $Key)</pre>

<p>Called as soon as <i>remove(...)</i> is called on the Cache::FastMmap class</p>
</li>

<li><b>cache_not_found</b>
<p>If set to true, then if the <i>read_cb</i> is called and it returns undef to say nothing was found, then that information is stored in the cache, so that next time a <i>get(...)</i> is called on that key, undef is returned immediately rather than again calling the <i>read_cb</i></p>
</li>

<li><b>write_action</b>
<p>Either &#39;write_back&#39; or &#39;write_through&#39;. (default: write_through)</p>
</li>

<li><b>allow_recursive</b>
<p>If you&#39;re using a callback function, then normally the cache is not re-enterable, and attempting to call a get/set on the cache will cause an error. By setting this to one, the cache will unlock any pages before calling the callback. During the unlock time, other processes may change data in current cache page, causing possible unexpected effects. You shouldn&#39;t set this unless you know you want to be able to recall to the cache within a callback. (default: 0)</p>
</li>

<li><b>empty_on_exit</b>
<p>When you have &#39;write_back&#39; mode enabled, then you really want to make sure all values from the cache are expunged when your program exits so any changes are written back.</p>

<p>The trick is that we only want to do this in the parent process, we don&#39;t want any child processes to empty the cache when they exit. So if you set this, it takes the PID via $$, and only calls empty in the DESTROY method if $$ matches the pid we captured at the start. (default: 0)</p>
</li>

<li><b>unlink_on_exit</b>
<p>Unlink the share file when the cache is destroyed.</p>

<p>As with empty_on_exit, this will only unlink the file if the DESTROY occurs in the same PID that the cache was created in so that any forked children don&#39;t unlink the file.</p>

<p>This value defaults to 1 if the share_file specified does not already exist. If the share_file specified does already exist, it defaults to 0.</p>
</li>

<li><b>catch_deadlocks</b>
<p>Sets an alarm(10) before each page is locked via fcntl(F_SETLKW) to catch any deadlock. This used to be the default behaviour, but it&#39;s not really needed in the default case and could clobber sub-second Time::HiRes alarms setup by other code. Defaults to 0.</p>
</li>
</ul>

<dt><a name="get($Key,_[_\%Options_])"
><i>get($Key, [ \%Options ])</i></a></dt>

<dd>
<p>Search cache for given Key. Returns undef if not found. If <i>read_cb</i> specified and not found, calls the callback to try and find the value for the key, and if found (or &#39;cache_not_found&#39; is set), stores it into the cache and returns the found value.</p>

<p><i>%Options</i> is optional, and is used by get_and_set() to control the locking behaviour. For now, you should probably ignore it unless you read the code to understand how it works</p>

<dt><a name="set($Key,_$Value,_[_\%Options_])"
><i>set($Key, $Value, [ \%Options ])</i></a></dt>

<dd>
<p>Store specified key/value pair into cache</p>

<p><i>%Options</i> is optional, and is used by get_and_set() to control the locking behaviour. For now, you should probably ignore it unless you read the code to understand how it works</p>

<p>This method returns true if the value was stored in the cache, false otherwise. See the PAGE SIZE AND KEY/VALUE LIMITS section for more details.</p>

<dt><a name="get_and_set($Key,_$Sub)"
><i>get_and_set($Key, $Sub)</i></a></dt>

<dd>
<p>Atomically retrieve and set the value of a Key.</p>

<p>The page is locked while retrieving the $Key and is unlocked only after the value is set, thus guaranteeing the value does not change betwen the get and set operations.</p>

<p>$Sub is a reference to a subroutine that is called to calculate the new value to store. $Sub gets $Key and the current value as parameters, and should return the new value to set in the cache for the given $Key.</p>

<p>For example, to atomically increment a value in the cache, you can just use:</p>

<pre>  $Cache-&#62;get_and_set($Key, sub { return ++$_[1]; });</pre>

<p>In scalar context, the return value from this function is the *new* value stored back into the cache.</p>

<p>In list context, a two item array is returned; the new value stored back into the cache and a boolean that&#39;s true if the value was stored in the cache, false otherwise. See the PAGE SIZE AND KEY/VALUE LIMITS section for more details.</p>

<p>Notes:</p>

<ul>
<li>Do not perform any get/set operations from the callback sub, as these operations lock the page and you may end up with a dead lock!</li>

<li>If your sub does a die/throws an exception, the page will correctly be unlocked (1.15 onwards)</li>
</ul>

<dt><a name="remove($Key,_[_\%Options_])"
><i>remove($Key, [ \%Options ])</i></a></dt>

<dd>
<p>Delete the given key from the cache</p>

<p><i>%Options</i> is optional, and is used by get_and_remove() to control the locking behaviour. For now, you should probably ignore it unless you read the code to understand how it works</p>

<dt><a name="get_and_remove($Key)"
><i>get_and_remove($Key)</i></a></dt>

<dd>
<p>Atomically retrieve value of a Key while removing it from the cache.</p>

<p>The page is locked while retrieving the $Key and is unlocked only after the value is removed, thus guaranteeing the value stored by someone else isn&#39;t removed by us.</p>

<dt><a name="clear()"
><i>clear()</i></a></dt>

<dd>
<p>Clear all items from the cache</p>

<p>Note: If you&#39;re using callbacks, this has no effect on items in the underlying data store. No delete callbacks are made</p>

<dt><a name="purge()"
><i>purge()</i></a></dt>

<dd>
<p>Clear all expired items from the cache</p>

<p>Note: If you&#39;re using callbacks, this has no effect on items in the underlying data store. No delete callbacks are made, and no write callbacks are made for the expired data</p>

<dt><a name="empty($OnlyExpired)"
><i>empty($OnlyExpired)</i></a></dt>

<dd>
<p>Empty all items from the cache, or if $OnlyExpired is true, only expired items.</p>

<p>Note: If &#39;write_back&#39; mode is enabled, any changed items are written back to the underlying store. Expired items are written back to the underlying store as well.</p>

<dt><a name="get_keys($Mode)"
><i>get_keys($Mode)</i></a></dt>

<dd>
<p>Get a list of keys/values held in the cache. May immediately be out of date because of the shared access nature of the cache</p>

<p>If $Mode == 0, an array of keys is returned</p>

<p>If $Mode == 1, then an array of hashrefs, with &#39;key&#39;, &#39;last_access&#39;, &#39;expire_time&#39; and &#39;flags&#39; keys is returned</p>

<p>If $Mode == 2, then hashrefs also contain &#39;value&#39; key</p>

<dt><a name="get_statistics($Clear)"
><i>get_statistics($Clear)</i></a></dt>

<dd>
<p>Returns a two value list of (nreads, nreadhits). This only works if you passed enable_stats in the constructor</p>

<p>nreads is the total number of read attempts done on the cache since it was created</p>

<p>nreadhits is the total number of read attempts done on the cache since it was created that found the key/value in the cache</p>

<p>If $Clear is true, the values are reset immediately after they are retrieved</p>

<dt><a name="multi_get($PageKey,_[_$Key1,_$Key2,_..._])"
><i>multi_get($PageKey, [ $Key1, $Key2, ... ])</i></a></dt>

<dd>
<p>The two multi_xxx routines act a bit differently to the other routines. With the multi_get, you pass a separate PageKey value and then multiple keys. The PageKey value is hashed, and that page locked. Then that page is searched for each key. It returns a hash ref of Key =&#62; Value items found in that page in the cache.</p>

<p>The main advantage of this is just a speed one, if you happen to need to search for a lot of items on each call.</p>

<p>For instance, say you have users and a bunch of pieces of separate information for each user. On a particular run, you need to retrieve a sub-set of that information for a user. You could do lots of get() calls, or you could use the &#39;username&#39; as the page key, and just use one multi_get() and multi_set() call instead.</p>

<p>A couple of things to note:</p>

<ol>
<li>This makes multi_get()/multi_set() and get()/set() incompatible. Don&#39;t mix calls to the two, because you won&#39;t find the data you&#39;re expecting</li>

<li>The writeback and callback modes of operation do not work with multi_get()/multi_set(). Don&#39;t attempt to use them together.</li>
</ol>

<dt><a name="multi_set($PageKey,_{_$Key1_=_$Value1,_$Key2_=&#62;_$Value2,_..._},_[_\%Options_])&#62;"
><i>multi_set($PageKey, { $Key1 =</i> $Value1, $Key2 =&#62; $Value2, ... }, [ \%Options ])&#62;</a></dt>

<dd>
<p>Store specified key/value pair into cache</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="INTERNAL_METHODS"
>INTERNAL METHODS</a></h1>

<dl>
<dt><a name="_expunge_all($Mode,_$WB)"
><i>_expunge_all($Mode, $WB)</i></a></dt>

<dd>
<p>Expunge all items from the cache</p>

<p>Expunged items (that have not expired) are written back to the underlying store if write_back is enabled</p>

<dt><a name="_expunge_page($Mode,_$WB,_$Len)"
><i>_expunge_page($Mode, $WB, $Len)</i></a></dt>

<dd>
<p>Expunge items from the current page to make space for $Len bytes key/value items</p>

<p>Expunged items (that have not expired) are written back to the underlying store if write_back is enabled</p>

<dt><a name="_lock_page($Page)"
><i>_lock_page($Page)</i></a></dt>

<dd>
<p>Lock a given page in the cache, and return an object reference that when DESTROYed, unlocks the page</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="INCOMPATIBLE_CHANGES"
>INCOMPATIBLE CHANGES</a></h1>

<ul>
<li>From 1.15
<ul>
<li>Default share_file name is no-longer /tmp/sharefile, but /tmp/sharefile-$pid-$time. This ensures that different runs/processes don&#39;t interfere with each other, but means you may not connect up to the file you expect. You should be choosing an explicit name in most cases.
<p>On Unix systems, you can pass in the environment variable TMPDIR to override the default directory of /tmp</p>
</li>

<li>The new option unlink_on_exit defaults to true if you pass a filename for the share_file which doesn&#39;t already exist. This means if you have one process that creates the file, and another that expects the file to be there, by default it won&#39;t be.
<p>Otherwise the defaults seem sensible to cleanup unneeded share files rather than leaving them around to accumulate.</p>
</li>
</ul>
</li>

<li>From 1.29
<ul>
<li>Default share_file name is no longer /tmp/sharefile-$pid-$time but /tmp/sharefile-$pid-$time-$random.</li>
</ul>
</li>

<li>From 1.31
<ul>
<li>Before 1.31, if you were using raw_values =&#62; 0 mode, then the write_cb would be called with raw frozen data, rather than the thawed object. From 1.31 onwards, it correctly calls write_cb with the thawed object value (eg what was passed to the -&#62;set() call in the first place)</li>
</ul>
</li>

<li>From 1.36
<ul>
<li>Before 1.36, an alarm(10) would be set before each attempt to lock a page. The only purpose of this was to detect deadlocks, which should only happen if the Cache::FastMmap code was buggy, or a callback function in get_and_set() made another call into Cache::FastMmap.
<p>However this added unnecessary extra system calls for every lookup, and for users using Time::HiRes, it could clobber any existing alarms that had been set with sub-second resolution.</p>

<p>So this has now been made an optional feature via the catch_deadlocks option passed to new.</p>
</li>
</ul>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../MLDBM/Sync.html" class="podlinkpod"
>MLDBM::Sync</a>, <a href="../IPC/MM.html" class="podlinkpod"
>IPC::MM</a>, <a href="../Cache/FileCache.html" class="podlinkpod"
>Cache::FileCache</a>, <a href="../Cache/SharedMemoryCache.html" class="podlinkpod"
>Cache::SharedMemoryCache</a>, <a href="../DBI.html" class="podlinkpod"
>DBI</a>, <a href="../Cache/Mmap.html" class="podlinkpod"
>Cache::Mmap</a>, <a href="../BerkeleyDB.html" class="podlinkpod"
>BerkeleyDB</a></p>

<p>Latest news/details can also be found at:</p>

<p><a href="http://cpan.robm.fastmail.fm/cachefastmmap/" class="podlinkurl"
>http://cpan.robm.fastmail.fm/cachefastmmap/</a></p>

<p>Available on github at:</p>

<p><a href="https://github.com/robmueller/cache-fastmmap/" class="podlinkurl"
>https://github.com/robmueller/cache-fastmmap/</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Rob Mueller <a href="mailto:cpan@robm.fastmail.fm" class="podlinkurl"
>mailto:cpan@robm.fastmail.fm</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>Copyright (C) 2003-2011 by Opera Software Australia Pty Ltd</p>

<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
