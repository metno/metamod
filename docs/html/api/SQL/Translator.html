<html><head><title>SQL::Translator</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:26 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#CONSTRUCTOR'>CONSTRUCTOR</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#add_drop_table'>add_drop_table</a>
    <li class='indexItem indexItem2'><a href='#quote_identifiers'>quote_identifiers</a>
    <li class='indexItem indexItem2'><a href='#quote_table_names'>quote_table_names</a>
    <li class='indexItem indexItem2'><a href='#quote_field_names'>quote_field_names</a>
    <li class='indexItem indexItem2'><a href='#no_comments'>no_comments</a>
    <li class='indexItem indexItem2'><a href='#producer'>producer</a>
    <li class='indexItem indexItem2'><a href='#parser'>parser</a>
    <li class='indexItem indexItem2'><a href='#filters'>filters</a>
    <li class='indexItem indexItem2'><a href='#show_warnings'>show_warnings</a>
    <li class='indexItem indexItem2'><a href='#translate'>translate</a>
    <li class='indexItem indexItem2'><a href='#filename%2C_data'>filename, data</a>
    <li class='indexItem indexItem2'><a href='#schema'>schema</a>
    <li class='indexItem indexItem2'><a href='#trace'>trace</a>
    <li class='indexItem indexItem2'><a href='#validate'>validate</a>
    <li class='indexItem indexItem2'><a href='#version'>version</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
  <li class='indexItem indexItem1'><a href='#LICENSE'>LICENSE</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#PRAISE'>PRAISE</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>SQL::Translator - manipulate structured data definitions (SQL and more)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use SQL::Translator;

  my $translator          = SQL::Translator-&#62;new(
      # Print debug info
      debug               =&#62; 1,
      # Print Parse::RecDescent trace
      trace               =&#62; 0,
      # Don&#39;t include comments in output
      no_comments         =&#62; 0,
      # Print name mutations, conflicts
      show_warnings       =&#62; 0,
      # Add &#34;drop table&#34; statements
      add_drop_table      =&#62; 1,
      # to quote or not to quote, thats the question
      quote_identifiers     =&#62; 1,
      # Validate schema object
      validate            =&#62; 1,
      # Make all table names CAPS in producers which support this option
      format_table_name   =&#62; sub {my $tablename = shift; return uc($tablename)},
      # Null-op formatting, only here for documentation&#39;s sake
      format_package_name =&#62; sub {return shift},
      format_fk_name      =&#62; sub {return shift},
      format_pk_name      =&#62; sub {return shift},
  );

  my $output     = $translator-&#62;translate(
      from       =&#62; &#39;MySQL&#39;,
      to         =&#62; &#39;Oracle&#39;,
      # Or an arrayref of filenames, i.e. [ $file1, $file2, $file3 ]
      filename   =&#62; $file,
  ) or die $translator-&#62;error;

  print $output;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This documentation covers the API for SQL::Translator. For a more general discussion of how to use the modules and scripts, please see <a href="../SQL/Translator/Manual.html" class="podlinkpod"
>SQL::Translator::Manual</a>.</p>

<p>SQL::Translator is a group of Perl modules that converts vendor-specific SQL table definitions into other formats, such as other vendor-specific SQL, ER diagrams, documentation (POD and HTML), XML, and Class::DBI classes. The main focus of SQL::Translator is SQL, but parsers exist for other structured data formats, including Excel spreadsheets and arbitrarily delimited text files. Through the separation of the code into parsers and producers with an object model in between, it&#39;s possible to combine any parser with any producer, to plug in custom parsers or producers, or to manipulate the parsed data via the built-in object model. Presently only the definition parts of SQL are handled (CREATE, ALTER), not the manipulation of data (INSERT, UPDATE, DELETE).</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CONSTRUCTOR"
>CONSTRUCTOR</a></h1>

<p>The constructor is called <code>new</code>, and accepts a optional hash of options. Valid options are:</p>

<ul>
<li>parser / from</li>

<li>parser_args</li>

<li>producer / to</li>

<li>producer_args</li>

<li>filters</li>

<li>filename / file</li>

<li>data</li>

<li>debug</li>

<li>add_drop_table</li>

<li>quote_identifiers</li>

<li>quote_table_names (DEPRECATED)</li>

<li>quote_field_names (DEPRECATED)</li>

<li>no_comments</li>

<li>trace</li>

<li>validate</li>
</ul>

<p>All options are, well, optional; these attributes can be set via instance methods. Internally, they are; no (non-syntactical) advantage is gained by passing options to the constructor.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="add_drop_table"
>add_drop_table</a></h2>

<p>Toggles whether or not to add &#34;DROP TABLE&#34; statements just before the create definitions.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="quote_identifiers"
>quote_identifiers</a></h2>

<p>Toggles whether or not to quote identifiers (table, column, constraint, etc.) with a quoting mechanism suitable for the chosen Producer. The default (true) is to quote them.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="quote_table_names"
>quote_table_names</a></h2>

<p>DEPRECATED - A legacy proxy to <a href="#quote_identifiers" class="podlinkpod"
>&#34;quote_identifiers&#34;</a></p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="quote_field_names"
>quote_field_names</a></h2>

<p>DEPRECATED - A legacy proxy to <a href="#quote_identifiers" class="podlinkpod"
>&#34;quote_identifiers&#34;</a></p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="no_comments"
>no_comments</a></h2>

<p>Toggles whether to print comments in the output. Accepts a true or false value, returns the current value.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="producer"
>producer</a></h2>

<p>The <code>producer</code> method is an accessor/mutator, used to retrieve or define what subroutine is called to produce the output. A subroutine defined as a producer will be invoked as a function (<i>not a method</i>) and passed its container <code>SQL::Translator</code> instance, which it should call the <code>schema</code> method on, to get the <code>SQL::Translator::Schema</code> generated by the parser. It is expected that the function transform the schema structure to a string. The <code>SQL::Translator</code> instance is also useful for informational purposes; for example, the type of the parser can be retrieved using the <code>parser_type</code> method, and the <code>error</code> and <code>debug</code> methods can be called when needed.</p>

<p>When defining a producer, one of several things can be passed in: A module name (e.g., <code>My::Groovy::Producer</code>), a module name relative to the <code>SQL::Translator::Producer</code> namespace (e.g., <code>MySQL</code>), a module name and function combination (<code>My::Groovy::Producer::transmogrify</code>), or a reference to an anonymous subroutine. If a full module name is passed in (for the purposes of this method, a string containing &#34;::&#34; is considered to be a module name), it is treated as a package, and a function called &#34;produce&#34; will be invoked: <code>$modulename::produce</code>. If $modulename cannot be loaded, the final portion is stripped off and treated as a function. In other words, if there is no file named <em>My/Groovy/Producer/transmogrify.pm</em>, <code>SQL::Translator</code> will attempt to load <em>My/Groovy/Producer.pm</em> and use <code>transmogrify</code> as the name of the function, instead of the default <code>produce</code>.</p>

<pre>  my $tr = SQL::Translator-&#62;new;

  # This will invoke My::Groovy::Producer::produce($tr, $data)
  $tr-&#62;producer(&#34;My::Groovy::Producer&#34;);

  # This will invoke SQL::Translator::Producer::Sybase::produce($tr, $data)
  $tr-&#62;producer(&#34;Sybase&#34;);

  # This will invoke My::Groovy::Producer::transmogrify($tr, $data),
  # assuming that My::Groovy::Producer::transmogrify is not a module
  # on disk.
  $tr-&#62;producer(&#34;My::Groovy::Producer::transmogrify&#34;);

  # This will invoke the referenced subroutine directly, as
  # $subref-&#62;($tr, $data);
  $tr-&#62;producer(\&#38;my_producer);</pre>

<p>There is also a method named <code>producer_type</code>, which is a string containing the classname to which the above <code>produce</code> function belongs. In the case of anonymous subroutines, this method returns the string &#34;CODE&#34;.</p>

<p>Finally, there is a method named <code>producer_args</code>, which is both an accessor and a mutator. Arbitrary data may be stored in name =&#62; value pairs for the producer subroutine to access:</p>

<pre>  sub My::Random::producer {
      my ($tr, $data) = @_;
      my $pr_args = $tr-&#62;producer_args();

      # $pr_args is a hashref.</pre>

<p>Extra data passed to the <code>producer</code> method is passed to <code>producer_args</code>:</p>

<pre>  $tr-&#62;producer(&#34;xSV&#34;, delimiter =&#62; &#39;,\s*&#39;);

  # In SQL::Translator::Producer::xSV:
  my $args = $tr-&#62;producer_args;
  my $delimiter = $args-&#62;{&#39;delimiter&#39;}; # value is ,\s*</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="parser"
>parser</a></h2>

<p>The <code>parser</code> method defines or retrieves a subroutine that will be called to perform the parsing. The basic idea is the same as that of <code>producer</code> (see above), except the default subroutine name is &#34;parse&#34;, and will be invoked as <code>$module_name::parse($tr, $data)</code>. Also, the parser subroutine will be passed a string containing the entirety of the data to be parsed.</p>

<pre>  # Invokes SQL::Translator::Parser::MySQL::parse()
  $tr-&#62;parser(&#34;MySQL&#34;);

  # Invokes My::Groovy::Parser::parse()
  $tr-&#62;parser(&#34;My::Groovy::Parser&#34;);

  # Invoke an anonymous subroutine directly
  $tr-&#62;parser(sub {
    my $dumper = Data::Dumper-&#62;new([ $_[1] ], [ &#34;SQL&#34; ]);
    $dumper-&#62;Purity(1)-&#62;Terse(1)-&#62;Deepcopy(1);
    return $dumper-&#62;Dump;
  });</pre>

<p>There is also <code>parser_type</code> and <code>parser_args</code>, which perform analogously to <code>producer_type</code> and <code>producer_args</code></p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="filters"
>filters</a></h2>

<p>Set or retreive the filters to run over the schema during the translation, before the producer creates its output. Filters are sub routines called, in order, with the schema object to filter as the 1st arg and a hash of options (passed as a list) for the rest of the args. They are free to do whatever they want to the schema object, which will be handed to any following filters, then used by the producer.</p>

<p>Filters are set as an array, which gives the order they run in. Like parsers and producers, they can be defined by a module name, a module name relative to the SQL::Translator::Filter namespace, a module name and function name together or a reference to an anonymous subroutine. When using a module name a function called <code>filter</code> will be invoked in that package to do the work.</p>

<p>To pass args to the filter set it as an array ref with the 1st value giving the filter (name or sub) and the rest its args. e.g.</p>

<pre> $tr-&#62;filters(
     sub {
        my $schema = shift;
        # Do stuff to schema here!
     },
     DropFKeys,
     [ &#34;Names&#34;, table =&#62; &#39;lc&#39; ],
     [ &#34;Foo&#34;,   foo =&#62; &#34;bar&#34;, hello =&#62; &#34;world&#34; ],
     [ &#34;Filter5&#34; ],
 );</pre>

<p>Although you normally set them in the constructor, which calls through to filters. i.e.</p>

<pre>  my $translator  = SQL::Translator-&#62;new(
      ...
      filters =&#62; [
          sub { ... },
          [ &#34;Names&#34;, table =&#62; &#39;lc&#39; ],
      ],
      ...
  );</pre>

<p>See <em>t/36-filters.t</em> for more examples.</p>

<p>Multiple set calls to filters are cumulative with new filters added to the end of the current list.</p>

<p>Returns the filters as a list of array refs, the 1st value being a reference to the filter sub and the rest its args.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="show_warnings"
>show_warnings</a></h2>

<p>Toggles whether to print warnings of name conflicts, identifier mutations, etc. Probably only generated by producers to let the user know when something won&#39;t translate very smoothly (e.g., MySQL &#34;enum&#34; fields into Oracle). Accepts a true or false value, returns the current value.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="translate"
>translate</a></h2>

<p>The <code>translate</code> method calls the subroutine referenced by the <code>parser</code> data member, then calls any <code>filters</code> and finally calls the <code>producer</code> sub routine (these members are described above). It accepts as arguments a number of things, in key =&#62; value format, including (potentially) a parser and a producer (they are passed directly to the <code>parser</code> and <code>producer</code> methods).</p>

<p>Here is how the parameter list to <code>translate</code> is parsed:</p>

<ul>
<li>1 argument means it&#39;s the data to be parsed; which could be a string (filename) or a reference to a scalar (a string stored in memory), or a reference to a hash, which is parsed as being more than one argument (see next section).
<pre>  # Parse the file /path/to/datafile
  my $output = $tr-&#62;translate(&#34;/path/to/datafile&#34;);

  # Parse the data contained in the string $data
  my $output = $tr-&#62;translate(\$data);</pre>
</li>

<li>More than 1 argument means its a hash of things, and it might be setting a parser, producer, or datasource (this key is named &#34;filename&#34; or &#34;file&#34; if it&#39;s a file, or &#34;data&#34; for a SCALAR reference.
<pre>  # As above, parse /path/to/datafile, but with different producers
  for my $prod (&#34;MySQL&#34;, &#34;XML&#34;, &#34;Sybase&#34;) {
      print $tr-&#62;translate(
                producer =&#62; $prod,
                filename =&#62; &#34;/path/to/datafile&#34;,
            );
  }

  # The filename hash key could also be:
      datasource =&#62; \$data,</pre>

<p>You get the idea.</p>
</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="filename,_data"
>filename, data</a></h2>

<p>Using the <code>filename</code> method, the filename of the data to be parsed can be set. This method can be used in conjunction with the <code>data</code> method, below. If both the <code>filename</code> and <code>data</code> methods are invoked as mutators, the data set in the <code>data</code> method is used.</p>

<pre>    $tr-&#62;filename(&#34;/my/data/files/create.sql&#34;);</pre>

<p>or:</p>

<pre>    my $create_script = do {
        local $/;
        open CREATE, &#34;/my/data/files/create.sql&#34; or die $!;
        &#60;CREATE&#62;;
    };
    $tr-&#62;data(\$create_script);</pre>

<p><code>filename</code> takes a string, which is interpreted as a filename. <code>data</code> takes a reference to a string, which is used as the data to be parsed. If a filename is set, then that file is opened and read when the <code>translate</code> method is called, as long as the data instance variable is not set.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="schema"
>schema</a></h2>

<p>Returns the SQL::Translator::Schema object.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="trace"
>trace</a></h2>

<p>Turns on/off the tracing option of Parse::RecDescent.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="validate"
>validate</a></h2>

<p>Whether or not to validate the schema object after parsing and before producing.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="version"
>version</a></h2>

<p>Returns the version of the SQL::Translator release.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<p>See the included AUTHORS file: <a href="http://search.cpan.org/dist/SQL-Translator/AUTHORS" class="podlinkurl"
>http://search.cpan.org/dist/SQL-Translator/AUTHORS</a></p>

<p>If you would like to contribute to the project, you can send patches to the developers mailing list:</p>

<pre>    sqlfairy-developers@lists.sourceforge.net</pre>

<p>Or send us a message (with your Sourceforge username) asking to be added to the project and what you&#39;d like to contribute.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright 2012 the SQL::Translator authors, as listed in <a href="#AUTHORS" class="podlinkpod"
>&#34;AUTHORS&#34;</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENSE"
>LICENSE</a></h1>

<p>This library is free software and may be distributed under the same terms as Perl 5 itself.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>Please use <a href="http://rt.cpan.org/" class="podlinkurl"
>http://rt.cpan.org/</a> for reporting bugs.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PRAISE"
>PRAISE</a></h1>

<p>If you find this module useful, please use <a href="http://cpanratings.perl.org/rate/?distribution=SQL-Translator" class="podlinkurl"
>http://cpanratings.perl.org/rate/?distribution=SQL-Translator</a> to rate it.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../perl.html" class="podlinkpod"
>perl</a>, <a href="../SQL/Translator/Parser.html" class="podlinkpod"
>SQL::Translator::Parser</a>, <a href="../SQL/Translator/Producer.html" class="podlinkpod"
>SQL::Translator::Producer</a>, <a href="../Parse/RecDescent.html" class="podlinkpod"
>Parse::RecDescent</a>, <a href="../GD.html" class="podlinkpod"
>GD</a>, <a href="../GraphViz.html" class="podlinkpod"
>GraphViz</a>, <a href="../Text/RecordParser.html" class="podlinkpod"
>Text::RecordParser</a>, <a href="../Class/DBI.html" class="podlinkpod"
>Class::DBI</a>, <a href="../XML/Writer.html" class="podlinkpod"
>XML::Writer</a>.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
