<html><head><title>SQL::Translator::Manual</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:26 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#SQLFAIRY_SCRIPTS'>SQLFAIRY SCRIPTS</a>
  <li class='indexItem indexItem1'><a href='#CONVERTING_SQL_DIALECTS'>CONVERTING SQL DIALECTS</a>
  <li class='indexItem indexItem1'><a href='#EXTRACT_SQL_SCHEMAS_DIRECTLY_FROM_DATABASE'>EXTRACT SQL SCHEMAS DIRECTLY FROM DATABASE</a>
  <li class='indexItem indexItem1'><a href='#HANDLING_NON-SQL_DATA'>HANDLING NON-SQL DATA</a>
  <li class='indexItem indexItem1'><a href='#SERIALIZING_SCHEMAS'>SERIALIZING SCHEMAS</a>
  <li class='indexItem indexItem1'><a href='#VISUALIZING_SQL_SCHEMAS'>VISUALIZING SQL SCHEMAS</a>
  <li class='indexItem indexItem1'><a href='#AUTOMATED_CODE-GENERATION'>AUTOMATED CODE-GENERATION</a>
  <li class='indexItem indexItem1'><a href='#CREATING_A_DATA_DUMPER_SCRIPT'>CREATING A DATA DUMPER SCRIPT</a>
  <li class='indexItem indexItem1'><a href='#DOCUMENTING_WITH_SQL%3A%3ATRANSLATOR'>DOCUMENTING WITH SQL::TRANSLATOR</a>
  <li class='indexItem indexItem1'><a href='#TEMPLATE-BASED_MANIPULATION_OF_SCHEMA_OBJECTS'>TEMPLATE-BASED MANIPULATION OF SCHEMA OBJECTS</a>
  <li class='indexItem indexItem1'><a href='#FINDING_THE_DIFFERENCES_BETWEEN_TWO_SCHEMAS'>FINDING THE DIFFERENCES BETWEEN TWO SCHEMAS</a>
  <li class='indexItem indexItem1'><a href='#A_UNIFIED_GRAPHICAL_INTERFACE'>A UNIFIED GRAPHICAL INTERFACE</a>
  <li class='indexItem indexItem1'><a href='#PLUGIN_YOUR_OWN_PARSERS_AND_PRODUCERS'>PLUGIN YOUR OWN PARSERS AND PRODUCERS</a>
  <li class='indexItem indexItem1'><a href='#PLUGIN_TEMPLATE_TOOLKIT_PRODUCERS'>PLUGIN TEMPLATE TOOLKIT PRODUCERS</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>SQL::Translator::Manual - sqlfairy user manual</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<p>SQL::Translator (AKA &#34;SQLFairy&#34;) is a collection of modules for transforming (mainly) SQL DDL files into a variety of other formats,
including other SQL dialects,
documentation,
images,
and code.
In this manual,
we will attempt to address how to use SQLFairy for common tasks.
For a lower-level discussion of how the code works,
please read the documentation for <a href="../../SQL/Translator.html" class="podlinkpod"
>SQL::Translator</a>.</p>

<p>It may prove helpful to have a general understanding of the SQLFairy code before continuing.
The code can be broken into three conceptual groupings:</p>

<ul>
<li>Parsers
<p>The parsers are responsible for reading the input files and describing them to the Schema object middleware.</p>
</li>

<li>Producers
<p>The producers create the output as described by the Schema middleware.</p>
</li>

<li>Schema objects
<p>The Schema objects bridge the communication between the Parsers and Producers by representing any parsed file through a standard set of generic objects to represent concepts like Tables,
Fields (columns),
Indices,
Constraints,
etc.</p>
</li>
</ul>

<p>It&#39;s not necessary to understand how to write or manipulate any of these for most common tasks,
but you should aware of the concepts as they will be referenced later in this document.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SQLFAIRY_SCRIPTS"
>SQLFAIRY SCRIPTS</a></h1>

<p>Most common tasks can be accomplished through the use of the script interfaces to the SQL::Translator code.
All SQLFairy scripts begin with &#34;sqlt.&#34; Here are the scripts and a description of what they each do:</p>

<ul>
<li>sqlt
<p>This is the main interface for text-to-text translations,
e.g.,
converting a MySQL schema to Oracle.</p>
</li>

<li>sqlt-diagram
<p>This is a tailored interface for the Diagram producer and its many myriad options.</p>
</li>

<li>sqlt-diff
<p>This script will examine two schemas and report the SQL commands (ALTER,
CREATE) needed to turn the first schema into the second.</p>
</li>

<li>sqlt-dumper
<p>This script generates a Perl script that can be used to connect to a database and dump the data in each table in different formats,
similar to the &#34;mysqldump&#34; program.</p>
</li>

<li>sqlt-graph
<p>This is an interface to the GraphViz visualization tool and its myriad options.</p>
</li>

<li>sqlt.cgi
<p>This is a CGI script that presents an HTML form for uploading or pasting a schema and choosing an output and the output options.</p>
</li>
</ul>

<p>To read the full documentation for each script,
use &#34;perldoc&#34; (or execute any of the command-line scripts with the &#34;--help&#34; flag).</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CONVERTING_SQL_DIALECTS"
>CONVERTING SQL DIALECTS</a></h1>

<p>Probably the most common task SQLFairy is used for is to convert one dialect of SQL to another.
If you have a text description of an SQL database (AKA a &#34;DDL&#34; -- &#34;Data Definition Language&#34;),
then you should use the &#34;sqlt&#34; script with switches to indicate the parser and producer and the name of the text file as the final argument.
For example,
to convert the &#34;foo.sql&#34; MySQL schema to a version suitable for PostgreSQL,
you would do the following:</p>

<pre>  $ sqlt -f MySQL -t PostgreSQL foo.sql &#62; foo-pg.sql</pre>

<p>The &#34;from&#34; and &#34;to&#34; options are case-sensitive and must match exactly the names of the Parser and Producer classes in SQL::Translator. For a complete listing of your options, execute &#34;sqlt&#34; with the &#34;--list&#34; flag.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXTRACT_SQL_SCHEMAS_DIRECTLY_FROM_DATABASE"
>EXTRACT SQL SCHEMAS DIRECTLY FROM DATABASE</a></h1>

<p>It is possible to extract some schemas directly from the database without parsing a text file (the &#34;foo.sql&#34; in the above example). This can prove significantly faster than parsing a text file. To do this, use the &#34;DBI&#34; parser and provide the necessary arguments to connect to the database and indicate the producer class, like so:</p>

<pre>  $ sqlt -f DBI --dsn dbi:mysql:FOO --db-user guest \
    --db-password p4ssw0rd -t PostgreSQL &#62; foo</pre>

<p>The &#34;--list&#34; option to &#34;sqlt&#34; will show the databases supported by DBI parsers.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="HANDLING_NON-SQL_DATA"
>HANDLING NON-SQL DATA</a></h1>

<p>Certain structured document formats can be easily thought of as tables. SQLFairy can parse Microsoft Excel spreadsheets and arbitrarily delimited text files just as if they were schemas which contained only one table definition. The column names are normalized to something sane for most databases (whitespace is converted to underscores and non-word characters are removed), and the data in each field is scanned to determine the appropriate data type (character, integer, or float) and size. For instance, to convert a comma-separated file to an SQLite database, do the following:</p>

<pre>  $ sqlt -f xSV --fs &#39;,&#39; -t SQLite foo.csv &#62; foo-sqlite.sql</pre>

<p>Additionally, there is a non-SQL represenation of relational schemas namely XML. Additionally, the only XML supported is our own version; however, it would be fairly easy to add an XML parser for something like the TorqueDB (http://db.apache.org/torque/) project. The actual parsing of XML should be trivial given the number of XML parsers available, so all that would be left would be to map the specific concepts in the source file to the Schema objects in SQLFairy.</p>

<p>To convert a schema in SQLFairy&#39;s XML dialect to Oracle, do the following:</p>

<pre>  $ sqlt -f XML-SQLFairy -t Oracle foo.xml &#62; foo-oracle.sql</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SERIALIZING_SCHEMAS"
>SERIALIZING SCHEMAS</a></h1>

<p>Parsing a schema is generally the most computationally expensive operation performed by SQLFairy, so it may behoove you to serialize a parsed schema if you need to perform repeated conversions. For example, as part of a build process the author converts a MySQL schema first to YAML, then to PostgreSQL, Oracle, SQLite and Sybase. Additionally, a variety of documention in HTML and images is produced. This can be accomplished like so:</p>

<pre>  $ sqlt -f MySQL -t YAML schema-mysql.sql &#62; schema.yaml
  $ sqlt -f YAML -t Oracle schema.yaml &#62; schema-oracle.sql
  $ sqlt -f YAML -t PostgreSQL schema.yaml &#62; schema-postgresql.sql
  $ ...</pre>

<p>SQLFairy has three serialization producers, none of which is superior to the other in their description of a schema.</p>

<ul>
<li>XML-SQLFairy
<p>This is the aforementioned XML format. It is essentially a direct mapping of the Schema objects into XML. This can also provide a very convenient bridge to describing a schema to a non-Perl application. Providing a producer argument to &#34;sqlt&#34; of just &#34;XML&#34; will default to using &#34;XML-SQLFairy.&#34;</p>
</li>

<li>Storable
<p>This producer stores the Schema object using Perl&#39;s Storable.pm module available on CPAN.</p>
</li>

<li>YAML
<p>This producer serialized the Schema object with the very readable structured data format of YAML (http://www.yaml.org/). Earlier examples show serializing to YAML.</p>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VISUALIZING_SQL_SCHEMAS"
>VISUALIZING SQL SCHEMAS</a></h1>

<p>The visualization tools in SQLFairy can graphically represent the tables, fields, datatypes and sizes, constraints, and foreign key relationships in a very compact and intuitive format. This can be very beneficial in understanding and document large or small schemas. Two producers in SQLFairy will create pseudo-E/R (entity-relationship) diagrams:</p>

<ul>
<li>Diagram
<p>The first visualization tool in SQLFairy, this producer uses libgd to draw a picture of the schema. The tables are evenly distributed in definition order running in columns (i.e., no graphing algorithms are used), so the many of the lines showing the foreign key relationships may cross over each other and the table boxes. Please read the documentation of the &#34;sqlt-diagram&#34; script for all the options available to this producer.</p>
</li>

<li>GraphViz
<p>The layout of the GraphViz producer is far superior to the Diagram producer as it uses the Graphviz binary from Bell Labs to create very professional-looking graphs. There are several different layout algorithms and node shapes available. Please see the documentation of the &#34;sqlt-graph&#34; script for more information.</p>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTOMATED_CODE-GENERATION"
>AUTOMATED CODE-GENERATION</a></h1>

<p>Given that so many applications interact with SQL databases, it&#39;s no wonder that people have automated code to deal with this interaction. Class::DBI from CPAN is one such module that allows a developer to describe the relationships between tables and fields in class declarations and then generates all the SQL to interact (SELECT, UPDATE, DELETE, INSERT statements) at runtime. Obviously, the schema already describes itself, so it only makes sense that you should be able to generate this kind of code directly from the schema. The &#34;ClassDBI&#34; producer in SQLFairy does just this, creating a Perl module that inherits from Class::DBI and sets up most of the code needed to interact with the database. Here is an example of how to do this:</p>

<pre>  $ sqlt -f MySQL -t ClassDBI foo.sql &#62; Foo.pm</pre>

<p>Then simply edit Foo.pm as needed and include it in your code.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CREATING_A_DATA_DUMPER_SCRIPT"
>CREATING A DATA DUMPER SCRIPT</a></h1>

<p>The Dumper producer creates a Perl script that can select the fields in each table and then create &#34;INSERT&#34; statements for each record in the database similar to the output generated by MySQL&#39;s &#34;mysqldump&#34; program:</p>

<pre>  $ sqlt -f YAML -t Dumper --dumper-db-user guest \
  &#62; --dumper-db-pass p4ssw0rd --dumper-dsn dbi:mysql:FOO \
  &#62; foo.yaml &#62; foo-dumper.pl</pre>

<p>And then execute the resulting script to dump the data:</p>

<pre>  $ chmod +x foo-dumper.pl
  $ ./foo-dumper.pl &#62; foo-data.sql</pre>

<p>The dumper script also has a number of options available. Execute the script with the &#34;--help&#34; flag to read about them.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DOCUMENTING_WITH_SQL::TRANSLATOR"
>DOCUMENTING WITH SQL::TRANSLATOR</a></h1>

<p>SQLFairy offers two producers to help document schemas:</p>

<ul>
<li>HTML
<p>This producer creates a single HTML document which uses HTML formatting to describe the Schema objects and to create hyperlinks on foreign key relationships. This can be a surprisingly useful documentation aid as it creates a very readable format that allows one to jump easily to specific tables and fields. It&#39;s also possible to plugin your own CSS to further control the presentation of the HTML.</p>
</li>

<li>POD
<p>This is arguably not that useful of a producer by itself, but the number of POD-conversion tools could be used to further transform the POD into something more interesting. The schema is basically represented in POD sections where tables are broken down into fields, indices, constraints, foreign keys, etc.</p>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TEMPLATE-BASED_MANIPULATION_OF_SCHEMA_OBJECTS"
>TEMPLATE-BASED MANIPULATION OF SCHEMA OBJECTS</a></h1>

<p>All of the producers which create text output could have been coded using a templating system to mix in the dynamic output with static text. CPAN offers several diverse templating systems, but few are as powerful as Template Toolkit (http://www.template-toolkit.org/). You can easily create your own producer without writing any Perl code at all simply by writing a template using Template Toolkit&#39;s syntax. The template will be passed a reference to the Schema object briefly described at the beginning of this document and mentioned many times throughout. For example, you could create a template that simply prints the name of each table and field that looks like this:</p>

<pre>  # file: schema.tt
  [% FOREACH table IN schema.get_tables %]
  Table: [% table.name %]
  Fields:
  [% FOREACH field IN table.get_fields -%]
    [% field.name %]
  [% END -%]
  [% END %]</pre>

<p>And then process it like so:</p>

<pre>  $ sqlt -f YAML -t TTSchema --template schema.tt foo.yaml</pre>

<p>To create output like this:</p>

<pre>  Table: foo
  Fields:
    foo_id
    foo_name</pre>

<p>For more information on Template Toolkit, please install the &#34;Template&#34; module and read the POD.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FINDING_THE_DIFFERENCES_BETWEEN_TWO_SCHEMAS"
>FINDING THE DIFFERENCES BETWEEN TWO SCHEMAS</a></h1>

<p>As mentioned above, the &#34;sqlt-diff&#34; schema examines two schemas and creates SQL schema modification statements that can be used to transform the first schema into the second. The flag syntax is somewhat quirky:</p>

<pre>  $ sqlt-diff foo-v1.sql=MySQL foo-v2.sql=Oracle &#62; diff.sql</pre>

<p>As demonstrated, the schemas need not even be from the same vendor, though this is likely to produce some spurious results as datatypes are not currently viewed equivalent unless they match exactly, even if they would be converted to the same. For example, MySQL&#39;s &#34;integer&#34; data type would be converted to Oracle&#39;s &#34;number,&#34; but the differ isn&#39;t quite smart enough yet to figure this out. Also, as the SQL to ALTER a field definition varies from database vendor to vendor, these statements are made using just the keyword &#34;CHANGE&#34; and will likely need to be corrected for the target database.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="A_UNIFIED_GRAPHICAL_INTERFACE"
>A UNIFIED GRAPHICAL INTERFACE</a></h1>

<p>Seeing all the above options and scripts, you may be pining for a single, graphical interface to handle all these transformations and choices. This is exactly what the &#34;sqlt.cgi&#34; script provides. Simply drop this script into your web server&#39;s CGI directory and enable the execute bit and you can point your web browser to an HTML form which provides a simple interface to all the SQLFairy parsers and producers.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PLUGIN_YOUR_OWN_PARSERS_AND_PRODUCERS"
>PLUGIN YOUR OWN PARSERS AND PRODUCERS</a></h1>

<p>Now that you have seen how the parsers and producers interact via the Schema objects, you may wish to create your own versions to plugin.</p>

<p>Producers are probably the easier concept to grok, so let&#39;s cover that first. By far the easiest way to create custom output is to use the TTSchema producer in conjunction with a Template Toolkit template as described earlier. However, you can also easily pass a reference to a subroutine that SQL::Translator can call for the production of the output. This subroutine will be passed a single argument of the SQL::Translator object which you can use to access the Schema objects. Please read the POD for SQL::Translator and SQL::Translator::Schema to learn the methods you can call. Here is a very simple example:</p>

<pre>  #!/usr/bin/perl

  use strict;
  use SQL::Translator;

  my $input = q[
      create table foo (
          foo_id int not null default &#39;0&#39; primary key,
          foo_name varchar(30) not null default &#39;&#39;
      );

      create table bar (
          bar_id int not null default &#39;0&#39; primary key,
          bar_value varchar(100) not null default &#39;&#39;
      );
  ];

  my $t = SQL::Translator-&#62;new;
  $t-&#62;parser(&#39;MySQL&#39;) or die $t-&#62;error;
  $t-&#62;producer( \&#38;produce ) or die $t-&#62;error;
  my $output = $t-&#62;translate( \$input ) or die $t-&#62;error;
  print $output;

  sub produce {
      my $tr     = shift;
      my $schema = $tr-&#62;schema;
      my $output = &#39;&#39;;
      for my $t ( $schema-&#62;get_tables ) {
          $output .= join(&#39;&#39;, &#34;Table = &#34;, $t-&#62;name, &#34;\n&#34;);
      }
      return $output;
  }</pre>

<p>Executing this script produces the following:</p>

<pre>  $ ./my-producer.pl
  Table = foo
  Table = bar</pre>

<p>A custom parser will be passed two arguments: the SQL::Translator object and the data to be parsed. In this example, the schema will be represented in a simple text format. Each line is a table definition where the fields are separated by colons. The first field is the table name and the following fields are column definitions where the column name, data type and size are separated by spaces. The specifics of the example are unimportant -- what is being demonstrated is that you have to decide how to parse the incoming data and then map the concepts in the data to the Schema object.</p>

<pre>  #!/usr/bin/perl

  use strict;
  use SQL::Translator;

  my $input =
      &#34;foo:foo_id int 11:foo_name varchar 30\n&#34; .
      &#34;bar:bar_id int 11:bar_value varchar 30&#34;
  ;

  my $t = SQL::Translator-&#62;new;
  $t-&#62;parser( \&#38;parser ) or die $t-&#62;error;
  $t-&#62;producer(&#39;Oracle&#39;) or die $t-&#62;error;
  my $output = $t-&#62;translate( \$input ) or die $t-&#62;error;
  print $output;

  sub parser {
      my ( $tr, $data ) = @_;
      my $schema = $tr-&#62;schema;

      for my $line ( split( /\n/, $data ) ) {
          my ( $table_name, @fields ) = split( /:/, $line );
          my $table = $schema-&#62;add_table( name =&#62; $table_name )
              or die $schema-&#62;error;
          for ( @fields ) {
              my ( $f_name, $type, $size ) = split;
              $table-&#62;add_field(
                  name      =&#62; $f_name,
                  data_type =&#62; $type,
                  size      =&#62; $size,
              ) or die $table-&#62;error;
          }
      }

      return 1;
  }</pre>

<p>And here is the output produced by this script:</p>

<pre>  --
  -- Created by SQL::Translator::Producer::Oracle
  -- Created on Wed Mar 31 15:43:30 2004
  --
  --
  -- Table: foo
  --

  CREATE TABLE foo (
    foo_id number(11),
    foo_name varchar2(30)
  );

  --
  -- Table: bar
  --

  CREATE TABLE bar (
    bar_id number(11),
    bar_value varchar2(30)
  );</pre>

<p>If you create a useful parser or producer, you are encouraged to submit your work to the SQLFairy project!</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PLUGIN_TEMPLATE_TOOLKIT_PRODUCERS"
>PLUGIN TEMPLATE TOOLKIT PRODUCERS</a></h1>

<p>You may find that the TTSchema producer doesn&#39;t give you enough control over templating and you want to play with the Template config or add you own variables. Or maybe you just have a really good template you want to submit to SQLFairy :) If so, the SQL::Translator::Producer::TT::Base producer may be just for you! Instead of working like a normal producer it provides a base class so you can cheaply build new producer modules based on templates.</p>

<p>It&#39;s simplest use is when we just want to put a single template in its own module. So to create a Foo producer we create a <em>Custom/Foo.pm</em> file as follows, putting our template in the __DATA__ section.</p>

<pre> package Custom::Foo.pm;
 use base qw/SQL::Translator::Producer::TT::Base/;
 # Use our new class as the producer
 sub produce { return __PACKAGE__-&#62;new( translator =&#62; shift )-&#62;run; };

 __DATA__
 [% FOREACH table IN schema.get_tables %]
 Table: [% table.name %]
 Fields:
 [% FOREACH field IN table.get_fields -%]
   [% field.name %]
 [% END -%]
 [% END %]</pre>

<p>For that we get a producer called Custom::Foo that we can now call like a normal producer (as long as the directory with <em>Custom/Foo.pm</em> is in our @INC path):</p>

<pre> $ sqlt -f YAML -t Custom-Foo foo.yaml</pre>

<p>The template gets variables of <code>schema</code> and <code>translator</code> to use in building its output. You also get a number of methods you can override to hook into the template generation.</p>

<p><b>tt_config</b> Allows you to set the config options used by the Template object. The Template Toolkit provides a huge number of options which allow you to do all sorts of magic (See <a href="../../Template/Manual/Config.html" class="podlinkpod"
>Template::Manual::Config</a> for details). This method provides a hook into them by returning a hash of options for the Template. e.g. Say you want to use the INTERPOLATE option to save some typing in your template;</p>

<pre> sub tt_config { ( INTERPOLATE =&#62; 1 ); }</pre>

<p>Another common use for this is to add you own filters to the template:</p>

<pre> sub tt_config {(
    INTERPOLATE =&#62; 1,
    FILTERS =&#62; { foo_filter =&#62; \&#38;foo_filter, }
 );}</pre>

<p>Another common extension is adding your own template variables. This is done with <b>tt_vars</b>:</p>

<pre> sub tt_vars { ( foo =&#62; &#34;bar&#34; ); }</pre>

<p>What about using template files instead of DATA sections? You can already - if you give a template on the command line your new producer will use that instead of reading the DATA section:</p>

<pre> $ sqlt -f YAML -t Custom-Foo --template foo.tt foo.yaml</pre>

<p>This is useful as you can set up a producer that adds a set of filters and variables that you can then use in templates given on the command line. (There is also a tt_schema method to over ride if you need even finer control over the source of your template). Note that if you leave out the DATA section all together then your producer will require a template file name to be given.</p>

<p>See <a href="../../SQL/Translator/Producer/TT/Base.html" class="podlinkpod"
>SQL::Translator::Producer::TT::Base</a> for more details.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Ken Y. Clark &#60;kclark@cpan.org&#62;.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
