<html><head><title>SQL::Translator::Diff</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:26 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#SNYOPSIS'>SNYOPSIS</a>
  <li class='indexItem indexItem1'><a href='#OPTIONS'>OPTIONS</a>
  <li class='indexItem indexItem1'><a href='#PRODUCER_FUNCTIONS'>PRODUCER FUNCTIONS</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>SQL::Translator::Diff - determine differences between two schemas</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Takes two input SQL::Translator::Schemas (or SQL files) and produces ALTER statments to make them the same</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SNYOPSIS"
>SNYOPSIS</a></h1>

<p>Simplest usage:</p>

<pre> use SQL::Translator::Diff;
 my $sql = SQL::Translator::Diff::schema_diff($source_schema, &#39;MySQL&#39;, $target_schema, &#39;MySQL&#39;, $options_hash)</pre>

<p>OO usage:</p>

<pre> use SQL::Translator::Diff;
 my $diff = SQL::Translator::Diff-&#62;new({
   output_db     =&#62; &#39;MySQL&#39;,
   source_schema =&#62; $source_schema,
   target_schema =&#62; $target_schema,
   %$options_hash,
 })-&#62;compute_differences-&#62;produce_diff_sql;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="OPTIONS"
>OPTIONS</a></h1>

<dl>
<dt><a name="ignore_index_names"
><b>ignore_index_names</b></a></dt>

<dd>
<p>Match indexes based on types and fields, ignoring name.</p>

<dt><a name="ignore_constraint_names"
><b>ignore_constraint_names</b></a></dt>

<dd>
<p>Match constrains based on types, fields and tables, ignoring name.</p>

<dt><a name="output_db"
><b>output_db</b></a></dt>

<dd>
<p>Which producer to use to produce the output.</p>

<dt><a name="case_insensitive"
><b>case_insensitive</b></a></dt>

<dd>
<p>Ignore case of table, field, index and constraint names when comparing</p>

<dt><a name="no_batch_alters"
><b>no_batch_alters</b></a></dt>

<dd>
<p>Produce each alter as a distinct <code>ALTER TABLE</code> statement even if the producer supports the ability to do all alters for a table as one statement.</p>

<dt><a name="ignore_missing_methods"
><b>ignore_missing_methods</b></a></dt>

<dd>
<p>If the diff would need a method that is missing from the producer, just emit a comment showing the method is missing, rather than dieing with an error</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PRODUCER_FUNCTIONS"
>PRODUCER FUNCTIONS</a></h1>

<p>The following producer functions should be implemented for completeness. If any of them are needed for a given diff, but not found, an error will be thrown.</p>

<ul>
<li><code>alter_create_constraint($con)</code></li>

<li><code>alter_drop_constraint($con)</code></li>

<li><code>alter_create_index($idx)</code></li>

<li><code>alter_drop_index($idx)</code></li>

<li><code>add_field($fld)</code></li>

<li><code>alter_field($old_fld, $new_fld)</code></li>

<li><code>rename_field($old_fld, $new_fld)</code></li>

<li><code>drop_field($fld)</code></li>

<li><code>alter_table($table)</code></li>

<li><code>drop_table($table)</code></li>

<li><code>rename_table($old_table, $new_table)</code> (optional)</li>

<li><code>batch_alter_table($table, $hash)</code> (optional)
<p>If the producer supports <code>batch_alter_table</code>, it will be called with the table to alter and a hash, the keys of which will be the method names listed above; values will be arrays of fields or constraints to operate on. In the case of the field functions that take two arguments this will appear as a hash.</p>

<p>I.e. the hash might look something like the following:</p>

<pre> {
   alter_create_constraint =&#62; [ $constraint1, $constraint2 ],
   add_field   =&#62; [ $field ],
   alter_field =&#62; [ [$old_field, $new_field] ]
 }</pre>
</li>

<li><code>preprocess_schema($class, $schema)</code> (optional)
<p><code>preprocess_schema</code> is called by the Diff code to allow the producer to normalize any data it needs to first. For example, the MySQL producer uses this method to ensure that FK contraint names are unique.</p>

<p>Basicaly any changes that need to be made to produce the SQL file for the schema should be done here, so that a diff between a parsed SQL file and (say) a parsed DBIx::Class::Schema object will be sane.</p>

<p>(As an aside, DBIx::Class, for instance, uses the presence of a <code>preprocess_schema</code> function on the producer to know that it can diff between the previous SQL file and its own internal representation. Without this method on th producer it will diff the two SQL files which is slower, but known to work better on old-style producers.)</p>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Original Author(s) unknown.</p>

<p>Refactor/re-write and more comprehensive tests by Ash Berlin <code>ash@cpan.org</code>.</p>

<p>Redevelopment sponsored by Takkle Inc.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
