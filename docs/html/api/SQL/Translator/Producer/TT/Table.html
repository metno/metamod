<html><head><title>SQL::Translator::Producer::TT::Table</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:26 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#OPTIONS'>OPTIONS</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#TODO'>TODO</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>SQL::Translator::Producer::TT::Table - Produces output using the Template Toolkit from a SQL schema,
per table.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  # Normal STDOUT version
  #
  my $translator     = SQL::Translator-&#62;new(
      from           =&#62; &#39;MySQL&#39;,
      filename       =&#62; &#39;foo_schema.sql&#39;,
      to             =&#62; &#39;TT::Table&#39;,
      producer_args  =&#62; {
          tt_table     =&#62; &#39;foo_table.tt&#39;,
      },
  );
  print $translator-&#62;translate;

  # To generate a file per table
  #
  my $translator     = SQL::Translator-&#62;new(
      from           =&#62; &#39;MySQL&#39;,
      filename       =&#62; &#39;foo_schema.sql&#39;,
      to             =&#62; &#39;TT::Table&#39;,
      producer_args  =&#62; {
          tt_table       =&#62; &#39;foo_table.tt.html&#39;,
          mk_files      =&#62; 1,
          mk_files_base =&#62; &#34;./doc/tables&#34;,
          mk_file_ext   =&#62; &#34;.html&#34;,
          on_exists     =&#62; &#34;replace&#34;,
      },
  );
  #
  # ./doc/tables/ now contains the templated tables as $tablename.html
  #</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Produces schema output using a given Template Tookit template, processing that template for each table in the schema. Optionally allows you to write the result for each table to a separate file.</p>

<p>It needs one additional producer_arg of <code>tt_table</code> which is the file name of the template to use. This template will be passed a template var of <code>table</code>, which is the current <a href="../../../../SQL/Translator/Producer/Table.html" class="podlinkpod"
>SQL::Translator::Producer::Table</a> table we are producing, which you can then use to walk the schema via the methods documented in that module. You also get <a href="../../../../schema.html" class="podlinkpod"
>schema</a> as a shortcut to the <a href="../../../../SQL/Translator/Producer/Schema.html" class="podlinkpod"
>SQL::Translator::Producer::Schema</a> for the table and <code>translator</code>, the <a href="../../../../SQL/Translator.html" class="podlinkpod"
>SQL::Translator</a> object for this parse in case you want to get access to any of the options etc set here.</p>

<p>Here&#39;s a brief example of what the template could look like:</p>

<pre>  [% table.name %]
  ================
  [% FOREACH field = table.get_fields %]
      [% field.name %]   [% field.data_type %]([% field.size %])
  [% END -%]</pre>

<p>See <em>t/data/template/table.tt</em> for a more complete example.</p>

<p>You can also set any of the options used to initiallize the Template object by adding them to your producer_args. See Template Toolkit docs for details of the options.</p>

<pre>  $translator          = SQL::Translator-&#62;new(
      to               =&#62; &#39;TT&#39;,
      producer_args    =&#62; {
          ttfile       =&#62; &#39;foo_template.tt&#39;,
          INCLUDE_PATH =&#62; &#39;/foo/templates/tt&#39;,
          INTERPOLATE  =&#62; 1,
      },
  );</pre>

<p>If you set <code>mk_files</code> and its additional options the producer will write a separate file for each table in the schema. This is useful for producing things like HTML documentation where every table gets its own page (you could also use TTSchema producer to add an index page). Its also particulary good for code generation where you want to produce a class file per table.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="OPTIONS"
>OPTIONS</a></h1>

<dl>
<dt><a name="tt_table"
>tt_table</a></dt>

<dd>
<p>File name of the template to run for each table.</p>

<dt><a name="mk_files"
>mk_files</a></dt>

<dd>
<p>Set to true to output a file for each table in the schema (as well as returning the whole lot back to the Translalor and hence STDOUT). The file will be named after the table, with the optional <code>mk_files_ext</code> added and placed in the directory <code>mk_files_base</code>.</p>

<dt><a name="mk_files_ext"
>mk_files_ext</a></dt>

<dd>
<p>Extension (without the dot) to add to the filename when using mk_files.</p>

<dt><a name="mk_files_base_=_DIR"
>mk_files_base = DIR</a></dt>

<dd>
<p>Dir to build the table files into when using mk_files. Defaults to the current directory.</p>

<dt><a name="mk_file_dir"
>mk_file_dir</a></dt>

<dd>
<p>Set true and if the file needs to written to a directory that doesn&#39;t exist, it will be created first.</p>

<dt><a name="on_exists_[Default:replace]"
>on_exists [Default:replace]</a></dt>

<dd>
<p>What to do if we are running with mk_files and a file already exists where we want to write our output. One of &#34;skip&#34;, &#34;die&#34;, &#34;replace&#34;, &#34;insert&#34;. The default is die.</p>

<p><b>replace</b> - Over-write the existing file with the new one, clobbering anything already there.</p>

<p><b>skip</b> - Leave the origional file as it was and don&#39;t write the new version anywhere.</p>

<p><b>die</b> - Die with an existing file error.</p>

<p><b>insert</b> - Insert the generated output into the file bewteen a set of special comments (defined by the following options.) Any code between the comments will be overwritten (ie the results from a previous produce) but the rest of the file is left alone (your custom code). This is particularly useful for code generation as it allows you to generate schema derived code and then add your own custom code to the file. Then when the schema changes you just re-produce to insert the new code.</p>

<dt><a name="insert_comment_start"
>insert_comment_start</a></dt>

<dd>
<p>The comment to look for in the file when on_exists is <code>insert</code>. Default is <code>SQLF INSERT START</code>. Must appear on it own line, with only whitespace either side, to be recognised.</p>

<dt><a name="insert_comment_end"
>insert_comment_end</a></dt>

<dd>
<p>The end comment to look for in the file when on_exists is <code>insert</code>. Default is <code>SQLF INSERT END</code>. Must appear on it own line, with only whitespace either side, to be recognised.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Mark Addison &#60;grommit@users.sourceforge.net&#62;.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TODO"
>TODO</a></h1>

<p>- Some tests for the various on exists options (they have been tested implicitley through use in a project but need some proper tests).</p>

<p>- More docs on code generation strategies.</p>

<p>- Better hooks for filename generation.</p>

<p>- Integrate with <a href="../../../../TT/Base.html" class="podlinkpod"
>TT::Base</a> and <a href="../../../../TTSchema.html" class="podlinkpod"
>TTSchema</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>SQL::Translator.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
