<html><head><title>Astro::FITS::Header</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:02 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Constructor'>Constructor</a>
    <li class='indexItem indexItem2'><a href='#Accessor_Methods'>Accessor Methods</a>
    <li class='indexItem indexItem2'><a href='#General_Methods'>General Methods</a>
    <li class='indexItem indexItem2'><a href='#Operator_Overloading'>Operator Overloading</a>
    <li class='indexItem indexItem2'><a href='#Private_methods'>Private methods</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#TIED_INTERFACE'>TIED INTERFACE</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Basic_hash_translation'>Basic hash translation</a>
    <li class='indexItem indexItem2'><a href='#Comment_cards'>Comment cards</a>
    <li class='indexItem indexItem2'><a href='#Multi-card_values'>Multi-card values</a>
    <li class='indexItem indexItem2'><a href='#Type_forcing'>Type forcing</a>
    <li class='indexItem indexItem2'><a href='#Sub-headers'>Sub-headers</a>
    <li class='indexItem indexItem2'><a href='#SIMPLE_and_END_cards'>SIMPLE and END cards</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Astro::FITS::Header - Object Orientated interface to FITS HDUs</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  $header = new Astro::FITS::Header( Cards =&#62; \@array );</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Stores information about a FITS header block in an object. Takes an hash with an array reference as an argument. The array should contain a list of FITS header cards as input.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Constructor"
>Constructor</a></h2>

<dl>
<dt><a name="new"
><b>new</b></a></dt>

<dd>
<p>Create a new instance from an array of FITS header cards.</p>

<pre>  $item = new Astro::FITS::Header( Cards =&#62; \@header );</pre>

<p>returns a reference to a Header object. If you pass in no cards, you get the (required) first SIMPLE card for free.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Accessor_Methods"
>Accessor Methods</a></h2>

<dl>
<dt><a name="tiereturnsref"
><b>tiereturnsref</b></a></dt>

<dd>
<p>Indicates whether the tied object should return multiple values as a single string joined by newline characters (false) or it should return a reference to an array containing all the values.</p>

<p>Only affects the tied interface.</p>

<pre>  tie %keywords, &#34;Astro::FITS::Header&#34;, $header, tiereturnsref =&#62; 1;
  $ref = $keywords{COMMENT};</pre>

<p>Defaults to returning a single string in all cases (for backwards compatibility)</p>

<dt><a name="subhdrs"
><b>subhdrs</b></a></dt>

<dd>
<p>Set or return the subheaders for a Header object. Arguments must be given as <code>Astro::FITS::Header</code> objects.</p>

<pre>    $header-&#62;subhdrs(@hdrs);
    @hdrs = $header-&#62;subhdrs;</pre>

<p>This method should be used when you have additional header components that should be associated with the primary header but they are not associated with a particular name, just an ordering.</p>

<p>FITS headers that are associated with a name can be stored directly in the header using an <code>Astro::FITS::Header::Item</code> of type &#39;HEADER&#39;.</p>

<dt><a name="item"
><b>item</b></a></dt>

<dd>
<p>Returns a FITS::Header:Item object referenced by index, <code>undef</code> if it does not exist.</p>

<pre>   $item = $header-&#62;item($index);</pre>

<dt><a name="get_wcs"
><b>get_wcs</b></a></dt>

<dd>
<p>Returns a Starlink::AST FrameSet object representing the WCS of the FITS Header.</p>

<pre>   $ast = $header-&#62;get_wcs();</pre>

<dt><a name="keyword"
><b>keyword</b></a></dt>

<dd>
<p>Returns keyword referenced by index, <code>undef</code> if it does not exist.</p>

<pre>   $keyword = $header-&#62;keyword($index);</pre>

<dt><a name="itembyname"
><b>itembyname</b></a></dt>

<dd>
<p>Returns an array of Header::Items for the requested keyword if called in list context, or the first matching Header::Item if called in scalar context. Returns <code>undef</code> if the keyword does not exist. The keyword may be a regular expression created with the <code>qr</code> operator.</p>

<pre>   @items = $header-&#62;itembyname($keyword);
   $item = $header-&#62;itembyname($keyword);</pre>

<dt><a name="itembytype"
><b>itembytype</b></a></dt>

<dd>
<p>Returns an array of Header::Items for the requested type if called in list context, or the first matching Header::Item if called in scalar context. See <code>Astro::FITS::Header::Item</code> for a list of allowed types.</p>

<pre>   @items = $header-&#62;itembytype( &#34;COMMENT&#34; );
   @items = $header-&#62;itembytype( &#34;HEADER&#34; );
   $item = $header-&#62;itembytype( &#34;INT&#34; );</pre>

<dt><a name="index"
><b>index</b></a></dt>

<dd>
<p>Returns an array of indices for the requested keyword if called in list context, or an empty array if it does not exist. The keyword may be a regular expression created with the <code>qr</code> operator.</p>

<pre>   @index = $header-&#62;index($keyword);</pre>

<p>If called in scalar context it returns the first item in the array, or <code>undef</code> if the keyword does not exist.</p>

<pre>   $index = $header-&#62;index($keyword);</pre>

<dt><a name="value"
><b>value</b></a></dt>

<dd>
<p>Returns an array of values for the requested keyword if called in list context, or an empty array if it does not exist. The keyword may be a regular expression created with the <code>qr</code> operator.</p>

<pre>   @value = $header-&#62;value($keyword);</pre>

<p>If called in scalar context it returns the first item in the array, or <code>undef</code> if the keyword does not exist.</p>

<dt><a name="comment"
><b>comment</b></a></dt>

<dd>
<p>Returns an array of comments for the requested keyword if called in list context, or an empty array if it does not exist. The keyword may be a regular expression created with the <code>qr</code> operator.</p>

<pre>   @comment = $header-&#62;comment($keyword);</pre>

<p>If called in scalar context it returns the first item in the array, or <code>undef</code> if the keyword does not exist.</p>

<pre>   $comment = $header-&#62;comment($keyword);</pre>

<dt><a name="insert"
><b>insert</b></a></dt>

<dd>
<p>Inserts a FITS header card object at position $index</p>

<pre>   $header-&#62;insert($index, $item);</pre>

<p>the object $item is not copied, multiple inserts of the same object mean that future modifications to the one instance of the inserted object will modify all inserted copies.</p>

<p>The insert position can be negative.</p>

<dt><a name="replace"
><b>replace</b></a></dt>

<dd>
<p>Replace FITS header card at index $index with card $item</p>

<pre>   $card = $header-&#62;replace($index, $item);</pre>

<p>returns the replaced card.</p>

<dt><a name="remove"
><b>remove</b></a></dt>

<dd>
<p>Removes a FITS header card object at position $index</p>

<pre>   $card = $header-&#62;remove($index);</pre>

<p>returns the removed card.</p>

<dt><a name="replacebyname"
><b>replacebyname</b></a></dt>

<dd>
<p>Replace FITS header cards with keyword $keyword with card $item</p>

<pre>   $card = $header-&#62;replacebyname($keyword, $item);</pre>

<p>returns the replaced card. The keyword may be a regular expression created with the <code>qr</code> operator.</p>

<dt><a name="removebyname"
><b>removebyname</b></a></dt>

<dd>
<p>Removes a FITS header card object by name</p>

<pre>  @card = $header-&#62;removebyname($keyword);</pre>

<p>returns the removed cards. The keyword may be a regular expression created with the <code>qr</code> operator.</p>

<dt><a name="splice"
><b>splice</b></a></dt>

<dd>
<p>Implements a standard splice operation for FITS headers</p>

<pre>   @cards = $header-&#62;splice($offset [,$length [, @list]]);
   $last_card = $header-&#62;splice($offset [,$length [, @list]]);</pre>

<p>Removes the FITS header cards from the header designated by $offset and $length, and replaces them with @list (if specified) which must be an array of FITS::Header::Item objects. Returns the cards removed. If offset is negative, counts from the end of the FITS header.</p>

<dt><a name="cards"
><b>cards</b></a></dt>

<dd>
<p>Return the object contents as an array of FITS cards.</p>

<pre>  @array = $header-&#62;cards;</pre>

<dt><a name="sizeof"
><b>sizeof</b></a></dt>

<dd>
<p>Returns the highest index in use in the FITS header. To get the total number of header items, add 1.</p>

<pre>  $number = $header-&#62;sizeof;</pre>

<dt><a name="allitems"
><b>allitems</b></a></dt>

<dd>
<p>Returns the header as an array of FITS::Header:Item objects.</p>

<pre>   @items = $header-&#62;allitems();</pre>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="General_Methods"
>General Methods</a></h2>

<dl>
<dt><a name="configure"
><b>configure</b></a></dt>

<dd>
<p>Configures the object, takes an array of FITS header cards, an array of Astro::FITS::Header::Item objects or a simple hash as input. If you feed in nothing at all, it uses a default array containing just the SIMPLE card required at the top of all FITS files.</p>

<pre>  $header-&#62;configure( Cards =&#62; \@array );
  $header-&#62;configure( Items =&#62; \@array );
  $header-&#62;configure( Hash =&#62; \%hash );</pre>

<p>Does nothing if the array is not supplied. If the hash scheme is used and the hash contains the special key of SUBHEADERS pointing to an array of hashes, these will be read as proper sub headers. All other references in the hash will be ignored. Note that the default key order will be retained in the object created via the hash.</p>

<dt><a name="merge_primary"
><b>merge_primary</b></a></dt>

<dd>
<p>Given the current header and a set of <code>Astro::FITS::Header</code> objects, return a merged FITS header (with the cards that have the same value and comment across all headers) along with, for each input, header objects containing all the header items that differ (including, by default, keys that are not present in all headers). Only the primary headers are merged, subheaders are ignored.</p>

<pre> ($clone) = $headerr-&#62;merge_primary();
 ($same, @different) = $header-&#62;merge_primary( $fits1, $fits2, ...);
 ($same, @different) = $header-&#62;merge_primary( \%options, $fits1, $fits2 );</pre>

<p>@different can be empty if all headers match (but see the <code>force_return_diffs</code> option) but if any headers are different there will always be the same number of headers in @different as supplied to the function (including the reference header). A clone of the input header (stripped of any subheaders) is returned if no comparison headers are supplied.</p>

<p>In scalar context, just returns the merged header.</p>

<pre>  $merged = $header-&#62;merge_primary( @hdrs );</pre>

<p>The options hash is itself optional. It contains the following keys:</p>

<pre> merge_unique - if an item is identical across multiple headers and only
                exists in those headers, propogate to the merged header rather
                than storing it in the difference headers.

 force_return_diffs - return an empty difference object per input header
                      even if there are no diffs</pre>

<dt><a name="freeze"
><b>freeze</b></a></dt>

<dd>
<p>Method to return a blessed reference to the object so that we can store ths object on disk using Data::Dumper module.</p>

<dt><a name="append"
><b>append</b></a></dt>

<dd>
<p>Append or update a card.</p>

<pre>  $header-&#62;append( $card );</pre>

<p>This method can take either an Astro::FITS::Header::Item object, an Astro::FITS::Header object, or a reference to an array of Astro::FITS::Header::Item objects.</p>

<p>In all cases, if the given Astro::FITS::Header::Item keyword exists in the header, then the value will be overwritten with the one passed to the method. Otherwise, the card will be appended to the end of the header.</p>

<p>Nothing is returned.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Operator_Overloading"
>Operator Overloading</a></h2>

<p>These operators are overloaded:</p>

<dl>
<dt><a name="&#34;&#34;"
><b>&#34;&#34;</b></a></dt>

<dd>
<p>When the object is used in a string context the FITS header block is returned as a single string.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Private_methods"
>Private methods</a></h2>

<p>These methods are for internal use only.</p>

<dl>
<dt><a name="_rebuild_lookup"
><b>_rebuild_lookup</b></a></dt>

<dd>
<p>Private function used to rebuild the lookup table after modifying the header block, its easier to do it this way than go through and add one to the indices of all header cards following the modifed card.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TIED_INTERFACE"
>TIED INTERFACE</a></h1>

<p>The <code>FITS::Header</code> object can also be tied to a hash:</p>

<pre>   use Astro::FITS::Header;

   $header = new Astro::FITS::Header( Cards =&#62; \@array );
   tie %hash, &#34;Astro::FITS::Header&#34;, $header

   $value = $hash{$keyword};
   $hash{$keyword} = $value;

   print &#34;keyword $keyword is present&#34; if exists $hash{$keyword};

   foreach my $key (keys %hash) {
      print &#34;$key = $hash{$key}\n&#34;;
   }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Basic_hash_translation"
>Basic hash translation</a></h2>

<p>Header value type is determined on-the-fly by parsing of the input values. Anything that parses as a number or a logical is converted to that before being put in a card (but see below).</p>

<p>Per-card comment fields can be accessed using the tied interface by specifying a key name of &#34;key_COMMENT&#34;. This works because in general &#34;_COMMENT&#34; is too long to be confused with a normal key name.</p>

<pre>  $comment = $hdr{CRPIX1_COMMENT};</pre>

<p>will return the comment associated with CRPIX1 header item. The comment can be modified in the same way:</p>

<pre>  $hdr{CRPIX1_COMMENT} = &#34;An axis&#34;;</pre>

<p>You can also modify the comment by slash-delimiting it when setting the associated keyword:</p>

<pre>  $hdr{CRPIX1} = &#34;34 / Set this field manually&#34;;</pre>

<p>If you want an actual slash character in your string field you must escape it with a backslash. (If you&#39;re in double quotes you have to use a double backslash):</p>

<pre>  $hdr{SLASHSTR} = &#39;foo\/bar / field contains &#34;foo/bar&#34;&#39;;</pre>

<p>Keywords are CaSE-inNSEnSiTIvE, unlike normal hash keywords. All keywords are translated to upper case internally, per the FITS standard.</p>

<p>Aside from the SIMPLE and END keywords, which are automagically placed at the beginning and end of the header respectively, keywords are included in the header in the order received. This gives you a modicum of control over card order, but if you actually care what order they&#39;re in, you probably don&#39;t want the tied interface.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Comment_cards"
>Comment cards</a></h2>

<p>Comment cards are a special case because they have no normal value and their comment field is treated as the hash value. The keywords &#34;COMMENT&#34; and &#34;HISTORY&#34; are magic and refer to comment cards; nearly all other keywords create normal valued cards. (see &#34;SIMPLE and END cards&#34;, below).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Multi-card_values"
>Multi-card values</a></h2>

<p>Multiline string values are broken up, one card per line in the string. Extra-long string values are handled gracefully: they get split among multiple cards, with a backslash at the end of each card image. They&#39;re transparently reassembled when you access the data, so that there is a strong analogy between multiline string values and multiple cards.</p>

<p>In general, appending to hash entries that look like strings does what you think it should. In particular, comment cards have a newline appended automatically on FETCH, so that</p>

<pre>  $hash{HISTORY} .= &#34;Added multi-line string support&#34;;</pre>

<p>adds a new HISTORY comment card, while</p>

<pre>  $hash{TELESCOP} .= &#34; dome B&#34;;</pre>

<p>only modifies an existing TELESCOP card.</p>

<p>You can make multi-line values by feeding in newline-delimited strings, or by assigning from an array ref. If you ask for a tag that has a multiline value it&#39;s always expanded to a multiline string, even if you fed in an array ref to start with. That&#39;s by design: multiline string expansion often acts as though you are getting just the first value back out, because perl string-to-number conversion stops at the first newline. So:</p>

<pre>  $hash{CDELT1} = [3,4,5];
  print $hash{CDELT1} + 99,&#34;\n$hash{CDELT1}&#34;;</pre>

<p>prints &#34;102\n3\n4\n5&#34;, and then</p>

<pre>  $hash{CDELT1}++;
  print $hash{CDELT1};</pre>

<p>prints &#34;4&#34;.</p>

<p>In short, most of the time you get what you want. But you can always fall back on the non-tied interface by calling methods like so:</p>

<pre>  ((tied $hash)-&#62;method())</pre>

<p>If you prefer to have multi-valued items automagically become array refs, then you can get that behavior using the <code>tiereturnsref</code> method:</p>

<pre>  tie %keywords, &#34;Astro::FITS::Header&#34;, $header, tiereturnsref =&#62; 1;</pre>

<p>When tiereturnsref is true, multi-valued items will be returned via a reference to an array (ties do not respect calling context). Note that if this is configured you will have to test each return value to see whether it is returning a real value or a reference to an array if you are not sure whether there will be more than one card with a duplicate name.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Type_forcing"
>Type forcing</a></h2>

<p>Because perl uses behind-the-scenes typing, there is an ambiguity between strings and numeric and/or logical values: sometimes you want to create a STRING card whose value could parse as a number or as a logical value, and perl kindly parses it into a number for you. To force string evaluation, feed in a trivial array ref:</p>

<pre>  $hash{NUMSTR} = 123;     # generates an INT card containing 123.
  $hash{NUMSTR} = &#34;123&#34;;   # generates an INT card containing 123.
  $hash{NUMSTR} = [&#34;123&#34;]; # generates a STRING card containing &#34;123&#34;.
  $hash{NUMSTR} = [123];   # generates a STRING card containing &#34;123&#34;.

  $hash{ALPHA} = &#34;T&#34;;      # generates a LOGICAL card containing T.
  $hash{ALPHA} = [&#34;T&#34;];    # generates a STRING card containing &#34;T&#34;.</pre>

<p>Calls to keys() or each() will, by default, return the keywords in the order in which they appear in the header.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Sub-headers"
>Sub-headers</a></h2>

<p>When the key refers to a subheader entry (ie an item of type &#34;HEADER&#34;), a hash reference is returned. If a hash reference is stored in a value it is converted to a <code>Astro::FITS::Header</code> object.</p>

<p>If the special key &#34;SUBHEADERS&#34; is used, it will return the array of subheaders, (as stored using the <code>subhdrs</code> method) each of which will be tied to a hash. Subheaders can be stored using normal array operations.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="SIMPLE_and_END_cards"
>SIMPLE and END cards</a></h2>

<p>No FITS interface would becomplete without special cases.</p>

<p>When you assign to SIMPLE or END, the tied interface ensures that they are first or last, respectively, in the deck -- as the FITS standard requires. Other cards are inserted in between the first and last elements, in the order that you define them.</p>

<p>The SIMPLE card is forced to FITS LOGICAL (boolean) type. The FITS standard forbids you from setting it to F, but you can if you want -- we&#39;re not the FITS police.</p>

<p>The END card is forced to a null type, so any value you assign to it will fall on the floor. If present in the deck, the END keyword always contains the value &#34; &#34;, which is both more-or-less invisible when printed and also true -- so you can test the return value to see if an END card is present.</p>

<p>SIMPLE and END come pre-defined from the constructor. If for some nefarious reason you want to remove them you must explicitly do so with &#34;delete&#34; or the appropriate method call from the object interface.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><code>Astro::FITS::Header::Item</code>, <code>Starlink::AST</code>, <code>Astro::FITS::Header::CFITSIO</code>, <code>Astro::FITS::Header::Item::NDF</code>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright (C) 2007-2011 Science and Technology Facilties Council. Copyright (C) 2001-2007 Particle Physics and Astronomy Research Council and portions Copyright (C) 2002 Southwest Research Institute. All Rights Reserved.</p>

<p>This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.</p>

<p>This program is distributed in the hope that it will be useful,but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>

<p>You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place,Suite 330, Boston, MA 02111-1307, USA</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<p>Alasdair Allan &#60;aa@astro.ex.ac.uk&#62;, Tim Jenness &#60;t.jenness@jach.hawaii.edu&#62;, Craig DeForest &#60;deforest@boulder.swri.edu&#62;, Jim Lewis &#60;jrl@ast.cam.ac.uk&#62;, Brad Cavanagh &#60;b.cavanagh@jach.hawaii.edu&#62;</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
