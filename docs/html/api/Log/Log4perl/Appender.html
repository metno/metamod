<html><head><title>Log::Log4perl::Appender</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:19 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#FUNCTIONS'>FUNCTIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Log%3A%3ALog4perl%3A%3AAppender-%3Enew(%24dispatcher_class_name%2C_...)%3B'>Log::Log4perl::Appender-&#62;new($dispatcher_class_name, ...);</a>
    <li class='indexItem indexItem2'><a href='#%24appender-%3Elayout(%24layout)%3B'>$appender-&#62;layout($layout);</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Supported_Appenders'>Supported Appenders</a>
  <li class='indexItem indexItem1'><a href='#Parameters_passed_on_to_the_appender%27s_log()_method'>Parameters passed on to the appender&#39;s log() method</a>
  <li class='indexItem indexItem1'><a href='#Pitfalls'>Pitfalls</a>
  <li class='indexItem indexItem1'><a href='#Appenders_Expecting_Message_Chunks'>Appenders Expecting Message Chunks</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Composite_Appenders'>Composite Appenders</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#LICENSE'>LICENSE</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Log::Log4perl::Appender - Log appender class</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use Log::Log4perl;

      # Define a logger
  my $logger = Log::Log4perl-&#62;get_logger(&#34;abc.def.ghi&#34;);

      # Define a layout
  my $layout = Log::Log4perl::Layout::PatternLayout-&#62;new(
                   &#34;%d (%F:%L)&#62; %m&#34;);

      # Define an appender
  my $appender = Log::Log4perl::Appender-&#62;new(
                   &#34;Log::Log4perl::Appender::Screen&#34;,
                   name =&#62; &#39;dumpy&#39;);

      # Set the appender&#39;s layout
  $appender-&#62;layout($layout);
  $logger-&#62;add_appender($appender);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This class is a wrapper around the <code>Log::Log4perl::Appender</code> appender set.</p>

<p>It also supports the &#60;Log::Dispatch::*&#62; collections of appenders. The module hides the idiosyncrasies of <code>Log::Dispatch</code> (e.g. every dispatcher gotta have a name, but there&#39;s no accessor to retrieve it) from <code>Log::Log4perl</code> and yet re-uses the extremely useful variety of dispatchers already created and tested in <code>Log::Dispatch</code>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FUNCTIONS"
>FUNCTIONS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Log::Log4perl::Appender-&#62;new($dispatcher_class_name,_...);"
>Log::Log4perl::Appender-&#62;new($dispatcher_class_name, ...);</a></h2>

<p>The constructor <code>new()</code> takes the name of the appender class to be created as a <i>string</i> (!) argument, optionally followed by a number of appender-specific parameters, for example:</p>

<pre>      # Define an appender
  my $appender = Log::Log4perl::Appender-&#62;new(
      &#34;Log::Log4perl::Appender::File&#34;
      filename =&#62; &#39;out.log&#39;);</pre>

<p>In case of <code>Log::Dispatch</code> appenders, if no <code>name</code> parameter is specified, the appender object will create a unique one (format <code>appNNN</code>), which can be retrieved later via the <code>name()</code> method:</p>

<pre>  print &#34;The appender&#39;s name is &#34;, $appender-&#62;name(), &#34;\n&#34;;</pre>

<p>Other parameters are specific to the appender class being used. In the case above, the <code>filename</code> parameter specifies the name of the <code>Log::Log4perl::Appender::File</code> dispatcher used.</p>

<p>However, if, for instance, you&#39;re using a <code>Log::Dispatch::Email</code> dispatcher to send you email, you&#39;ll have to specify <code>from</code> and <code>to</code> email addresses. Every dispatcher is different. Please check the <code>Log::Dispatch::*</code> documentation for the appender used for details on specific requirements.</p>

<p>The <code>new()</code> method will just pass these parameters on to a newly created <code>Log::Dispatch::*</code> object of the specified type.</p>

<p>When it comes to logging, the <code>Log::Log4perl::Appender</code> will transparently relay all messages to the <code>Log::Dispatch::*</code> object it carries in its womb.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$appender-&#62;layout($layout);"
>$appender-&#62;layout($layout);</a></h2>

<p>The <code>layout()</code> method sets the log layout used by the appender to the format specified by the <code>Log::Log4perl::Layout::*</code> object which is passed to it as a reference. Currently there&#39;s two layouts available:</p>

<pre>    Log::Log4perl::Layout::SimpleLayout
    Log::Log4perl::Layout::PatternLayout</pre>

<p>Please check the <a href="../../Log/Log4perl/Layout/SimpleLayout.html" class="podlinkpod"
>Log::Log4perl::Layout::SimpleLayout</a> and <a href="../../Log/Log4perl/Layout/PatternLayout.html" class="podlinkpod"
>Log::Log4perl::Layout::PatternLayout</a> manual pages for details.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Supported_Appenders"
>Supported Appenders</a></h1>

<p>Here&#39;s the list of appender modules currently available via <code>Log::Dispatch</code>, if not noted otherwise, written by Dave Rolsky:</p>

<pre>       Log::Dispatch::ApacheLog
       Log::Dispatch::DBI (by Tatsuhiko Miyagawa)
       Log::Dispatch::Email,
       Log::Dispatch::Email::MailSend,
       Log::Dispatch::Email::MailSendmail,
       Log::Dispatch::Email::MIMELite
       Log::Dispatch::File
       Log::Dispatch::FileRotate (by Mark Pfeiffer)
       Log::Dispatch::Handle
       Log::Dispatch::Screen
       Log::Dispatch::Syslog
       Log::Dispatch::Tk (by Dominique Dumont)</pre>

<p><code>Log4perl</code> doesn&#39;t care which ones you use, they&#39;re all handled in the same way via the <code>Log::Log4perl::Appender</code> interface. Please check the well-written manual pages of the <code>Log::Dispatch</code> hierarchy on how to use each one of them.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Parameters_passed_on_to_the_appender&#39;s_log()_method"
>Parameters passed on to the appender&#39;s log() method</a></h1>

<p>When calling the appender&#39;s log()-Funktion, Log::Log4perl will submit a list of key/value pairs. Entries to the following keys are guaranteed to be present:</p>

<dl>
<dt><a name="message"
>message</a></dt>

<dd>
<p>Text of the rendered message</p>

<dt><a name="log4p_category"
>log4p_category</a></dt>

<dd>
<p>Name of the category of the logger that triggered the event.</p>

<dt><a name="log4p_level"
>log4p_level</a></dt>

<dd>
<p>Log::Log4perl level of the event</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Pitfalls"
>Pitfalls</a></h1>

<p>Since the <code>Log::Dispatch::File</code> appender truncates log files by default, and most of the time this is <i>not</i> what you want, we&#39;ve instructed <code>Log::Log4perl</code> to change this behavior by slipping it the <code>mode =&#62; append</code> parameter behind the scenes. So, effectively with <code>Log::Log4perl</code> 0.23, a configuration like</p>

<pre>    log4perl.category = INFO, FileAppndr
    log4perl.appender.FileAppndr          = Log::Dispatch::File
    log4perl.appender.FileAppndr.filename = test.log
    log4perl.appender.FileAppndr.layout   = Log::Log4perl::Layout::SimpleLayout</pre>

<p>will always <i>append</i> to an existing logfile <code>test.log</code> while if you specifically request clobbering like in</p>

<pre>    log4perl.category = INFO, FileAppndr
    log4perl.appender.FileAppndr          = Log::Dispatch::File
    log4perl.appender.FileAppndr.filename = test.log
    log4perl.appender.FileAppndr.mode     = write
    log4perl.appender.FileAppndr.layout   = Log::Log4perl::Layout::SimpleLayout</pre>

<p>it will overwrite an existing log file <code>test.log</code> and start from scratch.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Appenders_Expecting_Message_Chunks"
>Appenders Expecting Message Chunks</a></h1>

<p>Instead of simple strings, certain appenders are expecting multiple fields as log messages. If a statement like</p>

<pre>    $logger-&#62;debug($ip, $user, &#34;signed in&#34;);</pre>

<p>causes an off-the-shelf <code>Log::Log4perl::Appender::Screen</code> appender to fire, the appender will just concatenate the three message chunks passed to it in order to form a single string. The chunks will be separated by a string defined in <code>$Log::Log4perl::JOIN_MSG_ARRAY_CHAR</code> (defaults to the empty string &#34;&#34;).</p>

<p>However, different appenders might choose to interpret the message above differently: An appender like <code>Log::Log4perl::Appender::DBI</code> might take the three arguments passed to the logger and put them in three separate rows into the DB.</p>

<p>The <code>warp_message</code> appender option is used to specify the desired behavior. If no setting for the appender property</p>

<pre>    # *** Not defined ***
    # log4perl.appender.SomeApp.warp_message</pre>

<p>is defined in the Log4perl configuration file, the appender referenced by <code>SomeApp</code> will fall back to the standard behavior and join all message chunks together, separating them by <code>$Log::Log4perl::JOIN_MSG_ARRAY_CHAR</code>.</p>

<p>If, on the other hand, it is set to a false value, like in</p>

<pre>    log4perl.appender.SomeApp.layout=NoopLayout
    log4perl.appender.SomeApp.warp_message = 0</pre>

<p>then the message chunks are passed unmodified to the appender as an array reference. Please note that you need to set the appender&#39;s layout to <code>Log::Log4perl::Layout::NoopLayout</code> which just leaves the messages chunks alone instead of formatting them or replacing conversion specifiers.</p>

<p><b>Please note that the standard appenders in the Log::Dispatch hierarchy will choke on a bunch of messages passed to them as an array reference. You can&#39;t use <code>warp_message = 0</code> (or the function name syntax defined below) on them. Only special appenders like Log::Log4perl::Appender::DBI can deal with this.</b></p>

<p>If (and now we&#39;re getting fancy) an appender expects message chunks, but we would like to pre-inspect and probably modify them before they&#39;re actually passed to the appender&#39;s <code>log</code> method, an inspection subroutine can be defined with the appender&#39;s <code>warp_message</code> property:</p>

<pre>    log4perl.appender.SomeApp.layout=NoopLayout
    log4perl.appender.SomeApp.warp_message = sub { \
                                           $#_ = 2 if @_ &#62; 3; \
                                           return @_; }</pre>

<p>The inspection subroutine defined by the <code>warp_message</code> property will receive the list of message chunks, like they were passed to the logger and is expected to return a corrected list. The example above simply limits the argument list to a maximum of three by cutting off excess elements and returning the shortened list.</p>

<p>Also, the warp function can be specified by name like in</p>

<pre>    log4perl.appender.SomeApp.layout=NoopLayout
    log4perl.appender.SomeApp.warp_message = main::filter_my_message</pre>

<p>In this example, <code>filter_my_message</code> is a function in the <code>main</code> package, defined like this:</p>

<pre>    my $COUNTER = 0;

    sub filter_my_message {
        my @chunks = @_;
        unshift @chunks, ++$COUNTER;
        return @chunks;
    }</pre>

<p>The subroutine above will add an ever increasing counter as an additional first field to every message passed to the <code>SomeApp</code> appender -- but not to any other appender in the system.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Composite_Appenders"
>Composite Appenders</a></h2>

<p>Composite appenders relay their messages to sub-appenders after providing some filtering or synchronizing functionality on incoming messages. Examples are Log::Log4perl::Appender::Synchronized, Log::Log4perl::Appender::Limit, and Log::Log4perl::Appender::Buffer. Check their manual pages for details.</p>

<p>Composite appender objects are regular Log::Log4perl::Appender objects, but they have the composite flag set:</p>

<pre>    $app-&#62;composite(1);</pre>

<p>and they define a post_init() method, which sets the appender it relays its messages to:</p>

<pre>    ###########################################
    sub post_init {
    ############################################
        my($self) = @_;
    
        if(! exists $self-&#62;{appender}) {
            die &#34;No appender defined for &#34; . __PACKAGE__;
        }
    
        my $appenders = Log::Log4perl-&#62;appenders();
        my $appender = Log::Log4perl-&#62;appenders()-&#62;{$self-&#62;{appender}};
    
        if(! defined $appender) {
            die &#34;Appender $self-&#62;{appender} not defined (yet) when &#34; .
                __PACKAGE__ . &#34; needed it&#34;;
        }
    
        $self-&#62;{app} = $appender;
    }</pre>

<p>The reason for this post-processing step is that the relay appender might not be defined yet when the composite appender gets defined. This can happen if Log4perl is initialized with a configuration file (which is the most common way to initialize Log4perl), because appenders spring into existance in unpredictable order.</p>

<p>For example, if you define a Synchronized appender like</p>

<pre>    log4perl.appender.Syncer            = Log::Log4perl::Appender::Synchronized
    log4perl.appender.Syncer.appender   = Logfile</pre>

<p>then Log4perl will set the appender&#39;s <code>appender</code> attribute to the <i>name</i> of the appender to finally relay messages to. After the Log4perl configuration file has been processed, Log4perl will remember to call the composite appender&#39;s post_init() method, which will grab the relay appender instance referred to by the name (Logfile) and set it in its <code>app</code> attribute. This is exactly what the code snippet above does.</p>

<p>But if you initialize Log4perl by its API, you need to remember to perform these steps. Here&#39;s the lineup:</p>

<pre>    use Log::Log4perl qw(get_logger :levels);
    
    my $fileApp = Log::Log4perl::Appender-&#62;new(
                &#39;Log::Log4perl::Appender::File&#39;,
                name     =&#62; &#39;MyFileApp&#39;,
                filename =&#62; &#39;mylog&#39;,
                mode     =&#62; &#39;append&#39;,
                );
    $fileApp-&#62;layout(
                Log::Log4perl::Layout::PatternLayout::Multiline-&#62;new(
                        &#39;%d{yyyy-MM-dd HH:mm:ss} %p [%c] #%P&#62; %m%n&#39;)
                );
      # Make the appender known to the system (without assigning it to
      # any logger
    Log::Log4perl-&#62;add_appender( $fileApp );
    
    my $syncApp = Log::Log4perl::Appender-&#62;new(
                &#39;Log::Log4perl::Appender::Synchronized&#39;,
                name       =&#62; &#39;MySyncApp&#39;,
                appender   =&#62; &#39;MyFileApp&#39;,
                key        =&#62; &#39;nem&#39;,
                );
    $syncApp-&#62;post_init();
    $syncApp-&#62;composite(1);

      # The Synchronized appender is now ready, assign it to a logger
      # and start logging.
    get_logger(&#34;&#34;)-&#62;add_appender($syncApp);

    get_logger(&#34;&#34;)-&#62;level($DEBUG);
    get_logger(&#34;wonk&#34;)-&#62;debug(&#34;waah!&#34;);</pre>

<p>The composite appender&#39;s log() function will typically cache incoming messages until a certain trigger condition is met and then forward a bulk of messages to the relay appender.</p>

<p>Caching messages is surprisingly tricky, because you want them to look like they came from the code location they were originally issued from and not from the location that triggers the flush. Luckily, Log4perl offers a cache mechanism for messages, all you need to do is call the base class&#39; log() function with an additional reference to a scalar, and then save its content to your composite appender&#39;s message buffer afterwards:</p>

<pre>    ###########################################
    sub log {
    ###########################################
        my($self, %params) = @_;

        # ... some logic to decide whether to cache or flush

            # Adjust the caller stack
        local $Log::Log4perl::caller_depth =
              $Log::Log4perl::caller_depth + 2;

            # We need to cache.
            # Ask the appender to save a cached message in $cache
        $self-&#62;{relay_app}-&#62;SUPER::log(\%params,
                             $params{log4p_category},
                             $params{log4p_level}, \my $cache);

            # Save it in the appender&#39;s message buffer
        push @{ $self-&#62;{buffer} }, $cache;
    }</pre>

<p>Note that before calling the log() method of the relay appender&#39;s base class (and thus introducing two additional levels on the call stack), we need to adjust the call stack to allow Log4perl to render cspecs like the %M or %L correctly. The cache will then contain a correctly rendered message, according to the layout of the target appender.</p>

<p>Later, when the time comes to flush the cached messages, a call to the relay appender&#39;s base class&#39; log_cached() method with the cached message as an argument will forward the correctly rendered message:</p>

<pre>    ###########################################
    sub log {
    ###########################################
        my($self, %params) = @_;

        # ... some logic to decide whether to cache or flush

            # Flush pending messages if we have any
        for my $cache (@{$self-&#62;{buffer}}) {
            $self-&#62;{relay_app}-&#62;SUPER::log_cached($cache);
        }
    }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>Log::Dispatch</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENSE"
>LICENSE</a></h1>

<p>Copyright 2002-2013 by Mike Schilli &#60;m@perlmeister.com&#62; and Kevin Goess &#60;cpan@goess.org&#62;.</p>

<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Please contribute patches to the project on Github:</p>

<pre>    http://github.com/mschilli/log4perl</pre>

<p>Send bug reports or requests for enhancements to the authors via our</p>

<p>MAILING LIST (questions, bug reports, suggestions/patches): log4perl-devel@lists.sourceforge.net</p>

<p>Authors (please contact them via the list above, not directly): Mike Schilli &#60;m@perlmeister.com&#62;, Kevin Goess &#60;cpan@goess.org&#62;</p>

<p>Contributors (in alphabetical order): Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy Grundman, Paul Harrington, Alexander Hartmaier David Hull, Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, Lars Thegler, David Viner, Mac Yang.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
