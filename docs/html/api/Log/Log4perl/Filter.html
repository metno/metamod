<html><head><title>Log::Log4perl::Filter</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:19 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Predefined_Filters'>Predefined Filters</a>
    <li class='indexItem indexItem2'><a href='#Attaching_a_filter_to_an_appender'>Attaching a filter to an appender</a>
    <li class='indexItem indexItem2'><a href='#Combining_filters_with_Log%3A%3ALog4perl%3A%3AFilter%3A%3ABoolean'>Combining filters with Log::Log4perl::Filter::Boolean</a>
    <li class='indexItem indexItem2'><a href='#Writing_your_own_filter_classes'>Writing your own filter classes</a>
    <li class='indexItem indexItem2'><a href='#A_Practical_Example%3A_Level_Matching'>A Practical Example: Level Matching</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#LICENSE'>LICENSE</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Log::Log4perl::Filter - Log4perl Custom Filter Base Class</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use Log::Log4perl;

  Log::Log4perl-&#62;init(\ &#60;&#60;&#39;EOT&#39;);
    log4perl.logger = INFO, Screen
    log4perl.filter.MyFilter        = sub { /let this through/ }
    log4perl.appender.Screen        = Log::Log4perl::Appender::Screen
    log4perl.appender.Screen.Filter = MyFilter
    log4perl.appender.Screen.layout = Log::Log4perl::Layout::SimpleLayout
  EOT

      # Define a logger
  my $logger = Log::Log4perl-&#62;get_logger(&#34;Some&#34;);

      # Let this through
  $logger-&#62;info(&#34;Here&#39;s the info, let this through!&#34;);

      # Suppress this
  $logger-&#62;info(&#34;Here&#39;s the info, suppress this!&#34;);

  #################################################################
  # StringMatch Filter:
  #################################################################
  log4perl.filter.M1               = Log::Log4perl::Filter::StringMatch
  log4perl.filter.M1.StringToMatch = let this through
  log4perl.filter.M1.AcceptOnMatch = true

  #################################################################
  # LevelMatch Filter:
  #################################################################
  log4perl.filter.M1               = Log::Log4perl::Filter::LevelMatch
  log4perl.filter.M1.LevelToMatch  = INFO
  log4perl.filter.M1.AcceptOnMatch = true</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Log4perl allows the use of customized filters in its appenders to control the output of messages. These filters might grep for certain text chunks in a message, verify that its priority matches or exceeds a certain level or that this is the 10th time the same message has been submitted -- and come to a log/no log decision based upon these circumstantial facts.</p>

<p>Filters have names and can be specified in two different ways in the Log4perl configuration file: As subroutines or as filter classes. Here&#39;s a simple filter named <code>MyFilter</code> which just verifies that the oncoming message matches the regular expression <code>/let this through/i</code>:</p>

<pre>    log4perl.filter.MyFilter        = sub { /let this through/i }</pre>

<p>It exploits the fact that when the subroutine defined above is called on a message, Perl&#39;s special <code>$_</code> variable will be set to the message text (prerendered, i.e. concatenated but not layouted) to be logged. The subroutine is expected to return a true value if it wants the message to be logged or a false value if doesn&#39;t.</p>

<p>Also, Log::Log4perl will pass a hash to the subroutine, containing all key/value pairs that it would pass to the corresponding appender, as specified in Log::Log4perl::Appender. Here&#39;s an example of a filter checking the priority of the oncoming message:</p>

<pre>  log4perl.filter.MyFilter        = sub {    \
       my %p = @_;                           \
       if($p{log4p_level} eq &#34;WARN&#34; or       \
          $p{log4p_level} eq &#34;INFO&#34;) {       \
           return 1;                         \
       }                                     \
       return 0;                             \
  }     </pre>

<p>If the message priority equals <code>WARN</code> or <code>INFO</code>, it returns a true value, causing the message to be logged.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Predefined_Filters"
>Predefined Filters</a></h2>

<p>For common tasks like verifying that the message priority matches a certain priority, there&#39;s already a set of predefined filters available. To perform an exact level match, it&#39;s much cleaner to use Log4perl&#39;s <code>LevelMatch</code> filter instead:</p>

<pre>  log4perl.filter.M1               = Log::Log4perl::Filter::LevelMatch
  log4perl.filter.M1.LevelToMatch  = INFO
  log4perl.filter.M1.AcceptOnMatch = true</pre>

<p>This will let the message through if its priority is INFO and suppress it otherwise. The statement can be negated by saying</p>

<pre>  log4perl.filter.M1.AcceptOnMatch = false</pre>

<p>instead. This way, the message will be logged if its priority is anything but INFO.</p>

<p>On a similar note, Log4perl&#39;s <code>StringMatch</code> filter will check the oncoming message for strings or regular expressions:</p>

<pre>  log4perl.filter.M1               = Log::Log4perl::Filter::StringMatch
  log4perl.filter.M1.StringToMatch = bl.. bl..
  log4perl.filter.M1.AcceptOnMatch = true</pre>

<p>This will open the gate for messages like <code>blah blah</code> because the regular expression in the <code>StringToMatch</code> matches them. Again, the setting of <code>AcceptOnMatch</code> determines if the filter is defined in a positive or negative way.</p>

<p>All class filter entries in the configuration file have to adhere to the following rule: Only after a filter has been defined by name and class/subroutine, its attribute values can be assigned, just like the <code>true</code> value above gets assigned to the <code>AcceptOnMatch</code> attribute <i>after</i> the filter <code>M1</code> has been defined.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Attaching_a_filter_to_an_appender"
>Attaching a filter to an appender</a></h2>

<p>Attaching a filter to an appender is as easy as assigning its name to the appender&#39;s <code>Filter</code> attribute:</p>

<pre>    log4perl.appender.MyAppender.Filter = MyFilter</pre>

<p>This will cause <code>Log::Log4perl</code> to call the filter subroutine/method every time a message is supposed to be passed to the appender. Depending on the filter&#39;s return value, <code>Log::Log4perl</code> will either continue as planned or withdraw immediately.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Combining_filters_with_Log::Log4perl::Filter::Boolean"
>Combining filters with Log::Log4perl::Filter::Boolean</a></h2>

<p>Sometimes, it&#39;s useful to combine the output of various filters to arrive at a log/no log decision. While Log4j, Log4perl&#39;s mother ship, has chosen to implement this feature as a filter chain, similar to Linux&#39; IP chains, Log4perl tries a different approach.</p>

<p>Typically, filter results will not need to be bumped along chains but combined in a programmatic manner using boolean logic. &#34;Log if this filter says &#39;yes&#39; and that filter says &#39;no&#39;&#34; is a fairly common requirement, but hard to implement as a chain.</p>

<p><code>Log::Log4perl::Filter::Boolean</code> is a specially predefined custom filter for Log4perl. It combines the results of other custom filters in arbitrary ways, using boolean expressions:</p>

<pre>    log4perl.logger = WARN, AppWarn, AppError

    log4perl.filter.Match1       = sub { /let this through/ }
    log4perl.filter.Match2       = sub { /and that, too/ }
    log4perl.filter.MyBoolean       = Log::Log4perl::Filter::Boolean
    log4perl.filter.MyBoolean.logic = Match1 || Match2

    log4perl.appender.Screen        = Log::Log4perl::Appender::Screen
    log4perl.appender.Screen.Filter = MyBoolean
    log4perl.appender.Screen.layout = Log::Log4perl::Layout::SimpleLayout</pre>

<p><code>Log::Log4perl::Filter::Boolean</code>&#39;s boolean expressions allow for combining different appenders by name using AND (&#38;&#38; or &#38;), OR (|| or |) and NOT (!) as logical expressions. Also, parentheses can be used for defining precedences. Operator precedence follows standard Perl conventions. Here&#39;s a bunch of examples:</p>

<pre>    Match1 &#38;&#38; !Match2            # Match1 and not Match2
    !(Match1 || Match2)          # Neither Match1 nor Match2
    (Match1 &#38;&#38; Match2) || Match3 # Both Match1 and Match2 or Match3</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Writing_your_own_filter_classes"
>Writing your own filter classes</a></h2>

<p>If none of Log::Log4perl&#39;s predefined filter classes fits your needs, you can easily roll your own: Just define a new class, derive it from the baseclass <code>Log::Log4perl::Filter</code>, and define its <code>new</code> and <code>ok</code> methods like this:</p>

<pre>    package Log::Log4perl::Filter::MyFilter;

    use base Log::Log4perl::Filter;

    sub new {
        my ($class, %options) = @_;

        my $self = { %options,
                   };
     
        bless $self, $class;

        return $self;
    }

    sub ok {
         my ($self, %p) = @_;

         # ... decide and return 1 or 0
    }

    1;</pre>

<p>Log4perl will call the ok() method to determine if the filter should let the message pass or not. A true return value indicates the message will be logged by the appender, a false value blocks it.</p>

<p>Values you&#39;ve defined for its attributes in Log4perl&#39;s configuration file, will be received through its <code>new</code> method:</p>

<pre>    log4perl.filter.MyFilter       = Log::Log4perl::Filter::MyFilter
    log4perl.filter.MyFilter.color = red</pre>

<p>will cause <code>Log::Log4perl::Filter::MyFilter</code>&#39;s constructor to be called like this:</p>

<pre>    Log::Log4perl::Filter::MyFilter-&#62;new( name  =&#62; &#34;MyFilter&#34;,
                                          color =&#62; &#34;red&#34; );</pre>

<p>The custom filter class should use this to set the object&#39;s attributes, to have them available later to base log/nolog decisions on it.</p>

<p><code>ok()</code> is the filter&#39;s method to tell if it agrees or disagrees with logging the message. It will be called by Log::Log4perl whenever it needs the filter to decide. A false value returned by <code>ok()</code> will block messages, a true value will let them through.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="A_Practical_Example:_Level_Matching"
>A Practical Example: Level Matching</a></h2>

<p>See <a href="../../Log/Log4perl/FAQ.html" class="podlinkpod"
>Log::Log4perl::FAQ</a> for this.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../../Log/Log4perl/Filter/LevelMatch.html" class="podlinkpod"
>Log::Log4perl::Filter::LevelMatch</a>, <a href="../../Log/Log4perl/Filter/LevelRange.html" class="podlinkpod"
>Log::Log4perl::Filter::LevelRange</a>, <a href="../../Log/Log4perl/Filter/StringRange.html" class="podlinkpod"
>Log::Log4perl::Filter::StringRange</a>, <a href="../../Log/Log4perl/Filter/Boolean.html" class="podlinkpod"
>Log::Log4perl::Filter::Boolean</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENSE"
>LICENSE</a></h1>

<p>Copyright 2002-2013 by Mike Schilli &#60;m@perlmeister.com&#62; and Kevin Goess &#60;cpan@goess.org&#62;.</p>

<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Please contribute patches to the project on Github:</p>

<pre>    http://github.com/mschilli/log4perl</pre>

<p>Send bug reports or requests for enhancements to the authors via our</p>

<p>MAILING LIST (questions, bug reports, suggestions/patches): log4perl-devel@lists.sourceforge.net</p>

<p>Authors (please contact them via the list above, not directly): Mike Schilli &#60;m@perlmeister.com&#62;, Kevin Goess &#60;cpan@goess.org&#62;</p>

<p>Contributors (in alphabetical order): Ateeq Altaf, Cory Bennett, Jens Berthold, Jeremy Bopp, Hutton Davidson, Chris R. Donnelly, Matisse Enzer, Hugh Esco, Anthony Foiani, James FitzGibbon, Carl Franks, Dennis Gregorovic, Andy Grundman, Paul Harrington, Alexander Hartmaier David Hull, Robert Jacobson, Jason Kohles, Jeff Macdonald, Markus Peter, Brett Rann, Peter Rabbitson, Erik Selberg, Aaron Straup Cope, Lars Thegler, David Viner, Mac Yang.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
