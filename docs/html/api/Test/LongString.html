<html><head><title>Test::LongString</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:28 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#FUNCTIONS'>FUNCTIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#is_string(_%24string%2C_%24expected_%5B%2C_%24label_%5D_)'>is_string( $string, $expected [, $label ] )</a>
    <li class='indexItem indexItem2'><a href='#is_string_nows(_%24string%2C_%24expected_%5B%2C_%24label_%5D_)'>is_string_nows( $string, $expected [, $label ] )</a>
    <li class='indexItem indexItem2'><a href='#like_string(_%24string%2C_qr%2Fregex%2F_%5B%2C_%24label_%5D_)'>like_string( $string, qr/regex/ [, $label ] )</a>
    <li class='indexItem indexItem2'><a href='#unlike_string(_%24string%2C_qr%2Fregex%2F_%5B%2C_%24label_%5D_)'>unlike_string( $string, qr/regex/ [, $label ] )</a>
    <li class='indexItem indexItem2'><a href='#contains_string(_%24string%2C_%24substring_%5B%2C_%24label_%5D_)'>contains_string( $string, $substring [, $label ] )</a>
    <li class='indexItem indexItem2'><a href='#lacks_string(_%24string%2C_%24substring_%5B%2C_%24label_%5D_)'>lacks_string( $string, $substring [, $label ] )</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#CONTROLLING_OUTPUT'>CONTROLLING OUTPUT</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Test::LongString - tests strings for equality,
with more helpful failures</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    use Test::More tests =&#62; 1;
    use Test::LongString;
    like_string( $html, qr/(perl|cpan)\.org/ );

    #     Failed test (html-test.t at line 12)
    #          got: &#34;&#60;!DOCTYPE HTML PUBLIC &#34;-//W3C//DTD HTML 4.01 Trans&#34;...
    #       length: 58930
    #     doesn&#39;t match &#39;(?-xism:(perl|cpan)\.org)&#39;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This module provides some drop-in replacements for the string comparison functions of <a href="../Test/More.html" class="podlinkpod"
>Test::More</a>, but which are more suitable when you test against long strings. If you&#39;ve ever had to search for text in a multi-line string like an HTML document, or find specific items in binary data, this is the module for you.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FUNCTIONS"
>FUNCTIONS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="is_string(_$string,_$expected_[,_$label_]_)"
>is_string( $string, $expected [, $label ] )</a></h2>

<p><code>is_string()</code> is equivalent to <code>Test::More::is()</code>, but with more helpful diagnostics in case of failure.</p>

<ul>
<li>It doesn&#39;t print the entire strings in the failure message.</li>

<li>It reports the lengths of the strings that have been compared.</li>

<li>It reports the length of the common prefix of the strings.</li>

<li>It reports the line and column the strings started to differ on.</li>

<li>In the diagnostics, non-ASCII characters are escaped as <code>\x{xx}</code>.</li>
</ul>

<p>For example:</p>

<pre>    is_string( $soliloquy, $juliet );

    #     Failed test (soliloquy.t at line 15)
    #          got: &#34;To be, or not to be: that is the question:\x{0a}Whether&#34;...
    #       length: 1490
    #     expected: &#34;O Romeo, Romeo,\x{0a}wherefore art thou Romeo?\x{0a}Deny thy&#34;...
    #       length: 154
    #     strings begin to differ at char 1 (line 1 column 1)</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="is_string_nows(_$string,_$expected_[,_$label_]_)"
>is_string_nows( $string, $expected [, $label ] )</a></h2>

<p>Like <code>is_string()</code>, but removes whitepace (in the <code>\s</code> sense) from the arguments before comparing them.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="like_string(_$string,_qr/regex/_[,_$label_]_)"
>like_string( $string, qr/regex/ [, $label ] )</a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="unlike_string(_$string,_qr/regex/_[,_$label_]_)"
>unlike_string( $string, qr/regex/ [, $label ] )</a></h2>

<p><code>like_string()</code> and <code>unlike_string()</code> are replacements for <code>Test::More:like()</code> and <code>unlike()</code> that only print the beginning of the received string in the output. Unfortunately, they can&#39;t print out the position where the regex failed to match.</p>

<pre>    like_string( $soliloquy, qr/Romeo|Juliet|Mercutio|Tybalt/ );

    #     Failed test (soliloquy.t at line 15)
    #          got: &#34;To be, or not to be: that is the question:\x{0a}Whether&#34;...
    #       length: 1490
    #     doesn&#39;t match &#39;(?-xism:Romeo|Juliet|Mercutio|Tybalt)&#39;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="contains_string(_$string,_$substring_[,_$label_]_)"
>contains_string( $string, $substring [, $label ] )</a></h2>

<p><code>contains_string()</code> searches for <i>$substring</i> in <i>$string</i>. It&#39;s the same as <code>like_string()</code>, except that it&#39;s not a regular expression search.</p>

<pre>    contains_string( $soliloquy, &#34;Romeo&#34; );

    #     Failed test (soliloquy.t at line 10)
    #         searched: &#34;To be, or not to be: that is the question:\x{0a}Whether&#34;...
    #   and can&#39;t find: &#34;Romeo&#34;</pre>

<p>As of version 0.12, <code>contains_string()</code> will also report the Longest Common SubString (LCSS) found in <i>$string</i> and, if the LCSS is short enough, the surroundings will also be shown under <i>LCSS Context</i>. This should help debug tests for really long strings like HTML output, so you&#39;ll get something like:</p>

<pre>   contains_string( $html, &#39;&#60;div id=&#34;MainContent&#34;&#62;&#39; );
   #   Failed test at t/foo.t line 10.
   #     searched: &#34;&#60;!DOCTYPE html PUBLIC &#34;-//W3C//DTD XHTML 1.0 Stric&#34;...
   #   can&#39;t find: &#34;&#60;div id=&#34;MainContent&#34;&#62;&#34;
   #         LCSS: &#34;ainContent&#34;&#34;
   # LCSS context: &#34;dolor sit amet&#60;/span&#62;\x{0a}&#60;div id=&#34;mainContent&#34; class=&#34;</pre>

<p>You can turn off LCSS reporting by setting <code>$Test::LongString::LCSS</code> to 0, or by specifying an argument to <code>use</code>:</p>

<pre>    use Test::LongString lcss =&#62; 0;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="lacks_string(_$string,_$substring_[,_$label_]_)"
>lacks_string( $string, $substring [, $label ] )</a></h2>

<p><code>lacks_string()</code> makes sure that <i>$substring</i> does NOT exist in <i>$string</i>. It&#39;s the same as <code>like_string()</code>, except that it&#39;s not a regular expression search.</p>

<pre>    lacks_string( $soliloquy, &#34;slings&#34; );

    #     Failed test (soliloquy.t at line 10)
    #         searched: &#34;To be, or not to be: that is the question:\x{0a}Whether&#34;...
    #        and found: &#34;slings&#34;
    #      at position: 147 (line 3 column 4)</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CONTROLLING_OUTPUT"
>CONTROLLING OUTPUT</a></h1>

<p>By default, only the first 50 characters of the compared strings are shown in the failure message. This value is in <code>$Test::LongString::Max</code>, and can be set at run-time.</p>

<p>You can also set it by specifying an argument to <code>use</code>:</p>

<pre>    use Test::LongString max =&#62; 100;</pre>

<p>When the compared strings begin to differ after a large prefix, Test::LongString will not print them from the beginning, but will start at the middle, more precisely at <code>$Test::LongString::Context</code> characters before the first difference. By default this value is 10 characters. If you want Test::LongString to always print the beginning of compared strings no matter where they differ, undefine <code>$Test::LongString::Context</code>.</p>

<p>When computing line numbers this module uses &#34;\n&#34; to count line endings. This may not be appropriate for strings on your platform, and can be overriden by setting the <code>$Test::LongString::EOL</code> variable to a suitable regular expression (either a reference to a regular expression or a string that can be interpolated into a regular expression.)</p>

<p>You can also set it by specifying an argument to <code>use</code>:</p>

<pre>    use Test::LongString eol =&#62; &#34;\x{0a}\x{0c}&#34;;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Written by Rafael Garcia-Suarez. Thanks to Mark Fowler (and to Joss Whedon) for the inspirational <a href="../Acme/Test/Buffy.html" class="podlinkpod"
>Acme::Test::Buffy</a>. Thanks to Andy Lester for lots of patches.</p>

<p>This program is free software; you may redistribute it and/or modify it under the same terms as Perl itself.</p>

<p>A git repository for this module is available at</p>

<pre>    git://github.com/rgs/Test-LongString.git</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../Test/Builder.html" class="podlinkpod"
>Test::Builder</a>, <a href="../Test/Builder/Tester.html" class="podlinkpod"
>Test::Builder::Tester</a>, <a href="../Test/More.html" class="podlinkpod"
>Test::More</a>.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
