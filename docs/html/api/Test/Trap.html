<html><head><title>Test::Trap</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:28 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#EXPORT'>EXPORT</a>
  <li class='indexItem indexItem1'><a href='#FUNCTION'>FUNCTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#trap_BLOCK'>trap BLOCK</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#TRAP_LAYERS'>TRAP LAYERS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#%3Araw'>:raw</a>
    <li class='indexItem indexItem2'><a href='#%3Adie'>:die</a>
    <li class='indexItem indexItem2'><a href='#%3Aexit'>:exit</a>
    <li class='indexItem indexItem2'><a href='#%3Aflow'>:flow</a>
    <li class='indexItem indexItem2'><a href='#%3Astdout%2C_%3Astderr'>:stdout, :stderr</a>
    <li class='indexItem indexItem2'><a href='#%3Astdout(perlio)%2C_%3Astderr(perlio)'>:stdout(perlio), :stderr(perlio)</a>
    <li class='indexItem indexItem2'><a href='#%3Astdout(tempfile)%2C_%3Astderr(tempfile)'>:stdout(tempfile), :stderr(tempfile)</a>
    <li class='indexItem indexItem2'><a href='#%3Astdout(a%3Bb%3Bc)%2C_%3Astderr(a%2Cb%2Cc)'>:stdout(a;b;c), :stderr(a,b,c)</a>
    <li class='indexItem indexItem2'><a href='#%3Awarn'>:warn</a>
    <li class='indexItem indexItem2'><a href='#%3Adefault'>:default</a>
    <li class='indexItem indexItem2'><a href='#%3Aon_fail(m)'>:on_fail(m)</a>
    <li class='indexItem indexItem2'><a href='#%3Avoid%2C_%3Ascalar%2C_%3Alist'>:void, :scalar, :list</a>
    <li class='indexItem indexItem2'><a href='#%3Aoutput(a%3Bb%3Bc)'>:output(a;b;c)</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#RESULT_ACCESSORS'>RESULT ACCESSORS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#leaveby'>leaveby</a>
    <li class='indexItem indexItem2'><a href='#die'>die</a>
    <li class='indexItem indexItem2'><a href='#exit'>exit</a>
    <li class='indexItem indexItem2'><a href='#return_%5BINDEX_...%5D'>return [INDEX ...]</a>
    <li class='indexItem indexItem2'><a href='#stdout%2C_stderr'>stdout, stderr</a>
    <li class='indexItem indexItem2'><a href='#warn_%5BINDEX%5D'>warn [INDEX]</a>
    <li class='indexItem indexItem2'><a href='#wantarray'>wantarray</a>
    <li class='indexItem indexItem2'><a href='#list%2C_scalar%2C_void'>list, scalar, void</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#RESULT_TESTS'>RESULT TESTS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#ACCESSOR_ok_%5BINDEX%2C%5D_TEST_NAME'>ACCESSOR_ok [INDEX,] TEST_NAME</a>
    <li class='indexItem indexItem2'><a href='#ACCESSOR_nok_%5BINDEX%2C%5D_TEST_NAME'>ACCESSOR_nok [INDEX,] TEST_NAME</a>
    <li class='indexItem indexItem2'><a href='#ACCESSOR_is_%5BINDEX%2C%5D_SCALAR%2C_TEST_NAME'>ACCESSOR_is [INDEX,] SCALAR, TEST_NAME</a>
    <li class='indexItem indexItem2'><a href='#ACCESSOR_isnt_%5BINDEX%2C%5D_SCALAR%2C_TEST_NAME'>ACCESSOR_isnt [INDEX,] SCALAR, TEST_NAME</a>
    <li class='indexItem indexItem2'><a href='#ACCESSOR_isa_ok_%5BINDEX%2C%5D_SCALAR%2C_INVOCANT_NAME'>ACCESSOR_isa_ok [INDEX,] SCALAR, INVOCANT_NAME</a>
    <li class='indexItem indexItem2'><a href='#ACCESSOR_like_%5BINDEX%2C%5D_REGEX%2C_TEST_NAME'>ACCESSOR_like [INDEX,] REGEX, TEST_NAME</a>
    <li class='indexItem indexItem2'><a href='#ACCESSOR_unlike_%5BINDEX%2C%5D_REGEX%2C_TEST_NAME'>ACCESSOR_unlike [INDEX,] REGEX, TEST_NAME</a>
    <li class='indexItem indexItem2'><a href='#ACCESSOR_is_deeply_STRUCTURE%2C_TEST_NAME'>ACCESSOR_is_deeply STRUCTURE, TEST_NAME</a>
    <li class='indexItem indexItem2'><a href='#did_die%2C_did_exit%2C_did_return'>did_die, did_exit, did_return</a>
    <li class='indexItem indexItem2'><a href='#quiet'>quiet</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#UTILITIES'>UTILITIES</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#diag_all'>diag_all</a>
    <li class='indexItem indexItem2'><a href='#diag_all_once'>diag_all_once</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#CAVEATS'>CAVEATS</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_%26_LICENSE'>COPYRIGHT &#38; LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Test::Trap - Trap exit codes,
exceptions,
output,
etc.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>Version 0.2.2</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use Test::More;
  use Test::Trap;

  my @r = trap { some_code(@some_parameters) };
  is ( $trap-&#62;exit, 1, &#39;Expecting &#38;some_code to exit with 1&#39; );
  is ( $trap-&#62;stdout, &#39;&#39;, &#39;Expecting no STDOUT&#39; );
  like ( $trap-&#62;stderr, qr/^Bad parameters; exiting\b/, &#39;Expecting warnings.&#39; );</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Primarily (but not exclusively) for use in test scripts: A block eval on steroids, configurable and extensible, but by default trapping (Perl) STDOUT, STDERR, warnings, exceptions, would-be exit codes, and return values from boxed blocks of test code.</p>

<p>The values collected by the latest trap can then be queried or tested through a special trap object.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXPORT"
>EXPORT</a></h1>

<p>A function and a scalar may be exported by any name. The function (by default named <code>trap</code>) is an analogue to block eval(), and the scalar (by default named <code>$trap</code>) is the corresponding analogue to <code>$@</code>.</p>

<p>Optionally, you may specify the layers of the exported trap. Layers may be specified by name, with a colon sigil. Multiple layers may be given in a list, or just stringed together like <code>:flow:stderr:warn</code>.</p>

<p>(For the advanced user, you may also specify anonymous layer implementations -- i.e. an appropriate subroutine.)</p>

<p>See below for a list of the built-in layers, most of which are enabled by default. Note, finally, that the ordering of the layers matter: The :raw layer is always on the bottom (anything underneath it is ignored), and any other &#34;flow control&#34; layers used should be right down there with it.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FUNCTION"
>FUNCTION</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="trap_BLOCK"
>trap BLOCK</a></h2>

<p>This function may be exported by any name, but defaults to <code>trap</code>.</p>

<p>By default, traps exceptions (like block eval), but also exits and exit codes, returns and return values, context, and (Perl) output on STDOUT or STDERR, and warnings. All information trapped can be queried through the trap object, which is by default exported as <code>$trap</code>, but can be exported by any name.</p>

<p>The value returned from <code>trap</code> mimics that returned from <code>eval</code>: If the <i>BLOCK</i> would die or exit, it returns an undefined value in scalar context or an empty list in list context; otherwise it returns whatever the <i>BLOCK</i> would return in the given context (also available as the trapped return values).</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TRAP_LAYERS"
>TRAP LAYERS</a></h1>

<p>Exactly what the <code>trap</code> traps depends on the layers of the trap. It is possible to register more (see <a href="../Test/Trap/Builder.html" class="podlinkpod"
>Test::Trap::Builder</a>), but the following layers are pre-defined by this module:</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name=":raw"
>:raw</a></h2>

<p>The terminating layer, at which the processing of the layers stops, and the actual call to the user code is performed. On success, it collects the return value(s) in the appropriate context. Pushing the :raw layer on a trap will for most purposes remove all layers below.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name=":die"
>:die</a></h2>

<p>The layer emulating block eval, capturing normal exceptions.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name=":exit"
>:exit</a></h2>

<p>The third &#34;flow control&#34; layer, capturing exit codes if anything used in the dynamic scope of the trap calls CORE::GLOBAL::exit(). (See CAVEATS below for more.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name=":flow"
>:flow</a></h2>

<p>A pseudo-layer shortcut for :raw:die:exit. Since this includes :raw, pushing :flow on a trap will remove all layers below.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name=":stdout,_:stderr"
>:stdout, :stderr</a></h2>

<p>Layers trapping Perl output on STDOUT and STDERR, respectively.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name=":stdout(perlio),_:stderr(perlio)"
>:stdout(perlio), :stderr(perlio)</a></h2>

<p>As above, but specifying a backend implemented using PerlIO::scalar. If this backend is not available (typically if PerlIO is not), this is an error.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name=":stdout(tempfile),_:stderr(tempfile)"
>:stdout(tempfile), :stderr(tempfile)</a></h2>

<p>As above, but specifying a backend implemented using File::Temp. Note that this is the default implementation, unless the <code>:output()</code> layer is used to set another default.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name=":stdout(a;b;c),_:stderr(a,b,c)"
>:stdout(a;b;c), :stderr(a,b,c)</a></h2>

<p>(Either syntax, commas or semicolons, is permitted, as is any number of names in the list.) As above, but specifying the backend implementation by the first existing name among <i>a</i>, <i>b</i>, and <i>c</i>. If no such implementation is available, this is an error.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name=":warn"
>:warn</a></h2>

<p>A layer trapping warnings, with additional tee: If STDERR is open, it will also print the warnings there. (This output may be trapped by the :stderr layer, be it above or below the :warn layer.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name=":default"
>:default</a></h2>

<p>A pseudo-layer short-cut for :raw:die:exit:stdout:stderr:warn. Since this includes :raw, pushing :default on a trap will remove all layers below. The other interesting property of :default is that it is what every trap starts with: In order not to include any of the six layers that make up :default, you need to push a terminating layer (such as :raw or :flow) on the trap.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name=":on_fail(m)"
>:on_fail(m)</a></h2>

<p>A (non-default) pseudo-layer that installs a callback method (by name) <i>m</i> to be run on test failures. To run the <a href="#diag_all" class="podlinkpod"
>&#34;diag_all&#34;</a> method every time a test fails:</p>

<pre>  use Test::Trap qw/ :on_fail(diag_all) /;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name=":void,_:scalar,_:list"
>:void, :scalar, :list</a></h2>

<p>Runs the trapped user code in void, scalar, or list context, respectively. (By default, the code is run in whatever context the trap itself is in.)</p>

<p>If more than one of these layers are pushed on the trap, the deepest (that is, leftmost) takes precedence:</p>

<pre>  use Test::Trap qw/ :scalar:void:list /;
  trap { 42, 13 };
  $trap-&#62;return_is_deeply( [ 13 ], &#39;Scalar comma.&#39; );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name=":output(a;b;c)"
>:output(a;b;c)</a></h2>

<p>A (non-default) pseudo-layers that sets the default backend layer implementation for any output trapping (<code>:stdout</code>, <code>:stderr</code>, or other similarly defined) layers already on the trap.</p>

<pre>  use Test::Trap qw/ :output(systemsafe) /;
  trap { system echo =&#62; &#39;Hello Unix!&#39; }; # trapped!</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="RESULT_ACCESSORS"
>RESULT ACCESSORS</a></h1>

<p>The following methods may be called on the trap objects after any trap has been sprung, and access the outcome of the run.</p>

<p>Any property will be undef if not actually trapped -- whether because there is no layer to trap them or because flow control passed them by. (If there is an active and successful trap layer, empty strings and empty arrays trapped will of course be defined.)</p>

<p>When properties are set, their values will be as follows:</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="leaveby"
>leaveby</a></h2>

<p>A string indicating how the trap terminated: <code>return</code>, <code>die</code>, or <code>exit</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="die"
>die</a></h2>

<p>The exception, if the latest trap threw one.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="exit"
>exit</a></h2>

<p>The exit code, if the latest trap tried to exit.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="return_[INDEX_...]"
>return [INDEX ...]</a></h2>

<p>Returns undef if the latest trap did not terminate with a return; otherwise returns three different views of the return array:</p>

<ul>
<li>if no <i>INDEX</i> is passed, returns a reference to the array (NB! an empty array of indices qualifies as &#34;no index&#34;)</li>

<li>if called with at least one <i>INDEX</i> in scalar context, returns the array element indexed by the first <i>INDEX</i> (ignoring the rest)</li>

<li>if called with at least one <i>INDEX</i> in list context, returns the slice of the array by these indices</li>
</ul>

<p>Note: The array will hold but a single value if the trap was sprung in scalar context, and will be empty if it was in void context.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="stdout,_stderr"
>stdout, stderr</a></h2>

<p>The captured output on the respective file handles.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="warn_[INDEX]"
>warn [INDEX]</a></h2>

<p>Returns undef if the latest trap had no warning-trapping layer; otherwise returns three different views of the warn array:</p>

<ul>
<li>if no <i>INDEX</i> is passed, returns a reference to the array (NB! an empty array of indices qualifies as &#34;no index&#34;)</li>

<li>if called with at least one <i>INDEX</i> in scalar context, returns the array element indexed by the first <i>INDEX</i> (ignoring the rest)</li>

<li>if called with at least one <i>INDEX</i> in list context, returns the slice of the array by these indices</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="wantarray"
>wantarray</a></h2>

<p>The context in which the latest code trapped was called. (By default a propagated context, but layers can override this.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="list,_scalar,_void"
>list, scalar, void</a></h2>

<p>True if the latest code trapped was called in the indicated context. (By default the code will be called in a propagated context, but layers can override this.)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="RESULT_TESTS"
>RESULT TESTS</a></h1>

<p>For each accessor, a number of convenient standard test methods are also available. By default, these are a few standard tests from Test::More, plus the <code>nok</code> test (a negated <code>ok</code> test). All for convenience:</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ACCESSOR_ok_[INDEX,]_TEST_NAME"
><i>ACCESSOR</i>_ok [INDEX,] TEST_NAME</a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ACCESSOR_nok_[INDEX,]_TEST_NAME"
><i>ACCESSOR</i>_nok [INDEX,] TEST_NAME</a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ACCESSOR_is_[INDEX,]_SCALAR,_TEST_NAME"
><i>ACCESSOR</i>_is [INDEX,] SCALAR, TEST_NAME</a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ACCESSOR_isnt_[INDEX,]_SCALAR,_TEST_NAME"
><i>ACCESSOR</i>_isnt [INDEX,] SCALAR, TEST_NAME</a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ACCESSOR_isa_ok_[INDEX,]_SCALAR,_INVOCANT_NAME"
><i>ACCESSOR</i>_isa_ok [INDEX,] SCALAR, INVOCANT_NAME</a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ACCESSOR_like_[INDEX,]_REGEX,_TEST_NAME"
><i>ACCESSOR</i>_like [INDEX,] REGEX, TEST_NAME</a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ACCESSOR_unlike_[INDEX,]_REGEX,_TEST_NAME"
><i>ACCESSOR</i>_unlike [INDEX,] REGEX, TEST_NAME</a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ACCESSOR_is_deeply_STRUCTURE,_TEST_NAME"
><i>ACCESSOR</i>_is_deeply STRUCTURE, TEST_NAME</a></h2>

<p><i>INDEX</i> is not optional: It is required for array accessors (like <code>return</code> and <code>warn</code>), and disallowed for scalar accessors. Note that the <code>is_deeply</code> test does not accept an index. Even for array accessors, it operates on the entire array.</p>

<p>For convenience and clarity, tests against a flow control <i>ACCESSOR</i> (<code>return</code>, <code>die</code>, <code>exit</code>, or any you define yourself) will first test whether the trap was left by way of the flow control mechanism in question, and fail with appropriate diagnostics otherwise.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="did_die,_did_exit,_did_return"
>did_die, did_exit, did_return</a></h2>

<p>Conveniences: Tests whether the trap was left by way of the flow control mechanism in question. Much like <code>leaveby_is(&#39;die&#39;)</code> etc, but with better diagnostics and (run-time) spell checking.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="quiet"
>quiet</a></h2>

<p>Convenience: Passes if zero-length output was trapped on both STDOUT and STDERR, and generate better diagnostics otherwise.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="UTILITIES"
>UTILITIES</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="diag_all"
>diag_all</a></h2>

<p>Prints a diagnostic message (as per <a href="../Test/More.html#diag" class="podlinkpod"
>&#34;diag&#34; in Test::More</a>) consisting of a dump (in Perl code, as per <a href="../Data/Dump.html" class="podlinkpod"
>Data::Dump</a>) of the trap object.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="diag_all_once"
>diag_all_once</a></h2>

<p>As <a href="#diag_all" class="podlinkpod"
>&#34;diag_all&#34;</a>, except if this instance of the trap object has already been diag_all_once&#39;d, the diagnostic message will instead consist of the string <code>(as above)</code>.</p>

<p>This could be useful with the <code>on_fail</code> layer:</p>

<pre>  use Test::Trap qw/ :on_fail(diag_all_once) /;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CAVEATS"
>CAVEATS</a></h1>

<p>This module must be loaded before any code containing exit()s to be trapped is compiled. Any exit() already compiled won&#39;t be trappable, and will terminate the program anyway.</p>

<p>This module overrides &#38;CORE::GLOBAL::exit, so may not work correctly (or even at all) in the presence of other code overriding &#38;CORE::GLOBAL::exit. More precisely: This module installs its own exit() on entry of the block, and restores the previous one, if any, only upon leaving the block.</p>

<p>If you use fork() in the dynamic scope of a trap, beware that the (default) :exit layer of that trap does not trap exit() in the children, but passes them to the outer handler. If you think about it, this is what you are likely to want it to do in most cases.</p>

<p>Note that the (default) :exit layer only traps &#38;CORE::GLOBAL::exit calls (and bare exit() calls that compile to that). It makes no attempt to trap CORE::exit(), POSIX::_exit(), exec(), nor segfault. Nor does it attempt to trap anything else that might terminate the program. The trap is a block eval on steroids -- not the last block eval of Krypton!</p>

<p>This module traps warnings using <code>$SIG{__WARN__}</code>, so may not work correctly (or even at all) in the presence of other code setting this handler. More precisely: This module installs its own __WARN__ handler on entry of the block, and restores the previous one, if any, only upon leaving the block.</p>

<p>The (default) :stdout and :stderr handlers will not trap output from system() calls.</p>

<p>Threads? No idea. It might even work correctly.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>Please report any bugs or feature requests directly to the author.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Eirik Berg Hanssen, <code>&#60;ebhanssen@allverden.no&#62;</code></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_&#38;_LICENSE"
>COPYRIGHT &#38; LICENSE</a></h1>

<p>Copyright 2006-2012 Eirik Berg Hanssen, All Rights Reserved.</p>

<p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
