<html><head><title>Test::DatabaseRow</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:27 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#row_ok'>row_ok</a>
    <li class='indexItem indexItem2'><a href='#Checking_the_number_of_results'>Checking the number of results</a>
    <li class='indexItem indexItem2'><a href='#Convenience_Functions'>Convenience Functions</a>
    <li class='indexItem indexItem2'><a href='#Other_SQL_modules'>Other SQL modules</a>
    <li class='indexItem indexItem2'><a href='#utf8_hacks'>utf8 hacks</a>
    <li class='indexItem indexItem2'><a href='#Using_a_custom_object_subclass'>Using a custom object subclass</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Test::DatabaseRow - simple database tests</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use Test::More tests =&#62; 3;
  use Test::DatabaseRow;

  # set the default database handle
  local $Test::DatabaseRow::dbh = $dbh;

  # sql based test
  all_row_ok(
    sql   =&#62; &#34;SELECT * FROM contacts WHERE cid = &#39;123&#39;&#34;,
    tests =&#62; [ name =&#62; &#34;trelane&#34; ],
    description =&#62; &#34;contact 123&#39;s name is trelane&#34;
  );

  # test with shortcuts
  all_row_ok(
    table =&#62; &#34;contacts&#34;,
    where =&#62; [ cid =&#62; 123 ],
    tests =&#62; [ name =&#62; &#34;trelane&#34; ],
    description =&#62; &#34;contact 123&#39;s name is trelane&#34;
  );

  # complex test
  all_row_ok(
    table =&#62; &#34;contacts&#34;,
    where =&#62; { &#39;=&#39;    =&#62; { name   =&#62; &#34;trelane&#34;            },
               &#39;like&#39; =&#62; { url    =&#62; &#39;%shortplanks.com&#39;   },},
    tests =&#62; { &#39;==&#39;   =&#62; { cid    =&#62; 123,
                           num    =&#62; 134                  },
               &#39;eq&#39;   =&#62; { person =&#62; &#34;Mark Fowler&#34;        },
               &#39;=~&#39;   =&#62; { road   =&#62; qr/Liverpool R.?.?d/ },},
    description =&#62; &#34;trelane entered into contacts okay&#34; );
  );</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This is a simple module for doing simple tests on a database, primarily designed to test if a row exists with the correct details in a table or not.</p>

<p>This module exports several functions.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="row_ok"
>row_ok</a></h2>

<p>The <code>row_ok</code> function takes named attributes that control which rows in which table it selects, and what tests are carried out on those rows.</p>

<p>By default it performs the tests against only the first row returned from the database, but parameters passed to it can alter that behavior.</p>

<dl>
<dt><a name="dbh"
>dbh</a></dt>

<dd>
<p>The database handle that the test should use. In lieu of this attribute being passed the test will use whatever handle is set in the <code>$Test::DatabaseRow::dbh</code> global variable.</p>

<dt><a name="sql"
>sql</a></dt>

<dd>
<p>Manually specify the SQL to select the rows you want this module to execute.</p>

<p>This can either be just a plain string, or it can be an array ref with the first element containing the SQL string and any further elements containing bind variables that will be used to fill in placeholders.</p>

<pre>  # using the plain string version
  row_ok(sql   =&#62; &#34;SELECT * FROM contacts WHERE cid = &#39;123&#39;&#34;,
         tests =&#62; [ name =&#62; &#34;Trelane&#34; ]);

  # using placeholders and bind variables
  row_ok(sql   =&#62; [ &#34;SELECT * FROM contacts WHERE cid = ?&#34;, 123 ],
         tests =&#62; [ name =&#62; &#34;Trelane&#34; ]);</pre>

<dt><a name="table"
>table</a></dt>

<dd>
<p>Build the SELECT statement programmatically. This parameter contains the name of the table the SELECT statement should be executed against. You cannot pass both a <code>table</code> parameter and a <code>sql</code> parameter. If you specify <code>table</code> you <b>must</b> pass a <code>where</code> parameter also (see below.)</p>

<dt><a name="where"
>where</a></dt>

<dd>
<p>Build the SELECT statement programmatically. This parameter should contain options that will combine into a WHERE clause in order to select the row that you want to test.</p>

<p>This options normally are a hash of hashes. It&#39;s a hashref keyed by SQL comparison operators that has in turn values that are further hashrefs of column name and values pairs. This sounds really complicated, but is quite simple once you&#39;ve been shown an example. If we could get get the data to test with a SQL like so:</p>

<pre>  SELECT *
    FROM tablename
   WHERE foo  =    &#39;bar&#39;
     AND baz  =     23
     AND fred LIKE &#39;wilma%&#39;
     AND age  &#62;=    18</pre>

<p>Then we could have the function build that SQL like so:</p>

<pre>  row_ok(table =&#62; &#34;tablename&#34;,
         where =&#62; { &#39;=&#39;    =&#62; { foo  =&#62; &#34;bar&#34;,
                                baz  =&#62; 23,       },
                    &#39;LIKE&#39; =&#62; { fred =&#62; &#39;wimla%&#39;, },
                    &#39;&#62;=&#39;   =&#62; { age  =&#62; &#39;18&#39;,     },});</pre>

<p>Note how each different type of comparison has it&#39;s own little hashref containing the column name and the value for that column that the associated operator SQL should search for.</p>

<p>This syntax is quite flexible, but can be overkill for simple tests. In order to make this simpler, if you are only using &#39;=&#39; tests you may just pass an arrayref of the column names / values. For example, just to test</p>

<pre>  SELECT *
    FROM tablename
   WHERE foo = &#39;bar&#39;
     AND baz = 23;</pre>

<p>You can simply pass</p>

<pre>  row_ok(table =&#62; &#34;tablename&#34;,
         where =&#62; [ foo  =&#62; &#34;bar&#34;,
                    baz  =&#62; 23,    ]);</pre>

<p>Which, in a lot of cases, makes things a lot quicker and simpler to write.</p>

<p>NULL values can confuse things in SQL. All you need to remember is that when building SQL statements use <code>undef</code> whenever you want to use a NULL value. Don&#39;t use the string &#34;NULL&#34; as that&#39;ll be interpreted as the literal string made up of a N, a U and two Ls.</p>

<p>As a special case, using <code>undef</code> either in a <code>=</code> or in the short arrayref form will cause a &#34;IS&#34; test to be used instead of a <code>=</code> test. This means the statements:</p>

<pre>  row_ok(table =&#62; &#34;tablename&#34;,
         where =&#62; [ foo  =&#62; undef ],)</pre>

<p>Will produce:</p>

<pre>  SELECT *
    FROM tablename
   WHERE foo IS NULL</pre>

<dt><a name="tests"
>tests</a></dt>

<dd>
<p>The comparisons that you want to run between the expected data and the data in the first line returned from the database. If you do not specify any tests then the test will simply check if <i>any</i> rows are returned from the database and will pass no matter what they actually contain.</p>

<p>Normally this is a hash of hashes in a similar vein to <code>where</code>. This time the outer hash is keyed by Perl comparison operators, and the inner hashes contain column names and the expected values for these columns. For example:</p>

<pre>  row_ok(sql   =&#62; $sql,
         tests =&#62; { &#34;eq&#34; =&#62; { wibble =&#62; &#34;wobble&#34;,
                              fish   =&#62; &#34;fosh&#34;,    },
                    &#34;==&#34; =&#62; { bob    =&#62; 4077       },
                    &#34;=~&#34; =&#62; { fred   =&#62; qr/barney/ },},);</pre>

<p>This checks that the column wibble is the string &#34;wobble&#34;, column fish is the string &#34;fosh&#34;, column bob is equal numerically to 4077, and that fred contains the text &#34;barney&#34;. You may use any infix comparison operator (e.g. &#34;&#60;&#34;, &#34;&#62;&#34;, &#34;&#38;&#38;&#34;, etc, etc) as a test key.</p>

<p>The first comparison to fail (to return false) will cause the whole test to fail, and debug information will be printed out on that comparison.</p>

<p>In a similar fashion to <code>where</code> you can also pass a arrayref for simple comparisons. The function will try and Do The Right Thing with regard to the expected value for that comparison. Any expected value that looks like a number will be compared numerically, a regular expression will be compared with the <code>=~</code> operator, and anything else will undergo string comparison. The above example therefore could be rewritten:</p>

<pre>  row_ok(sql   =&#62; $sql,
         tests =&#62; [ wibble =&#62; &#34;wobble&#34;,
                    fish   =&#62; &#34;fosh&#34;,
                    bob    =&#62; 4077,
                    fred   =&#62; qr/barney/ ]);</pre>

<dt><a name="check_all_rows"
>check_all_rows</a></dt>

<dd>
<p>Setting this to a true value causes <code>row_ok</code> to run the tests against all rows returned from the database not just the first.</p>

<dt><a name="verbose"
>verbose</a></dt>

<dd>
<p>Setting this option to a true value will cause verbose diagnostics to be printed out during any failing tests. You may also enable this feature by setting either <code>$Test::DatabaseRow::verbose</code> variable the <code>TEST_DBROW_VERBOSE</code> environmental variable to a true value.</p>

<dt><a name="store_rows"
>store_rows</a></dt>

<dd>
<p>Sometimes, it&#39;s not enough to just use the simple tests that <b>Test::DatabaseRow</b> offers you. In this situation you can use the <code>store_rows</code> function to get at the results that row_ok has extracted from the database. You should pass a reference to an array for the results to be stored in; After the call to <code>row_ok</code> this array will be populated with one hashref per row returned from the database, keyed by column names.</p>

<pre>  row_ok(sql =&#62; &#34;SELECT * FROM contact WHERE name = &#39;Trelane&#39;&#34;,
         store_rows =&#62; \@rows);

  ok(Email::Valid-&#62;address($rows[0]{&#39;email&#39;}));</pre>

<dt><a name="store_row"
>store_row</a></dt>

<dd>
<p>The same as <code>store_rows</code>, but only the stores the first row returned in the variable. Instead of passing in an array reference you should pass in either a reference to a hash...</p>

<pre>  row_ok(sql =&#62; &#34;SELECT * FROM contact WHERE name = &#39;Trelane&#39;&#34;,
         store_rows =&#62; \%row);

  ok(Email::Valid-&#62;address($row{&#39;email&#39;}));</pre>

<p>...or a reference to a scalar which should be populated with a hashref...</p>

<pre>  row_ok(sql =&#62; &#34;SELECT * FROM contact WHERE name = &#39;Trelane&#39;&#34;,
         store_rows =&#62; \$row);

  ok(Email::Valid-&#62;address($row-&#62;{&#39;email&#39;}));</pre>

<dt><a name="description"
>description</a></dt>

<dd>
<p>The description that this test will use with <code>Test::Builder</code>, i.e the thing that will be printed out after ok/not ok. For example:</p>

<pre>  row_ok(
    sql =&#62; &#34;SELECT * FROM queue&#34;,
    description =&#62; &#34;something in the queue&#34;
  );</pre>

<p>Hopefully produces something like:</p>

<pre>  ok 1 - something in the queue</pre>

<p>For historical reasons you may also pass <code>label</code> for this parameter.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Checking_the_number_of_results"
>Checking the number of results</a></h2>

<p>By default <code>row_ok</code> just checks the first row returned from the database matches the criteria passed. By setting the parameters below you can also cause the module to check that the correct number of rows are returned from by the select statement (though only the first row will be tested against the test conditions.)</p>

<dl>
<dt><a name="results"
>results</a></dt>

<dd>
<p>Setting this parameter causes the test to ensure that the database returns exactly this number of rows when the select statement is executed. Setting this to zero allows you to ensure that no matching rows were found by the database, hence this parameter can be used for negative assertions about the database.</p>

<pre>  # assert that Trelane is _not_ in the database
  row_ok(sql     =&#62; &#34;SELECT * FROM contacts WHERE name = &#39;Trelane&#39;&#34;,
         results =&#62; 0 );

  # convenience function that does the same thing
  not_row_ok(sql =&#62; &#34;SELECT * FROM contacts WHERE name = &#39;Trelane&#39;&#34;)</pre>

<dt><a name="min_results_/_max_results"
>min_results / max_results</a></dt>

<dd>
<p>This parameter allows you to test that the database returns at least or no more than the passed number of rows when the select statement is executed.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Convenience_Functions"
>Convenience Functions</a></h2>

<p>This module also exports a few convenience functions that make using certain features of <code>row_ok</code> more straight forward.</p>

<dl>
<dt><a name="all_row_ok"
>all_row_ok</a></dt>

<dd>
<p>The <code>all_row_ok</code> function is shorthand notation for &#34;Check every row returned from the database not just the first&#34;</p>

<p>For example:</p>

<pre>  all_row_ok(tests =&#62; { &#34;&#62;=&#34; =&#62; { age =&#62; &#34;18&#34; } }, sql =&#62; &#60;&#60;&#39;SQL&#39;);
    SELECT *
      FROM drinkers
     WHERE country = &#39;uk&#39;
  SQL</pre>

<p>Checks to see that all drinkers from the UK are over 18. It&#39;s identical to having written:</p>

<pre>  row_ok(tests =&#62; { &#34;&#62;=&#34; =&#62; { age =&#62; &#34;18&#34; } },
         check_all_rows =&#62; 1, sql =&#62; &#60;&#60;&#39;SQL&#39;);
    SELECT *
      FROM drinkers
     WHERE country = &#39;uk&#39;
  SQL</pre>

<dt><a name="not_row_ok"
>not_row_ok</a></dt>

<dd>
<p>The <code>not_row_ok</code> function is shorthand notation for &#34;the database returned no rows when I executed this SQL&#34;.</p>

<p>For example:</p>

<pre>  not_row_ok(sql =&#62; &#60;&#60;&#39;SQL&#39;);
    SELECT *
      FROM languages
     WHERE name = &#39;Java&#39;
  SQL</pre>

<p>Checks to see the database doesn&#39;t have any rows in the language table that have a name &#34;Java&#34;. It&#39;s exactly the same as if we&#39;d written:</p>

<pre>  row_ok(sql =&#62; &#60;&#60;&#39;SQL&#39;, results =&#62; 0);
    SELECT *
      FROM languages
     WHERE name = &#39;Java&#39;
  SQL</pre>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Other_SQL_modules"
>Other SQL modules</a></h2>

<p>The SQL creation routines that are part of this module are designed primarily with the concept of getting simple single rows out of the database with as little fuss as possible. This having been said, it&#39;s quite possible that you need to use a more complicated SQL generation scheme than the one provided.</p>

<p>This module is designed to work (hopefully) reasonably well with the other modules on CPAN that can automatically create SQL for you. For example, <b>SQL::Abstract</b> is a module that can manufacture much more complex select statements that can easily be &#39;tied in&#39; to <code>row_ok</code>:</p>

<pre>  use SQL::Abstract;
  use Test::DatabaseRow;
  my $sql = SQL::Abstract-&#62;new();

  # more complex routine to find me heuristically by looking
  # for any one of my nicknames and my street address
  row_ok(sql   =&#62; [ $sql-&#62;select(&#34;contacts&#34;,
                                 &#34;*&#34;,
                                 { name =&#62; [ &#34;Trelane&#34;,
                                             &#34;Trel&#34;,
                                             &#34;MarkF&#34; ],
                                   road =&#62; { &#39;like&#39; =&#62; &#34;Liverpool%&#34; },
                                 })],
         tests =&#62; [ email =&#62; &#39;mark@twoshortplanks.com&#39; ],
         description =&#62; &#34;check mark&#39;s email address&#34;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="utf8_hacks"
>utf8 hacks</a></h2>

<p>Often, you may store data utf8 data in your database. However, many modern databases still do not store the metadata to indicate the data stored in them is utf8 and their DBD drivers may not set the utf8 flag on values returned to Perl. This means that data returned to Perl will be treated as if it is encoded in your normal character set rather than being encoded in utf8 and when compared to a byte for byte an identical utf8 string may fail comparison.</p>

<pre>    # this will fail incorrectly on data coming back from
    # mysql since the utf8 flags won&#39;t be set on returning data
    use utf8;
    row_ok(sql   =&#62; $sql,
           tests =&#62; [ name =&#62; &#34;Napol\x{e9}on&#34; ]);</pre>

<p>The solution to this is to use <code>Encode::_utf_on($value)</code> on each value returned from the database, something you will have to do yourself in your application code. To get this module to do this for you you can either pass the <code>force_utf8</code> flag to <code>row_ok</code>.</p>

<pre>    use utf8;
    row_ok(sql        =&#62; $sql,
           tests      =&#62; [ name =&#62; &#34;Napol\x{e9}on&#34; ],
           force_utf8 =&#62; 1);</pre>

<p>Or set the global <code>$Test::DatabaseRow::force_utf8</code> variable</p>

<pre>   use utf8;
   local $Test::DatabaseRow::force_utf8 = 1;
   row_ok(sql        =&#62; $sql,
          tests      =&#62; [ name =&#62; &#34;Napol\x{e9}on&#34; ]);</pre>

<p>Please note that in the above examples with <code>use utf8</code> enabled I could have typed Unicode eacutes into the string directly rather than using the <code>\x{e9}</code> escape sequence, but alas the pod renderer you&#39;re using to view this documentation would have been unlikely to render those examples correctly, so I didn&#39;t.</p>

<p>Please also note that if you want the debug information that this module creates to be rendered to STDERR correctly for your utf8 terminal then you may need to stick</p>

<pre>   binmode STDERR, &#34;:utf8&#34;;</pre>

<p>At the top of your script.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Using_a_custom_object_subclass"
>Using a custom object subclass</a></h2>

<p>This procedural wrapper relies on the base functionality of <code>Test::DatabaseRow::Object</code> to do the actual work. If you want to subclass that class (for example to use an alternative method of accessing the database) but continue to use this wrapper class you can do so by setting the <code>$Test::DatabaseRow::object_class</code> variable.</p>

<p>For example:</p>

<pre>   local $Test::DatabaseRow::object_class =
     &#34;Test::DatabaseRow::Object::MyFunnySubclassOrOther&#34;;
   row_ok(
     sql =&#62; &#34;SELECT * FROM qa WHERE a = &#39;42&#39;&#34;,
   );</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>You <i>must</i> pass a <code>sql</code> or <code>where</code> argument to limit what is returned from the table. The case where you don&#39;t want to is so unlikely (and it&#39;s much more likely that you&#39;ve written a bug in your test script) that omitting both of these is treated as an error. If you <i>really</i> need to not pass a <code>sql</code> or <code>where</code> argument, do <code>where =&#62; [ 1 =&#62; 1 ]</code>.</p>

<p>Passing shared variables (variables shared between multiple threads with <b>threads::shared</b>) in with <code>store_row</code> and <code>store_rows</code> and then changing them while <code>row_ok</code> is still executing is just asking for trouble.</p>

<p>The utf8 stuff only really works with perl 5.8 and later. It just goes horribly wrong on earlier perls. There&#39;s nothing I can do to correct that. Also, no matter what version of Perl you&#39;re running, currently no way provided by this module to force the utf8 flag to be turned on for some fields and not on for others.</p>

<p>The inbuilt SQL builder always assumes you mean <code>IS NULL</code> not <code>= NULL</code> when you pass in <code>undef</code> in a <code>=</code> section</p>

<p>Bugs (and requests for new features) can be reported though the CPAN RT system: <a href="http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-DatabaseRow" class="podlinkurl"
>http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-DatabaseRow</a></p>

<p>Alternatively, you can simply fork this project on github and send me pull requests. Please see <a href="http://github.com/2shortplanks/Test-DatabaseRow" class="podlinkurl"
>http://github.com/2shortplanks/Test-DatabaseRow</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Written by Mark Fowler <b>mark@twoshortplanks.com</b></p>

<p>Copyright Profero 2003, 2004. Copyright Mark Fowler 2011.</p>

<p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../Test/DatabaseRow/Object.html" class="podlinkpod"
>Test::DatabaseRow::Object</a>, <a href="../Test/More.html" class="podlinkpod"
>Test::More</a>, <a href="../DBI.html" class="podlinkpod"
>DBI</a></p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
