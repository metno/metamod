<html><head><title>DBI::DBD::SqlEngine::Developers</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:15 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#CLASSES'>CLASSES</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#DBI%3A%3ADBD%3A%3ASqlEngine'>DBI::DBD::SqlEngine</a>
    <li class='indexItem indexItem2'><a href='#DBI%3A%3ADBD%3A%3ASqlEngine%3A%3Adr'>DBI::DBD::SqlEngine::dr</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Methods_provided_by_DBI%3A%3ADBD%3A%3ASqlEngine%3A%3Adr%3A'>Methods provided by DBI::DBD::SqlEngine::dr:</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#DBI%3A%3ADBD%3A%3ASqlEngine%3A%3Adb'>DBI::DBD::SqlEngine::db</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Methods_provided_by_DBI%3A%3ADBD%3A%3ASqlEngine%3A%3Adb%3A'>Methods provided by DBI::DBD::SqlEngine::db:</a>
      <li class='indexItem indexItem3'><a href='#Attributes_used_by_DBI%3A%3ADBD%3A%3ASqlEngine%3A%3Adb%3A'>Attributes used by DBI::DBD::SqlEngine::db:</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#DBI%3A%3ADBD%3A%3ASqlEngine%3A%3Ast'>DBI::DBD::SqlEngine::st</a>
    <li class='indexItem indexItem2'><a href='#DBI%3A%3ADBD%3A%3ASqlEngine%3A%3ATableSource'>DBI::DBD::SqlEngine::TableSource</a>
    <li class='indexItem indexItem2'><a href='#DBI%3A%3ADBD%3A%3ASqlEngine%3A%3ADataSource'>DBI::DBD::SqlEngine::DataSource</a>
    <li class='indexItem indexItem2'><a href='#DBI%3A%3ADBD%3A%3ASqlEngine%3A%3AStatement'>DBI::DBD::SqlEngine::Statement</a>
    <li class='indexItem indexItem2'><a href='#DBI%3A%3ADBD%3A%3ASqlEngine%3A%3ATable'>DBI::DBD::SqlEngine::Table</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>DBI::DBD::SqlEngine::Developers - Developers documentation for DBI::DBD::SqlEngine</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    package DBD::myDriver;

    use base qw(DBI::DBD::SqlEngine);

    sub driver
    {
        ...
        my $drh = $proto-&#62;SUPER::driver($attr);
        ...
        return $drh-&#62;{class};
    }

    sub CLONE { ... }

    package DBD::myDriver::dr;

    @ISA = qw(DBI::DBD::SqlEngine::dr);

    sub data_sources { ... }
    ...

    package DBD::myDriver::db;

    @ISA = qw(DBI::DBD::SqlEngine::db);

    sub init_valid_attributes { ... }
    sub init_default_attributes { ... }
    sub set_versions { ... }
    sub validate_STORE_attr { my ($dbh, $attrib, $value) = @_; ... }
    sub validate_FETCH_attr { my ($dbh, $attrib) = @_; ... }
    sub get_myd_versions { ... }
    sub get_avail_tables { ... }

    package DBD::myDriver::st;

    @ISA = qw(DBI::DBD::SqlEngine::st);

    sub FETCH { ... }
    sub STORE { ... }

    package DBD::myDriver::Statement;

    @ISA = qw(DBI::DBD::SqlEngine::Statement);

    sub open_table { ... }

    package DBD::myDriver::Table;

    @ISA = qw(DBI::DBD::SqlEngine::Table);

    my %reset_on_modify = (
                            myd_abc =&#62; &#34;myd_foo&#34;,
                            myd_mno =&#62; &#34;myd_bar&#34;,
                          );
    __PACKAGE__-&#62;register_reset_on_modify( \%reset_on_modify );
    my %compat_map = (
                       abc =&#62; &#39;foo_abc&#39;,
                       xyz =&#62; &#39;foo_xyz&#39;,
                     );
    __PACKAGE__-&#62;register_compat_map( \%compat_map );

    sub bootstrap_table_meta { ... }
    sub init_table_meta { ... }
    sub table_meta_attr_changed { ... }
    sub open_data { ... }

    sub new { ... }

    sub fetch_row { ... }
    sub push_row { ... }
    sub push_names { ... }
    sub seek { ... }
    sub truncate { ... }
    sub drop { ... }

    # optimize the SQL engine by add one or more of
    sub update_current_row { ... }
    # or
    sub update_specific_row { ... }
    # or
    sub update_one_row { ... }
    # or
    sub insert_new_row { ... }
    # or
    sub delete_current_row { ... }
    # or
    sub delete_one_row { ... }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This document describes the interface of DBI::DBD::SqlEngine for DBD developers who write DBI::DBD::SqlEngine based DBI drivers. It supplements <a href="../../../DBI/DBD.html" class="podlinkpod"
>DBI::DBD</a> and <a href="../../../DBI/DBD/SqlEngine/HowTo.html" class="podlinkpod"
>DBI::DBD::SqlEngine::HowTo</a>, which you should read first.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CLASSES"
>CLASSES</a></h1>

<p>Each DBI driver must provide a package global <code>driver</code> method and three DBI related classes:</p>

<dl>
<dt><a name="DBI::DBD::SqlEngine::dr"
>DBI::DBD::SqlEngine::dr</a></dt>

<dd>
<p>Driver package, contains the methods DBI calls indirectly via DBI interface:</p>

<pre>  DBI-&#62;connect (&#39;DBI:DBM:&#39;, undef, undef, {})

  # invokes
  package DBD::DBM::dr;
  @DBD::DBM::dr::ISA = qw(DBI::DBD::SqlEngine::dr);

  sub connect ($$;$$$)
  {
      ...
  }</pre>

<p>Similar for <code>data_sources ()</code> and <code>disconnect_all()</code>.</p>

<p>Pure Perl DBI drivers derived from DBI::DBD::SqlEngine usually don&#39;t need to override any of the methods provided through the DBD::XXX::dr package. However if you need additional initialization not fitting in <code>init_valid_attributes()</code> and <code>init_default_attributes()</code> of you&#39;re ::db class, the connect method might be the final place to be modified.</p>

<dt><a name="DBI::DBD::SqlEngine::db"
>DBI::DBD::SqlEngine::db</a></dt>

<dd>
<p>Contains the methods which are called through DBI database handles (<code>$dbh</code>). e.g.,</p>

<pre>  $sth = $dbh-&#62;prepare (&#34;select * from foo&#34;);
  # returns the f_encoding setting for table foo
  $dbh-&#62;csv_get_meta (&#34;foo&#34;, &#34;f_encoding&#34;);</pre>

<p>DBI::DBD::SqlEngine provides the typical methods required here. Developers who write DBI drivers based on DBI::DBD::SqlEngine need to override the methods <code>set_versions</code> and <code>init_valid_attributes</code>.</p>

<dt><a name="DBI::DBD::SqlEngine::TieMeta;"
>DBI::DBD::SqlEngine::TieMeta;</a></dt>

<dd>
<p>Provides the tie-magic for <code>$dbh-&#62;{$drv_pfx . &#34;_meta&#34;}</code>. Routes <code>STORE</code> through <code>$drv-&#62;set_sql_engine_meta()</code> and <code>FETCH</code> through <code>$drv-&#62;get_sql_engine_meta()</code>. <code>DELETE</code> is not supported, you have to execute a <code>DROP TABLE</code> statement, where applicable.</p>

<dt><a name="DBI::DBD::SqlEngine::TieTables;"
>DBI::DBD::SqlEngine::TieTables;</a></dt>

<dd>
<p>Provides the tie-magic for tables in <code>$dbh-&#62;{$drv_pfx . &#34;_meta&#34;}</code>. Routes <code>STORE</code> though <code>$tblClass-&#62;set_table_meta_attr()</code> and <code>FETCH</code> though <code>$tblClass-&#62;get_table_meta_attr()</code>. <code>DELETE</code> removes an attribute from the <i>meta object</i> retrieved by <code>$tblClass-&#62;get_table_meta()</code>.</p>

<dt><a name="DBI::DBD::SqlEngine::st"
>DBI::DBD::SqlEngine::st</a></dt>

<dd>
<p>Contains the methods to deal with prepared statement handles. e.g.,</p>

<pre>  $sth-&#62;execute () or die $sth-&#62;errstr;</pre>

<dt><a name="DBI::DBD::SqlEngine::TableSource;"
>DBI::DBD::SqlEngine::TableSource;</a></dt>

<dd>
<p>Base class for 3rd party table sources:</p>

<pre>  $dbh-&#62;{sql_table_source} = &#34;DBD::Foo::TableSource&#34;;</pre>

<dt><a name="DBI::DBD::SqlEngine::DataSource;"
>DBI::DBD::SqlEngine::DataSource;</a></dt>

<dd>
<p>Base class for 3rd party data sources:</p>

<pre>  $dbh-&#62;{sql_data_source} = &#34;DBD::Foo::DataSource&#34;;</pre>

<dt><a name="DBI::DBD::SqlEngine::Statement;"
>DBI::DBD::SqlEngine::Statement;</a></dt>

<dd>
<p>Base class for derived drivers statement engine. Implements <code>open_table</code>.</p>

<dt><a name="DBI::DBD::SqlEngine::Table;"
>DBI::DBD::SqlEngine::Table;</a></dt>

<dd>
<p>Contains tailoring between SQL engine&#39;s requirements and <code>DBI::DBD::SqlEngine</code> magic for finding the right tables and storage. Builds bridges between <code>sql_meta</code> handling of <code>DBI::DBD::SqlEngine::db</code>, table initialization for SQL engines and <i>meta object</i>&#39;s attribute management for derived drivers.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="DBI::DBD::SqlEngine"
>DBI::DBD::SqlEngine</a></h2>

<p>This is the main package containing the routines to initialize DBI::DBD::SqlEngine based DBI drivers. Primarily the <code>DBI::DBD::SqlEngine::driver</code> method is invoked, either directly from DBI when the driver is initialized or from the derived class.</p>

<pre>  package DBD::DBM;

  use base qw( DBI::DBD::SqlEngine );

  sub driver
  {
      my ( $class, $attr ) = @_;
      ...
      my $drh = $class-&#62;SUPER::driver( $attr );
      ...
      return $drh;
  }</pre>

<p>It is not necessary to implement your own driver method as long as additional initialization (e.g. installing more private driver methods) is not required. You do not need to call <code>setup_driver</code> as DBI::DBD::SqlEngine takes care of it.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="DBI::DBD::SqlEngine::dr"
>DBI::DBD::SqlEngine::dr</a></h2>

<p>The driver package contains the methods DBI calls indirectly via the DBI interface (see <a href="../../../DBI.html#DBI_Class_Methods" class="podlinkpod"
>&#34;DBI Class Methods&#34; in DBI</a>).</p>

<p>DBI::DBD::SqlEngine based DBI drivers usually do not need to implement anything here, it is enough to do the basic initialization:</p>

<pre>  package DBD:XXX::dr;

  @DBD::XXX::dr::ISA = qw (DBI::DBD::SqlEngine::dr);
  $DBD::XXX::dr::imp_data_size     = 0;
  $DBD::XXX::dr::data_sources_attr = undef;
  $DBD::XXX::ATTRIBUTION = &#34;DBD::XXX $DBD::XXX::VERSION by Hans Mustermann&#34;;</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Methods_provided_by_DBI::DBD::SqlEngine::dr:"
>Methods provided by <code>DBI::DBD::SqlEngine::dr</code>:</a></h3>

<dl>
<dt><a name="connect"
>connect</a></dt>

<dd>
<p>Supervises the driver bootstrap when calling</p>

<pre>  DBI-&#62;connect( &#34;dbi:Foo&#34;, , , { ... } );</pre>

<p>First it instantiates a new driver using <code>DBI::_new_dbh</code>. After that, initial bootstrap of the newly instantiated driver is done by</p>

<pre>  $dbh-&#62;func( 0, &#34;init_default_attributes&#34; );</pre>

<p>The first argument (<code>0</code>) signals that this is the very first call to <code>init_default_attributes</code>. Modern drivers understand that and do early stage setup here after calling</p>

<pre>  package DBD::Foo::db;
  our @DBD::Foo::db::ISA = qw(DBI::DBD::SqlEngine::db);
  
  sub init_default_attributes
  {
    my ($dbh, $phase) = @_;
    $dbh-&#62;SUPER::init_default_attributes($phase);
    ...; # own setup code, maybe separated by phases
  }</pre>

<p>When the <code>$phase</code> argument is passed down until <code>DBI::DBD::SqlEngine::db::init_default_attributes</code>, <code>connect()</code> recognizes a <i>modern</i> driver and initializes the attributes from <i>DSN</i> and <i>$attr</i> arguments passed via <code>DBI-&#62;connect( $dsn, $user, $pass, \%attr )</code>.</p>

<p>At the end of the attribute initialization after <i>phase 0</i>, <code>connect()</code> invoked <code>init_default_attributes</code> again for <i>phase 1</i>:</p>

<pre>  $dbh-&#62;func( 1, &#34;init_default_attributes&#34; );</pre>

<dt><a name="data_sources"
>data_sources</a></dt>

<dd>
<p>Returns a list of <i>DSN</i>&#39;s using the <code>data_sources</code> method of the class specified in <code>$dbh-&#62;{sql_table_source}</code> or via <code>\%attr</code>:</p>

<pre>  @ary = DBI-&#62;data_sources($driver);
  @ary = DBI-&#62;data_sources($driver, \%attr);</pre>

<dt><a name="disconnect_all"
>disconnect_all</a></dt>

<dd>
<p><code>DBI::DBD::SqlEngine</code> doesn&#39;t have an overall driver cache, so nothing happens here at all.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="DBI::DBD::SqlEngine::db"
>DBI::DBD::SqlEngine::db</a></h2>

<p>This package defines the database methods, which are called via the DBI database handle <code>$dbh</code>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Methods_provided_by_DBI::DBD::SqlEngine::db:"
>Methods provided by <code>DBI::DBD::SqlEngine::db</code>:</a></h3>

<dl>
<dt><a name="ping"
>ping</a></dt>

<dd>
<p>Simply returns the content of the <code>Active</code> attribute. Override when your driver needs more complicated actions here.</p>

<dt><a name="prepare"
>prepare</a></dt>

<dd>
<p>Prepares a new SQL statement to execute. Returns a statement handle, <code>$sth</code> - instance of the DBD:XXX::st. It is neither required nor recommended to override this method.</p>

<dt><a name="validate_FETCH_attr"
>validate_FETCH_attr</a></dt>

<dd>
<p>Called by <code>FETCH</code> to allow inherited drivers do their own attribute name validation. Calling convention is similar to <code>FETCH</code> and the return value is the approved attribute name.</p>

<pre>    return $validated_attribute_name;</pre>

<p>In case of validation fails (e.g. accessing private attribute or similar), <code>validate_FETCH_attr</code> is permitted to throw an exception.</p>

<dt><a name="FETCH"
>FETCH</a></dt>

<dd>
<p>Fetches an attribute of a DBI database object. Private handle attributes must have a prefix (this is mandatory). If a requested attribute is detected as a private attribute without a valid prefix, the driver prefix (written as <code>$drv_prefix</code>) is added.</p>

<p>The driver prefix is extracted from the attribute name and verified against <code>$dbh-&#62;{ $drv_prefix . &#34;valid_attrs&#34; }</code> (when it exists). If the requested attribute value is not listed as a valid attribute, this method croaks. If the attribute is valid and readonly (listed in <code>$dbh-&#62;{ $drv_prefix . &#34;readonly_attrs&#34; }</code> when it exists), a real copy of the attribute value is returned. So it&#39;s not possible to modify <code>f_valid_attrs</code> from outside of DBI::DBD::SqlEngine::db or a derived class.</p>

<dt><a name="validate_STORE_attr"
>validate_STORE_attr</a></dt>

<dd>
<p>Called by <code>STORE</code> to allow inherited drivers do their own attribute name validation. Calling convention is similar to <code>STORE</code> and the return value is the approved attribute name followed by the approved new value.</p>

<pre>    return ($validated_attribute_name, $validated_attribute_value);</pre>

<p>In case of validation fails (e.g. accessing private attribute or similar), <code>validate_STORE_attr</code> is permitted to throw an exception (<code>DBI::DBD::SqlEngine::db::validate_STORE_attr</code> throws an exception when someone tries to assign value other than <code>SQL_IC_UPPER .. SQL_IC_MIXED</code> to <code>$dbh-&#62;{sql_identifier_case}</code> or <code>$dbh-&#62;{sql_quoted_identifier_case}</code>).</p>

<dt><a name="STORE"
>STORE</a></dt>

<dd>
<p>Stores a database private attribute. Private handle attributes must have a prefix (this is mandatory). If a requested attribute is detected as a private attribute without a valid prefix, the driver prefix (written as <code>$drv_prefix</code>) is added. If the database handle has an attribute <code>${drv_prefix}_valid_attrs</code> - for attribute names which are not listed in that hash, this method croaks. If the database handle has an attribute <code>${drv_prefix}_readonly_attrs</code>, only attributes which are not listed there can be stored (once they are initialized). Trying to overwrite such an immutable attribute forces this method to croak.</p>

<p>An example of a valid attributes list can be found in <code>DBI::DBD::SqlEngine::db::init_valid_attributes</code>.</p>

<dt><a name="set_versions"
>set_versions</a></dt>

<dd>
<p>This method sets the attributes <code>f_version</code>, <code>sql_nano_version</code>, <code>sql_statement_version</code> and (if not prohibited by a restrictive <code>${prefix}_valid_attrs</code>) <code>${prefix}_version</code>.</p>

<p>This method is called at the end of the <code>connect ()</code> phase.</p>

<p>When overriding this method, do not forget to invoke the superior one.</p>

<dt><a name="init_valid_attributes"
>init_valid_attributes</a></dt>

<dd>
<p>This method is called after the database handle is instantiated as the first attribute initialization.</p>

<p><code>DBI::DBD::SqlEngine::db::init_valid_attributes</code> initializes the attributes <code>sql_valid_attrs</code> and <code>sql_readonly_attrs</code>.</p>

<p>When overriding this method, do not forget to invoke the superior one, preferably before doing anything else.</p>

<dt><a name="init_default_attributes"
>init_default_attributes</a></dt>

<dd>
<p>This method is called after the database handle is instantiated to initialize the default attributes. It expects one argument: <code>$phase</code>. If <code>$phase</code> is not given, <code>connect</code> of <code>DBI::DBD::SqlEngine::dr</code> expects this is an old-fashioned driver which isn&#39;t capable of multi-phased initialization.</p>

<p><code>DBI::DBD::SqlEngine::db::init_default_attributes</code> initializes the attributes <code>sql_identifier_case</code>, <code>sql_quoted_identifier_case</code>, <code>sql_handler</code>, <code>sql_init_order</code>, <code>sql_meta</code>, <code>sql_engine_version</code>, <code>sql_nano_version</code> and <code>sql_statement_version</code> when <a href="../../../SQL/Statement.html" class="podlinkpod"
>SQL::Statement</a> is available.</p>

<p>It sets <code>sql_init_order</code> to the given <code>$phase</code>.</p>

<p>When the derived implementor class provides the attribute to validate attributes (e.g. <code>$dbh-&#62;{dbm_valid_attrs} = {...};</code>) or the attribute containing the immutable attributes (e.g. <code>$dbh-&#62;{dbm_readonly_attrs} = {...};</code>), the attributes <code>drv_valid_attrs</code>, <code>drv_readonly_attrs</code> and <code>drv_version</code> are added (when available) to the list of valid and immutable attributes (where <code>drv_</code> is interpreted as the driver prefix).</p>

<dt><a name="get_versions"
>get_versions</a></dt>

<dd>
<p>This method is called by the code injected into the instantiated driver to provide the user callable driver method <code>${prefix}versions</code> (e.g. <code>dbm_versions</code>, <code>csv_versions</code>, ...).</p>

<p>The DBI::DBD::SqlEngine implementation returns all version information known by DBI::DBD::SqlEngine (e.g. DBI version, Perl version, DBI::DBD::SqlEngine version and the SQL handler version).</p>

<p><code>get_versions</code> takes the <code>$dbh</code> as the first argument and optionally a second argument containing a table name. The second argument is not evaluated in <code>DBI::DBD::SqlEngine::db::get_versions</code> itself - but might be in the future.</p>

<p>If the derived implementor class provides a method named <code>get_${drv_prefix}versions</code>, this is invoked and the return value of it is associated to the derived driver name:</p>

<pre>    if (my $dgv = $dbh-&#62;{ImplementorClass}-&#62;can (&#34;get_&#34; . $drv_prefix . &#34;versions&#34;) {
        (my $derived_driver = $dbh-&#62;{ImplementorClass}) =~ s/::db$//;
        $versions{$derived_driver} = &#38;$dgv ($dbh, $table);
    }</pre>

<p>Override it to add more version information about your module, (e.g. some kind of parser version in case of DBD::CSV, ...), if one line is not enough room to provide all relevant information.</p>

<dt><a name="sql_parser_object"
>sql_parser_object</a></dt>

<dd>
<p>Returns a <a href="../../../SQL/Parser.html" class="podlinkpod"
>SQL::Parser</a> instance, when <code>sql_handler</code> is set to &#34;SQL::Statement&#34;. The parser instance is stored in <code>sql_parser_object</code>.</p>

<p>It is not recommended to override this method.</p>

<dt><a name="disconnect"
>disconnect</a></dt>

<dd>
<p>Disconnects from a database. All local table information is discarded and the <code>Active</code> attribute is set to 0.</p>

<dt><a name="type_info_all"
>type_info_all</a></dt>

<dd>
<p>Returns information about all the types supported by DBI::DBD::SqlEngine.</p>

<dt><a name="table_info"
>table_info</a></dt>

<dd>
<p>Returns a statement handle which is prepared to deliver information about all known tables.</p>

<dt><a name="list_tables"
>list_tables</a></dt>

<dd>
<p>Returns a list of all known table names.</p>

<dt><a name="quote"
>quote</a></dt>

<dd>
<p>Quotes a string for use in SQL statements.</p>

<dt><a name="commit"
>commit</a></dt>

<dd>
<p>Warns about a useless call (if warnings enabled) and returns. DBI::DBD::SqlEngine is typically a driver which commits every action instantly when executed.</p>

<dt><a name="rollback"
>rollback</a></dt>

<dd>
<p>Warns about a useless call (if warnings enabled) and returns. DBI::DBD::SqlEngine is typically a driver which commits every action instantly when executed.</p>
</dd>
</dl>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Attributes_used_by_DBI::DBD::SqlEngine::db:"
>Attributes used by <code>DBI::DBD::SqlEngine::db</code>:</a></h3>

<p>This section describes attributes which are important to developers of DBI Database Drivers derived from <code>DBI::DBD::SqlEngine</code>.</p>

<dl>
<dt><a name="sql_init_order"
>sql_init_order</a></dt>

<dd>
<p>This attribute contains a hash with priorities as key and an array containing the <code>$dbh</code> attributes to be initialized during before/after other attributes.</p>

<p><code>DBI::DBD::SqlEngine</code> initializes following attributes:</p>

<pre>  $dbh-&#62;{sql_init_order} = {
       0 =&#62; [qw( Profile RaiseError PrintError AutoCommit )],
      90 =&#62; [ &#34;sql_meta&#34;, $dbh-&#62;{$drv_pfx_meta} ? $dbh-&#62;{$drv_pfx_meta} : () ]
  }</pre>

<p>The default priority of not listed attribute keys is <code>50</code>. It is well known that a lot of attributes needed to be set before some table settings are initialized. For example, for <a href="../../../DBD/DBM.html" class="podlinkpod"
>DBD::DBM</a>, when using</p>

<pre>  my $dbh = DBI-&#62;connect( &#34;dbi:DBM:&#34;, undef, undef, {
      f_dir =&#62; &#34;/path/to/dbm/databases&#34;,
      dbm_type =&#62; &#34;BerkeleyDB&#34;,
      dbm_mldbm =&#62; &#34;JSON&#34;, # use MLDBM::Serializer::JSON
      dbm_tables =&#62; {
          quick =&#62; {
              dbm_type =&#62; &#34;GDBM_File&#34;,
              dbm_MLDBM =&#62; &#34;FreezeThaw&#34;
          }
      }
  });</pre>

<p>This defines a known table <code>quick</code> which uses the <a href="../../../GDBM_File.html" class="podlinkpod"
>GDBM_File</a> backend and <a href="../../../FreezeThaw.html" class="podlinkpod"
>FreezeThaw</a> as serializer instead of the overall default <a href="../../../BerkeleyDB.html" class="podlinkpod"
>BerkeleyDB</a> and <a href="../../../JSON.html" class="podlinkpod"
>JSON</a>. <b>But</b> all files containing the table data have to be searched in <code>$dbh-&#62;{f_dir}</code>, which requires <code>$dbh-&#62;{f_dir}</code> must be initialized before <code>$dbh-&#62;{sql_meta}-&#62;{quick}</code> is initialized by <code>bootstrap_table_meta</code> method of <a href="#DBI%3A%3ADBD%3A%3ASqlEngine%3A%3ATable" class="podlinkpod"
>&#34;DBI::DBD::SqlEngine::Table&#34;</a> to get <code>$dbh-&#62;{sql_meta}-&#62;{quick}-&#62;{f_dir}</code> being initialized properly.</p>

<dt><a name="sql_init_phase"
>sql_init_phase</a></dt>

<dd>
<p>This attribute is only set during the initialization steps of the DBI Database Driver. It contains the value of the currently run initialization phase. Currently supported phases are <i>phase 0</i> and <i>phase 1</i>. This attribute is set in <code>init_default_attributes</code> and removed in <code>init_done</code>.</p>

<dt><a name="sql_engine_in_gofer"
>sql_engine_in_gofer</a></dt>

<dd>
<p>This value has a true value in case of this driver is operated via <a href="../../../DBD/Gofer.html" class="podlinkpod"
>DBD::Gofer</a>. The impact of being operated via Gofer is a read-only driver (not read-only databases!), so you cannot modify any attributes later - neither any table settings. <b>But</b> you won&#39;t get an error in cases you modify table attributes, so please carefully watch <code>sql_engine_in_gofer</code>.</p>

<dt><a name="sql_table_source"
>sql_table_source</a></dt>

<dd>
<p>Names a class which is responsible for delivering <i>data sources</i> and <i>available tables</i> (Database Driver related). <i>data sources</i> here refers to <a href="../../../DBI.html#data_sources" class="podlinkpod"
>&#34;data_sources&#34; in DBI</a>, not <code>sql_data_source</code>.</p>

<p>See <a href="#DBI%3A%3ADBD%3A%3ASqlEngine%3A%3ATableSource" class="podlinkpod"
>&#34;DBI::DBD::SqlEngine::TableSource&#34;</a> for details.</p>

<dt><a name="sql_data_source"
>sql_data_source</a></dt>

<dd>
<p>Name a class which is responsible for handling table resources open and completing table names requested via SQL statements.</p>

<p>See <a href="#DBI%3A%3ADBD%3A%3ASqlEngine%3A%3ADataSource" class="podlinkpod"
>&#34;DBI::DBD::SqlEngine::DataSource&#34;</a> for details.</p>

<dt><a name="sql_dialect"
>sql_dialect</a></dt>

<dd>
<p>Controls the dialect understood by SQL::Parser. Possible values (delivery state of SQL::Statement):</p>

<pre>  * ANSI
  * CSV
  * AnyData</pre>

<p>Defaults to &#34;CSV&#34;. Because an SQL::Parser is instantiated only once and SQL::Parser doesn&#39;t allow to modify the dialect once instantiated, it&#39;s strongly recommended to set this flag before any statement is executed (best place is connect attribute hash).</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="DBI::DBD::SqlEngine::st"
>DBI::DBD::SqlEngine::st</a></h2>

<p>Contains the methods to deal with prepared statement handles:</p>

<dl>
<dt><a name="bind_param"
>bind_param</a></dt>

<dd>
<p>Common routine to bind placeholders to a statement for execution. It is dangerous to override this method without detailed knowledge about the DBI::DBD::SqlEngine internal storage structure.</p>

<dt><a name="execute"
>execute</a></dt>

<dd>
<p>Executes a previously prepared statement (with placeholders, if any).</p>

<dt><a name="finish"
>finish</a></dt>

<dd>
<p>Finishes a statement handle, discards all buffered results. The prepared statement is not discarded so the statement can be executed again.</p>

<dt><a name="fetch"
>fetch</a></dt>

<dd>
<p>Fetches the next row from the result-set. This method may be rewritten in a later version and if it&#39;s overridden in a derived class, the derived implementation should not rely on the storage details.</p>

<dt><a name="fetchrow_arrayref"
>fetchrow_arrayref</a></dt>

<dd>
<p>Alias for <code>fetch</code>.</p>

<dt><a name="FETCH"
>FETCH</a></dt>

<dd>
<p>Fetches statement handle attributes. Supported attributes (for full overview see <a href="../../../DBI.html#Statement_Handle_Attributes" class="podlinkpod"
>&#34;Statement Handle Attributes&#34; in DBI</a>) are <code>NAME</code>, <code>TYPE</code>, <code>PRECISION</code> and <code>NULLABLE</code>. Each column is returned as <code>NULLABLE</code> which might be wrong depending on the derived backend storage. If the statement handle has private attributes, they can be fetched using this method, too. <b>Note</b> that statement attributes are not associated with any table used in this statement.</p>

<p>This method usually requires extending in a derived implementation. See <a href="../../../DBD/CSV.html" class="podlinkpod"
>DBD::CSV</a> or <a href="../../../DBD/DBM.html" class="podlinkpod"
>DBD::DBM</a> for some example.</p>

<dt><a name="STORE"
>STORE</a></dt>

<dd>
<p>Allows storing of statement private attributes. No special handling is currently implemented here.</p>

<dt><a name="rows"
>rows</a></dt>

<dd>
<p>Returns the number of rows affected by the last execute. This method might return <code>undef</code>.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="DBI::DBD::SqlEngine::TableSource"
>DBI::DBD::SqlEngine::TableSource</a></h2>

<p>Provides data sources and table information on database driver and database handle level.</p>

<pre>  package DBI::DBD::SqlEngine::TableSource;

  sub data_sources ($;$)
  {
    my ( $class, $drh, $attrs ) = @_;
    ...
  }

  sub avail_tables
  {
    my ( $class, $drh ) = @_;
    ...
  }</pre>

<p>The <code>data_sources</code> method is called when the user invokes any of the following:</p>

<pre>  @ary = DBI-&#62;data_sources($driver);
  @ary = DBI-&#62;data_sources($driver, \%attr);
  
  @ary = $dbh-&#62;data_sources();
  @ary = $dbh-&#62;data_sources(\%attr);</pre>

<p>The <code>avail_tables</code> method is called when the user invokes any of the following:</p>

<pre>  @names = $dbh-&#62;tables( $catalog, $schema, $table, $type );
  
  $sth = $dbh-&#62;table_info( $catalog, $schema, $table, $type );
  $sth = $dbh-&#62;table_info( $catalog, $schema, $table, $type, \%attr );

  $dbh-&#62;func( &#34;list_tables&#34; );</pre>

<p>Every time where an <code>\%attr</code> argument can be specified, this <code>\%attr</code> object&#39;s <code>sql_table_source</code> attribute is preferred over the <code>$dbh</code> attribute or the driver default.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="DBI::DBD::SqlEngine::DataSource"
>DBI::DBD::SqlEngine::DataSource</a></h2>

<p>Provides base functionality for dealing with tables. It is primarily designed for allowing transparent access to files on disk or already opened (file-)streams (e.g. for DBD::CSV).</p>

<p>Derived classes shall be restricted to similar functionality, too (e.g. opening streams from an archive, transparently compress/uncompress log files before parsing them,</p>

<pre>  package DBI::DBD::SqlEngine::DataSource;

  sub complete_table_name ($$;$)
  {
    my ( $self, $meta, $table, $respect_case ) = @_;
    ...
  }</pre>

<p>The method <code>complete_table_name</code> is called when first setting up the <i>meta information</i> for a table:</p>

<pre>  &#34;SELECT user.id, user.name, user.shell FROM user WHERE ...&#34;</pre>

<p>results in opening the table <code>user</code>. First step of the table open process is completing the name. Let&#39;s imagine you&#39;re having a <a href="../../../DBD/CSV.html" class="podlinkpod"
>DBD::CSV</a> handle with following settings:</p>

<pre>  $dbh-&#62;{sql_identifier_case} = SQL_IC_LOWER;
  $dbh-&#62;{f_ext} = &#39;.lst&#39;;
  $dbh-&#62;{f_dir} = &#39;/data/web/adrmgr&#39;;</pre>

<p>Those settings will result in looking for files matching <code>[Uu][Ss][Ee][Rr](\.lst)?$</code> in <code>/data/web/adrmgr/</code>. The scanning of the directory <code>/data/web/adrmgr/</code> and the pattern match check will be done in <code>DBD::File::DataSource::File</code> by the <code>complete_table_name</code> method.</p>

<p>If you intend to provide other sources of data streams than files, in addition to provide an appropriate <code>complete_table_name</code> method, a method to open the resource is required:</p>

<pre>  package DBI::DBD::SqlEngine::DataSource;

  sub open_data ($)
  {
    my ( $self, $meta, $attrs, $flags ) = @_;
    ...
  }</pre>

<p>After the method <code>open_data</code> has been run successfully, the table&#39;s meta information are in a state which allows the table&#39;s data accessor methods will be able to fetch/store row information. Implementation details heavily depends on the table implementation, whereby the most famous is surely <a href="../../../DBD/File/Table.html" class="podlinkpod"
>DBD::File/DBD::File::Table</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="DBI::DBD::SqlEngine::Statement"
>DBI::DBD::SqlEngine::Statement</a></h2>

<p>Derives from DBI::SQL::Nano::Statement for unified naming when deriving new drivers. No additional feature is provided from here.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="DBI::DBD::SqlEngine::Table"
>DBI::DBD::SqlEngine::Table</a></h2>

<p>Derives from DBI::SQL::Nano::Table for unified naming when deriving new drivers.</p>

<p>You should consult the documentation of <code>SQL::Eval::Table</code> (see <a href="../../../SQL/Eval.html" class="podlinkpod"
>SQL::Eval</a>) to get more information about the abstract methods of the table&#39;s base class you have to override and a description of the table meta information expected by the SQL engines.</p>

<dl>
<dt><a name="bootstrap_table_meta"
>bootstrap_table_meta</a></dt>

<dd>
<p>Initializes a table meta structure. Can be safely overridden in a derived class, as long as the <code>SUPER</code> method is called at the end of the overridden method.</p>

<p>It copies the following attributes from the database into the table meta data <code>$dbh-&#62;{ReadOnly}</code> into <code>$meta-&#62;{readonly}</code>, <code>sql_identifier_case</code> and <code>sql_data_source</code> and makes them sticky to the table.</p>

<p>This method should be called before you attempt to map between file name and table name to ensure the correct directory, extension etc. are used.</p>

<dt><a name="init_table_meta"
>init_table_meta</a></dt>

<dd>
<p>Initializes more attributes of the table meta data - usually more expensive ones (e.g. those which require class instantiations) - when the file name and the table name could mapped.</p>

<dt><a name="get_table_meta"
>get_table_meta</a></dt>

<dd>
<p>Returns the table meta data. If there are none for the required table, a new one is initialized. When after bootstrapping a new <i>table_meta</i> and <a href="../../../completing%20the%20table%20name.html" class="podlinkpod"
>/DBI::DBD::SqlEngine::DataSource</a> a mapping can be established between an existing <i>table_meta</i> and the new bootstrapped one, the already existing is used and a mapping shortcut between the recent used table name and the already known table name is hold in <code>$dbh-&#62;{sql_meta_map}</code>. When it fails, nothing is returned. On success, the name of the table and the meta data structure is returned.</p>

<dt><a name="get_table_meta_attr"
>get_table_meta_attr</a></dt>

<dd>
<p>Returns a single attribute from the table meta data. If the attribute name appears in <code>%compat_map</code>, the attribute name is updated from there.</p>

<dt><a name="set_table_meta_attr"
>set_table_meta_attr</a></dt>

<dd>
<p>Sets a single attribute in the table meta data. If the attribute name appears in <code>%compat_map</code>, the attribute name is updated from there.</p>

<dt><a name="table_meta_attr_changed"
>table_meta_attr_changed</a></dt>

<dd>
<p>Called when an attribute of the meta data is modified.</p>

<p>If the modified attribute requires to reset a calculated attribute, the calculated attribute is reset (deleted from meta data structure) and the <i>initialized</i> flag is removed, too. The decision is made based on <code>%register_reset_on_modify</code>.</p>

<dt><a name="register_reset_on_modify"
>register_reset_on_modify</a></dt>

<dd>
<p>Allows <code>set_table_meta_attr</code> to reset meta attributes when special attributes are modified. For DBD::File, modifying one of <code>f_file</code>, <code>f_dir</code>, <code>f_ext</code> or <code>f_lockfile</code> will reset <code>f_fqfn</code>. DBD::DBM extends the list for <code>dbm_type</code> and <code>dbm_mldbm</code> to reset the value of <code>dbm_tietype</code>.</p>

<p>If your DBD has calculated values in the meta data area, then call <code>register_reset_on_modify</code>:</p>

<pre>    my %reset_on_modify = ( &#34;xxx_foo&#34; =&#62; &#34;xxx_bar&#34; );
    __PACKAGE__-&#62;register_reset_on_modify( \%reset_on_modify );</pre>

<dt><a name="register_compat_map"
>register_compat_map</a></dt>

<dd>
<p>Allows <code>get_table_meta_attr</code> and <code>set_table_meta_attr</code> to update the attribute name to the current favored one:</p>

<pre>    # from DBD::DBM
    my %compat_map = ( &#34;dbm_ext&#34; =&#62; &#34;f_ext&#34; );
    __PACKAGE__-&#62;register_compat_map( \%compat_map );</pre>

<dt><a name="open_data"
>open_data</a></dt>

<dd>
<p>Called to open the table&#39;s data storage. This is silently forwarded to <code>$meta-&#62;{sql_data_source}-&#62;open_data()</code>.</p>

<p>After this is done, a derived class might add more steps in an overridden <code>open_file</code> method.</p>

<dt><a name="new"
>new</a></dt>

<dd>
<p>Instantiates the table. This is done in 3 steps:</p>

<pre> 1. get the table meta data
 2. open the data file
 3. bless the table data structure using inherited constructor new</pre>

<p>It is not recommended to override the constructor of the table class. Find a reasonable place to add you extensions in one of the above four methods.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>The module DBI::DBD::SqlEngine is currently maintained by</p>

<p>H.Merijn Brand &#60; h.m.brand at xs4all.nl &#62; and Jens Rehsack &#60; rehsack at googlemail.com &#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>Copyright (C) 2010 by H.Merijn Brand &#38; Jens Rehsack</p>

<p>All rights reserved.</p>

<p>You may freely distribute and/or modify this module under the terms of either the GNU General Public License (GPL) or the Artistic License, as specified in the Perl README file.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
