<html><head><title>DBIx::Class::FilterColumn</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:15 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#filter_column'>filter_column</a>
    <li class='indexItem indexItem2'><a href='#get_filtered_column'>get_filtered_column</a>
    <li class='indexItem indexItem2'><a href='#set_filtered_column'>set_filtered_column</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#EXAMPLE_OF_USE'>EXAMPLE OF USE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>DBIx::Class::FilterColumn - Automatically convert column data</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<p>In your Schema or DB class add &#34;FilterColumn&#34; to the top of the component list.</p>

<pre>  __PACKAGE__-&#62;load_components(qw( FilterColumn ... ));</pre>

<p>Set up filters for the columns you want to convert.</p>

<pre> __PACKAGE__-&#62;filter_column( money =&#62; {
     filter_to_storage =&#62; &#39;to_pennies&#39;,
     filter_from_storage =&#62; &#39;from_pennies&#39;,
 });

 sub to_pennies   { $_[1] * 100 }

 sub from_pennies { $_[1] / 100 }

 1;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This component is meant to be a more powerful, but less DWIM-y, <a href="../../DBIx/Class/InflateColumn.html" class="podlinkpod"
>DBIx::Class::InflateColumn</a>. One of the major issues with said component is that it <b>only</b> works with references. Generally speaking anything that can be done with <a href="../../DBIx/Class/InflateColumn.html" class="podlinkpod"
>DBIx::Class::InflateColumn</a> can be done with this component.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="filter_column"
>filter_column</a></h2>

<pre> __PACKAGE__-&#62;filter_column( colname =&#62; {
     filter_from_storage =&#62; &#39;method&#39;|\&#38;coderef,
     filter_to_storage   =&#62; &#39;method&#39;|\&#38;coderef,
 })</pre>

<p>This is the method that you need to call to set up a filtered column. It takes exactly two arguments; the first being the column name the second being a hash reference with <code>filter_from_storage</code> and <code>filter_to_storage</code> set to either a method name or a code reference. In either case the filter is invoked as:</p>

<pre>  $row_obj-&#62;$filter_specification ($value_to_filter)</pre>

<p>with <code>$filter_specification</code> being chosen depending on whether the <code>$value_to_filter</code> is being retrieved from or written to permanent storage.</p>

<p>If a specific directional filter is not specified, the original value will be passed to/from storage unfiltered.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_filtered_column"
>get_filtered_column</a></h2>

<pre> $obj-&#62;get_filtered_column(&#39;colname&#39;)</pre>

<p>Returns the filtered value of the column</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="set_filtered_column"
>set_filtered_column</a></h2>

<pre> $obj-&#62;set_filtered_column(colname =&#62; &#39;new_value&#39;)</pre>

<p>Sets the filtered value of the column</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXAMPLE_OF_USE"
>EXAMPLE OF USE</a></h1>

<p>Some databases have restrictions on values that can be passed to boolean columns, and problems can be caused by passing value that perl considers to be false (such as <code>undef</code>).</p>

<p>One solution to this is to ensure that the boolean values are set to something that the database can handle - such as numeric zero and one, using code like this:-</p>

<pre>    __PACKAGE__-&#62;filter_column(
        my_boolean_column =&#62; {
            filter_to_storage   =&#62; sub { $_[1] ? 1 : 0 },
        }
    );</pre>

<p>In this case the <code>filter_from_storage</code> is not required, as just passing the database value through to perl does the right thing.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
