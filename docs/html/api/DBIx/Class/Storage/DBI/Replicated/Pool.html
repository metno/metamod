<html><head><title>DBIx::Class::Storage::DBI::Replicated::Pool</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../../../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../../../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../../../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../../../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../../../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../../../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../../../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../../../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:16 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../../../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#ATTRIBUTES'>ATTRIBUTES</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#maximum_lag_(%24num)'>maximum_lag ($num)</a>
    <li class='indexItem indexItem2'><a href='#last_validated'>last_validated</a>
    <li class='indexItem indexItem2'><a href='#replicant_type_(%24classname)'>replicant_type ($classname)</a>
    <li class='indexItem indexItem2'><a href='#replicants'>replicants</a>
    <li class='indexItem indexItem2'><a href='#master'>master</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#connect_replicants_(%24schema%2C_Array%5B%24connect_info%5D)'>connect_replicants ($schema, Array[$connect_info])</a>
    <li class='indexItem indexItem2'><a href='#connect_replicant_(%24schema%2C_%24connect_info)'>connect_replicant ($schema, $connect_info)</a>
    <li class='indexItem indexItem2'><a href='#_safely_ensure_connected_(%24replicant)'>_safely_ensure_connected ($replicant)</a>
    <li class='indexItem indexItem2'><a href='#_safely_(%24replicant%2C_%24name%2C_%24code)'>_safely ($replicant, $name, $code)</a>
    <li class='indexItem indexItem2'><a href='#connected_replicants'>connected_replicants</a>
    <li class='indexItem indexItem2'><a href='#active_replicants'>active_replicants</a>
    <li class='indexItem indexItem2'><a href='#all_replicants'>all_replicants</a>
    <li class='indexItem indexItem2'><a href='#validate_replicants'>validate_replicants</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#LICENSE'>LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>DBIx::Class::Storage::DBI::Replicated::Pool - Manage a pool of replicants</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<p>This class is used internally by <a href="../../../../../DBIx/Class/Storage/DBI/Replicated.html" class="podlinkpod"
>DBIx::Class::Storage::DBI::Replicated</a>.
You shouldn&#39;t need to create instances of this class.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>In a replicated storage type,
there is at least one replicant to handle the read-only traffic.
The Pool class manages this replicant,
or list of replicants,
and gives some methods for querying information about their status.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ATTRIBUTES"
>ATTRIBUTES</a></h1>

<p>This class defines the following attributes.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="maximum_lag_($num)"
>maximum_lag ($num)</a></h2>

<p>This is a number which defines the maximum allowed lag returned by the <a href="../../../../../DBIx/Class/Storage/DBI.html#lag_behind_master" class="podlinkpod"
>&#34;lag_behind_master&#34; in DBIx::Class::Storage::DBI</a> method.
The default is 0.
In general,
this should return a larger number when the replicant is lagging behind its master,
however the implementation of this is database specific,
so don&#39;t count on this number having a fixed meaning.
For example,
MySQL will return a number of seconds that the replicating database is lagging.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="last_validated"
>last_validated</a></h2>

<p>This is an integer representing a time since the last time the replicants were validated.
It&#39;s nothing fancy,
just an integer provided via the perl <a href="../../../../../perlfunc.html#time" class="podlinkpod"
>time</a> built-in.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="replicant_type_($classname)"
>replicant_type ($classname)</a></h2>

<p>Base class used to instantiate replicants that are in the pool.
Unless you need to subclass <a href="../../../../../DBIx/Class/Storage/DBI/Replicated/Replicant.html" class="podlinkpod"
>DBIx::Class::Storage::DBI::Replicated::Replicant</a> you should just leave this alone.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="replicants"
>replicants</a></h2>

<p>A hashref of replicant,
with the key being the dsn and the value returning the actual replicant storage.
For example,
if the $dsn element is something like:</p>

<pre>  &#34;dbi:SQLite:dbname=dbfile&#34;</pre>

<p>You could access the specific replicant via:</p>

<pre>  $schema-&#62;storage-&#62;replicants-&#62;{&#39;dbname=dbfile&#39;}</pre>

<p>This attributes also supports the following helper methods:</p>

<dl>
<dt><a name="set_replicant($key=&#62;$storage)"
>set_replicant($key=&#62;$storage)</a></dt>

<dd>
<p>Pushes a replicant onto the HashRef under $key</p>

<dt><a name="get_replicant($key)"
>get_replicant($key)</a></dt>

<dd>
<p>Retrieves the named replicant</p>

<dt><a name="has_replicants"
>has_replicants</a></dt>

<dd>
<p>Returns true if the Pool defines replicants.</p>

<dt><a name="num_replicants"
>num_replicants</a></dt>

<dd>
<p>The number of replicants in the pool</p>

<dt><a name="delete_replicant_($key)"
>delete_replicant ($key)</a></dt>

<dd>
<p>Removes the replicant under $key from the pool</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="master"
>master</a></h2>

<p>Reference to the master Storage.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<p>This class defines the following methods.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="connect_replicants_($schema,_Array[$connect_info])"
>connect_replicants ($schema, Array[$connect_info])</a></h2>

<p>Given an array of $dsn or connect_info structures suitable for connected to a database, create an <a href="../../../../../DBIx/Class/Storage/DBI/Replicated/Replicant.html" class="podlinkpod"
>DBIx::Class::Storage::DBI::Replicated::Replicant</a> object and store it in the <a href="#replicants" class="podlinkpod"
>&#34;replicants&#34;</a> attribute.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="connect_replicant_($schema,_$connect_info)"
>connect_replicant ($schema, $connect_info)</a></h2>

<p>Given a schema object and a hashref of $connect_info, connect the replicant and return it.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="_safely_ensure_connected_($replicant)"
>_safely_ensure_connected ($replicant)</a></h2>

<p>The standard ensure_connected method with throw an exception should it fail to connect. For the master database this is desirable, but since replicants are allowed to fail, this behavior is not desirable. This method wraps the call to ensure_connected in an eval in order to catch any generated errors. That way a slave can go completely offline (e.g. the box itself can die) without bringing down your entire pool of databases.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="_safely_($replicant,_$name,_$code)"
>_safely ($replicant, $name, $code)</a></h2>

<p>Execute <code>$code</code> for operation <code>$name</code> catching any exceptions and printing an error message to the <code>&#60;$replicant-</code>debugobj&#62;&#62;.</p>

<p>Returns 1 on success and undef on failure.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="connected_replicants"
>connected_replicants</a></h2>

<p>Returns true if there are connected replicants. Actually is overloaded to return the number of replicants. So you can do stuff like:</p>

<pre>  if( my $num_connected = $storage-&#62;has_connected_replicants ) {
    print &#34;I have $num_connected connected replicants&#34;;
  } else {
    print &#34;Sorry, no replicants.&#34;;
  }</pre>

<p>This method will actually test that each replicant in the <a href="#replicants" class="podlinkpod"
>&#34;replicants&#34;</a> hashref is actually connected, try not to hit this 10 times a second.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="active_replicants"
>active_replicants</a></h2>

<p>This is an array of replicants that are considered to be active in the pool. This does not check to see if they are connected, but if they are not, DBIC should automatically reconnect them for us when we hit them with a query.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="all_replicants"
>all_replicants</a></h2>

<p>Just a simple array of all the replicant storages. No particular order to the array is given, nor should any meaning be derived.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="validate_replicants"
>validate_replicants</a></h2>

<p>This does a check to see if 1) each replicate is connected (or reconnectable), 2) that is -&#62;is_replicating, and 3) that it is not exceeding the lag amount defined by <a href="#maximum_lag" class="podlinkpod"
>&#34;maximum_lag&#34;</a>. Replicants that fail any of these tests are set to inactive, and thus removed from the replication pool.</p>

<p>This tests <a href="#all_replicants" class="podlinkpod"
>&#34;all_replicants&#34;</a>, since a replicant that has been previous marked as inactive can be reactivated should it start to pass the validation tests again.</p>

<p>See <a href="../../../../../DBIx/Class/Storage/DBI.html" class="podlinkpod"
>DBIx::Class::Storage::DBI</a> for more about checking if a replicating connection is not following a master or is lagging.</p>

<p>Calling this method will generate queries on the replicant databases so it is not recommended that you run them very often.</p>

<p>This method requires that your underlying storage engine supports some sort of native replication mechanism. Currently only MySQL native replication is supported. Your patches to make other replication types work are welcomed.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>John Napiorkowski &#60;john.napiorkowski@takkle.com&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENSE"
>LICENSE</a></h1>

<p>You may distribute this code under the same terms as Perl itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../../../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
