<html><head><title>DBIx::Class::Storage::DBI::Replicated::Introduction</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../../../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../../../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../../../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../../../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../../../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../../../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../../../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../../../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:16 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../../../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#REPLICATED_STORAGE'>REPLICATED STORAGE</a>
  <li class='indexItem indexItem1'><a href='#PARTS_OF_REPLICATED_STORAGE'>PARTS OF REPLICATED STORAGE</a>
  <li class='indexItem indexItem1'><a href='#REPLICATED_STORAGE_CONFIGURATION'>REPLICATED STORAGE CONFIGURATION</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#LICENSE'>LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>DBIx::Class::Storage::DBI::Replicated::Introduction - Minimum Need to Know</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<p>This is an introductory document for <a href="../../../../../DBIx/Class/Storage/Replication.html" class="podlinkpod"
>DBIx::Class::Storage::Replication</a>.</p>

<p>This document is not an overview of what replication is or why you should be using it.
It is not a document explaining how to setup MySQL native replication either.
Copious external resources are available for both.
This document presumes you have the basics down.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p><a href="../../../../../DBIx/Class.html" class="podlinkpod"
>DBIx::Class</a> supports a framework for using database replication.
This system is integrated completely,
which means once it&#39;s setup you should be able to automatically just start using a replication cluster without additional work or changes to your code.
Some caveats apply,
primarily related to the proper use of transactions (you are wrapping all your database modifying statements inside a transaction,
right ;) ) however in our experience properly written DBIC will work transparently with Replicated storage.</p>

<p>Currently we have support for MySQL native replication,
which is relatively easy to install and configure.
We also currently support single master to one or more replicants (also called &#39;slaves&#39; in some documentation).
However the framework is not specifically tied to the MySQL framework and supporting other replication systems or topographies should be possible.
Please bring your patches and ideas to the #dbix-class IRC channel or the mailing list.</p>

<p>For an easy way to start playing with MySQL native replication,
see: <a href="../../../../../MySQL/Sandbox.html" class="podlinkpod"
>MySQL::Sandbox</a>.</p>

<p>If you are using this with a <a href="../../../../../Catalyst.html" class="podlinkpod"
>Catalyst</a> based application,
you may also want to see more recent updates to <a href="../../../../../Catalyst/Model/DBIC/Schema.html" class="podlinkpod"
>Catalyst::Model::DBIC::Schema</a>,
which has support for replication configuration options as well.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="REPLICATED_STORAGE"
>REPLICATED STORAGE</a></h1>

<p>By default,
when you start <a href="../../../../../DBIx/Class.html" class="podlinkpod"
>DBIx::Class</a>,
your Schema (<a href="../../../../../DBIx/Class/Schema.html" class="podlinkpod"
>DBIx::Class::Schema</a>) is assigned a storage_type,
which when fully connected will reflect your underlying storage engine as defined by your chosen database driver.
For example,
if you connect to a MySQL database,
your storage_type will be <a href="../../../../../DBIx/Class/Storage/DBI/mysql.html" class="podlinkpod"
>DBIx::Class::Storage::DBI::mysql</a> Your storage type class will contain database specific code to help smooth over the differences between databases and let <a href="../../../../../DBIx/Class.html" class="podlinkpod"
>DBIx::Class</a> do its thing.</p>

<p>If you want to use replication,
you will override this setting so that the replicated storage engine will &#39;wrap&#39; your underlying storages and present a unified interface to the end programmer.
This wrapper storage class will delegate method calls to either a master database or one or more replicated databases based on if they are read only (by default sent to the replicants) or write (reserved for the master).
Additionally,
the Replicated storage will monitor the health of your replicants and automatically drop them should one exceed configurable parameters.
Later,
it can automatically restore a replicant when its health is restored.</p>

<p>This gives you a very robust system,
since you can add or drop replicants and DBIC will automatically adjust itself accordingly.</p>

<p>Additionally,
if you need high data integrity,
such as when you are executing a transaction,
replicated storage will automatically delegate all database traffic to the master storage.
There are several ways to enable this high integrity mode,
but wrapping your statements inside a transaction is the easy and canonical option.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PARTS_OF_REPLICATED_STORAGE"
>PARTS OF REPLICATED STORAGE</a></h1>

<p>A replicated storage contains several parts.
First,
there is the replicated storage itself (<a href="../../../../../DBIx/Class/Storage/DBI/Replicated.html" class="podlinkpod"
>DBIx::Class::Storage::DBI::Replicated</a>).
A replicated storage takes a pool of replicants (<a href="../../../../../DBIx/Class/Storage/DBI/Replicated/Pool.html" class="podlinkpod"
>DBIx::Class::Storage::DBI::Replicated::Pool</a>) and a software balancer (<a href="../../../../../DBIx/Class/Storage/DBI/Replicated/Balancer.html" class="podlinkpod"
>DBIx::Class::Storage::DBI::Replicated::Balancer</a>).
The balancer does the job of splitting up all the read traffic amongst the replicants in the Pool.
Currently there are two types of balancers,
a Random one which chooses a Replicant in the Pool using a naive randomizer algorithm,
and a First replicant,
which just uses the first one in the Pool (and obviously is only of value when you have a single replicant).</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="REPLICATED_STORAGE_CONFIGURATION"
>REPLICATED STORAGE CONFIGURATION</a></h1>

<p>All the parts of replication can be altered dynamically at runtime,
which makes it possibly to create a system that automatically scales under load by creating more replicants as needed,
perhaps using a cloud system such as Amazon EC2.
However,
for common use you can setup your replicated storage to be enabled at the time you connect the databases.
The following is a breakdown of how you may wish to do this.
Again,
if you are using <a href="../../../../../Catalyst.html" class="podlinkpod"
>Catalyst</a>,
I strongly recommend you use (or upgrade to) the latest <a href="../../../../../Catalyst/Model/DBIC/Schema.html" class="podlinkpod"
>Catalyst::Model::DBIC::Schema</a>,
which makes this job even easier.</p>

<p>First,
you need to get a <code>$schema</code> object and set the storage_type:</p>

<pre>  my $schema = MyApp::Schema-&#62;clone;
  $schema-&#62;storage_type([
    &#39;::DBI::Replicated&#39; =&#62; {
      balancer_type =&#62; &#39;::Random&#39;,
      balancer_args =&#62; {
        auto_validate_every =&#62; 5,
        master_read_weight =&#62; 1
      },
      pool_args =&#62; {
        maximum_lag =&#62;2,
      },
    }
  ]);</pre>

<p>Then, you need to connect your <a href="../../../../../DBIx/Class/Schema.html" class="podlinkpod"
>DBIx::Class::Schema</a>.</p>

<pre>  $schema-&#62;connection($dsn, $user, $pass);</pre>

<p>Let&#39;s break down the settings. The method <a href="../../../../../DBIx/Class/Schema.html#storage_type" class="podlinkpod"
>&#34;storage_type&#34; in DBIx::Class::Schema</a> takes one mandatory parameter, a scalar value, and an option second value which is a Hash Reference of configuration options for that storage. In this case, we are setting the Replicated storage type using &#39;::DBI::Replicated&#39; as the first value. You will only use a different value if you are subclassing the replicated storage, so for now just copy that first parameter.</p>

<p>The second parameter contains a hash reference of stuff that gets passed to the replicated storage. <a href="../../../../../DBIx/Class/Storage/DBI/Replicated.html#balancer_type" class="podlinkpod"
>&#34;balancer_type&#34; in DBIx::Class::Storage::DBI::Replicated</a> is the type of software load balancer you will use to split up traffic among all your replicants. Right now we have two options, &#34;::Random&#34; and &#34;::First&#34;. You can review documentation for both at:</p>

<p><a href="../../../../../DBIx/Class/Storage/DBI/Replicated/Balancer/First.html" class="podlinkpod"
>DBIx::Class::Storage::DBI::Replicated::Balancer::First</a>, <a href="../../../../../DBIx/Class/Storage/DBI/Replicated/Balancer/Random.html" class="podlinkpod"
>DBIx::Class::Storage::DBI::Replicated::Balancer::Random</a>.</p>

<p>In this case we will have three replicants, so the ::Random option is the only one that makes sense.</p>

<p>&#39;balancer_args&#39; get passed to the balancer when it&#39;s instantiated. All balancers have the &#39;auto_validate_every&#39; option. This is the number of seconds we allow to pass between validation checks on a load balanced replicant. So the higher the number, the more possibility that your reads to the replicant may be inconsistent with what&#39;s on the master. Setting this number too low will result in increased database loads, so choose a number with care. Our experience is that setting the number around 5 seconds results in a good performance / integrity balance.</p>

<p>&#39;master_read_weight&#39; is an option associated with the ::Random balancer. It allows you to let the master be read from. I usually leave this off (default is off).</p>

<p>The &#39;pool_args&#39; are configuration options associated with the replicant pool. This object (<a href="../../../../../DBIx/Class/Storage/DBI/Replicated/Pool.html" class="podlinkpod"
>DBIx::Class::Storage::DBI::Replicated::Pool</a>) manages all the declared replicants. &#39;maximum_lag&#39; is the number of seconds a replicant is allowed to lag behind the master before being temporarily removed from the pool. Keep in mind that the Balancer option &#39;auto_validate_every&#39; determines how often a replicant is tested against this condition, so the true possible lag can be higher than the number you set. The default is zero.</p>

<p>No matter how low you set the maximum_lag or the auto_validate_every settings, there is always the chance that your replicants will lag a bit behind the master for the supported replication system built into MySQL. You can ensure reliable reads by using a transaction, which will force both read and write activity to the master, however this will increase the load on your master database.</p>

<p>After you&#39;ve configured the replicated storage, you need to add the connection information for the replicants:</p>

<pre>  $schema-&#62;storage-&#62;connect_replicants(
    [$dsn1, $user, $pass, \%opts],
    [$dsn2, $user, $pass, \%opts],
    [$dsn3, $user, $pass, \%opts],
  );</pre>

<p>These replicants should be configured as slaves to the master using the instructions for MySQL native replication, or if you are just learning, you will find <a href="../../../../../MySQL/Sandbox.html" class="podlinkpod"
>MySQL::Sandbox</a> an easy way to set up a replication cluster.</p>

<p>And now your $schema object is properly configured! Enjoy!</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>John Napiorkowski &#60;jjnapiork@cpan.org&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENSE"
>LICENSE</a></h1>

<p>You may distribute this code under the same terms as Perl itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../../../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
