<html><head><title>DBIx::Class::ResultSet</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:16 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#CUSTOM_ResultSet_CLASSES_THAT_USE_Moose'>CUSTOM ResultSet CLASSES THAT USE Moose</a>
  <li class='indexItem indexItem1'><a href='#EXAMPLES'>EXAMPLES</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Chaining_resultsets'>Chaining resultsets</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Resolving_conditions_and_attributes'>Resolving conditions and attributes</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Multiple_queries'>Multiple queries</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#new'>new</a>
    <li class='indexItem indexItem2'><a href='#search'>search</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#CAVEAT'>CAVEAT</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#search_rs'>search_rs</a>
    <li class='indexItem indexItem2'><a href='#search_literal'>search_literal</a>
    <li class='indexItem indexItem2'><a href='#find'>find</a>
    <li class='indexItem indexItem2'><a href='#search_related'>search_related</a>
    <li class='indexItem indexItem2'><a href='#search_related_rs'>search_related_rs</a>
    <li class='indexItem indexItem2'><a href='#cursor'>cursor</a>
    <li class='indexItem indexItem2'><a href='#single'>single</a>
    <li class='indexItem indexItem2'><a href='#get_column'>get_column</a>
    <li class='indexItem indexItem2'><a href='#search_like'>search_like</a>
    <li class='indexItem indexItem2'><a href='#slice'>slice</a>
    <li class='indexItem indexItem2'><a href='#next'>next</a>
    <li class='indexItem indexItem2'><a href='#result_source'>result_source</a>
    <li class='indexItem indexItem2'><a href='#result_class'>result_class</a>
    <li class='indexItem indexItem2'><a href='#count'>count</a>
    <li class='indexItem indexItem2'><a href='#count_rs'>count_rs</a>
    <li class='indexItem indexItem2'><a href='#count_literal'>count_literal</a>
    <li class='indexItem indexItem2'><a href='#all'>all</a>
    <li class='indexItem indexItem2'><a href='#reset'>reset</a>
    <li class='indexItem indexItem2'><a href='#first'>first</a>
    <li class='indexItem indexItem2'><a href='#update'>update</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#CAVEAT'>CAVEAT</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#update_all'>update_all</a>
    <li class='indexItem indexItem2'><a href='#delete'>delete</a>
    <li class='indexItem indexItem2'><a href='#delete_all'>delete_all</a>
    <li class='indexItem indexItem2'><a href='#populate'>populate</a>
    <li class='indexItem indexItem2'><a href='#pager'>pager</a>
    <li class='indexItem indexItem2'><a href='#page'>page</a>
    <li class='indexItem indexItem2'><a href='#new_result'>new_result</a>
    <li class='indexItem indexItem2'><a href='#as_query'>as_query</a>
    <li class='indexItem indexItem2'><a href='#find_or_new'>find_or_new</a>
    <li class='indexItem indexItem2'><a href='#create'>create</a>
    <li class='indexItem indexItem2'><a href='#find_or_create'>find_or_create</a>
    <li class='indexItem indexItem2'><a href='#update_or_create'>update_or_create</a>
    <li class='indexItem indexItem2'><a href='#update_or_new'>update_or_new</a>
    <li class='indexItem indexItem2'><a href='#get_cache'>get_cache</a>
    <li class='indexItem indexItem2'><a href='#set_cache'>set_cache</a>
    <li class='indexItem indexItem2'><a href='#clear_cache'>clear_cache</a>
    <li class='indexItem indexItem2'><a href='#is_paged'>is_paged</a>
    <li class='indexItem indexItem2'><a href='#is_ordered'>is_ordered</a>
    <li class='indexItem indexItem2'><a href='#related_resultset'>related_resultset</a>
    <li class='indexItem indexItem2'><a href='#current_source_alias'>current_source_alias</a>
    <li class='indexItem indexItem2'><a href='#as_subselect_rs'>as_subselect_rs</a>
    <li class='indexItem indexItem2'><a href='#throw_exception'>throw_exception</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#ATTRIBUTES'>ATTRIBUTES</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#order_by'>order_by</a>
    <li class='indexItem indexItem2'><a href='#columns'>columns</a>
    <li class='indexItem indexItem2'><a href='#%2Bcolumns'>+columns</a>
    <li class='indexItem indexItem2'><a href='#include_columns'>include_columns</a>
    <li class='indexItem indexItem2'><a href='#select'>select</a>
    <li class='indexItem indexItem2'><a href='#%2Bselect'>+select</a>
    <li class='indexItem indexItem2'><a href='#as'>as</a>
    <li class='indexItem indexItem2'><a href='#%2Bas'>+as</a>
    <li class='indexItem indexItem2'><a href='#join'>join</a>
    <li class='indexItem indexItem2'><a href='#collapse'>collapse</a>
    <li class='indexItem indexItem2'><a href='#prefetch'>prefetch</a>
    <li class='indexItem indexItem2'><a href='#alias'>alias</a>
    <li class='indexItem indexItem2'><a href='#page'>page</a>
    <li class='indexItem indexItem2'><a href='#rows'>rows</a>
    <li class='indexItem indexItem2'><a href='#offset'>offset</a>
    <li class='indexItem indexItem2'><a href='#software_limit'>software_limit</a>
    <li class='indexItem indexItem2'><a href='#group_by'>group_by</a>
    <li class='indexItem indexItem2'><a href='#having'>having</a>
    <li class='indexItem indexItem2'><a href='#distinct'>distinct</a>
    <li class='indexItem indexItem2'><a href='#where'>where</a>
    <li class='indexItem indexItem2'><a href='#cache'>cache</a>
    <li class='indexItem indexItem2'><a href='#for'>for</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#PREFETCHING'>PREFETCHING</a>
  <ul   class='indexList indexList2'>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#CAVEATS'>CAVEATS</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#DBIC_BIND_VALUES'>DBIC BIND VALUES</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR_AND_CONTRIBUTORS'>AUTHOR AND CONTRIBUTORS</a>
  <li class='indexItem indexItem1'><a href='#LICENSE'>LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>DBIx::Class::ResultSet - Represents a query used for fetching a set of results.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  my $users_rs = $schema-&#62;resultset(&#39;User&#39;);
  while( $user = $users_rs-&#62;next) {
    print $user-&#62;username;
  }

  my $registered_users_rs = $schema-&#62;resultset(&#39;User&#39;)-&#62;search({ registered =&#62; 1 });
  my @cds_in_2005 = $schema-&#62;resultset(&#39;CD&#39;)-&#62;search({ year =&#62; 2005 })-&#62;all();</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>A ResultSet is an object which stores a set of conditions representing a query. It is the backbone of DBIx::Class (i.e. the really important/useful bit).</p>

<p>No SQL is executed on the database when a ResultSet is created, it just stores all the conditions needed to create the query.</p>

<p>A basic ResultSet representing the data of an entire table is returned by calling <code>resultset</code> on a <a href="../../DBIx/Class/Schema.html" class="podlinkpod"
>DBIx::Class::Schema</a> and passing in a <a href="../../DBIx/Class/Manual/Glossary.html#Source" class="podlinkpod"
>Source</a> name.</p>

<pre>  my $users_rs = $schema-&#62;resultset(&#39;User&#39;);</pre>

<p>A new ResultSet is returned from calling <a href="#search" class="podlinkpod"
>&#34;search&#34;</a> on an existing ResultSet. The new one will contain all the conditions of the original, plus any new conditions added in the <code>search</code> call.</p>

<p>A ResultSet also incorporates an implicit iterator. <a href="#next" class="podlinkpod"
>&#34;next&#34;</a> and <a href="#reset" class="podlinkpod"
>&#34;reset&#34;</a> can be used to walk through all the <a href="../../DBIx/Class/Row.html" class="podlinkpod"
>DBIx::Class::Row</a>s the ResultSet represents.</p>

<p>The query that the ResultSet represents is <b>only</b> executed against the database when these methods are called: <a href="#find" class="podlinkpod"
>&#34;find&#34;</a>, <a href="#next" class="podlinkpod"
>&#34;next&#34;</a>, <a href="#all" class="podlinkpod"
>&#34;all&#34;</a>, <a href="#first" class="podlinkpod"
>&#34;first&#34;</a>, <a href="#single" class="podlinkpod"
>&#34;single&#34;</a>, <a href="#count" class="podlinkpod"
>&#34;count&#34;</a>.</p>

<p>If a resultset is used in a numeric context it returns the <a href="#count" class="podlinkpod"
>&#34;count&#34;</a>. However, if it is used in a boolean context it is <b>always</b> true. So if you want to check if a resultset has any results, you must use <code>if $rs != 0</code>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CUSTOM_ResultSet_CLASSES_THAT_USE_Moose"
>CUSTOM ResultSet CLASSES THAT USE Moose</a></h1>

<p>If you want to make your custom ResultSet classes with <a href="../../Moose.html" class="podlinkpod"
>Moose</a>, use a template similar to:</p>

<pre>    package MyApp::Schema::ResultSet::User;

    use Moose;
    use namespace::autoclean;
    use MooseX::NonMoose;
    extends &#39;DBIx::Class::ResultSet&#39;;

    sub BUILDARGS { $_[2] }

    ...your code...

    __PACKAGE__-&#62;meta-&#62;make_immutable;

    1;</pre>

<p>The <a href="../../MooseX/NonMoose.html" class="podlinkpod"
>MooseX::NonMoose</a> is necessary so that the <a href="../../Moose.html" class="podlinkpod"
>Moose</a> constructor does not clash with the regular ResultSet constructor. Alternatively, you can use:</p>

<pre>    __PACKAGE__-&#62;meta-&#62;make_immutable(inline_constructor =&#62; 0);</pre>

<p>The <a href="../../Moose/Manual/Construction.html#BUILDARGS" class="podlinkpod"
>BUILDARGS</a> is necessary because the signature of the ResultSet <code>new</code> is <code>-&#62;new($source, \%args)</code>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXAMPLES"
>EXAMPLES</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Chaining_resultsets"
>Chaining resultsets</a></h2>

<p>Let&#39;s say you&#39;ve got a query that needs to be run to return some data to the user. But, you have an authorization system in place that prevents certain users from seeing certain information. So, you want to construct the basic query in one method, but add constraints to it in another.</p>

<pre>  sub get_data {
    my $self = shift;
    my $request = $self-&#62;get_request; # Get a request object somehow.
    my $schema = $self-&#62;result_source-&#62;schema;

    my $cd_rs = $schema-&#62;resultset(&#39;CD&#39;)-&#62;search({
      title =&#62; $request-&#62;param(&#39;title&#39;),
      year =&#62; $request-&#62;param(&#39;year&#39;),
    });

    $cd_rs = $self-&#62;apply_security_policy( $cd_rs );

    return $cd_rs-&#62;all();
  }

  sub apply_security_policy {
    my $self = shift;
    my ($rs) = @_;

    return $rs-&#62;search({
      subversive =&#62; 0,
    });
  }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Resolving_conditions_and_attributes"
>Resolving conditions and attributes</a></h3>

<p>When a resultset is chained from another resultset (ie: <code>my $new_rs = $old_rs-</code>search(\%extra_cond, \%attrs)&#62;), conditions and attributes with the same keys need resolving.</p>

<p>If any of <a href="#columns" class="podlinkpod"
>&#34;columns&#34;</a>, <a href="#select" class="podlinkpod"
>&#34;select&#34;</a>, <a href="#as" class="podlinkpod"
>&#34;as&#34;</a> are present, they reset the original selection, and start the selection &#34;clean&#34;.</p>

<p>The <a href="#join" class="podlinkpod"
>&#34;join&#34;</a>, <a href="#prefetch" class="podlinkpod"
>&#34;prefetch&#34;</a>, <a href="#%2Bcolumns" class="podlinkpod"
>&#34;+columns&#34;</a>, <a href="#%2Bselect" class="podlinkpod"
>&#34;+select&#34;</a>, <a href="#%2Bas" class="podlinkpod"
>&#34;+as&#34;</a> attributes are merged into the existing ones from the original resultset.</p>

<p>The <a href="#where" class="podlinkpod"
>&#34;where&#34;</a> and <a href="#having" class="podlinkpod"
>&#34;having&#34;</a> attributes, and any search conditions, are merged with an SQL <code>AND</code> to the existing condition from the original resultset.</p>

<p>All other attributes are overridden by any new ones supplied in the search attributes.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Multiple_queries"
>Multiple queries</a></h2>

<p>Since a resultset just defines a query, you can do all sorts of things with it with the same object.</p>

<pre>  # Don&#39;t hit the DB yet.
  my $cd_rs = $schema-&#62;resultset(&#39;CD&#39;)-&#62;search({
    title =&#62; &#39;something&#39;,
    year =&#62; 2009,
  });

  # Each of these hits the DB individually.
  my $count = $cd_rs-&#62;count;
  my $most_recent = $cd_rs-&#62;get_column(&#39;date_released&#39;)-&#62;max();
  my @records = $cd_rs-&#62;all;</pre>

<p>And it&#39;s not just limited to SELECT statements.</p>

<pre>  $cd_rs-&#62;delete();</pre>

<p>This is even cooler:</p>

<pre>  $cd_rs-&#62;create({ artist =&#62; &#39;Fred&#39; });</pre>

<p>Which is the same as:</p>

<pre>  $schema-&#62;resultset(&#39;CD&#39;)-&#62;create({
    title =&#62; &#39;something&#39;,
    year =&#62; 2009,
    artist =&#62; &#39;Fred&#39;
  });</pre>

<p>See: <a href="#search" class="podlinkpod"
>&#34;search&#34;</a>, <a href="#count" class="podlinkpod"
>&#34;count&#34;</a>, <a href="#get_column" class="podlinkpod"
>&#34;get_column&#34;</a>, <a href="#all" class="podlinkpod"
>&#34;all&#34;</a>, <a href="#create" class="podlinkpod"
>&#34;create&#34;</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="new"
>new</a></h2>

<dl>
<dt><a name="Arguments:_$source,_\%attrs?"
>Arguments: <a href="../../DBIx/Class/ResultSource.html" class="podlinkpod"
>$source</a>, <a href="#ATTRIBUTES" class="podlinkpod"
>\%attrs?</a></a></dt>

<dd>
<dt><a name="Return_Value:_$resultset"
>Return Value: <a href="#search" class="podlinkpod"
>$resultset</a></a></dt>
</dl>

<p>The resultset constructor. Takes a source object (usually a <a href="../../DBIx/Class/ResultSourceProxy/Table.html" class="podlinkpod"
>DBIx::Class::ResultSourceProxy::Table</a>) and an attribute hash (see <a href="#ATTRIBUTES" class="podlinkpod"
>&#34;ATTRIBUTES&#34;</a> below). Does not perform any queries -- these are executed as needed by the other methods.</p>

<p>Generally you never construct a resultset manually. Instead you get one from e.g. a <code>$schema-&#62;<a href="../../DBIx/Class/Schema.html#resultset" class="podlinkpod"
>resultset</a>(&#39;$source_name&#39;)</code> or <code>$another_resultset-&#62;<a href="#search" class="podlinkpod"
>search</a>(...)</code> (the later called in scalar context):</p>

<pre>  my $rs = $schema-&#62;resultset(&#39;CD&#39;)-&#62;search({ title =&#62; &#39;100th Window&#39; });</pre>

<dl>
<dt><a name="WARNING"
>WARNING</a></dt>

<dd>
<p>If called on an object, proxies to <a href="#new_result" class="podlinkpod"
>&#34;new_result&#34;</a> instead, so</p>

<pre>  my $cd = $schema-&#62;resultset(&#39;CD&#39;)-&#62;new({ title =&#62; &#39;Spoon&#39; });</pre>

<p>will return a CD object, not a ResultSet, and is equivalent to:</p>

<pre>  my $cd = $schema-&#62;resultset(&#39;CD&#39;)-&#62;new_result({ title =&#62; &#39;Spoon&#39; });</pre>

<p>Please also keep in mind that many internals call <a href="#new_result" class="podlinkpod"
>&#34;new_result&#34;</a> directly, so overloading this method with the idea of intercepting new result object creation <b>will not work</b>. See also warning pertaining to <a href="#create" class="podlinkpod"
>&#34;create&#34;</a>.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="search"
>search</a></h2>

<dl>
<dt><a name="Arguments:_$cond_|_undef,_\%attrs?"
>Arguments: <a href="../../DBIx/Class/SQLMaker.html" class="podlinkpod"
>$cond</a> | undef, <a href="#ATTRIBUTES" class="podlinkpod"
>\%attrs?</a></a></dt>

<dd>
<dt><a name="Return_Value:_$resultset_(scalar_context)_|_@result_objs_(list_context)"
>Return Value: $resultset (scalar context) | <a href="../../DBIx/Class/Manual/ResultClass.html" class="podlinkpod"
>@result_objs</a> (list context)</a></dt>
</dl>

<pre>  my @cds    = $cd_rs-&#62;search({ year =&#62; 2001 }); # &#34;... WHERE year = 2001&#34;
  my $new_rs = $cd_rs-&#62;search({ year =&#62; 2005 });

  my $new_rs = $cd_rs-&#62;search([ { year =&#62; 2005 }, { year =&#62; 2004 } ]);
                 # year = 2005 OR year = 2004</pre>

<p>In list context, <code>-&#62;all()</code> is called implicitly on the resultset, thus returning a list of <a href="../../DBIx/Class/Manual/ResultClass.html" class="podlinkpod"
>result</a> objects instead. To avoid that, use <a href="#search_rs" class="podlinkpod"
>&#34;search_rs&#34;</a>.</p>

<p>If you need to pass in additional attributes but no additional condition, call it as <code>search(undef, \%attrs)</code>.</p>

<pre>  # &#34;SELECT name, artistid FROM $artist_table&#34;
  my @all_artists = $schema-&#62;resultset(&#39;Artist&#39;)-&#62;search(undef, {
    columns =&#62; [qw/name artistid/],
  });</pre>

<p>For a list of attributes that can be passed to <code>search</code>, see <a href="#ATTRIBUTES" class="podlinkpod"
>&#34;ATTRIBUTES&#34;</a>. For more examples of using this function, see <a href="../../DBIx/Class/Manual/Cookbook.html#Searching" class="podlinkpod"
>Searching</a>. For a complete documentation for the first argument, see <a href="../../SQL/Abstract.html" class="podlinkpod"
>SQL::Abstract</a> and its extension <a href="../../DBIx/Class/SQLMaker.html" class="podlinkpod"
>DBIx::Class::SQLMaker</a>.</p>

<p>For more help on using joins with search, see <a href="../../DBIx/Class/Manual/Joining.html" class="podlinkpod"
>DBIx::Class::Manual::Joining</a>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="CAVEAT"
>CAVEAT</a></h3>

<p>Note that <a href="#search" class="podlinkpod"
>&#34;search&#34;</a> does not process/deflate any of the values passed in the <a href="../../SQL/Abstract.html" class="podlinkpod"
>SQL::Abstract</a>-compatible search condition structure. This is unlike other condition-bound methods <a href="#new_result" class="podlinkpod"
>&#34;new_result&#34;</a>, <a href="#create" class="podlinkpod"
>&#34;create&#34;</a> and <a href="#find" class="podlinkpod"
>&#34;find&#34;</a>. The user must ensure manually that any value passed to this method will stringify to something the RDBMS knows how to deal with. A notable example is the handling of <a href="../../DateTime.html" class="podlinkpod"
>DateTime</a> objects, for more info see: <a href="../../DBIx/Class/Manual/Cookbook.html#Formatting_DateTime_objects_in_queries" class="podlinkpod"
>&#34;Formatting DateTime objects in queries&#34; in DBIx::Class::Manual::Cookbook</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="search_rs"
>search_rs</a></h2>

<dl>
<dt><a name="Arguments:_$cond,_\%attrs?"
>Arguments: <a href="../../DBIx/Class/SQLMaker.html" class="podlinkpod"
>$cond</a>, <a href="#ATTRIBUTES" class="podlinkpod"
>\%attrs?</a></a></dt>

<dd>
<dt><a name="Return_Value:_$resultset"
>Return Value: <a href="#search" class="podlinkpod"
>$resultset</a></a></dt>
</dl>

<p>This method does the same exact thing as search() except it will always return a resultset, even in list context.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="search_literal"
>search_literal</a></h2>

<p><b>CAVEAT</b>: <code>search_literal</code> is provided for Class::DBI compatibility and should only be used in that context. <code>search_literal</code> is a convenience method. It is equivalent to calling <code>$schema-&#62;search(\[])</code>, but if you want to ensure columns are bound correctly, use <a href="#search" class="podlinkpod"
>&#34;search&#34;</a>.</p>

<p>See <a href="../../DBIx/Class/Manual/Cookbook.html#Searching" class="podlinkpod"
>&#34;Searching&#34; in DBIx::Class::Manual::Cookbook</a> and <a href="../../DBIx/Class/Manual/FAQ.html#Searching" class="podlinkpod"
>&#34;Searching&#34; in DBIx::Class::Manual::FAQ</a> for searching techniques that do not require <code>search_literal</code>.</p>

<dl>
<dt><a name="Arguments:_$sql_fragment,_@standalone_bind_values"
>Arguments: $sql_fragment, @standalone_bind_values</a></dt>

<dd>
<dt><a name="Return_Value:_$resultset_(scalar_context)_|_@result_objs_(list_context)"
>Return Value: <a href="#search" class="podlinkpod"
>$resultset</a> (scalar context) | <a href="../../DBIx/Class/Manual/ResultClass.html" class="podlinkpod"
>@result_objs</a> (list context)</a></dt>
</dl>

<pre>  my @cds   = $cd_rs-&#62;search_literal(&#39;year = ? AND title = ?&#39;, qw/2001 Reload/);
  my $newrs = $artist_rs-&#62;search_literal(&#39;name = ?&#39;, &#39;Metallica&#39;);</pre>

<p>Pass a literal chunk of SQL to be added to the conditional part of the resultset query.</p>

<p>Example of how to use <code>search</code> instead of <code>search_literal</code></p>

<pre>  my @cds = $cd_rs-&#62;search_literal(&#39;cdid = ? AND (artist = ? OR artist = ?)&#39;, (2, 1, 2));
  my @cds = $cd_rs-&#62;search(\[ &#39;cdid = ? AND (artist = ? OR artist = ?)&#39;, [ &#39;cdid&#39;, 2 ], [ &#39;artist&#39;, 1 ], [ &#39;artist&#39;, 2 ] ]);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="find"
>find</a></h2>

<dl>
<dt><a name="Arguments:_\%columns_values_|_@pk_values,_{_key_=&#62;_$unique_constraint,_%attrs_}?"
>Arguments: \%columns_values | @pk_values, { key =&#62; $unique_constraint, <a href="#ATTRIBUTES" class="podlinkpod"
>%attrs</a> }?</a></dt>

<dd>
<dt><a name="Return_Value:_$result_|_undef"
>Return Value: <a href="../../DBIx/Class/Manual/ResultClass.html" class="podlinkpod"
>$result</a> | undef</a></dt>
</dl>

<p>Finds and returns a single row based on supplied criteria. Takes either a hashref with the same format as <a href="#create" class="podlinkpod"
>&#34;create&#34;</a> (including inference of foreign keys from related objects), or a list of primary key values in the same order as the <a href="../../DBIx/Class/ResultSource.html#primary_columns" class="podlinkpod"
>primary columns</a> declaration on the <a href="#result_source" class="podlinkpod"
>&#34;result_source&#34;</a>.</p>

<p>In either case an attempt is made to combine conditions already existing on the resultset with the condition passed to this method.</p>

<p>To aid with preparing the correct query for the storage you may supply the <code>key</code> attribute, which is the name of a <a href="../../DBIx/Class/ResultSource.html#add_unique_constraint" class="podlinkpod"
>unique constraint</a> (the unique constraint corresponding to the <a href="../../DBIx/Class/ResultSource.html#primary_columns" class="podlinkpod"
>primary columns</a> is always named <code>primary</code>). If the <code>key</code> attribute has been supplied, and DBIC is unable to construct a query that satisfies the named unique constraint fully ( non-NULL values for each column member of the constraint) an exception is thrown.</p>

<p>If no <code>key</code> is specified, the search is carried over all unique constraints which are fully defined by the available condition.</p>

<p>If no such constraint is found, <code>find</code> currently defaults to a simple <code>search-&#62;(\%column_values)</code> which may or may not do what you expect. Note that this fallback behavior may be deprecated in further versions. If you need to search with arbitrary conditions - use <a href="#search" class="podlinkpod"
>&#34;search&#34;</a>. If the query resulting from this fallback produces more than one row, a warning to the effect is issued, though only the first row is constructed and returned as <code>$result_object</code>.</p>

<p>In addition to <code>key</code>, <a href="#find" class="podlinkpod"
>&#34;find&#34;</a> recognizes and applies standard <a href="#ATTRIBUTES" class="podlinkpod"
>resultset attributes</a> in the same way as <a href="#search" class="podlinkpod"
>&#34;search&#34;</a> does.</p>

<p>Note that if you have extra concerns about the correctness of the resulting query you need to specify the <code>key</code> attribute and supply the entire condition as an argument to find (since it is not always possible to perform the combination of the resultset condition with the supplied one, especially if the resultset condition contains literal sql).</p>

<p>For example, to find a row by its primary key:</p>

<pre>  my $cd = $schema-&#62;resultset(&#39;CD&#39;)-&#62;find(5);</pre>

<p>You can also find a row by a specific unique constraint:</p>

<pre>  my $cd = $schema-&#62;resultset(&#39;CD&#39;)-&#62;find(
    {
      artist =&#62; &#39;Massive Attack&#39;,
      title  =&#62; &#39;Mezzanine&#39;,
    },
    { key =&#62; &#39;cd_artist_title&#39; }
  );</pre>

<p>See also <a href="#find_or_create" class="podlinkpod"
>&#34;find_or_create&#34;</a> and <a href="#update_or_create" class="podlinkpod"
>&#34;update_or_create&#34;</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="search_related"
>search_related</a></h2>

<dl>
<dt><a name="Arguments:_$rel_name,_$cond?,_\%attrs?"
>Arguments: $rel_name, $cond?, <a href="#ATTRIBUTES" class="podlinkpod"
>\%attrs?</a></a></dt>

<dd>
<dt><a name="Return_Value:_$resultset_(scalar_context)_|_@result_objs_(list_context)"
>Return Value: <a href="#search" class="podlinkpod"
>$resultset</a> (scalar context) | <a href="../../DBIx/Class/Manual/ResultClass.html" class="podlinkpod"
>@result_objs</a> (list context)</a></dt>
</dl>

<pre>  $new_rs = $cd_rs-&#62;search_related(&#39;artist&#39;, {
    name =&#62; &#39;Emo-R-Us&#39;,
  });</pre>

<p>Searches the specified relationship, optionally specifying a condition and attributes for matching records. See <a href="#ATTRIBUTES" class="podlinkpod"
>&#34;ATTRIBUTES&#34;</a> for more information.</p>

<p>In list context, <code>-&#62;all()</code> is called implicitly on the resultset, thus returning a list of result objects instead. To avoid that, use <a href="#search_related_rs" class="podlinkpod"
>&#34;search_related_rs&#34;</a>.</p>

<p>See also <a href="#search_related_rs" class="podlinkpod"
>&#34;search_related_rs&#34;</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="search_related_rs"
>search_related_rs</a></h2>

<p>This method works exactly the same as search_related, except that it guarantees a resultset, even in list context.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="cursor"
>cursor</a></h2>

<dl>
<dt><a name="Arguments:_none"
>Arguments: none</a></dt>

<dd>
<dt><a name="Return_Value:_$cursor"
>Return Value: <a href="../../DBIx/Class/Cursor.html" class="podlinkpod"
>$cursor</a></a></dt>
</dl>

<p>Returns a storage-driven cursor to the given resultset. See <a href="../../DBIx/Class/Cursor.html" class="podlinkpod"
>DBIx::Class::Cursor</a> for more information.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="single"
>single</a></h2>

<dl>
<dt><a name="Arguments:_$cond?"
>Arguments: <a href="../../DBIx/Class/SQLMaker.html" class="podlinkpod"
>$cond?</a></a></dt>

<dd>
<dt><a name="Return_Value:_$result_|_undef"
>Return Value: <a href="../../DBIx/Class/Manual/ResultClass.html" class="podlinkpod"
>$result</a> | undef</a></dt>
</dl>

<pre>  my $cd = $schema-&#62;resultset(&#39;CD&#39;)-&#62;single({ year =&#62; 2001 });</pre>

<p>Inflates the first result without creating a cursor if the resultset has any records in it; if not returns <code>undef</code>. Used by <a href="#find" class="podlinkpod"
>&#34;find&#34;</a> as a lean version of <a href="#search" class="podlinkpod"
>&#34;search&#34;</a>.</p>

<p>While this method can take an optional search condition (just like <a href="#search" class="podlinkpod"
>&#34;search&#34;</a>) being a fast-code-path it does not recognize search attributes. If you need to add extra joins or similar, call <a href="#search" class="podlinkpod"
>&#34;search&#34;</a> and then chain-call <a href="#single" class="podlinkpod"
>&#34;single&#34;</a> on the <a href="../../DBIx/Class/ResultSet.html" class="podlinkpod"
>DBIx::Class::ResultSet</a> returned.</p>

<dl>
<dt><a name="Note"
><b>Note</b></a></dt>

<dd>
<p>As of 0.08100, this method enforces the assumption that the preceding query returns only one row. If more than one row is returned, you will receive a warning:</p>

<pre>  Query returned more than one row</pre>

<p>In this case, you should be using <a href="#next" class="podlinkpod"
>&#34;next&#34;</a> or <a href="#find" class="podlinkpod"
>&#34;find&#34;</a> instead, or if you really know what you are doing, use the <a href="#rows" class="podlinkpod"
>&#34;rows&#34;</a> attribute to explicitly limit the size of the resultset.</p>

<p>This method will also throw an exception if it is called on a resultset prefetching has_many, as such a prefetch implies fetching multiple rows from the database in order to assemble the resulting object.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_column"
>get_column</a></h2>

<dl>
<dt><a name="Arguments:_$cond?"
>Arguments: <a href="../../DBIx/Class/SQLMaker.html" class="podlinkpod"
>$cond?</a></a></dt>

<dd>
<dt><a name="Return_Value:_$resultsetcolumn"
>Return Value: <a href="../../DBIx/Class/ResultSetColumn.html" class="podlinkpod"
>$resultsetcolumn</a></a></dt>
</dl>

<pre>  my $max_length = $rs-&#62;get_column(&#39;length&#39;)-&#62;max;</pre>

<p>Returns a <a href="../../DBIx/Class/ResultSetColumn.html" class="podlinkpod"
>DBIx::Class::ResultSetColumn</a> instance for a column of the ResultSet.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="search_like"
>search_like</a></h2>

<dl>
<dt><a name="Arguments:_$cond,_\%attrs?"
>Arguments: <a href="../../DBIx/Class/SQLMaker.html" class="podlinkpod"
>$cond</a>, <a href="#ATTRIBUTES" class="podlinkpod"
>\%attrs?</a></a></dt>

<dd>
<dt><a name="Return_Value:_$resultset_(scalar_context)_|_@result_objs_(list_context)"
>Return Value: <a href="#search" class="podlinkpod"
>$resultset</a> (scalar context) | <a href="../../DBIx/Class/Manual/ResultClass.html" class="podlinkpod"
>@result_objs</a> (list context)</a></dt>
</dl>

<pre>  # WHERE title LIKE &#39;%blue%&#39;
  $cd_rs = $rs-&#62;search_like({ title =&#62; &#39;%blue%&#39;});</pre>

<p>Performs a search, but uses <code>LIKE</code> instead of <code>=</code> as the condition. Note that this is simply a convenience method retained for ex Class::DBI users. You most likely want to use <a href="#search" class="podlinkpod"
>&#34;search&#34;</a> with specific operators.</p>

<p>For more information, see <a href="../../DBIx/Class/Manual/Cookbook.html" class="podlinkpod"
>DBIx::Class::Manual::Cookbook</a>.</p>

<p>This method is deprecated and will be removed in 0.09. Use <a href="#search()" class="podlinkpod"
>&#34;search()&#34;</a> instead. An example conversion is:</p>

<pre>  -&#62;search_like({ foo =&#62; &#39;bar&#39; });

  # Becomes

  -&#62;search({ foo =&#62; { like =&#62; &#39;bar&#39; } });</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="slice"
>slice</a></h2>

<dl>
<dt><a name="Arguments:_$first,_$last"
>Arguments: $first, $last</a></dt>

<dd>
<dt><a name="Return_Value:_$resultset_(scalar_context)_|_@result_objs_(list_context)"
>Return Value: <a href="#search" class="podlinkpod"
>$resultset</a> (scalar context) | <a href="../../DBIx/Class/Manual/ResultClass.html" class="podlinkpod"
>@result_objs</a> (list context)</a></dt>
</dl>

<p>Returns a resultset or object list representing a subset of elements from the resultset slice is called on. Indexes are from 0, i.e., to get the first three records, call:</p>

<pre>  my ($one, $two, $three) = $rs-&#62;slice(0, 2);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="next"
>next</a></h2>

<dl>
<dt><a name="Arguments:_none"
>Arguments: none</a></dt>

<dd>
<dt><a name="Return_Value:_$result_|_undef"
>Return Value: <a href="../../DBIx/Class/Manual/ResultClass.html" class="podlinkpod"
>$result</a> | undef</a></dt>
</dl>

<p>Returns the next element in the resultset (<code>undef</code> is there is none).</p>

<p>Can be used to efficiently iterate over records in the resultset:</p>

<pre>  my $rs = $schema-&#62;resultset(&#39;CD&#39;)-&#62;search;
  while (my $cd = $rs-&#62;next) {
    print $cd-&#62;title;
  }</pre>

<p>Note that you need to store the resultset object, and call <code>next</code> on it. Calling <code>resultset(&#39;Table&#39;)-&#62;next</code> repeatedly will always return the first record from the resultset.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="result_source"
>result_source</a></h2>

<dl>
<dt><a name="Arguments:_$result_source?"
>Arguments: <a href="../../DBIx/Class/ResultSource.html" class="podlinkpod"
>$result_source?</a></a></dt>

<dd>
<dt><a name="Return_Value:_$result_source"
>Return Value: <a href="../../DBIx/Class/ResultSource.html" class="podlinkpod"
>$result_source</a></a></dt>
</dl>

<p>An accessor for the primary ResultSource object from which this ResultSet is derived.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="result_class"
>result_class</a></h2>

<dl>
<dt><a name="Arguments:_$result_class?"
>Arguments: $result_class?</a></dt>

<dd>
<dt><a name="Return_Value:_$result_class"
>Return Value: $result_class</a></dt>
</dl>

<p>An accessor for the class to use when creating result objects. Defaults to <code>result_source-&#62;result_class</code> - which in most cases is the name of the <a href="../../DBIx/Class/Manual/Glossary.html#ResultSource" class="podlinkpod"
>&#34;table&#34;</a> class.</p>

<p>Note that changing the result_class will also remove any components that were originally loaded in the source class via <a href="../../DBIx/Class/ResultSource.html#load_components" class="podlinkpod"
>&#34;load_components&#34; in DBIx::Class::ResultSource</a>. Any overloaded methods in the original source class will not run.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="count"
>count</a></h2>

<dl>
<dt><a name="Arguments:_$cond,_\%attrs?"
>Arguments: <a href="../../DBIx/Class/SQLMaker.html" class="podlinkpod"
>$cond</a>, <a href="#ATTRIBUTES" class="podlinkpod"
>\%attrs?</a></a></dt>

<dd>
<dt><a name="Return_Value:_$count"
>Return Value: $count</a></dt>
</dl>

<p>Performs an SQL <code>COUNT</code> with the same query as the resultset was built with to find the number of elements. Passing arguments is equivalent to <code>$rs-&#62;search ($cond, \%attrs)-&#62;count</code></p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="count_rs"
>count_rs</a></h2>

<dl>
<dt><a name="Arguments:_$cond,_\%attrs?"
>Arguments: <a href="../../DBIx/Class/SQLMaker.html" class="podlinkpod"
>$cond</a>, <a href="#ATTRIBUTES" class="podlinkpod"
>\%attrs?</a></a></dt>

<dd>
<dt><a name="Return_Value:_$count_rs"
>Return Value: <a href="../../DBIx/Class/ResultSetColumn.html" class="podlinkpod"
>$count_rs</a></a></dt>
</dl>

<p>Same as <a href="#count" class="podlinkpod"
>&#34;count&#34;</a> but returns a <a href="../../DBIx/Class/ResultSetColumn.html" class="podlinkpod"
>DBIx::Class::ResultSetColumn</a> object. This can be very handy for subqueries:</p>

<pre>  -&#62;search( { amount =&#62; $some_rs-&#62;count_rs-&#62;as_query } )</pre>

<p>As with regular resultsets the SQL query will be executed only after the resultset is accessed via <a href="#next" class="podlinkpod"
>&#34;next&#34;</a> or <a href="#all" class="podlinkpod"
>&#34;all&#34;</a>. That would return the same single value obtainable via <a href="#count" class="podlinkpod"
>&#34;count&#34;</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="count_literal"
>count_literal</a></h2>

<p><b>CAVEAT</b>: <code>count_literal</code> is provided for Class::DBI compatibility and should only be used in that context. See <a href="#search_literal" class="podlinkpod"
>&#34;search_literal&#34;</a> for further info.</p>

<dl>
<dt><a name="Arguments:_$sql_fragment,_@standalone_bind_values"
>Arguments: $sql_fragment, @standalone_bind_values</a></dt>

<dd>
<dt><a name="Return_Value:_$count"
>Return Value: $count</a></dt>
</dl>

<p>Counts the results in a literal query. Equivalent to calling <a href="#search_literal" class="podlinkpod"
>&#34;search_literal&#34;</a> with the passed arguments, then <a href="#count" class="podlinkpod"
>&#34;count&#34;</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="all"
>all</a></h2>

<dl>
<dt><a name="Arguments:_none"
>Arguments: none</a></dt>

<dd>
<dt><a name="Return_Value:_@result_objs"
>Return Value: <a href="../../DBIx/Class/Manual/ResultClass.html" class="podlinkpod"
>@result_objs</a></a></dt>
</dl>

<p>Returns all elements in the resultset.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="reset"
>reset</a></h2>

<dl>
<dt><a name="Arguments:_none"
>Arguments: none</a></dt>

<dd>
<dt><a name="Return_Value:_$self"
>Return Value: $self</a></dt>
</dl>

<p>Resets the resultset&#39;s cursor, so you can iterate through the elements again. Implicitly resets the storage cursor, so a subsequent <a href="#next" class="podlinkpod"
>&#34;next&#34;</a> will trigger another query.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="first"
>first</a></h2>

<dl>
<dt><a name="Arguments:_none"
>Arguments: none</a></dt>

<dd>
<dt><a name="Return_Value:_$result_|_undef"
>Return Value: <a href="../../DBIx/Class/Manual/ResultClass.html" class="podlinkpod"
>$result</a> | undef</a></dt>
</dl>

<p><a href="#reset" class="podlinkpod"
>Resets</a> the resultset (causing a fresh query to storage) and returns an object for the first result (or <code>undef</code> if the resultset is empty).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="update"
>update</a></h2>

<dl>
<dt><a name="Arguments:_\%values"
>Arguments: \%values</a></dt>

<dd>
<dt><a name="Return_Value:_$underlying_storage_rv"
>Return Value: $underlying_storage_rv</a></dt>
</dl>

<p>Sets the specified columns in the resultset to the supplied values in a single query. Note that this will not run any accessor/set_column/update triggers, nor will it update any result object instances derived from this resultset (this includes the contents of the <a href="#set_cache" class="podlinkpod"
>resultset cache</a> if any). See <a href="#update_all" class="podlinkpod"
>&#34;update_all&#34;</a> if you need to execute any on-update triggers or cascades defined either by you or a <a href="../../DBIx/Class/Manual/Component.html#WHAT_IS_A_COMPONENT" class="podlinkpod"
>result component</a>.</p>

<p>The return value is a pass through of what the underlying storage backend returned, and may vary. See <a href="../../DBI.html#execute" class="podlinkpod"
>&#34;execute&#34; in DBI</a> for the most common case.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="CAVEAT"
>CAVEAT</a></h3>

<p>Note that <a href="#update" class="podlinkpod"
>&#34;update&#34;</a> does not process/deflate any of the values passed in. This is unlike the corresponding <a href="../../DBIx/Class/Row.html#update" class="podlinkpod"
>&#34;update&#34; in DBIx::Class::Row</a>. The user must ensure manually that any value passed to this method will stringify to something the RDBMS knows how to deal with. A notable example is the handling of <a href="../../DateTime.html" class="podlinkpod"
>DateTime</a> objects, for more info see: <a href="../../DBIx/Class/Manual/Cookbook.html#Formatting_DateTime_objects_in_queries" class="podlinkpod"
>&#34;Formatting DateTime objects in queries&#34; in DBIx::Class::Manual::Cookbook</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="update_all"
>update_all</a></h2>

<dl>
<dt><a name="Arguments:_\%values"
>Arguments: \%values</a></dt>

<dd>
<dt><a name="Return_Value:_1"
>Return Value: 1</a></dt>
</dl>

<p>Fetches all objects and updates them one at a time via <a href="../../DBIx/Class/Row.html#update" class="podlinkpod"
>&#34;update&#34; in DBIx::Class::Row</a>. Note that <code>update_all</code> will run DBIC defined triggers, while <a href="#update" class="podlinkpod"
>&#34;update&#34;</a> will not.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="delete"
>delete</a></h2>

<dl>
<dt><a name="Arguments:_none"
>Arguments: none</a></dt>

<dd>
<dt><a name="Return_Value:_$underlying_storage_rv"
>Return Value: $underlying_storage_rv</a></dt>
</dl>

<p>Deletes the rows matching this resultset in a single query. Note that this will not run any delete triggers, nor will it alter the <a href="../../DBIx/Class/Row.html#in_storage" class="podlinkpod"
>in_storage</a> status of any result object instances derived from this resultset (this includes the contents of the <a href="#set_cache" class="podlinkpod"
>resultset cache</a> if any). See <a href="#delete_all" class="podlinkpod"
>&#34;delete_all&#34;</a> if you need to execute any on-delete triggers or cascades defined either by you or a <a href="../../DBIx/Class/Manual/Component.html#WHAT_IS_A_COMPONENT" class="podlinkpod"
>result component</a>.</p>

<p>The return value is a pass through of what the underlying storage backend returned, and may vary. See <a href="../../DBI.html#execute" class="podlinkpod"
>&#34;execute&#34; in DBI</a> for the most common case.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="delete_all"
>delete_all</a></h2>

<dl>
<dt><a name="Arguments:_none"
>Arguments: none</a></dt>

<dd>
<dt><a name="Return_Value:_1"
>Return Value: 1</a></dt>
</dl>

<p>Fetches all objects and deletes them one at a time via <a href="../../DBIx/Class/Row.html#delete" class="podlinkpod"
>&#34;delete&#34; in DBIx::Class::Row</a>. Note that <code>delete_all</code> will run DBIC defined triggers, while <a href="#delete" class="podlinkpod"
>&#34;delete&#34;</a> will not.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="populate"
>populate</a></h2>

<dl>
<dt><a name="Arguments:_[_\@column_list,_\@row_values+_]_|_[_\%col_data+_]"
>Arguments: [ \@column_list, \@row_values+ ] | [ \%col_data+ ]</a></dt>

<dd>
<dt><a name="Return_Value:_\@result_objects_(scalar_context)_|_@result_objects_(list_context)"
>Return Value: <a href="../../DBIx/Class/Manual/ResultClass.html" class="podlinkpod"
>\@result_objects</a> (scalar context) | <a href="../../DBIx/Class/Manual/ResultClass.html" class="podlinkpod"
>@result_objects</a> (list context)</a></dt>
</dl>

<p>Accepts either an arrayref of hashrefs or alternatively an arrayref of arrayrefs.</p>

<dl>
<dt><a name="NOTE"
>NOTE</a></dt>

<dd>
<p>The context of this method call has an important effect on what is submitted to storage. In void context data is fed directly to fastpath insertion routines provided by the underlying storage (most often <a href="../../DBI.html#execute_for_fetch" class="podlinkpod"
>&#34;execute_for_fetch&#34; in DBI</a>), bypassing the <a href="../../DBIx/Class/Row.html#new" class="podlinkpod"
>new</a> and <a href="../../DBIx/Class/Row.html#insert" class="podlinkpod"
>insert</a> calls on the <a href="../../DBIx/Class/Manual/ResultClass.html" class="podlinkpod"
>Result</a> class, including any augmentation of these methods provided by components. For example if you are using something like <a href="../../DBIx/Class/UUIDColumns.html" class="podlinkpod"
>DBIx::Class::UUIDColumns</a> to create primary keys for you, you will find that your PKs are empty. In this case you will have to explicitly force scalar or list context in order to create those values.</p>
</dd>
</dl>

<p>In non-void (scalar or list) context, this method is simply a wrapper for <a href="#create" class="podlinkpod"
>&#34;create&#34;</a>. Depending on list or scalar context either a list of <a href="../../DBIx/Class/Manual/ResultClass.html" class="podlinkpod"
>Result</a> objects or an arrayref containing these objects is returned.</p>

<p>When supplying data in &#34;arrayref of arrayrefs&#34; invocation style, the first element should be a list of column names and each subsequent element should be a data value in the earlier specified column order. For example:</p>

<pre>  $Arstist_rs-&#62;populate([
    [ qw( artistid name ) ],
    [ 100, &#39;A Formally Unknown Singer&#39; ],
    [ 101, &#39;A singer that jumped the shark two albums ago&#39; ],
    [ 102, &#39;An actually cool singer&#39; ],
  ]);</pre>

<p>For the arrayref of hashrefs style each hashref should be a structure suitable for passing to <a href="#create" class="podlinkpod"
>&#34;create&#34;</a>. Multi-create is also permitted with this syntax.</p>

<pre>  $schema-&#62;resultset(&#34;Artist&#34;)-&#62;populate([
     { artistid =&#62; 4, name =&#62; &#39;Manufactured Crap&#39;, cds =&#62; [
        { title =&#62; &#39;My First CD&#39;, year =&#62; 2006 },
        { title =&#62; &#39;Yet More Tweeny-Pop crap&#39;, year =&#62; 2007 },
      ],
     },
     { artistid =&#62; 5, name =&#62; &#39;Angsty-Whiny Girl&#39;, cds =&#62; [
        { title =&#62; &#39;My parents sold me to a record company&#39;, year =&#62; 2005 },
        { title =&#62; &#39;Why Am I So Ugly?&#39;, year =&#62; 2006 },
        { title =&#62; &#39;I Got Surgery and am now Popular&#39;, year =&#62; 2007 }
      ],
     },
  ]);</pre>

<p>If you attempt a void-context multi-create as in the example above (each Artist also has the related list of CDs), and <b>do not</b> supply the necessary autoinc foreign key information, this method will proxy to the less efficient <a href="#create" class="podlinkpod"
>&#34;create&#34;</a>, and then throw the Result objects away. In this case there are obviously no benefits to using this method over <a href="#create" class="podlinkpod"
>&#34;create&#34;</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="pager"
>pager</a></h2>

<dl>
<dt><a name="Arguments:_none"
>Arguments: none</a></dt>

<dd>
<dt><a name="Return_Value:_$pager"
>Return Value: <a href="../../Data/Page.html" class="podlinkpod"
>$pager</a></a></dt>
</dl>

<p>Returns a <a href="../../Data/Page.html" class="podlinkpod"
>Data::Page</a> object for the current resultset. Only makes sense for queries with a <code>page</code> attribute.</p>

<p>To get the full count of entries for a paged resultset, call <code>total_entries</code> on the <a href="../../Data/Page.html" class="podlinkpod"
>Data::Page</a> object.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="page"
>page</a></h2>

<dl>
<dt><a name="Arguments:_$page_number"
>Arguments: $page_number</a></dt>

<dd>
<dt><a name="Return_Value:_$resultset"
>Return Value: <a href="#search" class="podlinkpod"
>$resultset</a></a></dt>
</dl>

<p>Returns a resultset for the $page_number page of the resultset on which page is called, where each page contains a number of rows equal to the &#39;rows&#39; attribute set on the resultset (10 by default).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="new_result"
>new_result</a></h2>

<dl>
<dt><a name="Arguments:_\%col_data"
>Arguments: \%col_data</a></dt>

<dd>
<dt><a name="Return_Value:_$result"
>Return Value: <a href="../../DBIx/Class/Manual/ResultClass.html" class="podlinkpod"
>$result</a></a></dt>
</dl>

<p>Creates a new result object in the resultset&#39;s result class and returns it. The row is not inserted into the database at this point, call <a href="../../DBIx/Class/Row.html#insert" class="podlinkpod"
>&#34;insert&#34; in DBIx::Class::Row</a> to do that. Calling <a href="../../DBIx/Class/Row.html#in_storage" class="podlinkpod"
>&#34;in_storage&#34; in DBIx::Class::Row</a> will tell you whether the result object has been inserted or not.</p>

<p>Passes the hashref of input on to <a href="../../DBIx/Class/Row.html#new" class="podlinkpod"
>&#34;new&#34; in DBIx::Class::Row</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="as_query"
>as_query</a></h2>

<dl>
<dt><a name="Arguments:_none"
>Arguments: none</a></dt>

<dd>
<dt><a name="Return_Value:_\[_$sql,_@bind_values_]"
>Return Value: \[ $sql, <a href="#DBIC_BIND_VALUES" class="podlinkpod"
>@bind_values</a> ]</a></dt>
</dl>

<p>Returns the SQL query and bind vars associated with the invocant.</p>

<p>This is generally used as the RHS for a subquery.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="find_or_new"
>find_or_new</a></h2>

<dl>
<dt><a name="Arguments:_\%col_data,_{_key_=&#62;_$unique_constraint,_%attrs_}?"
>Arguments: \%col_data, { key =&#62; $unique_constraint, <a href="#ATTRIBUTES" class="podlinkpod"
>%attrs</a> }?</a></dt>

<dd>
<dt><a name="Return_Value:_$result"
>Return Value: <a href="../../DBIx/Class/Manual/ResultClass.html" class="podlinkpod"
>$result</a></a></dt>
</dl>

<pre>  my $artist = $schema-&#62;resultset(&#39;Artist&#39;)-&#62;find_or_new(
    { artist =&#62; &#39;fred&#39; }, { key =&#62; &#39;artists&#39; });

  $cd-&#62;cd_to_producer-&#62;find_or_new({ producer =&#62; $producer },
                                   { key =&#62; &#39;primary&#39; });</pre>

<p>Find an existing record from this resultset using <a href="#find" class="podlinkpod"
>&#34;find&#34;</a>. if none exists, instantiate a new result object and return it. The object will not be saved into your storage until you call <a href="../../DBIx/Class/Row.html#insert" class="podlinkpod"
>&#34;insert&#34; in DBIx::Class::Row</a> on it.</p>

<p>You most likely want this method when looking for existing rows using a unique constraint that is not the primary key, or looking for related rows.</p>

<p>If you want objects to be saved immediately, use <a href="#find_or_create" class="podlinkpod"
>&#34;find_or_create&#34;</a> instead.</p>

<p><b>Note</b>: Make sure to read the documentation of <a href="#find" class="podlinkpod"
>&#34;find&#34;</a> and understand the significance of the <code>key</code> attribute, as its lack may skew your search, and subsequently result in spurious new objects.</p>

<p><b>Note</b>: Take care when using <code>find_or_new</code> with a table having columns with default values that you intend to be automatically supplied by the database (e.g. an auto_increment primary key column). In normal usage, the value of such columns should NOT be included at all in the call to <code>find_or_new</code>, even when set to <code>undef</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="create"
>create</a></h2>

<dl>
<dt><a name="Arguments:_\%col_data"
>Arguments: \%col_data</a></dt>

<dd>
<dt><a name="Return_Value:_$result"
>Return Value: <a href="../../DBIx/Class/Manual/ResultClass.html" class="podlinkpod"
>$result</a></a></dt>
</dl>

<p>Attempt to create a single new row or a row with multiple related rows in the table represented by the resultset (and related tables). This will not check for duplicate rows before inserting, use <a href="#find_or_create" class="podlinkpod"
>&#34;find_or_create&#34;</a> to do that.</p>

<p>To create one row for this resultset, pass a hashref of key/value pairs representing the columns of the table and the values you wish to store. If the appropriate relationships are set up, foreign key fields can also be passed an object representing the foreign row, and the value will be set to its primary key.</p>

<p>To create related objects, pass a hashref of related-object column values <b>keyed on the relationship name</b>. If the relationship is of type <code>multi</code> (<a href="../../DBIx/Class/Relationship.html#has_many" class="podlinkpod"
>&#34;has_many&#34; in DBIx::Class::Relationship</a>) - pass an arrayref of hashrefs. The process will correctly identify columns holding foreign keys, and will transparently populate them from the keys of the corresponding relation. This can be applied recursively, and will work correctly for a structure with an arbitrary depth and width, as long as the relationships actually exists and the correct column data has been supplied.</p>

<p>Instead of hashrefs of plain related data (key/value pairs), you may also pass new or inserted objects. New objects (not inserted yet, see <a href="#new_result" class="podlinkpod"
>&#34;new_result&#34;</a>), will be inserted into their appropriate tables.</p>

<p>Effectively a shortcut for <code>-&#62;new_result(\%col_data)-&#62;insert</code>.</p>

<p>Example of creating a new row.</p>

<pre>  $person_rs-&#62;create({
    name=&#62;&#34;Some Person&#34;,
    email=&#62;&#34;somebody@someplace.com&#34;
  });</pre>

<p>Example of creating a new row and also creating rows in a related <code>has_many</code> or <code>has_one</code> resultset. Note Arrayref.</p>

<pre>  $artist_rs-&#62;create(
     { artistid =&#62; 4, name =&#62; &#39;Manufactured Crap&#39;, cds =&#62; [
        { title =&#62; &#39;My First CD&#39;, year =&#62; 2006 },
        { title =&#62; &#39;Yet More Tweeny-Pop crap&#39;, year =&#62; 2007 },
      ],
     },
  );</pre>

<p>Example of creating a new row and also creating a row in a related <code>belongs_to</code> resultset. Note Hashref.</p>

<pre>  $cd_rs-&#62;create({
    title=&#62;&#34;Music for Silly Walks&#34;,
    year=&#62;2000,
    artist =&#62; {
      name=&#62;&#34;Silly Musician&#34;,
    }
  });</pre>

<dl>
<dt><a name="WARNING"
>WARNING</a></dt>

<dd>
<p>When subclassing ResultSet never attempt to override this method. Since it is a simple shortcut for <code>$self-&#62;new_result($attrs)-&#62;insert</code>, a lot of the internals simply never call it, so your override will be bypassed more often than not. Override either <a href="../../DBIx/Class/Row.html#new" class="podlinkpod"
>&#34;new&#34; in DBIx::Class::Row</a> or <a href="../../DBIx/Class/Row.html#insert" class="podlinkpod"
>&#34;insert&#34; in DBIx::Class::Row</a> depending on how early in the <a href="#create" class="podlinkpod"
>&#34;create&#34;</a> process you need to intervene. See also warning pertaining to <a href="#new" class="podlinkpod"
>&#34;new&#34;</a>.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="find_or_create"
>find_or_create</a></h2>

<dl>
<dt><a name="Arguments:_\%col_data,_{_key_=&#62;_$unique_constraint,_%attrs_}?"
>Arguments: \%col_data, { key =&#62; $unique_constraint, <a href="#ATTRIBUTES" class="podlinkpod"
>%attrs</a> }?</a></dt>

<dd>
<dt><a name="Return_Value:_$result"
>Return Value: <a href="../../DBIx/Class/Manual/ResultClass.html" class="podlinkpod"
>$result</a></a></dt>
</dl>

<pre>  $cd-&#62;cd_to_producer-&#62;find_or_create({ producer =&#62; $producer },
                                      { key =&#62; &#39;primary&#39; });</pre>

<p>Tries to find a record based on its primary key or unique constraints; if none is found, creates one and returns that instead.</p>

<pre>  my $cd = $schema-&#62;resultset(&#39;CD&#39;)-&#62;find_or_create({
    cdid   =&#62; 5,
    artist =&#62; &#39;Massive Attack&#39;,
    title  =&#62; &#39;Mezzanine&#39;,
    year   =&#62; 2005,
  });</pre>

<p>Also takes an optional <code>key</code> attribute, to search by a specific key or unique constraint. For example:</p>

<pre>  my $cd = $schema-&#62;resultset(&#39;CD&#39;)-&#62;find_or_create(
    {
      artist =&#62; &#39;Massive Attack&#39;,
      title  =&#62; &#39;Mezzanine&#39;,
    },
    { key =&#62; &#39;cd_artist_title&#39; }
  );</pre>

<p><b>Note</b>: Make sure to read the documentation of <a href="#find" class="podlinkpod"
>&#34;find&#34;</a> and understand the significance of the <code>key</code> attribute, as its lack may skew your search, and subsequently result in spurious row creation.</p>

<p><b>Note</b>: Because find_or_create() reads from the database and then possibly inserts based on the result, this method is subject to a race condition. Another process could create a record in the table after the find has completed and before the create has started. To avoid this problem, use find_or_create() inside a transaction.</p>

<p><b>Note</b>: Take care when using <code>find_or_create</code> with a table having columns with default values that you intend to be automatically supplied by the database (e.g. an auto_increment primary key column). In normal usage, the value of such columns should NOT be included at all in the call to <code>find_or_create</code>, even when set to <code>undef</code>.</p>

<p>See also <a href="#find" class="podlinkpod"
>&#34;find&#34;</a> and <a href="#update_or_create" class="podlinkpod"
>&#34;update_or_create&#34;</a>. For information on how to declare unique constraints, see <a href="../../DBIx/Class/ResultSource.html#add_unique_constraint" class="podlinkpod"
>&#34;add_unique_constraint&#34; in DBIx::Class::ResultSource</a>.</p>

<p>If you need to know if an existing row was found or a new one created use <a href="#find_or_new" class="podlinkpod"
>&#34;find_or_new&#34;</a> and <a href="../../DBIx/Class/Row.html#in_storage" class="podlinkpod"
>&#34;in_storage&#34; in DBIx::Class::Row</a> instead. Don&#39;t forget to call <a href="../../DBIx/Class/Row.html#insert" class="podlinkpod"
>&#34;insert&#34; in DBIx::Class::Row</a> to save the newly created row to the database!</p>

<pre>  my $cd = $schema-&#62;resultset(&#39;CD&#39;)-&#62;find_or_new({
    cdid   =&#62; 5,
    artist =&#62; &#39;Massive Attack&#39;,
    title  =&#62; &#39;Mezzanine&#39;,
    year   =&#62; 2005,
  });

  if( !$cd-&#62;in_storage ) {
      # do some stuff
      $cd-&#62;insert;
  }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="update_or_create"
>update_or_create</a></h2>

<dl>
<dt><a name="Arguments:_\%col_data,_{_key_=&#62;_$unique_constraint,_%attrs_}?"
>Arguments: \%col_data, { key =&#62; $unique_constraint, <a href="#ATTRIBUTES" class="podlinkpod"
>%attrs</a> }?</a></dt>

<dd>
<dt><a name="Return_Value:_$result"
>Return Value: <a href="../../DBIx/Class/Manual/ResultClass.html" class="podlinkpod"
>$result</a></a></dt>
</dl>

<pre>  $resultset-&#62;update_or_create({ col =&#62; $val, ... });</pre>

<p>Like <a href="#find_or_create" class="podlinkpod"
>&#34;find_or_create&#34;</a>, but if a row is found it is immediately updated via <code>$found_row-&#62;update (\%col_data)</code>.</p>

<p>Takes an optional <code>key</code> attribute to search on a specific unique constraint. For example:</p>

<pre>  # In your application
  my $cd = $schema-&#62;resultset(&#39;CD&#39;)-&#62;update_or_create(
    {
      artist =&#62; &#39;Massive Attack&#39;,
      title  =&#62; &#39;Mezzanine&#39;,
      year   =&#62; 1998,
    },
    { key =&#62; &#39;cd_artist_title&#39; }
  );

  $cd-&#62;cd_to_producer-&#62;update_or_create({
    producer =&#62; $producer,
    name =&#62; &#39;harry&#39;,
  }, {
    key =&#62; &#39;primary&#39;,
  });</pre>

<p><b>Note</b>: Make sure to read the documentation of <a href="#find" class="podlinkpod"
>&#34;find&#34;</a> and understand the significance of the <code>key</code> attribute, as its lack may skew your search, and subsequently result in spurious row creation.</p>

<p><b>Note</b>: Take care when using <code>update_or_create</code> with a table having columns with default values that you intend to be automatically supplied by the database (e.g. an auto_increment primary key column). In normal usage, the value of such columns should NOT be included at all in the call to <code>update_or_create</code>, even when set to <code>undef</code>.</p>

<p>See also <a href="#find" class="podlinkpod"
>&#34;find&#34;</a> and <a href="#find_or_create" class="podlinkpod"
>&#34;find_or_create&#34;</a>. For information on how to declare unique constraints, see <a href="../../DBIx/Class/ResultSource.html#add_unique_constraint" class="podlinkpod"
>&#34;add_unique_constraint&#34; in DBIx::Class::ResultSource</a>.</p>

<p>If you need to know if an existing row was updated or a new one created use <a href="#update_or_new" class="podlinkpod"
>&#34;update_or_new&#34;</a> and <a href="../../DBIx/Class/Row.html#in_storage" class="podlinkpod"
>&#34;in_storage&#34; in DBIx::Class::Row</a> instead. Don&#39;t forget to call <a href="../../DBIx/Class/Row.html#insert" class="podlinkpod"
>&#34;insert&#34; in DBIx::Class::Row</a> to save the newly created row to the database!</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="update_or_new"
>update_or_new</a></h2>

<dl>
<dt><a name="Arguments:_\%col_data,_{_key_=&#62;_$unique_constraint,_%attrs_}?"
>Arguments: \%col_data, { key =&#62; $unique_constraint, <a href="#ATTRIBUTES" class="podlinkpod"
>%attrs</a> }?</a></dt>

<dd>
<dt><a name="Return_Value:_$result"
>Return Value: <a href="../../DBIx/Class/Manual/ResultClass.html" class="podlinkpod"
>$result</a></a></dt>
</dl>

<pre>  $resultset-&#62;update_or_new({ col =&#62; $val, ... });</pre>

<p>Like <a href="#find_or_new" class="podlinkpod"
>&#34;find_or_new&#34;</a> but if a row is found it is immediately updated via <code>$found_row-&#62;update (\%col_data)</code>.</p>

<p>For example:</p>

<pre>  # In your application
  my $cd = $schema-&#62;resultset(&#39;CD&#39;)-&#62;update_or_new(
    {
      artist =&#62; &#39;Massive Attack&#39;,
      title  =&#62; &#39;Mezzanine&#39;,
      year   =&#62; 1998,
    },
    { key =&#62; &#39;cd_artist_title&#39; }
  );

  if ($cd-&#62;in_storage) {
      # the cd was updated
  }
  else {
      # the cd is not yet in the database, let&#39;s insert it
      $cd-&#62;insert;
  }</pre>

<p><b>Note</b>: Make sure to read the documentation of <a href="#find" class="podlinkpod"
>&#34;find&#34;</a> and understand the significance of the <code>key</code> attribute, as its lack may skew your search, and subsequently result in spurious new objects.</p>

<p><b>Note</b>: Take care when using <code>update_or_new</code> with a table having columns with default values that you intend to be automatically supplied by the database (e.g. an auto_increment primary key column). In normal usage, the value of such columns should NOT be included at all in the call to <code>update_or_new</code>, even when set to <code>undef</code>.</p>

<p>See also <a href="#find" class="podlinkpod"
>&#34;find&#34;</a>, <a href="#find_or_create" class="podlinkpod"
>&#34;find_or_create&#34;</a> and <a href="#find_or_new" class="podlinkpod"
>&#34;find_or_new&#34;</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_cache"
>get_cache</a></h2>

<dl>
<dt><a name="Arguments:_none"
>Arguments: none</a></dt>

<dd>
<dt><a name="Return_Value:_\@result_objs_|_undef"
>Return Value: <a href="../../DBIx/Class/Manual/ResultClass.html" class="podlinkpod"
>\@result_objs</a> | undef</a></dt>
</dl>

<p>Gets the contents of the cache for the resultset, if the cache is set.</p>

<p>The cache is populated either by using the <a href="#prefetch" class="podlinkpod"
>&#34;prefetch&#34;</a> attribute to <a href="#search" class="podlinkpod"
>&#34;search&#34;</a> or by calling <a href="#set_cache" class="podlinkpod"
>&#34;set_cache&#34;</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="set_cache"
>set_cache</a></h2>

<dl>
<dt><a name="Arguments:_\@result_objs"
>Arguments: <a href="../../DBIx/Class/Manual/ResultClass.html" class="podlinkpod"
>\@result_objs</a></a></dt>

<dd>
<dt><a name="Return_Value:_\@result_objs"
>Return Value: <a href="../../DBIx/Class/Manual/ResultClass.html" class="podlinkpod"
>\@result_objs</a></a></dt>
</dl>

<p>Sets the contents of the cache for the resultset. Expects an arrayref of objects of the same class as those produced by the resultset. Note that if the cache is set, the resultset will return the cached objects rather than re-querying the database even if the cache attr is not set.</p>

<p>The contents of the cache can also be populated by using the <a href="#prefetch" class="podlinkpod"
>&#34;prefetch&#34;</a> attribute to <a href="#search" class="podlinkpod"
>&#34;search&#34;</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="clear_cache"
>clear_cache</a></h2>

<dl>
<dt><a name="Arguments:_none"
>Arguments: none</a></dt>

<dd>
<dt><a name="Return_Value:_undef"
>Return Value: undef</a></dt>
</dl>

<p>Clears the cache for the resultset.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="is_paged"
>is_paged</a></h2>

<dl>
<dt><a name="Arguments:_none"
>Arguments: none</a></dt>

<dd>
<dt><a name="Return_Value:_true,_if_the_resultset_has_been_paginated"
>Return Value: true, if the resultset has been paginated</a></dt>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="is_ordered"
>is_ordered</a></h2>

<dl>
<dt><a name="Arguments:_none"
>Arguments: none</a></dt>

<dd>
<dt><a name="Return_Value:_true,_if_the_resultset_has_been_ordered_with_order_by."
>Return Value: true, if the resultset has been ordered with <code>order_by</code>.</a></dt>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="related_resultset"
>related_resultset</a></h2>

<dl>
<dt><a name="Arguments:_$rel_name"
>Arguments: $rel_name</a></dt>

<dd>
<dt><a name="Return_Value:_$resultset"
>Return Value: <a href="#search" class="podlinkpod"
>$resultset</a></a></dt>
</dl>

<p>Returns a related resultset for the supplied relationship name.</p>

<pre>  $artist_rs = $schema-&#62;resultset(&#39;CD&#39;)-&#62;related_resultset(&#39;Artist&#39;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="current_source_alias"
>current_source_alias</a></h2>

<dl>
<dt><a name="Arguments:_none"
>Arguments: none</a></dt>

<dd>
<dt><a name="Return_Value:_$source_alias"
>Return Value: $source_alias</a></dt>
</dl>

<p>Returns the current table alias for the result source this resultset is built on, that will be used in the SQL query. Usually it is <code>me</code>.</p>

<p>Currently the source alias that refers to the result set returned by a <a href="#search" class="podlinkpod"
>&#34;search&#34;</a>/<a href="#find" class="podlinkpod"
>&#34;find&#34;</a> family method depends on how you got to the resultset: it&#39;s <code>me</code> by default, but eg. <a href="#search_related" class="podlinkpod"
>&#34;search_related&#34;</a> aliases it to the related result source name (and keeps <code>me</code> referring to the original result set). The long term goal is to make <a href="../../DBIx/Class.html" class="podlinkpod"
>DBIx::Class</a> always alias the current resultset as <code>me</code> (and make this method unnecessary).</p>

<p>Thus it&#39;s currently necessary to use this method in predefined queries (see <a href="../../DBIx/Class/Manual/Cookbook.html#Predefined_searches" class="podlinkpod"
>&#34;Predefined searches&#34; in DBIx::Class::Manual::Cookbook</a>) when referring to the source alias of the current result set:</p>

<pre>  # in a result set class
  sub modified_by {
    my ($self, $user) = @_;

    my $me = $self-&#62;current_source_alias;

    return $self-&#62;search({
      &#34;$me.modified&#34; =&#62; $user-&#62;id,
    });
  }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="as_subselect_rs"
>as_subselect_rs</a></h2>

<dl>
<dt><a name="Arguments:_none"
>Arguments: none</a></dt>

<dd>
<dt><a name="Return_Value:_$resultset"
>Return Value: <a href="#search" class="podlinkpod"
>$resultset</a></a></dt>
</dl>

<p>Act as a barrier to SQL symbols. The resultset provided will be made into a &#34;virtual view&#34; by including it as a subquery within the from clause. From this point on, any joined tables are inaccessible to -&#62;search on the resultset (as if it were simply where-filtered without joins). For example:</p>

<pre> my $rs = $schema-&#62;resultset(&#39;Bar&#39;)-&#62;search({&#39;x.name&#39; =&#62; &#39;abc&#39;},{ join =&#62; &#39;x&#39; });

 # &#39;x&#39; now pollutes the query namespace

 # So the following works as expected
 my $ok_rs = $rs-&#62;search({&#39;x.other&#39; =&#62; 1});

 # But this doesn&#39;t: instead of finding a &#39;Bar&#39; related to two x rows (abc and
 # def) we look for one row with contradictory terms and join in another table
 # (aliased &#39;x_2&#39;) which we never use
 my $broken_rs = $rs-&#62;search({&#39;x.name&#39; =&#62; &#39;def&#39;});

 my $rs2 = $rs-&#62;as_subselect_rs;

 # doesn&#39;t work - &#39;x&#39; is no longer accessible in $rs2, having been sealed away
 my $not_joined_rs = $rs2-&#62;search({&#39;x.other&#39; =&#62; 1});

 # works as expected: finds a &#39;table&#39; row related to two x rows (abc and def)
 my $correctly_joined_rs = $rs2-&#62;search({&#39;x.name&#39; =&#62; &#39;def&#39;});</pre>

<p>Another example of when one might use this would be to select a subset of columns in a group by clause:</p>

<pre> my $rs = $schema-&#62;resultset(&#39;Bar&#39;)-&#62;search(undef, {
   group_by =&#62; [qw{ id foo_id baz_id }],
 })-&#62;as_subselect_rs-&#62;search(undef, {
   columns =&#62; [qw{ id foo_id }]
 });</pre>

<p>In the above example normally columns would have to be equal to the group by, but because we isolated the group by into a subselect the above works.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="throw_exception"
>throw_exception</a></h2>

<p>See <a href="../../DBIx/Class/Schema.html#throw_exception" class="podlinkpod"
>&#34;throw_exception&#34; in DBIx::Class::Schema</a> for details.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ATTRIBUTES"
>ATTRIBUTES</a></h1>

<p>Attributes are used to refine a ResultSet in various ways when searching for data. They can be passed to any method which takes an <code>\%attrs</code> argument. See <a href="#search" class="podlinkpod"
>&#34;search&#34;</a>, <a href="#search_rs" class="podlinkpod"
>&#34;search_rs&#34;</a>, <a href="#find" class="podlinkpod"
>&#34;find&#34;</a>, <a href="#count" class="podlinkpod"
>&#34;count&#34;</a>.</p>

<p>Default attributes can be set on the result class using <a href="../../DBIx/Class/ResultSource.html#resultset_attributes" class="podlinkpod"
>&#34;resultset_attributes&#34; in DBIx::Class::ResultSource</a>. (Please read the CAVEATS on that feature before using it!)</p>

<p>These are in no particular order:</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="order_by"
>order_by</a></h2>

<dl>
<dt><a name="Value:_(_$order_by_|_\@order_by_|_\%order_by_)"
>Value: ( $order_by | \@order_by | \%order_by )</a></dt>
</dl>

<p>Which column(s) to order the results by.</p>

<p>[The full list of suitable values is documented in <a href="../../SQL/Abstract.html#ORDER_BY_CLAUSES" class="podlinkpod"
>&#34;ORDER BY CLAUSES&#34; in SQL::Abstract</a>; the following is a summary of common options.]</p>

<p>If a single column name, or an arrayref of names is supplied, the argument is passed through directly to SQL. The hashref syntax allows for connection-agnostic specification of ordering direction:</p>

<pre> For descending order:

  order_by =&#62; { -desc =&#62; [qw/col1 col2 col3/] }

 For explicit ascending order:

  order_by =&#62; { -asc =&#62; &#39;col&#39; }</pre>

<p>The old scalarref syntax (i.e. order_by =&#62; \&#39;year DESC&#39;) is still supported, although you are strongly encouraged to use the hashref syntax as outlined above.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="columns"
>columns</a></h2>

<dl>
<dt><a name="Value:_\@columns_|_\%columns_|_$column"
>Value: \@columns | \%columns | $column</a></dt>
</dl>

<p>Shortcut to request a particular set of columns to be retrieved. Each column spec may be a string (a table column name), or a hash (in which case the key is the <code>as</code> value, and the value is used as the <code>select</code> expression). Adds <code>me.</code> onto the start of any column without a <code>.</code> in it and sets <code>select</code> from that, then auto-populates <code>as</code> from <code>select</code> as normal. (You may also use the <code>cols</code> attribute, as in earlier versions of DBIC, but this is deprecated.)</p>

<p>Essentially <code>columns</code> does the same as <a href="#select" class="podlinkpod"
>&#34;select&#34;</a> and <a href="#as" class="podlinkpod"
>&#34;as&#34;</a>.</p>

<pre>    columns =&#62; [ &#39;foo&#39;, { bar =&#62; &#39;baz&#39; } ]</pre>

<p>is the same as</p>

<pre>    select =&#62; [qw/foo baz/],
    as =&#62; [qw/foo bar/]</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="+columns"
>+columns</a></h2>

<dl>
<dt><a name="Value:_\@columns"
>Value: \@columns</a></dt>
</dl>

<p>Indicates additional columns to be selected from storage. Works the same as <a href="#columns" class="podlinkpod"
>&#34;columns&#34;</a> but adds columns to the selection. (You may also use the <code>include_columns</code> attribute, as in earlier versions of DBIC, but this is deprecated). For example:-</p>

<pre>  $schema-&#62;resultset(&#39;CD&#39;)-&#62;search(undef, {
    &#39;+columns&#39; =&#62; [&#39;artist.name&#39;],
    join =&#62; [&#39;artist&#39;]
  });</pre>

<p>would return all CDs and include a &#39;name&#39; column to the information passed to object inflation. Note that the &#39;artist&#39; is the name of the column (or relationship) accessor, and &#39;name&#39; is the name of the column accessor in the related table.</p>

<p><b>NOTE:</b> You need to explicitly quote &#39;+columns&#39; when defining the attribute. Not doing so causes Perl to incorrectly interpret +columns as a bareword with a unary plus operator before it.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="include_columns"
>include_columns</a></h2>

<dl>
<dt><a name="Value:_\@columns"
>Value: \@columns</a></dt>
</dl>

<p>Deprecated. Acts as a synonym for <a href="#%2Bcolumns" class="podlinkpod"
>&#34;+columns&#34;</a> for backward compatibility.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="select"
>select</a></h2>

<dl>
<dt><a name="Value:_\@select_columns"
>Value: \@select_columns</a></dt>
</dl>

<p>Indicates which columns should be selected from the storage. You can use column names, or in the case of RDBMS back ends, function or stored procedure names:</p>

<pre>  $rs = $schema-&#62;resultset(&#39;Employee&#39;)-&#62;search(undef, {
    select =&#62; [
      &#39;name&#39;,
      { count =&#62; &#39;employeeid&#39; },
      { max =&#62; { length =&#62; &#39;name&#39; }, -as =&#62; &#39;longest_name&#39; }
    ]
  });

  # Equivalent SQL
  SELECT name, COUNT( employeeid ), MAX( LENGTH( name ) ) AS longest_name FROM employee</pre>

<p><b>NOTE:</b> You will almost always need a corresponding <a href="#as" class="podlinkpod"
>&#34;as&#34;</a> attribute when you use <a href="#select" class="podlinkpod"
>&#34;select&#34;</a>, to instruct DBIx::Class how to store the result of the column. Also note that the <a href="#as" class="podlinkpod"
>&#34;as&#34;</a> attribute has nothing to do with the SQL-side &#39;AS&#39; identifier aliasing. You can however alias a function, so you can use it in e.g. an <code>ORDER BY</code> clause. This is done via the <code>-as</code> <b>select function attribute</b> supplied as shown in the example above.</p>

<p><b>NOTE:</b> You need to explicitly quote &#39;+select&#39;/&#39;+as&#39; when defining the attributes. Not doing so causes Perl to incorrectly interpret them as a bareword with a unary plus operator before it.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="+select"
>+select</a></h2>

<blockquote>
<p>Indicates additional columns to be selected from storage. Works the same as <a href="#select" class="podlinkpod"
>&#34;select&#34;</a> but adds columns to the default selection, instead of specifying an explicit list.</p>
</blockquote>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="as"
>as</a></h2>

<dl>
<dt><a name="Value:_\@inflation_names"
>Value: \@inflation_names</a></dt>
</dl>

<p>Indicates column names for object inflation. That is <a href="#as" class="podlinkpod"
>&#34;as&#34;</a> indicates the slot name in which the column value will be stored within the <a href="../../DBIx/Class/Row.html" class="podlinkpod"
>Row</a> object. The value will then be accessible via this identifier by the <code>get_column</code> method (or via the object accessor <b>if one with the same name already exists</b>) as shown below. The <a href="#as" class="podlinkpod"
>&#34;as&#34;</a> attribute has <b>nothing to do</b> with the SQL-side <code>AS</code>. See <a href="#select" class="podlinkpod"
>&#34;select&#34;</a> for details.</p>

<pre>  $rs = $schema-&#62;resultset(&#39;Employee&#39;)-&#62;search(undef, {
    select =&#62; [
      &#39;name&#39;,
      { count =&#62; &#39;employeeid&#39; },
      { max =&#62; { length =&#62; &#39;name&#39; }, -as =&#62; &#39;longest_name&#39; }
    ],
    as =&#62; [qw/
      name
      employee_count
      max_name_length
    /],
  });</pre>

<p>If the object against which the search is performed already has an accessor matching a column name specified in <code>as</code>, the value can be retrieved using the accessor as normal:</p>

<pre>  my $name = $employee-&#62;name();</pre>

<p>If on the other hand an accessor does not exist in the object, you need to use <code>get_column</code> instead:</p>

<pre>  my $employee_count = $employee-&#62;get_column(&#39;employee_count&#39;);</pre>

<p>You can create your own accessors if required - see <a href="../../DBIx/Class/Manual/Cookbook.html" class="podlinkpod"
>DBIx::Class::Manual::Cookbook</a> for details.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="+as"
>+as</a></h2>

<blockquote>
<p>Indicates additional column names for those added via <a href="#%2Bselect" class="podlinkpod"
>&#34;+select&#34;</a>. See <a href="#as" class="podlinkpod"
>&#34;as&#34;</a>.</p>
</blockquote>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="join"
>join</a></h2>

<dl>
<dt><a name="Value:_($rel_name_|_\@rel_names_|_\%rel_names)"
>Value: ($rel_name | \@rel_names | \%rel_names)</a></dt>
</dl>

<p>Contains a list of relationships that should be joined for this query. For example:</p>

<pre>  # Get CDs by Nine Inch Nails
  my $rs = $schema-&#62;resultset(&#39;CD&#39;)-&#62;search(
    { &#39;artist.name&#39; =&#62; &#39;Nine Inch Nails&#39; },
    { join =&#62; &#39;artist&#39; }
  );</pre>

<p>Can also contain a hash reference to refer to the other relation&#39;s relations. For example:</p>

<pre>  package MyApp::Schema::Track;
  use base qw/DBIx::Class/;
  __PACKAGE__-&#62;table(&#39;track&#39;);
  __PACKAGE__-&#62;add_columns(qw/trackid cd position title/);
  __PACKAGE__-&#62;set_primary_key(&#39;trackid&#39;);
  __PACKAGE__-&#62;belongs_to(cd =&#62; &#39;MyApp::Schema::CD&#39;);
  1;

  # In your application
  my $rs = $schema-&#62;resultset(&#39;Artist&#39;)-&#62;search(
    { &#39;track.title&#39; =&#62; &#39;Teardrop&#39; },
    {
      join     =&#62; { cd =&#62; &#39;track&#39; },
      order_by =&#62; &#39;artist.name&#39;,
    }
  );</pre>

<p>You need to use the relationship (not the table) name in conditions, because they are aliased as such. The current table is aliased as &#34;me&#34;, so you need to use me.column_name in order to avoid ambiguity. For example:</p>

<pre>  # Get CDs from 1984 with a &#39;Foo&#39; track
  my $rs = $schema-&#62;resultset(&#39;CD&#39;)-&#62;search(
    {
      &#39;me.year&#39; =&#62; 1984,
      &#39;tracks.name&#39; =&#62; &#39;Foo&#39;
    },
    { join =&#62; &#39;tracks&#39; }
  );</pre>

<p>If the same join is supplied twice, it will be aliased to &#60;rel&#62;_2 (and similarly for a third time). For e.g.</p>

<pre>  my $rs = $schema-&#62;resultset(&#39;Artist&#39;)-&#62;search({
    &#39;cds.title&#39;   =&#62; &#39;Down to Earth&#39;,
    &#39;cds_2.title&#39; =&#62; &#39;Popular&#39;,
  }, {
    join =&#62; [ qw/cds cds/ ],
  });</pre>

<p>will return a set of all artists that have both a cd with title &#39;Down to Earth&#39; and a cd with title &#39;Popular&#39;.</p>

<p>If you want to fetch related objects from other tables as well, see <a href="#prefetch" class="podlinkpod"
>&#34;prefetch&#34;</a> below.</p>

<pre> NOTE: An internal join-chain pruner will discard certain joins while
 constructing the actual SQL query, as long as the joins in question do not
 affect the retrieved result. This for example includes 1:1 left joins
 that are not part of the restriction specification (WHERE/HAVING) nor are
 a part of the query selection.</pre>

<p>For more help on using joins with search, see <a href="../../DBIx/Class/Manual/Joining.html" class="podlinkpod"
>DBIx::Class::Manual::Joining</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="collapse"
>collapse</a></h2>

<dl>
<dt><a name="Value:_(0_|_1)"
>Value: (0 | 1)</a></dt>
</dl>

<p>When set to a true value, indicates that any rows fetched from joined has_many relationships are to be aggregated into the corresponding &#34;parent&#34; object. For example, the resultset:</p>

<pre>  my $rs = $schema-&#62;resultset(&#39;CD&#39;)-&#62;search({}, {
    &#39;+columns&#39; =&#62; [ qw/ tracks.title tracks.position / ],
    join =&#62; &#39;tracks&#39;,
    collapse =&#62; 1,
  });</pre>

<p>While executing the following query:</p>

<pre>  SELECT me.*, tracks.title, tracks.position
    FROM cd me
    LEFT JOIN track tracks
      ON tracks.cdid = me.cdid</pre>

<p>Will return only as many objects as there are rows in the CD source, even though the result of the query may span many rows. Each of these CD objects will in turn have multiple &#34;Track&#34; objects hidden behind the has_many generated accessor <code>tracks</code>. Without <code>collapse =&#62; 1</code>, the return values of this resultset would be as many CD objects as there are tracks (a &#34;Cartesian product&#34;), with each CD object containing exactly one of all fetched Track data.</p>

<p>When a collapse is requested on a non-ordered resultset, an order by some unique part of the main source (the left-most table) is inserted automatically. This is done so that the resultset is allowed to be &#34;lazy&#34; - calling <a href="#next" class="podlinkpod"
>$rs-&#62;next</a> will fetch only as many rows as it needs to build the next object with all of its related data.</p>

<p>If an <a href="#order_by" class="podlinkpod"
>&#34;order_by&#34;</a> is already declared, and orders the resultset in a way that makes collapsing as described above impossible (e.g. <code>ORDER BY has_many_rel.column</code> or <code>ORDER BY RANDOM()</code>), DBIC will automatically switch to &#34;eager&#34; mode and slurp the entire resultset before consturcting the first object returned by <a href="#next" class="podlinkpod"
>&#34;next&#34;</a>.</p>

<p>Setting this attribute on a resultset that does not join any has_many relations is a no-op.</p>

<p>For a more in-depth discussion, see <a href="#PREFETCHING" class="podlinkpod"
>&#34;PREFETCHING&#34;</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="prefetch"
>prefetch</a></h2>

<dl>
<dt><a name="Value:_($rel_name_|_\@rel_names_|_\%rel_names)"
>Value: ($rel_name | \@rel_names | \%rel_names)</a></dt>
</dl>

<p>This attribute is a shorthand for specifying a <a href="#join" class="podlinkpod"
>&#34;join&#34;</a> spec, adding all columns from the joined related sources as <a href="#%2Bcolumns" class="podlinkpod"
>&#34;+columns&#34;</a> and setting <a href="#collapse" class="podlinkpod"
>&#34;collapse&#34;</a> to a true value. For example, the following two queries are equivalent:</p>

<pre>  my $rs = $schema-&#62;resultset(&#39;Artist&#39;)-&#62;search({}, {
    prefetch =&#62; { cds =&#62; [&#39;genre&#39;, &#39;tracks&#39; ] },
  });</pre>

<p>and</p>

<pre>  my $rs = $schema-&#62;resultset(&#39;Artist&#39;)-&#62;search({}, {
    join =&#62; { cds =&#62; [&#39;genre&#39;, &#39;tracks&#39; ] },
    collapse =&#62; 1,
    &#39;+columns&#39; =&#62; [
      (map
        { +{ &#34;cds.$_&#34; =&#62; &#34;cds.$_&#34; } }
        $schema-&#62;source(&#39;Artist&#39;)-&#62;related_source(&#39;cds&#39;)-&#62;columns
      ),
      (map
        { +{ &#34;cds.genre.$_&#34; =&#62; &#34;genre.$_&#34; } }
        $schema-&#62;source(&#39;Artist&#39;)-&#62;related_source(&#39;cds&#39;)-&#62;related_source(&#39;genre&#39;)-&#62;columns
      ),
      (map
        { +{ &#34;cds.tracks.$_&#34; =&#62; &#34;tracks.$_&#34; } }
        $schema-&#62;source(&#39;Artist&#39;)-&#62;related_source(&#39;cds&#39;)-&#62;related_source(&#39;tracks&#39;)-&#62;columns
      ),
    ],
  });</pre>

<p>Both producing the following SQL:</p>

<pre>  SELECT  me.artistid, me.name, me.rank, me.charfield,
          cds.cdid, cds.artist, cds.title, cds.year, cds.genreid, cds.single_track,
          genre.genreid, genre.name,
          tracks.trackid, tracks.cd, tracks.position, tracks.title, tracks.last_updated_on, tracks.last_updated_at
    FROM artist me
    LEFT JOIN cd cds
      ON cds.artist = me.artistid
    LEFT JOIN genre genre
      ON genre.genreid = cds.genreid
    LEFT JOIN track tracks
      ON tracks.cd = cds.cdid
  ORDER BY me.artistid</pre>

<p>While <a href="#prefetch" class="podlinkpod"
>&#34;prefetch&#34;</a> implies a <a href="#join" class="podlinkpod"
>&#34;join&#34;</a>, it is ok to mix the two together, as the arguments are properly merged and generally do the right thing. For example, you may want to do the following:</p>

<pre>  my $artists_and_cds_without_genre = $schema-&#62;resultset(&#39;Artist&#39;)-&#62;search(
    { &#39;genre.genreid&#39; =&#62; undef },
    {
      join =&#62; { cds =&#62; &#39;genre&#39; },
      prefetch =&#62; &#39;cds&#39;,
    }
  );</pre>

<p>Which generates the following SQL:</p>

<pre>  SELECT  me.artistid, me.name, me.rank, me.charfield,
          cds.cdid, cds.artist, cds.title, cds.year, cds.genreid, cds.single_track
    FROM artist me
    LEFT JOIN cd cds
      ON cds.artist = me.artistid
    LEFT JOIN genre genre
      ON genre.genreid = cds.genreid
  WHERE genre.genreid IS NULL
  ORDER BY me.artistid</pre>

<p>For a more in-depth discussion, see <a href="#PREFETCHING" class="podlinkpod"
>&#34;PREFETCHING&#34;</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="alias"
>alias</a></h2>

<dl>
<dt><a name="Value:_$source_alias"
>Value: $source_alias</a></dt>
</dl>

<p>Sets the source alias for the query. Normally, this defaults to <code>me</code>, but nested search queries (sub-SELECTs) might need specific aliases set to reference inner queries. For example:</p>

<pre>   my $q = $rs
      -&#62;related_resultset(&#39;CDs&#39;)
      -&#62;related_resultset(&#39;Tracks&#39;)
      -&#62;search({
         &#39;track.id&#39; =&#62; { -ident =&#62; &#39;none_search.id&#39; },
      })
      -&#62;as_query;

   my $ids = $self-&#62;search({
      -not_exists =&#62; $q,
   }, {
      alias    =&#62; &#39;none_search&#39;,
      group_by =&#62; &#39;none_search.id&#39;,
   })-&#62;get_column(&#39;id&#39;)-&#62;as_query;

   $self-&#62;search({ id =&#62; { -in =&#62; $ids } })</pre>

<p>This attribute is directly tied to <a href="#current_source_alias" class="podlinkpod"
>&#34;current_source_alias&#34;</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="page"
>page</a></h2>

<dl>
<dt><a name="Value:_$page"
>Value: $page</a></dt>
</dl>

<p>Makes the resultset paged and specifies the page to retrieve. Effectively identical to creating a non-pages resultset and then calling -&#62;page($page) on it.</p>

<p>If <a href="#rows" class="podlinkpod"
>&#34;rows&#34;</a> attribute is not specified it defaults to 10 rows per page.</p>

<p>When you have a paged resultset, <a href="#count" class="podlinkpod"
>&#34;count&#34;</a> will only return the number of rows in the page. To get the total, use the <a href="#pager" class="podlinkpod"
>&#34;pager&#34;</a> and call <code>total_entries</code> on it.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="rows"
>rows</a></h2>

<dl>
<dt><a name="Value:_$rows"
>Value: $rows</a></dt>
</dl>

<p>Specifies the maximum number of rows for direct retrieval or the number of rows per page if the page attribute or method is used.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="offset"
>offset</a></h2>

<dl>
<dt><a name="Value:_$offset"
>Value: $offset</a></dt>
</dl>

<p>Specifies the (zero-based) row number for the first row to be returned, or the of the first row of the first page if paging is used.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="software_limit"
>software_limit</a></h2>

<dl>
<dt><a name="Value:_(0_|_1)"
>Value: (0 | 1)</a></dt>
</dl>

<p>When combined with <a href="#rows" class="podlinkpod"
>&#34;rows&#34;</a> and/or <a href="#offset" class="podlinkpod"
>&#34;offset&#34;</a> the generated SQL will not include any limit dialect stanzas. Instead the entire result will be selected as if no limits were specified, and DBIC will perform the limit locally, by artificially advancing and finishing the resulting <a href="#cursor" class="podlinkpod"
>&#34;cursor&#34;</a>.</p>

<p>This is the recommended way of performing resultset limiting when no sane RDBMS implementation is available (e.g. <a href="../../DBIx/Class/Storage/DBI/Sybase/ASE.html" class="podlinkpod"
>Sybase ASE</a> using the <a href="../../DBIx/Class/SQLMaker/LimitDialects.html#GenericSubQ" class="podlinkpod"
>Generic Sub Query</a> hack)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="group_by"
>group_by</a></h2>

<dl>
<dt><a name="Value:_\@columns"
>Value: \@columns</a></dt>
</dl>

<p>A arrayref of columns to group by. Can include columns of joined tables.</p>

<pre>  group_by =&#62; [qw/ column1 column2 ... /]</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="having"
>having</a></h2>

<dl>
<dt><a name="Value:_$condition"
>Value: $condition</a></dt>
</dl>

<p>HAVING is a select statement attribute that is applied between GROUP BY and ORDER BY. It is applied to the after the grouping calculations have been done.</p>

<pre>  having =&#62; { &#39;count_employee&#39; =&#62; { &#39;&#62;=&#39;, 100 } }</pre>

<p>or with an in-place function in which case literal SQL is required:</p>

<pre>  having =&#62; \[ &#39;count(employee) &#62;= ?&#39;, [ count =&#62; 100 ] ]</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="distinct"
>distinct</a></h2>

<dl>
<dt><a name="Value:_(0_|_1)"
>Value: (0 | 1)</a></dt>
</dl>

<p>Set to 1 to group by all columns. If the resultset already has a group_by attribute, this setting is ignored and an appropriate warning is issued.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="where"
>where</a></h2>

<blockquote>
<p>Adds to the WHERE clause.</p>

<pre>  # only return rows WHERE deleted IS NULL for all searches
  __PACKAGE__-&#62;resultset_attributes({ where =&#62; { deleted =&#62; undef } });</pre>

<p>Can be overridden by passing <code>{ where =&#62; undef }</code> as an attribute to a resultset.</p>

<p>For more complicated where clauses see <a href="../../SQL/Abstract.html#WHERE_CLAUSES" class="podlinkpod"
>&#34;WHERE CLAUSES&#34; in SQL::Abstract</a>.</p>
</blockquote>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="cache"
>cache</a></h2>

<p>Set to 1 to cache search results. This prevents extra SQL queries if you revisit rows in your ResultSet:</p>

<pre>  my $resultset = $schema-&#62;resultset(&#39;Artist&#39;)-&#62;search( undef, { cache =&#62; 1 } );

  while( my $artist = $resultset-&#62;next ) {
    ... do stuff ...
  }

  $rs-&#62;first; # without cache, this would issue a query</pre>

<p>By default, searches are not cached.</p>

<p>For more examples of using these attributes, see <a href="../../DBIx/Class/Manual/Cookbook.html" class="podlinkpod"
>DBIx::Class::Manual::Cookbook</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="for"
>for</a></h2>

<dl>
<dt><a name="Value:_(_&#39;update&#39;_|_&#39;shared&#39;_|_\$scalar_)"
>Value: ( &#39;update&#39; | &#39;shared&#39; | \$scalar )</a></dt>
</dl>

<p>Set to &#39;update&#39; for a SELECT ... FOR UPDATE or &#39;shared&#39; for a SELECT ... FOR SHARED. If \$scalar is passed, this is taken directly and embedded in the query.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PREFETCHING"
>PREFETCHING</a></h1>

<p>DBIx::Class supports arbitrary related data prefetching from multiple related sources. Any combination of relationship types and column sets are supported. If <a href="#collapse" class="podlinkpod"
>collapsing</a> is requested, there is an additional requirement of selecting enough data to make every individual object uniquely identifiable.</p>

<p>Here are some more involved examples, based on the following relationship map:</p>

<pre>  # Assuming:
  My::Schema::CD-&#62;belongs_to( artist      =&#62; &#39;My::Schema::Artist&#39;     );
  My::Schema::CD-&#62;might_have( liner_note  =&#62; &#39;My::Schema::LinerNotes&#39; );
  My::Schema::CD-&#62;has_many(   tracks      =&#62; &#39;My::Schema::Track&#39;      );

  My::Schema::Artist-&#62;belongs_to( record_label =&#62; &#39;My::Schema::RecordLabel&#39; );

  My::Schema::Track-&#62;has_many( guests =&#62; &#39;My::Schema::Guest&#39; );



  my $rs = $schema-&#62;resultset(&#39;Tag&#39;)-&#62;search(
    undef,
    {
      prefetch =&#62; {
        cd =&#62; &#39;artist&#39;
      }
    }
  );</pre>

<p>The initial search results in SQL like the following:</p>

<pre>  SELECT tag.*, cd.*, artist.* FROM tag
  JOIN cd ON tag.cd = cd.cdid
  JOIN artist ON cd.artist = artist.artistid</pre>

<p><a href="../../DBIx/Class.html" class="podlinkpod"
>DBIx::Class</a> has no need to go back to the database when we access the <code>cd</code> or <code>artist</code> relationships, which saves us two SQL statements in this case.</p>

<p>Simple prefetches will be joined automatically, so there is no need for a <code>join</code> attribute in the above search.</p>

<p>The <a href="#prefetch" class="podlinkpod"
>&#34;prefetch&#34;</a> attribute can be used with any of the relationship types and multiple prefetches can be specified together. Below is a more complex example that prefetches a CD&#39;s artist, its liner notes (if present), the cover image, the tracks on that CD, and the guests on those tracks.</p>

<pre>  my $rs = $schema-&#62;resultset(&#39;CD&#39;)-&#62;search(
    undef,
    {
      prefetch =&#62; [
        { artist =&#62; &#39;record_label&#39;},  # belongs_to =&#62; belongs_to
        &#39;liner_note&#39;,                 # might_have
        &#39;cover_image&#39;,                # has_one
        { tracks =&#62; &#39;guests&#39; },       # has_many =&#62; has_many
      ]
    }
  );</pre>

<p>This will produce SQL like the following:</p>

<pre>  SELECT cd.*, artist.*, record_label.*, liner_note.*, cover_image.*,
         tracks.*, guests.*
    FROM cd me
    JOIN artist artist
      ON artist.artistid = me.artistid
    JOIN record_label record_label
      ON record_label.labelid = artist.labelid
    LEFT JOIN track tracks
      ON tracks.cdid = me.cdid
    LEFT JOIN guest guests
      ON guests.trackid = track.trackid
    LEFT JOIN liner_notes liner_note
      ON liner_note.cdid = me.cdid
    JOIN cd_artwork cover_image
      ON cover_image.cdid = me.cdid
  ORDER BY tracks.cd</pre>

<p>Now the <code>artist</code>, <code>record_label</code>, <code>liner_note</code>, <code>cover_image</code>, <code>tracks</code>, and <code>guests</code> of the CD will all be available through the relationship accessors without the need for additional queries to the database.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="CAVEATS"
>CAVEATS</a></h3>

<p>Prefetch does a lot of deep magic. As such, it may not behave exactly as you might expect.</p>

<ul>
<li>Prefetch uses the <a href="#cache" class="podlinkpod"
>&#34;cache&#34;</a> to populate the prefetched relationships. This may or may not be what you want.</li>

<li>If you specify a condition on a prefetched relationship, ONLY those rows that match the prefetched condition will be fetched into that relationship. This means that adding prefetch to a search() <b>may alter</b> what is returned by traversing a relationship. So, if you have <code>Artist-&#62;has_many(CDs)</code> and you do
<pre>  my $artist_rs = $schema-&#62;resultset(&#39;Artist&#39;)-&#62;search({
      &#39;cds.year&#39; =&#62; 2008,
  }, {
      join =&#62; &#39;cds&#39;,
  });

  my $count = $artist_rs-&#62;first-&#62;cds-&#62;count;

  my $artist_rs_prefetch = $artist_rs-&#62;search( {}, { prefetch =&#62; &#39;cds&#39; } );

  my $prefetch_count = $artist_rs_prefetch-&#62;first-&#62;cds-&#62;count;

  cmp_ok( $count, &#39;==&#39;, $prefetch_count, &#34;Counts should be the same&#34; );</pre>

<p>That cmp_ok() may or may not pass depending on the datasets involved. In other words the <code>WHERE</code> condition would apply to the entire dataset, just like it would in regular SQL. If you want to add a condition only to the &#34;right side&#34; of a <code>LEFT JOIN</code> - consider declaring and using a <a href="../../DBIx/Class/Relationship/Base.html#condition" class="podlinkpod"
>relationship with a custom condition</a></p>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DBIC_BIND_VALUES"
>DBIC BIND VALUES</a></h1>

<p>Because DBIC may need more information to bind values than just the column name and value itself, it uses a special format for both passing and receiving bind values. Each bind value should be composed of an arrayref of <code>[ \%args =&#62; $val ]</code>. The format of <code>\%args</code> is currently:</p>

<dl>
<dt><a name="dbd_attrs"
>dbd_attrs</a></dt>

<dd>
<p>If present (in any form), this is what is being passed directly to bind_param. Note that different DBD&#39;s expect different bind args. (e.g. DBD::SQLite takes a single numerical type, while DBD::Pg takes a hashref if bind options.)</p>

<p>If this is specified, all other bind options described below are ignored.</p>

<dt><a name="sqlt_datatype"
>sqlt_datatype</a></dt>

<dd>
<p>If present, this is used to infer the actual bind attribute by passing to <code>$resolved_storage-&#62;bind_attribute_by_data_type()</code>. Defaults to the &#34;data_type&#34; from the <a href="../../DBIx/Class/ResultSource.html#add_columns" class="podlinkpod"
>add_columns column info</a>.</p>

<p>Note that the data type is somewhat freeform (hence the sqlt_ prefix); currently drivers are expected to &#34;Do the Right Thing&#34; when given a common datatype name. (Not ideal, but that&#39;s what we got at this point.)</p>

<dt><a name="sqlt_size"
>sqlt_size</a></dt>

<dd>
<p>Currently used to correctly allocate buffers for bind_param_inout(). Defaults to &#34;size&#34; from the <a href="../../DBIx/Class/ResultSource.html#add_columns" class="podlinkpod"
>add_columns column info</a>, or to a sensible value based on the &#34;data_type&#34;.</p>

<dt><a name="dbic_colname"
>dbic_colname</a></dt>

<dd>
<p>Used to fill in missing sqlt_datatype and sqlt_size attributes (if they are explicitly specified they are never overriden). Also used by some weird DBDs, where the column name should be available at bind_param time (e.g. Oracle).</p>
</dd>
</dl>

<p>For backwards compatibility and convenience, the following shortcuts are supported:</p>

<pre>  [ $name =&#62; $val ] === [ { dbic_colname =&#62; $name }, $val ]
  [ \$dt  =&#62; $val ] === [ { sqlt_datatype =&#62; $dt }, $val ]
  [ undef,   $val ] === [ {}, $val ]
  $val              === [ {}, $val ]</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR_AND_CONTRIBUTORS"
>AUTHOR AND CONTRIBUTORS</a></h1>

<p>See <a href="../../DBIx/Class.html#AUTHOR" class="podlinkpod"
>AUTHOR</a> and <a href="../../DBIx/Class.html#CONTRIBUTORS" class="podlinkpod"
>CONTRIBUTORS</a> in DBIx::Class</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENSE"
>LICENSE</a></h1>

<p>You may distribute this code under the same terms as Perl itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
