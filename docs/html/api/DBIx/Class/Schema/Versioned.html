<html><head><title>DBIx::Class::Schema::Versioned</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:16 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#GETTING_STARTED'>GETTING STARTED</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#upgrade_directory'>upgrade_directory</a>
    <li class='indexItem indexItem2'><a href='#backup_directory'>backup_directory</a>
    <li class='indexItem indexItem2'><a href='#install'>install</a>
    <li class='indexItem indexItem2'><a href='#deploy'>deploy</a>
    <li class='indexItem indexItem2'><a href='#create_upgrade_path'>create_upgrade_path</a>
    <li class='indexItem indexItem2'><a href='#ordered_schema_versions'>ordered_schema_versions</a>
    <li class='indexItem indexItem2'><a href='#upgrade'>upgrade</a>
    <li class='indexItem indexItem2'><a href='#upgrade_single_step'>upgrade_single_step</a>
    <li class='indexItem indexItem2'><a href='#do_upgrade'>do_upgrade</a>
    <li class='indexItem indexItem2'><a href='#run_upgrade'>run_upgrade</a>
    <li class='indexItem indexItem2'><a href='#apply_statement'>apply_statement</a>
    <li class='indexItem indexItem2'><a href='#get_db_version'>get_db_version</a>
    <li class='indexItem indexItem2'><a href='#schema_version'>schema_version</a>
    <li class='indexItem indexItem2'><a href='#backup'>backup</a>
    <li class='indexItem indexItem2'><a href='#connection'>connection</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#AUTHOR_AND_CONTRIBUTORS'>AUTHOR AND CONTRIBUTORS</a>
  <li class='indexItem indexItem1'><a href='#LICENSE'>LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>DBIx::Class::Schema::Versioned - DBIx::Class::Schema plugin for Schema upgrades</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  package MyApp::Schema;
  use base qw/DBIx::Class::Schema/;

  our $VERSION = 0.001;

  # load MyApp::Schema::CD, MyApp::Schema::Book, MyApp::Schema::DVD
  __PACKAGE__-&#62;load_classes(qw/CD Book DVD/);

  __PACKAGE__-&#62;load_components(qw/Schema::Versioned/);
  __PACKAGE__-&#62;upgrade_directory(&#39;/path/to/upgrades/&#39;);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This module provides methods to apply DDL changes to your database using SQL diff files. Normally these diff files would be created using <a href="../../../DBIx/Class/Schema.html#create_ddl_dir" class="podlinkpod"
>&#34;create_ddl_dir&#34; in DBIx::Class::Schema</a>.</p>

<p>A table called <i>dbix_class_schema_versions</i> is created and maintained by the module. This is used to determine which version your database is currently at. Similarly the $VERSION in your DBIC schema class is used to determine the current DBIC schema version.</p>

<p>The upgrade is initiated manually by calling <code>upgrade</code> on your schema object, this will attempt to upgrade the database from its current version to the current schema version using a diff from your <i>upgrade_directory</i>. If a suitable diff is not found then no upgrade is possible.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../../../DBIx/Class/DeploymentHandler.html" class="podlinkpod"
>DBIx::Class::DeploymentHandler</a> is a much more powerful alternative to this module. Examples of things it can do that this module cannot do include</p>

<ul>
<li>Downgrades in addition to upgrades</li>

<li>Multiple sql files files per upgrade/downgrade/install</li>

<li>Perl scripts allowed for upgrade/downgrade/install</li>

<li>Just one set of files needed for upgrade, unlike this module where one might need to generate <code>factorial(scalar @versions)</code></li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="GETTING_STARTED"
>GETTING STARTED</a></h1>

<p>Firstly you need to setup your schema class as per the <a href="#SYNOPSIS" class="podlinkpod"
>&#34;SYNOPSIS&#34;</a>, make sure you have specified an upgrade_directory and an initial $VERSION.</p>

<p>Then you&#39;ll need two scripts, one to create DDL files and diffs and another to perform upgrades. Your creation script might look like a bit like this:</p>

<pre>  use strict;
  use Pod::Usage;
  use Getopt::Long;
  use MyApp::Schema;

  my ( $preversion, $help );
  GetOptions(
    &#39;p|preversion:s&#39;  =&#62; \$preversion,
  ) or die pod2usage;

  my $schema = MyApp::Schema-&#62;connect(
    $dsn,
    $user,
    $password,
  );
  my $sql_dir = &#39;./sql&#39;;
  my $version = $schema-&#62;schema_version();
  $schema-&#62;create_ddl_dir( &#39;MySQL&#39;, $version, $sql_dir, $preversion );</pre>

<p>Then your upgrade script might look like so:</p>

<pre>  use strict;
  use MyApp::Schema;

  my $schema = MyApp::Schema-&#62;connect(
    $dsn,
    $user,
    $password,
  );

  if (!$schema-&#62;get_db_version()) {
    # schema is unversioned
    $schema-&#62;deploy();
  } else {
    $schema-&#62;upgrade();
  }</pre>

<p>The script above assumes that if the database is unversioned then it is empty and we can safely deploy the DDL to it. However things are not always so simple.</p>

<p>if you want to initialise a pre-existing database where the DDL is not the same as the DDL for your current schema version then you will need a diff which converts the database&#39;s DDL to the current DDL. The best way to do this is to get a dump of the database schema (without data) and save that in your SQL directory as version 0.000 (the filename must be as with <a href="../../../DBIx/Class/Schema.html#ddl_filename" class="podlinkpod"
>&#34;ddl_filename&#34; in DBIx::Class::Schema</a>) then create a diff using your create DDL script given above from version 0.000 to the current version. Then hand check and if necessary edit the resulting diff to ensure that it will apply. Once you have done all that you can do this:</p>

<pre>  if (!$schema-&#62;get_db_version()) {
    # schema is unversioned
    $schema-&#62;install(&#34;0.000&#34;);
  }

  # this will now apply the 0.000 to current version diff
  $schema-&#62;upgrade();</pre>

<p>In the case of an unversioned database the above code will create the dbix_class_schema_versions table and write version 0.000 to it, then upgrade will then apply the diff we talked about creating in the previous paragraph and then you&#39;re good to go.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="upgrade_directory"
>upgrade_directory</a></h2>

<p>Use this to set the directory your upgrade files are stored in.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="backup_directory"
>backup_directory</a></h2>

<p>Use this to set the directory you want your backups stored in (note that backups are disabled by default).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="install"
>install</a></h2>

<dl>
<dt><a name="Arguments:_$db_version"
>Arguments: $db_version</a></dt>
</dl>

<p>Call this to initialise a previously unversioned database. The table &#39;dbix_class_schema_versions&#39; will be created which will be used to store the database version.</p>

<p>Takes one argument which should be the version that the database is currently at. Defaults to the return value of <a href="#schema_version" class="podlinkpod"
>&#34;schema_version&#34;</a>.</p>

<p>See <a href="#getting_started" class="podlinkpod"
>&#34;getting_started&#34;</a> for more details.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="deploy"
>deploy</a></h2>

<p>Same as <a href="../../../DBIx/Class/Schema.html#deploy" class="podlinkpod"
>&#34;deploy&#34; in DBIx::Class::Schema</a> but also calls <code>install</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="create_upgrade_path"
>create_upgrade_path</a></h2>

<dl>
<dt><a name="Arguments:_{_upgrade_file_=&#62;_$file_}"
>Arguments: { upgrade_file =&#62; $file }</a></dt>
</dl>

<p>Virtual method that should be overridden to create an upgrade file. This is useful in the case of upgrading across multiple versions to concatenate several files to create one upgrade file.</p>

<p>You&#39;ll probably want the db_version retrieved via $self-&#62;get_db_version and the schema_version which is retrieved via $self-&#62;schema_version</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ordered_schema_versions"
>ordered_schema_versions</a></h2>

<dl>
<dt><a name="Return_Value:_a_list_of_version_numbers,_ordered_from_lowest_to_highest"
>Return Value: a list of version numbers, ordered from lowest to highest</a></dt>
</dl>

<p>Virtual method that should be overridden to return an ordered list of schema versions. This is then used to produce a set of steps to upgrade through to achieve the required schema version.</p>

<p>You may want the db_version retrieved via $self-&#62;get_db_version and the schema_version which is retrieved via $self-&#62;schema_version</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="upgrade"
>upgrade</a></h2>

<p>Call this to attempt to upgrade your database from the version it is at to the version this DBIC schema is at. If they are the same it does nothing.</p>

<p>It will call <a href="#ordered_schema_versions" class="podlinkpod"
>&#34;ordered_schema_versions&#34;</a> to retrieve an ordered list of schema versions (if ordered_schema_versions returns nothing then it is assumed you can do the upgrade as a single step). It then iterates through the list of versions between the current db version and the schema version applying one update at a time until all relevant updates are applied.</p>

<p>The individual update steps are performed by using <a href="#upgrade_single_step" class="podlinkpod"
>&#34;upgrade_single_step&#34;</a>, which will apply the update and also update the dbix_class_schema_versions table.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="upgrade_single_step"
>upgrade_single_step</a></h2>

<dl>
<dt><a name="Arguments:_db_version_-_the_version_currently_within_the_db"
>Arguments: db_version - the version currently within the db</a></dt>

<dd>
<dt><a name="Arguments:_target_version_-_the_version_to_upgrade_to"
>Arguments: target_version - the version to upgrade to</a></dt>
</dl>

<p>Call this to attempt to upgrade your database from the <i>db_version</i> to the <i>target_version</i>. If they are the same it does nothing.</p>

<p>It requires an SQL diff file to exist in your <i>upgrade_directory</i>, normally you will have created this using <a href="../../../DBIx/Class/Schema.html#create_ddl_dir" class="podlinkpod"
>&#34;create_ddl_dir&#34; in DBIx::Class::Schema</a>.</p>

<p>If successful the dbix_class_schema_versions table is updated with the <i>target_version</i>.</p>

<p>This method may be called repeatedly by the upgrade method to upgrade through a series of updates.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="do_upgrade"
>do_upgrade</a></h2>

<p>This is an overwritable method used to run your upgrade. The freeform method allows you to run your upgrade any way you please, you can call <code>run_upgrade</code> any number of times to run the actual SQL commands, and in between you can sandwich your data upgrading. For example, first run all the <b>CREATE</b> commands, then migrate your data from old to new tables/formats, then issue the DROP commands when you are finished. Will run the whole file as it is by default.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="run_upgrade"
>run_upgrade</a></h2>

<pre> $self-&#62;run_upgrade(qr/create/i);</pre>

<p>Runs a set of SQL statements matching a passed in regular expression. The idea is that this method can be called any number of times from your <code>do_upgrade</code> method, running whichever commands you specify via the regex in the parameter. Probably won&#39;t work unless called from the overridable do_upgrade method.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="apply_statement"
>apply_statement</a></h2>

<p>Takes an SQL statement and runs it. Override this if you want to handle errors differently.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_db_version"
>get_db_version</a></h2>

<p>Returns the version that your database is currently at. This is determined by the values in the dbix_class_schema_versions table that <code>upgrade</code> and <code>install</code> write to.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="schema_version"
>schema_version</a></h2>

<p>Returns the current schema class&#39; $VERSION</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="backup"
>backup</a></h2>

<p>This is an overwritable method which is called just before the upgrade, to allow you to make a backup of the database. Per default this method attempts to call <code>$self-&#62;storage-&#62;backup</code>, to run the standard backup on each database type.</p>

<p>This method should return the name of the backup file, if appropriate..</p>

<p>This method is disabled by default. Set $schema-&#62;do_backup(1) to enable it.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="connection"
>connection</a></h2>

<p>Overloaded method. This checks the DBIC schema version against the DB version and warns if they are not the same or if the DB is unversioned. It also provides compatibility between the old versions table (SchemaVersions) and the new one (dbix_class_schema_versions).</p>

<p>To avoid the checks on connect, set the environment var DBIC_NO_VERSION_CHECK or alternatively you can set the ignore_version attr in the forth argument like so:</p>

<pre>  my $schema = MyApp::Schema-&#62;connect(
    $dsn,
    $user,
    $password,
    { ignore_version =&#62; 1 },
  );</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR_AND_CONTRIBUTORS"
>AUTHOR AND CONTRIBUTORS</a></h1>

<p>See <a href="../../../DBIx/Class.html#AUTHOR" class="podlinkpod"
>AUTHOR</a> and <a href="../../../DBIx/Class.html#CONTRIBUTORS" class="podlinkpod"
>CONTRIBUTORS</a> in DBIx::Class</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENSE"
>LICENSE</a></h1>

<p>You may distribute this code under the same terms as Perl itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
