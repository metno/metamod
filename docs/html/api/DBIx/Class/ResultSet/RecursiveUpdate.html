<html><head><title>DBIx::Class::ResultSet::RecursiveUpdate</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:16 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Additional_data_in_the_updates_hashref'>Additional data in the updates hashref</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#DESIGN_CHOICES'>DESIGN CHOICES</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Treatment_of_belongs_to_relations'>Treatment of belongs_to relations</a>
    <li class='indexItem indexItem2'><a href='#Treatment_of_might_have_relationships'>Treatment of might_have relationships</a>
    <li class='indexItem indexItem2'><a href='#Treatment_of_has_many_relations'>Treatment of has_many relations</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#All_foreign_table_columns_are_nullable'>All foreign table columns are nullable</a>
      <li class='indexItem indexItem3'><a href='#Not_all_foreign_table_columns_are_nullable'>Not all foreign table columns are nullable</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Treatment_of_many-to-many_pseudo_relations'>Treatment of many-to-many pseudo relations</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#INTERFACE'>INTERFACE</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#recursive_update'>recursive_update</a>
    <li class='indexItem indexItem2'><a href='#is_m2m'>is_m2m</a>
    <li class='indexItem indexItem2'><a href='#get_m2m_source'>get_m2m_source</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#CONFIGURATION_AND_ENVIRONMENT'>CONFIGURATION AND ENVIRONMENT</a>
  <li class='indexItem indexItem1'><a href='#DEPENDENCIES'>DEPENDENCIES</a>
  <li class='indexItem indexItem1'><a href='#INCOMPATIBILITIES'>INCOMPATIBILITIES</a>
  <li class='indexItem indexItem1'><a href='#BUGS_AND_LIMITATIONS'>BUGS AND LIMITATIONS</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>DBIx::Class::ResultSet::RecursiveUpdate - like update_or_create - but recursive</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>version 0.26</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    # The functional interface:

    my $schema = MyDB::Schema-&#62;connect();
    my $new_item = DBIx::Class::ResultSet::RecursiveUpdate::Functions::recursive_update(
        resultset =&#62; $schema-&#62;resultset(&#39;User&#39;),
        updates =&#62; {
            id =&#62; 1,
            owned_dvds =&#62; [
                {
                    title =&#62; &#34;One Flew Over the Cuckoo&#39;s Nest&#34;
                }
            ]
        },
        unknown_params_ok =&#62; 1,
    );


    # As ResultSet subclass:

    __PACKAGE__-&#62;load_namespaces( default_resultset_class =&#62; &#39;+DBIx::Class::ResultSet::RecursiveUpdate&#39; );

    # in the Schema file (see t/lib/DBSchema.pm).  Or appropriate &#39;use base&#39; in the ResultSet classes.

    my $user = $schema-&#62;resultset(&#39;User&#39;)-&#62;recursive_update({
        id =&#62; 1,
        owned_dvds =&#62; [
            {
                title =&#62; &#34;One Flew Over the Cuckoo&#39;s Nest&#34;
            }
        ]
    }, {
        unknown_params_ok =&#62; 1,
    });

    # You&#39;ll get a warning if you pass non-result specific data to
    # recursive_update. See L&#60;/&#34;Additional data in the updates hashref&#34;&#62;
    # for more information how to prevent this.</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>You can feed the -&#62;create method of DBIx::Class with a recursive datastructure and have the related records created. Unfortunately you cannot do a similar thing with update_or_create. This module tries to fill that void until <a href="../../../DBIx/Class.html" class="podlinkpod"
>DBIx::Class</a> has an api itself.</p>

<p>The functional interface can be used without modifications of the model, for example by form processors like <a href="../../../HTML/FormHandler/Model/DBIC.html" class="podlinkpod"
>HTML::FormHandler::Model::DBIC</a>.</p>

<p>It is a base class for <a href="../../../DBIx/Class/ResultSet.html" class="podlinkpod"
>DBIx::Class::ResultSet</a>s providing the method recursive_update which works just like update_or_create but can recursively update or create result objects composed of multiple rows. All rows need to be identified by primary keys so you need to provide them in the update structure (unless they can be deduced from the parent row. For example a related row of a belongs_to relationship). If any of the primary key columns are missing, a new row will be created, with the expectation that the missing columns will be filled by it (as in the case of auto_increment primary keys).</p>

<p>If the resultset itself stores an assignment for the primary key, like in the case of:</p>

<pre>    my $restricted_rs = $user_rs-&#62;search( { id =&#62; 1 } );</pre>

<p>you need to inform recursive_update about the additional predicate with the fixed_fields attribute:</p>

<pre>    my $user = $restricted_rs-&#62;recursive_update( {
            owned_dvds =&#62; [
            {
                title =&#62; &#39;One Flew Over the Cuckoo&#39;s Nest&#39;
            }
            ]
        },
        {
            fixed_fields =&#62; [ &#39;id&#39; ],
        }
    );</pre>

<p>For a many_to_many (pseudo) relation you can supply a list of primary keys from the other table and it will link the record at hand to those and only those records identified by them. This is convenient for handling web forms with check boxes (or a select field with multiple choice) that lets you update such (pseudo) relations.</p>

<p>For a description how to set up base classes for ResultSets see <a href="../../../DBIx/Class/Schema.html#load_namespaces" class="podlinkpod"
>&#34;load_namespaces&#34; in DBIx::Class::Schema</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Additional_data_in_the_updates_hashref"
>Additional data in the updates hashref</a></h2>

<p>If you pass additional data to recursive_update which doesn&#39;t match a column name, column accessor, relationship or many-to-many helper accessor, it will throw a warning by default. To disable this behaviour you can set the unknown_params_ok attribute to a true value.</p>

<p>The warning thrown is: &#34;No such column, relationship, many-to-many helper accessor or generic accessor &#39;$key&#39;&#34;</p>

<p>When used by <a href="../../../HTML/FormHandler/Model/DBIC.html" class="podlinkpod"
>HTML::FormHandler::Model::DBIC</a> this can happen if you have additional form fields that aren&#39;t relevant to the database but don&#39;t have the noupdate attribute set to a true value.</p>

<p>NOTE: in a future version this behaviour will change and throw an exception instead of a warning!</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESIGN_CHOICES"
>DESIGN CHOICES</a></h1>

<p>Columns and relationships which are excluded from the updates hashref aren&#39;t touched at all.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Treatment_of_belongs_to_relations"
>Treatment of belongs_to relations</a></h2>

<p>In case the relationship is included but undefined in the updates hashref, all columns forming the relationship will be set to null. If not all of them are nullable, DBIx::Class will throw an error.</p>

<p>Updating the relationship:</p>

<pre>    my $dvd = $dvd_rs-&#62;recursive_update( {
        id    =&#62; 1,
        owner =&#62; $user-&#62;id,
    });</pre>

<p>Clearing the relationship (only works if cols are nullable!):</p>

<pre>    my $dvd = $dvd_rs-&#62;recursive_update( {
        id    =&#62; 1,
        owner =&#62; undef,
    });</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Treatment_of_might_have_relationships"
>Treatment of might_have relationships</a></h2>

<p>In case the relationship is included but undefined in the updates hashref, all columns forming the relationship will be set to null.</p>

<p>Updating the relationship:</p>

<pre>    my $user = $user_rs-&#62;recursive_update( {
        id =&#62; 1,
        address =&#62; {
            street =&#62; &#34;101 Main Street&#34;,
            city   =&#62; &#34;Podunk&#34;,
            state  =&#62; &#34;New York&#34;,
        }
    });</pre>

<p>Clearing the relationship:</p>

<pre>    my $user = $user_rs-&#62;recursive_update( {
        id =&#62; 1,
        address =&#62; undef,
    });</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Treatment_of_has_many_relations"
>Treatment of has_many relations</a></h2>

<p>If a relationship key is included in the data structure with a value of undef or an empty array, all existing related rows will be deleted, or their foreign key columns will be set to null.</p>

<p>The exact behaviour depends on the nullability of the foreign key columns and the value of the &#34;if_not_submitted&#34; parameter. The parameter defaults to undefined which neither nullifies nor deletes.</p>

<p>When the array contains elements they are updated if they exist, created when not and deleted if not included.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="All_foreign_table_columns_are_nullable"
>All foreign table columns are nullable</a></h3>

<p>In this case recursive_update defaults to nullifying the foreign columns.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Not_all_foreign_table_columns_are_nullable"
>Not all foreign table columns are nullable</a></h3>

<p>In this case recursive_update deletes the foreign rows.</p>

<p>Updating the relationship:</p>

<pre>    Passing ids:

    my $user = $user_rs-&#62;recursive_update( {
        id         =&#62; 1,
        owned_dvds =&#62; [1, 2],
    });

    Passing hashrefs:

    my $user = $user_rs-&#62;recursive_update( {
        id         =&#62; 1,
        owned_dvds =&#62; [
            {
                name =&#62; &#39;temp name 1&#39;,
            },
            {
                name =&#62; &#39;temp name 2&#39;,
            },
        ],
    });

    Passing objects:

    my $user = $user_rs-&#62;recursive_update( {
        id         =&#62; 1,
        owned_dvds =&#62; [ $dvd1, $dvd2 ],
    });

    You can even mix them:

    my $user = $user_rs-&#62;recursive_update( {
        id         =&#62; 1,
        owned_dvds =&#62; [ 1, { id =&#62; 2 } ],
    });</pre>

<p>Clearing the relationship:</p>

<pre>    my $user = $user_rs-&#62;recursive_update( {
        id         =&#62; 1,
        owned_dvds =&#62; undef,
    });

    This is the same as passing an empty array:

    my $user = $user_rs-&#62;recursive_update( {
        id         =&#62; 1,
        owned_dvds =&#62; [],
    });</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Treatment_of_many-to-many_pseudo_relations"
>Treatment of many-to-many pseudo relations</a></h2>

<p>If a many-to-many accessor key is included in the data structure with a value of undef or an empty array, all existing related rows are unlinked.</p>

<p>When the array contains elements they are updated if they exist, created when not and deleted if not included.</p>

<p>See <a href="#is_m2m" class="podlinkpod"
>&#34;is_m2m&#34;</a> for many-to-many pseudo relationship detection.</p>

<p>Updating the relationship:</p>

<pre>    Passing ids:

    my $dvd = $dvd_rs-&#62;recursive_update( {
        id   =&#62; 1,
        tags =&#62; [1, 2],
    });

    Passing hashrefs:

    my $dvd = $dvd_rs-&#62;recursive_update( {
        id   =&#62; 1,
        tags =&#62; [
            {
                id   =&#62; 1,
                file =&#62; &#39;file0&#39;
            },
            {
                id   =&#62; 2,
                file =&#62; &#39;file1&#39;,
            },
        ],
    });

    Passing objects:

    my $dvd = $dvd_rs-&#62;recursive_update( {
        id   =&#62; 1,
        tags =&#62; [ $tag1, $tag2 ],
    });

    You can even mix them:

    my $dvd = $dvd_rs-&#62;recursive_update( {
        id   =&#62; 1,
        tags =&#62; [ 2, { id =&#62; 3 } ],
    });</pre>

<p>Clearing the relationship:</p>

<pre>    my $dvd = $dvd_rs-&#62;recursive_update( {
        id   =&#62; 1,
        tags =&#62; undef,
    });

    This is the same as passing an empty array:

    my $dvd = $dvd_rs-&#62;recursive_update( {
        id   =&#62; 1,
        tags =&#62; [],
    });</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="INTERFACE"
>INTERFACE</a></h1>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="recursive_update"
>recursive_update</a></h2>

<p>The method that does the work here.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="is_m2m"
>is_m2m</a></h2>

<dl>
<dt><a name="Arguments:_$name"
>Arguments: $name</a></dt>

<dd>
<dt><a name="Return_Value:_true,_if_$name_is_a_many_to_many_pseudo-relationship"
>Return Value: true, if $name is a many to many pseudo-relationship</a></dt>
</dl>

<p>The function gets the information about m2m relations from <a href="../../../DBIx/Class/IntrospectableM2M.html" class="podlinkpod"
>DBIx::Class::IntrospectableM2M</a>. If it isn&#39;t loaded in the ResultSource class, the code relies on the fact:</p>

<pre>    if($object-&#62;can($name) and
             !$object-&#62;result_source-&#62;has_relationship($name) and
             $object-&#62;can( &#39;set_&#39; . $name )
         )</pre>

<p>to identify a many to many pseudo relationship. In a similar ugly way the ResultSource of that many to many pseudo relationship is detected.</p>

<p>So if you need many to many pseudo relationship support, it&#39;s strongly recommended to load <a href="../../../DBIx/Class/IntrospectableM2M.html" class="podlinkpod"
>DBIx::Class::IntrospectableM2M</a> in your ResultSource class!</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_m2m_source"
>get_m2m_source</a></h2>

<dl>
<dt><a name="Arguments:_$name"
>Arguments: $name</a></dt>

<dd>
<dt><a name="Return_Value:_$result_source"
>Return Value: $result_source</a></dt>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CONFIGURATION_AND_ENVIRONMENT"
>CONFIGURATION AND ENVIRONMENT</a></h1>

<p>DBIx::Class::RecursiveUpdate requires no configuration files or environment variables.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DEPENDENCIES"
>DEPENDENCIES</a></h1>

<pre>    DBIx::Class</pre>

<p>optional but recommended: DBIx::Class::IntrospectableM2M</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="INCOMPATIBILITIES"
>INCOMPATIBILITIES</a></h1>

<p>None reported.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS_AND_LIMITATIONS"
>BUGS AND LIMITATIONS</a></h1>

<p>The list of reported bugs can be viewed at <a href="http://rt.cpan.org/Public/Dist/Display.html?Name=DBIx-Class-ResultSet-RecursiveUpdate" class="podlinkurl"
>http://rt.cpan.org/Public/Dist/Display.html?Name=DBIx-Class-ResultSet-RecursiveUpdate</a>.</p>

<p>Please report any bugs or feature requests to <code>bug-dbix-class-recursiveput@rt.cpan.org</code>, or through the web interface at <a href="http://rt.cpan.org" class="podlinkurl"
>http://rt.cpan.org</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<ul>
<li>Zbigniew Lukasiak &#60;zby@cpan.org&#62;</li>

<li>John Napiorkowski &#60;jjnapiork@cpan.org&#62;</li>

<li>Alexander Hartmaier &#60;abraxxa@cpan.org&#62;</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>This software is copyright (c) 2012 by Zbigniew Lukasiak, John Napiorkowski, Alexander Hartmaier.</p>

<p>This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
