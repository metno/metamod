<html><head><title>DBIx::Class::Manual::Intro</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:15 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#INTRODUCTION'>INTRODUCTION</a>
  <li class='indexItem indexItem1'><a href='#THE_DBIx%3A%3AClass_WAY'>THE DBIx::Class WAY</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Tables_become_Result_classes'>Tables become Result classes</a>
    <li class='indexItem indexItem2'><a href='#It%27s_all_about_the_ResultSet'>It&#39;s all about the ResultSet</a>
    <li class='indexItem indexItem2'><a href='#Search_is_like_%22prepare%22'>Search is like &#34;prepare&#34;</a>
    <li class='indexItem indexItem2'><a href='#Search_results_are_returned_as_Rows'>Search results are returned as Rows</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SETTING_UP_DBIx%3A%3AClass'>SETTING UP DBIx::Class</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Setting_it_up_manually'>Setting it up manually</a>
    <li class='indexItem indexItem2'><a href='#Using_DBIx%3A%3AClass%3A%3ASchema%3A%3ALoader'>Using DBIx::Class::Schema::Loader</a>
    <li class='indexItem indexItem2'><a href='#Connecting'>Connecting</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Via_connection_details'>Via connection details</a>
      <li class='indexItem indexItem3'><a href='#Via_a_database_handle'>Via a database handle</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Basic_usage'>Basic usage</a>
    <li class='indexItem indexItem2'><a href='#Adding_and_removing_rows'>Adding and removing rows</a>
    <li class='indexItem indexItem2'><a href='#Finding_your_objects'>Finding your objects</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#NOTES'>NOTES</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#The_Significance_and_Importance_of_Primary_Keys'>The Significance and Importance of Primary Keys</a>
    <li class='indexItem indexItem2'><a href='#Problems_on_RHEL5%2FCentOS5'>Problems on RHEL5/CentOS5</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>DBIx::Class::Manual::Intro - Introduction to DBIx::Class</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="INTRODUCTION"
>INTRODUCTION</a></h1>

<p>You&#39;re bored with SQL,
and want a native Perl interface for your database?
Or you&#39;ve been doing this for a while with <a href="../../../Class/DBI.html" class="podlinkpod"
>Class::DBI</a>,
and think there&#39;s a better way?
You&#39;ve come to the right place.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="THE_DBIx::Class_WAY"
>THE DBIx::Class WAY</a></h1>

<p>Here are a few simple tips that will help you get your bearings with DBIx::Class.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Tables_become_Result_classes"
>Tables become Result classes</a></h2>

<p>DBIx::Class needs to know what your Table structure looks like.
You do that by defining Result classes.
Result classes are defined by calling methods proxied to <a href="../../../DBIx/Class/ResultSource.html" class="podlinkpod"
>DBIx::Class::ResultSource</a>.
Each Result class defines one Table,
which defines the Columns it has,
along with any Relationships it has to other tables.
(And oh,
so much more besides) The important thing to understand:</p>

<pre>  A Result class == Table</pre>

<p>(most of the time, but just bear with my simplification)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="It&#39;s_all_about_the_ResultSet"
>It&#39;s all about the ResultSet</a></h2>

<p>So, we&#39;ve got some ResultSources defined. Now, we want to actually use those definitions to help us translate the queries we need into handy perl objects!</p>

<p>Let&#39;s say we defined a ResultSource for an &#34;album&#34; table with three columns: &#34;albumid&#34;, &#34;artist&#34;, and &#34;title&#34;. Any time we want to query this table, we&#39;ll be creating a <a href="../../../DBIx/Class/ResultSet.html" class="podlinkpod"
>DBIx::Class::ResultSet</a> from its ResultSource. For example, the results of:</p>

<pre>  SELECT albumid, artist, title FROM album;</pre>

<p>Would be retrieved by creating a ResultSet object from the album table&#39;s ResultSource, likely by using the &#34;search&#34; method.</p>

<p>DBIx::Class doesn&#39;t limit you to creating only simple ResultSets -- if you wanted to do something like:</p>

<pre>  SELECT title FROM album GROUP BY title;</pre>

<p>You could easily achieve it.</p>

<p>The important thing to understand:</p>

<pre>  Any time you would reach for a SQL query in DBI, you are
  creating a DBIx::Class::ResultSet.</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Search_is_like_&#34;prepare&#34;"
>Search is like &#34;prepare&#34;</a></h2>

<p>DBIx::Class tends to wait until it absolutely must fetch information from the database. If you are returning a ResultSet, the query won&#39;t execute until you use a method that wants to access the data. (Such as &#34;next&#34;, or &#34;first&#34;)</p>

<p>The important thing to understand:</p>

<pre>  Setting up a ResultSet does not execute the query; retrieving
  the data does.</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Search_results_are_returned_as_Rows"
>Search results are returned as Rows</a></h2>

<p>Rows of the search from the database are blessed into <a href="../../../DBIx/Class/Manual/ResultClass.html" class="podlinkpod"
>Result</a> objects.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SETTING_UP_DBIx::Class"
>SETTING UP DBIx::Class</a></h1>

<p>Let&#39;s look at how you can set and use your first native <a href="../../../DBIx/Class.html" class="podlinkpod"
>DBIx::Class</a> tree.</p>

<p>First we&#39;ll see how you can set up your classes yourself. If you want them to be auto-discovered, just skip to the <a href="#Using_DBIx%3A%3AClass%3A%3ASchema%3A%3ALoader" class="podlinkpod"
>next section</a>, which shows you how to use <a href="../../../DBIx/Class/Schema/Loader.html" class="podlinkpod"
>DBIx::Class::Schema::Loader</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Setting_it_up_manually"
>Setting it up manually</a></h2>

<p>First, you should create your base schema class, which inherits from <a href="../../../DBIx/Class/Schema.html" class="podlinkpod"
>DBIx::Class::Schema</a>:</p>

<pre>  package My::Schema;
  use base qw/DBIx::Class::Schema/;</pre>

<p>In this class you load your result_source (&#34;table&#34;, &#34;model&#34;) classes, which we will define later, using the load_namespaces() method:</p>

<pre>  # load My::Schema::Result::* and their resultset classes
  __PACKAGE__-&#62;load_namespaces();</pre>

<p>By default this loads all the Result (Row) classes in the My::Schema::Result:: namespace, and also any resultset classes in the My::Schema::ResultSet:: namespace (if missing, the resultsets are defaulted to be DBIx::Class::ResultSet objects). You can change the result and resultset namespaces by using options to the <a href="../../../DBIx/Class/Schema.html#load_namespaces" class="podlinkpod"
>&#34;load_namespaces&#34; in DBIx::Class::Schema</a> call.</p>

<p>It is also possible to do the same things manually by calling <code>load_classes</code> for the Row classes and defining in those classes any required resultset classes.</p>

<p>Next, create each of the classes you want to load as specified above:</p>

<pre>  package My::Schema::Result::Album;
  use base qw/DBIx::Class::Core/;</pre>

<p>Load any additional components you may need with the load_components() method, and provide component configuration if required. For example, if you want automatic row ordering:</p>

<pre>  __PACKAGE__-&#62;load_components(qw/ Ordered /);
  __PACKAGE__-&#62;position_column(&#39;rank&#39;);</pre>

<p>Ordered will refer to a field called &#39;position&#39; unless otherwise directed. Here you are defining the ordering field to be named &#39;rank&#39;. (NOTE: Insert errors may occur if you use the Ordered component, but have not defined a position column or have a &#39;position&#39; field in your row.)</p>

<p>Set the table for your class:</p>

<pre>  __PACKAGE__-&#62;table(&#39;album&#39;);</pre>

<p>Add columns to your class:</p>

<pre>  __PACKAGE__-&#62;add_columns(qw/ albumid artist title rank /);</pre>

<p>Each column can also be set up with its own accessor, data_type and other pieces of information that it may be useful to have -- just pass <code>add_columns</code> a hash:</p>

<pre>  __PACKAGE__-&#62;add_columns(albumid =&#62;
                            { accessor  =&#62; &#39;album&#39;,
                              data_type =&#62; &#39;integer&#39;,
                              size      =&#62; 16,
                              is_nullable =&#62; 0,
                              is_auto_increment =&#62; 1,
                            },
                          artist =&#62;
                            { data_type =&#62; &#39;integer&#39;,
                              size      =&#62; 16,
                              is_nullable =&#62; 0,
                            },
                          title  =&#62;
                            { data_type =&#62; &#39;varchar&#39;,
                              size      =&#62; 256,
                              is_nullable =&#62; 0,
                            },
                          rank =&#62;
                            { data_type =&#62; &#39;integer&#39;,
                              size      =&#62; 16,
                              is_nullable =&#62; 0,
                              default_value =&#62; 0,
                            }
                         );</pre>

<p>DBIx::Class doesn&#39;t directly use most of this data yet, but various related modules such as <a href="../../../HTML/FormHandler/Model/DBIC.html" class="podlinkpod"
>HTML::FormHandler::Model::DBIC</a> make use of it. Also it allows you to create your database tables from your Schema, instead of the other way around. See <a href="../../../DBIx/Class/Schema.html#deploy" class="podlinkpod"
>&#34;deploy&#34; in DBIx::Class::Schema</a> for details.</p>

<p>See <a href="../../../DBIx/Class/ResultSource.html" class="podlinkpod"
>DBIx::Class::ResultSource</a> for more details of the possible column attributes.</p>

<p>Accessors are created for each column automatically, so My::Schema::Result::Album will have albumid() (or album(), when using the accessor), artist() and title() methods.</p>

<p>Define a primary key for your class:</p>

<pre>  __PACKAGE__-&#62;set_primary_key(&#39;albumid&#39;);</pre>

<p>If you have a multi-column primary key, just pass a list instead:</p>

<pre>  __PACKAGE__-&#62;set_primary_key( qw/ albumid artistid / );</pre>

<p>Define this class&#39; relationships with other classes using either <code>belongs_to</code> to describe a column which contains an ID of another Table, or <code>has_many</code> to make a predefined accessor for fetching objects that contain this Table&#39;s foreign key:</p>

<pre>  # in My::Schema::Result::Artist
  __PACKAGE__-&#62;has_many(&#39;albums&#39;, &#39;My::Schema::Result::Album&#39;, &#39;artist&#39;);</pre>

<p>See <a href="../../../DBIx/Class/Relationship.html" class="podlinkpod"
>DBIx::Class::Relationship</a> for more information about the various types of available relationships and how you can design your own.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Using_DBIx::Class::Schema::Loader"
>Using DBIx::Class::Schema::Loader</a></h2>

<p>This module (<a href="../../../DBIx/Class/Schema/Loader.html" class="podlinkpod"
>DBIx::Class::Schema::Loader</a>) is an external module, and not part of the <a href="../../../DBIx/Class.html" class="podlinkpod"
>DBIx::Class</a> distribution. It inspects your database, and automatically creates classes for all the tables in your schema.</p>

<p>The simplest way to use it is via the <a href="../../../dbicdump.html" class="podlinkpod"
>dbicdump</a> script from the <a href="../../../DBIx/Class/Schema/Loader.html" class="podlinkpod"
>DBIx::Class::Schema::Loader</a> distribution. For example:</p>

<pre>    $ dbicdump -o dump_directory=./lib \
        -o components=&#39;[&#34;InflateColumn::DateTime&#34;]&#39; \
        MyApp::Schema dbi:mysql:mydb user pass</pre>

<p>If you have a mixed-case database, use the <code>preserve_case</code> option, e.g.:</p>

<pre>    $ dbicdump -o dump_directory=./lib -o preserve_case=1 \
        -o components=&#39;[&#34;InflateColumn::DateTime&#34;]&#39; \
        MyApp::Schema dbi:mysql:mydb user pass</pre>

<p>If you are using <a href="../../../Catalyst.html" class="podlinkpod"
>Catalyst</a>, then you can use the helper that comes with <a href="../../../Catalyst/Model/DBIC/Schema.html" class="podlinkpod"
>Catalyst::Model::DBIC::Schema</a>:</p>

<pre>    $ script/myapp_create.pl model MyDB DBIC::Schema MyDB::Schema \
        create=static moniker_map=&#39;{ foo =&#62; &#34;FOO&#34; }&#39; dbi:SQLite:./myapp.db \
        on_connect_do=&#39;PRAGMA foreign_keys=ON&#39; quote_char=&#39;&#34;&#39;</pre>

<p>See <a href="../../../Catalyst/Helper/Model/DBIC/Schema.html" class="podlinkpod"
>Catalyst::Helper::Model::DBIC::Schema</a> for more information on this helper.</p>

<p>See the <a href="../../../DBIx/Class/Schema/Loader.html" class="podlinkpod"
>DBIx::Class::Schema::Loader</a> and <a href="../../../DBIx/Class/Schema/Loader/Base.html" class="podlinkpod"
>DBIx::Class::Schema::Loader::Base</a> documentation for more information on the many loader options.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Connecting"
>Connecting</a></h2>

<p>To connect to your Schema, you need to provide the connection details or a database handle.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Via_connection_details"
>Via connection details</a></h3>

<p>The arguments are the same as for <a href="../../../DBI.html#connect" class="podlinkpod"
>&#34;connect&#34; in DBI</a>:</p>

<pre>  my $schema = My::Schema-&#62;connect(&#39;dbi:SQLite:/home/me/myapp/my.db&#39;);</pre>

<p>You can create as many different schema instances as you need. So if you have a second database you want to access:</p>

<pre>  my $other_schema = My::Schema-&#62;connect( $dsn, $user, $password, $attrs );</pre>

<p>Note that <a href="../../../DBIx/Class/Schema.html" class="podlinkpod"
>DBIx::Class::Schema</a> does not cache connections for you. If you use multiple connections, you need to do this manually.</p>

<p>To execute some SQL statements on every connect you can add them as an option in a special fifth argument to connect:</p>

<pre>  my $another_schema = My::Schema-&#62;connect(
      $dsn,
      $user,
      $password,
      $attrs,
      { on_connect_do =&#62; \@on_connect_sql_statments }
  );</pre>

<p>See <a href="../../../DBIx/Class/Storage/DBI.html#connect_info" class="podlinkpod"
>&#34;connect_info&#34; in DBIx::Class::Storage::DBI</a> for more information about this and other special <code>connect</code>-time options.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Via_a_database_handle"
>Via a database handle</a></h3>

<p>The supplied coderef is expected to return a single connected database handle (e.g. a <a href="../../../DBI.html" class="podlinkpod"
>DBI</a> <code>$dbh</code>)</p>

<pre>  my $schema = My::Schema-&#62;connect (
    sub { Some::DBH::Factory-&#62;connect },
    \%extra_attrs,
  );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Basic_usage"
>Basic usage</a></h2>

<p>Once you&#39;ve defined the basic classes, either manually or using <a href="../../../DBIx/Class/Schema/Loader.html" class="podlinkpod"
>DBIx::Class::Schema::Loader</a>, you can start interacting with your database.</p>

<p>To access your database using your $schema object, you can fetch a <a href="../../../DBIx/Class/Manual/Glossary.html#ResultSet" class="podlinkpod"
>&#34;ResultSet&#34; in DBIx::Class::Manual::Glossary</a> representing each of your tables by calling the <code>resultset</code> method.</p>

<p>The simplest way to get a record is by primary key:</p>

<pre>  my $album = $schema-&#62;resultset(&#39;Album&#39;)-&#62;find(14);</pre>

<p>This will run a <code>SELECT</code> with <code>albumid = 14</code> in the <code>WHERE</code> clause, and return an instance of <code>My::Schema::Result::Album</code> that represents this row. Once you have that row, you can access and update columns:</p>

<pre>  $album-&#62;title(&#39;Physical Graffiti&#39;);
  my $title = $album-&#62;title; # $title holds &#39;Physical Graffiti&#39;</pre>

<p>If you prefer, you can use the <code>set_column</code> and <code>get_column</code> accessors instead:</p>

<pre>  $album-&#62;set_column(&#39;title&#39;, &#39;Presence&#39;);
  $title = $album-&#62;get_column(&#39;title&#39;);</pre>

<p>Just like with <a href="../../../Class/DBI.html" class="podlinkpod"
>Class::DBI</a>, you call <code>update</code> to save your changes to the database (by executing the actual <code>UPDATE</code> statement):</p>

<pre>  $album-&#62;update;</pre>

<p>If needed, you can throw away your local changes:</p>

<pre>  $album-&#62;discard_changes if $album-&#62;is_changed;</pre>

<p>As you can see, <code>is_changed</code> allows you to check if there are local changes to your object.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Adding_and_removing_rows"
>Adding and removing rows</a></h2>

<p>To create a new record in the database, you can use the <code>create</code> method. It returns an instance of <code>My::Schema::Result::Album</code> that can be used to access the data in the new record:</p>

<pre>  my $new_album = $schema-&#62;resultset(&#39;Album&#39;)-&#62;create({
    title  =&#62; &#39;Wish You Were Here&#39;,
    artist =&#62; &#39;Pink Floyd&#39;
  });</pre>

<p>Now you can add data to the new record:</p>

<pre>  $new_album-&#62;label(&#39;Capitol&#39;);
  $new_album-&#62;year(&#39;1975&#39;);
  $new_album-&#62;update;</pre>

<p>Likewise, you can remove it from the database:</p>

<pre>  $new_album-&#62;delete;</pre>

<p>You can also remove records without retrieving them first, by calling delete directly on a ResultSet object.</p>

<pre>  # Delete all of Falco&#39;s albums
  $schema-&#62;resultset(&#39;Album&#39;)-&#62;search({ artist =&#62; &#39;Falco&#39; })-&#62;delete;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Finding_your_objects"
>Finding your objects</a></h2>

<p><a href="../../../DBIx/Class.html" class="podlinkpod"
>DBIx::Class</a> provides a few different ways to retrieve data from your database. Here&#39;s one example:</p>

<pre>  # Find all of Santana&#39;s albums
  my $rs = $schema-&#62;resultset(&#39;Album&#39;)-&#62;search({ artist =&#62; &#39;Santana&#39; });</pre>

<p>In scalar context, as above, <code>search</code> returns a <a href="../../../DBIx/Class/ResultSet.html" class="podlinkpod"
>DBIx::Class::ResultSet</a> object. It can be used to peek at the first album returned by the database:</p>

<pre>  my $album = $rs-&#62;first;
  print $album-&#62;title;</pre>

<p>You can loop over the albums and update each one:</p>

<pre>  while (my $album = $rs-&#62;next) {
    print $album-&#62;artist . &#39; - &#39; . $album-&#62;title;
    $album-&#62;year(2001);
    $album-&#62;update;
  }</pre>

<p>Or, you can update them all at once:</p>

<pre>  $rs-&#62;update({ year =&#62; 2001 });</pre>

<p>In list context, the <code>search</code> method returns all of the matching rows:</p>

<pre>  # Fetch immediately all of Carlos Santana&#39;s albums
  my @albums = $schema-&#62;resultset(&#39;Album&#39;)-&#62;search(
    { artist =&#62; &#39;Carlos Santana&#39; }
  );
  foreach my $album (@albums) {
    print $album-&#62;artist . &#39; - &#39; . $album-&#62;title;
  }</pre>

<p>We also provide a handy shortcut for doing a <code>LIKE</code> search:</p>

<pre>  # Find albums whose artist starts with &#39;Jimi&#39;
  my $rs = $schema-&#62;resultset(&#39;Album&#39;)-&#62;search_like({ artist =&#62; &#39;Jimi%&#39; });</pre>

<p>Or you can provide your own <code>WHERE</code> clause:</p>

<pre>  # Find Peter Frampton albums from the year 1986
  my $where = &#39;artist = ? AND year = ?&#39;;
  my @bind  = ( &#39;Peter Frampton&#39;, 1986 );
  my $rs    = $schema-&#62;resultset(&#39;Album&#39;)-&#62;search_literal( $where, @bind );</pre>

<p>The preferred way to generate complex queries is to provide a <a href="../../../SQL/Abstract.html" class="podlinkpod"
>SQL::Abstract</a> construct to <code>search</code>:</p>

<pre>  my $rs = $schema-&#62;resultset(&#39;Album&#39;)-&#62;search({
    artist  =&#62; { &#39;!=&#39;, &#39;Janis Joplin&#39; },
    year    =&#62; { &#39;&#60;&#39; =&#62; 1980 },
    albumid =&#62; { &#39;-in&#39; =&#62; [ 1, 14, 15, 65, 43 ] }
  });</pre>

<p>This results in something like the following <code>WHERE</code> clause:</p>

<pre>  WHERE artist != &#39;Janis Joplin&#39;
    AND year &#60; 1980
    AND albumid IN (1, 14, 15, 65, 43)</pre>

<p>For more examples of complex queries, see <a href="../../../DBIx/Class/Manual/Cookbook.html" class="podlinkpod"
>DBIx::Class::Manual::Cookbook</a>.</p>

<p>The search can also be modified by passing another hash with attributes:</p>

<pre>  my @albums = My::Schema-&#62;resultset(&#39;Album&#39;)-&#62;search(
    { artist =&#62; &#39;Bob Marley&#39; },
    { rows =&#62; 2, order_by =&#62; { -desc =&#62; &#39;year&#39; } }
  );</pre>

<p><code>@albums</code> then holds the two most recent Bob Marley albums.</p>

<p>For more information on what you can do with a <a href="../../../DBIx/Class/ResultSet.html" class="podlinkpod"
>DBIx::Class::ResultSet</a>, see <a href="../../../DBIx/Class/ResultSet.html#METHODS" class="podlinkpod"
>&#34;METHODS&#34; in DBIx::Class::ResultSet</a>.</p>

<p>For a complete overview of the available attributes, see <a href="../../../DBIx/Class/ResultSet.html#ATTRIBUTES" class="podlinkpod"
>&#34;ATTRIBUTES&#34; in DBIx::Class::ResultSet</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NOTES"
>NOTES</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_Significance_and_Importance_of_Primary_Keys"
>The Significance and Importance of Primary Keys</a></h2>

<p>The concept of a <a href="../../../DBIx/Class/ResultSource.html#set_primary_key" class="podlinkpod"
>primary key</a> in DBIx::Class warrants special discussion. The formal definition (which somewhat resembles that of a classic RDBMS) is <i>a unique constraint that is least likely to change after initial row creation</i>. However this is where the similarity ends. Any time you call a CRUD operation on a row (e.g. <a href="../../../DBIx/Class/Row.html#delete" class="podlinkpod"
>delete</a>, <a href="../../../DBIx/Class/Row.html#update" class="podlinkpod"
>update</a>, <a href="../../../DBIx/Class/Row.html#discard_changes" class="podlinkpod"
>discard_changes</a>, etc.) DBIx::Class will use the values of of the <a href="../../../DBIx/Class/ResultSource.html#set_primary_key" class="podlinkpod"
>primary key</a> columns to populate the <code>WHERE</code> clause necessary to accomplish the operation. This is why it is important to declare a <a href="../../../DBIx/Class/ResultSource.html#set_primary_key" class="podlinkpod"
>primary key</a> on all your result sources <b>even if the underlying RDBMS does not have one</b>. In a pinch one can always declare each row identifiable by all its columns:</p>

<pre> __PACKAGE__-&#62;set_primary_key(__PACKAGE__-&#62;columns);</pre>

<p>Note that DBIx::Class is smart enough to store a copy of the PK values before any row-object changes take place, so even if you change the values of PK columns the <code>WHERE</code> clause will remain correct.</p>

<p>If you elect not to declare a <code>primary key</code>, DBIx::Class will behave correctly by throwing exceptions on any row operation that relies on unique identifiable rows. If you inherited datasets with multiple identical rows in them, you can still operate with such sets provided you only utilize <a href="../../../DBIx/Class/ResultSet.html" class="podlinkpod"
>DBIx::Class::ResultSet</a> CRUD methods: <a href="../../../DBIx/Class/ResultSet.html#search" class="podlinkpod"
>search</a>, <a href="../../../DBIx/Class/ResultSet.html#update" class="podlinkpod"
>update</a>, <a href="../../../DBIx/Class/ResultSet.html#delete" class="podlinkpod"
>delete</a></p>

<p>For example, the following would not work (assuming <code>People</code> does not have a declared PK):</p>

<pre> my $row = $schema-&#62;resultset(&#39;People&#39;)
                   -&#62;search({ last_name =&#62; &#39;Dantes&#39; })
                    -&#62;next;
 $row-&#62;update({ children =&#62; 2 }); # &#60;-- exception thrown because $row isn&#39;t
                                  # necessarily unique</pre>

<p>So instead the following should be done:</p>

<pre> $schema-&#62;resultset(&#39;People&#39;)
         -&#62;search({ last_name =&#62; &#39;Dantes&#39; })
          -&#62;update({ children =&#62; 2 }); # &#60;-- update&#39;s ALL Dantes to have children of 2</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Problems_on_RHEL5/CentOS5"
>Problems on RHEL5/CentOS5</a></h2>

<p>There used to be an issue with the system perl on Red Hat Enterprise Linux 5, some versions of Fedora and derived systems. Further information on this can be found in <a href="../../../DBIx/Class/Manual/Troubleshooting.html" class="podlinkpod"
>DBIx::Class::Manual::Troubleshooting</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<ul>
<li><a href="../../../DBIx/Class/Manual/Cookbook.html" class="podlinkpod"
>DBIx::Class::Manual::Cookbook</a></li>
</ul>
<p class="backlinkbottom"><b><a name="___bottom" href="../../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
