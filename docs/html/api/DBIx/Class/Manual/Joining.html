<html><head><title>DBIx::Class::Manual::Joining</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:15 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#WHAT_ARE_JOINS'>WHAT ARE JOINS</a>
  <li class='indexItem indexItem1'><a href='#DEFINING_JOINS_AND_RELATIONSHIPS'>DEFINING JOINS AND RELATIONSHIPS</a>
  <li class='indexItem indexItem1'><a href='#USING_JOINS'>USING JOINS</a>
  <li class='indexItem indexItem1'><a href='#FETCHING_RELATED_DATA'>FETCHING RELATED DATA</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Whole_related_objects'>Whole related objects</a>
    <li class='indexItem indexItem2'><a href='#Subset_of_related_fields'>Subset of related fields</a>
    <li class='indexItem indexItem2'><a href='#Incomplete_related_objects'>Incomplete related objects</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#COMPLEX_JOINS_AND_STUFF'>COMPLEX JOINS AND STUFF</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Across_multiple_relations'>Across multiple relations</a>
    <li class='indexItem indexItem2'><a href='#Table_aliases'>Table aliases</a>
    <li class='indexItem indexItem2'><a href='#Joining_to_the_same_table_twice'>Joining to the same table twice</a>
  </ul>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>DBIx::Class::Manual::Joining - Manual on joining tables with DBIx::Class</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This document should help you to use <a href="../../../DBIx/Class.html" class="podlinkpod"
>DBIx::Class</a> if you are trying to convert your normal SQL queries into DBIx::Class based queries,
if you use joins extensively (and also probably if you don&#39;t).</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="WHAT_ARE_JOINS"
>WHAT ARE JOINS</a></h1>

<p>If you ended up here and you don&#39;t actually know what joins are yet,
then you should likely try the <a href="../../../DBIx/Class/Manual/Intro.html" class="podlinkpod"
>DBIx::Class::Manual::Intro</a> instead.
Skip this part if you know what joins are..</p>

<p>But I&#39;ll explain anyway.
Assuming you have created your database in a more or less sensible way,
you will end up with several tables that contain <code>related</code> information.
For example,
you may have a table containing information about <code>CD</code>s,
containing the CD title and it&#39;s year of publication,
and another table containing all the <code>Track</code>s for the CDs,
one track per row.</p>

<p>When you wish to extract information about a particular CD and all it&#39;s tracks,
You can either fetch the CD row,
then make another query to fetch the tracks,
or you can use a join.
Compare:</p>

<pre>  SELECT ID, Title, Year FROM CD WHERE Title = &#39;Funky CD&#39;;
  # .. Extract the ID, which is 10
  SELECT Name, Artist FROM Tracks WHERE CDID = 10;

  SELECT cd.ID, cd.Title, cd.Year, tracks.Name, tracks.Artist FROM CD JOIN Tracks ON CD.ID = tracks.CDID WHERE cd.Title = &#39;Funky CD&#39;;</pre>

<p>So, joins are a way of extending simple select statements to include fields from other, related, tables. There are various types of joins, depending on which combination of the data you wish to retrieve, see MySQL&#39;s doc on JOINs: <a href="http://dev.mysql.com/doc/refman/5.0/en/join.html" class="podlinkurl"
>http://dev.mysql.com/doc/refman/5.0/en/join.html</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DEFINING_JOINS_AND_RELATIONSHIPS"
>DEFINING JOINS AND RELATIONSHIPS</a></h1>

<p>In <a href="../../../DBIx/Class.html" class="podlinkpod"
>DBIx::Class</a> each relationship between two tables needs to first be defined in the <a href="../../../DBIx/Class/Manual/Glossary.html#ResultSource" class="podlinkpod"
>ResultSource</a> for the table. If the relationship needs to be accessed in both directions (i.e. Fetch all tracks of a CD, and fetch the CD data for a Track), then it needs to be defined for both tables.</p>

<p>For the CDs/Tracks example, that means writing, in <code>MySchema::CD</code>:</p>

<pre>  MySchema::CD-&#62;has_many(&#39;tracks&#39;, &#39;MySchema::Tracks&#39;);</pre>

<p>And in <code>MySchema::Tracks</code>:</p>

<pre>  MySchema::Tracks-&#62;belongs_to(&#39;cd&#39;, &#39;MySchema::CD&#39;, &#39;CDID&#39;);</pre>

<p>There are several other types of relationships, they are more comprehensively described in <a href="../../../DBIx/Class/Relationship.html" class="podlinkpod"
>DBIx::Class::Relationship</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="USING_JOINS"
>USING JOINS</a></h1>

<p>Once you have defined all your relationships, using them in actual joins is fairly simple. The type of relationship that you chose e.g. <code>has_many</code>, already indicates what sort of join will be performed. <code>has_many</code> produces a <code>LEFT JOIN</code> for example, which will fetch all the rows on the left side, whether there are matching rows on the right (table being joined to), or not. You can force other types of joins in your relationship, see the <a href="../../../DBIx/Class/Relationship.html" class="podlinkpod"
>DBIx::Class::Relationship</a> docs.</p>

<p>When performing either a <a href="../../../DBIx/Class/ResultSet.html#search" class="podlinkpod"
>search</a> or a <a href="../../../DBIx/Class/ResultSet.html#find" class="podlinkpod"
>find</a> operation, you can specify which <code>relations</code> to also refine your results based on, using the <a href="../../../DBIx/Class/ResultSet.html#join" class="podlinkpod"
>join</a> attribute, like this:</p>

<pre>  $schema-&#62;resultset(&#39;CD&#39;)-&#62;search(
    { &#39;Title&#39; =&#62; &#39;Funky CD&#39;,
      &#39;tracks.Name&#39; =&#62; { like =&#62; &#39;T%&#39; }
    },
    { join      =&#62; &#39;tracks&#39;,
      order_by  =&#62; [&#39;tracks.id&#39;],
    }
  );</pre>

<p>If you don&#39;t recognise most of this syntax, you should probably go read <a href="../../../DBIx/Class/ResultSet.html#search" class="podlinkpod"
>&#34;search&#34; in DBIx::Class::ResultSet</a> and <a href="../../../DBIx/Class/ResultSet.html#ATTRIBUTES" class="podlinkpod"
>&#34;ATTRIBUTES&#34; in DBIx::Class::ResultSet</a>, but here&#39;s a quick break down:</p>

<p>The first argument to search is a hashref of the WHERE attributes, in this case a restriction on the Title column in the CD table, and a restriction on the name of the track in the Tracks table, but ONLY for tracks actually related to the chosen CD(s). The second argument is a hashref of attributes to the search, the results will be returned sorted by the <code>id</code> of the related tracks.</p>

<p>The special &#39;join&#39; attribute specifies which <code>relationships</code> to include in the query. The distinction between <code>relationships</code> and <code>tables</code> is important here, only the <code>relationship</code> names are valid.</p>

<p>This slightly nonsense example will produce SQL similar to:</p>

<pre>  SELECT cd.ID, cd.Title, cd.Year FROM CD cd JOIN Tracks tracks ON cd.ID = tracks.CDID WHERE cd.Title = &#39;Funky CD&#39; AND tracks.Name LIKE &#39;T%&#39; ORDER BY &#39;tracks.id&#39;;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FETCHING_RELATED_DATA"
>FETCHING RELATED DATA</a></h1>

<p>Another common use for joining to related tables, is to fetch the data from both tables in one query, preventing extra round-trips to the database. See the example above in <a href="#WHAT_ARE_JOINS" class="podlinkpod"
>&#34;WHAT ARE JOINS&#34;</a>.</p>

<p>Three techniques are described here. Of the three, only the <code>prefetch</code> technique will deal sanely with fetching related objects over a <code>has_many</code> relation. The others work fine for 1 to 1 type relationships.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Whole_related_objects"
>Whole related objects</a></h2>

<p>To fetch entire related objects, e.g. CDs and all Track data, use the &#39;prefetch&#39; attribute:</p>

<pre>  $schema-&#62;resultset(&#39;CD&#39;)-&#62;search(
    { &#39;Title&#39; =&#62; &#39;Funky CD&#39;,
    },
    { prefetch      =&#62; &#39;tracks&#39;,
      order_by  =&#62; [&#39;tracks.id&#39;],
    }
  );</pre>

<p>This will produce SQL similar to the following:</p>

<pre>  SELECT cd.ID, cd.Title, cd.Year, tracks.id, tracks.Name, tracks.Artist FROM CD JOIN Tracks ON CD.ID = tracks.CDID WHERE cd.Title = &#39;Funky CD&#39; ORDER BY &#39;tracks.id&#39;;</pre>

<p>The syntax of &#39;prefetch&#39; is the same as &#39;join&#39; and implies the joining, so there is no need to use both together.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Subset_of_related_fields"
>Subset of related fields</a></h2>

<p>To fetch a subset or the related fields, the &#39;+select&#39; and &#39;+as&#39; attributes can be used. For example, if the CD data is required and just the track name from the Tracks table:</p>

<pre>  $schema-&#62;resultset(&#39;CD&#39;)-&#62;search(
    { &#39;Title&#39; =&#62; &#39;Funky CD&#39;,
    },
    { join      =&#62; &#39;tracks&#39;,
      &#39;+select&#39; =&#62; [&#39;tracks.Name&#39;],
      &#39;+as&#39;     =&#62; [&#39;track_name&#39;],
      order_by  =&#62; [&#39;tracks.id&#39;],
    }
  );</pre>

<p>Which will produce the query:</p>

<pre>  SELECT cd.ID, cd.Title, cd.Year, tracks.Name FROM CD JOIN Tracks ON CD.ID = tracks.CDID WHERE cd.Title = &#39;Funky CD&#39; ORDER BY &#39;tracks.id&#39;;</pre>

<p>Note that the &#39;+as&#39; does not produce an SQL &#39;AS&#39; keyword in the output, see the <a href="../../../DBIx/Class/Manual/FAQ.html" class="podlinkpod"
>DBIx::Class::Manual::FAQ</a> for an explanation.</p>

<p>This type of column restriction has a downside, the resulting $row object will have no &#39;track_name&#39; accessor:</p>

<pre>  while(my $row = $search_rs-&#62;next) {
     print $row-&#62;track_name; ## ERROR
  }</pre>

<p>Instead <code>get_column</code> must be used:</p>

<pre>  while(my $row = $search_rs-&#62;next) {
     print $row-&#62;get_column(&#39;track_name&#39;); ## WORKS
  }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Incomplete_related_objects"
>Incomplete related objects</a></h2>

<p>In rare circumstances, you may also wish to fetch related data as incomplete objects. The usual reason to do is when the related table has a very large field you don&#39;t need for the current data output. This is better solved by storing that field in a separate table which you only join to when needed.</p>

<p>To fetch an incomplete related object, supply the dotted notation to the &#39;+as&#39; attribute:</p>

<pre>  $schema-&#62;resultset(&#39;CD&#39;)-&#62;search(
    { &#39;Title&#39; =&#62; &#39;Funky CD&#39;,
    },
    { join      =&#62; &#39;tracks&#39;,
      &#39;+select&#39; =&#62; [&#39;tracks.Name&#39;],
      &#39;+as&#39;     =&#62; [&#39;tracks.Name&#39;],
      order_by  =&#62; [&#39;tracks.id&#39;],
    }
  );</pre>

<p>Which will produce same query as above;</p>

<pre>  SELECT cd.ID, cd.Title, cd.Year, tracks.Name FROM CD JOIN Tracks ON CD.ID = tracks.CDID WHERE cd.Title = &#39;Funky CD&#39; ORDER BY &#39;tracks.id&#39;;</pre>

<p>Now you can access the result using the relationship accessor:</p>

<pre>  while(my $row = $search_rs-&#62;next) {
     print $row-&#62;tracks-&#62;name; ## WORKS
  }</pre>

<p>However, this will produce broken objects. If the tracks id column is not fetched, the object will not be usable for any operation other than reading its data. Use the <a href="#Whole_related_objects" class="podlinkpod"
>&#34;Whole related objects&#34;</a> method as much as possible to avoid confusion in your code later.</p>

<p>Broken means: Update will not work. Fetching other related objects will not work. Deleting the object will not work.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COMPLEX_JOINS_AND_STUFF"
>COMPLEX JOINS AND STUFF</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Across_multiple_relations"
>Across multiple relations</a></h2>

<p>For simplicity in the example above, the <code>Artist</code> was shown as a simple text field in the <code>Tracks</code> table, in reality, you&#39;ll want to have the artists in their own table as well, thus to fetch the complete set of data we&#39;ll need to join to the Artist table too.</p>

<p>In <code>MySchema::Tracks</code>:</p>

<pre>  MySchema::Tracks-&#62;belongs_to(&#39;artist&#39;, &#39;MySchema::Artist&#39;, &#39;ArtistID&#39;);</pre>

<p>The search:</p>

<pre>  $schema-&#62;resultset(&#39;CD&#39;)-&#62;search(
    { &#39;Title&#39; =&#62; &#39;Funky CD&#39; },
    { join      =&#62; { &#39;tracks&#39; =&#62; &#39;artist&#39; },
    }
  );</pre>

<p>Which is:</p>

<pre>  SELECT me.ID, me.Title, me.Year FROM CD me JOIN Tracks tracks ON CD.ID = tracks.CDID JOIN Artists artist ON tracks.ArtistID = artist.ID WHERE me.Title = &#39;Funky CD&#39;;</pre>

<p>To perform joins using relations of the tables you are joining to, use a hashref to indicate the join depth. This can theoretically go as deep as you like (warning: contrived examples!):</p>

<pre>  join =&#62; { room =&#62; { table =&#62; &#39;leg&#39; } }</pre>

<p>To join two relations at the same level, use an arrayref instead:</p>

<pre>  join =&#62; { room =&#62; [ &#39;chair&#39;, &#39;table&#39; ] }</pre>

<p>Or combine the two:</p>

<pre>  join =&#62; { room =&#62; [ &#39;chair&#39;, { table =&#62; &#39;leg&#39; } ]</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Table_aliases"
>Table aliases</a></h2>

<p>As an aside to all the discussion on joins, note that <a href="../../../DBIx/Class.html" class="podlinkpod"
>DBIx::Class</a> uses the <code>relation names</code> as table aliases. This is important when you need to add grouping or ordering to your queries:</p>

<pre>  $schema-&#62;resultset(&#39;CD&#39;)-&#62;search(
    { &#39;Title&#39; =&#62; &#39;Funky CD&#39; },
    { join      =&#62; { &#39;tracks&#39; =&#62; &#39;artist&#39; },
      order_by  =&#62; [ &#39;tracks.Name&#39;, &#39;artist.Artist&#39; ],
    }
  );

  SELECT me.ID, me.Title, me.Year FROM CD me JOIN Tracks tracks ON CD.ID = tracks.CDID JOIN Artists artist ON tracks.ArtistID = artist.ID WHERE me.Title = &#39;Funky CD&#39; ORDER BY tracks.Name, artist.Artist;</pre>

<p>This is essential if any of your tables have columns with the same names.</p>

<p>Note that the table of the resultsource the search was performed on, is always aliased to <code>me</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Joining_to_the_same_table_twice"
>Joining to the same table twice</a></h2>

<p>There is no magic to this, just do it. The table aliases will automatically be numbered:</p>

<pre>  join =&#62; [ &#39;room&#39;, &#39;room&#39; ]</pre>

<p>The aliases are: <code>room</code> and <code>room_2</code>.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
