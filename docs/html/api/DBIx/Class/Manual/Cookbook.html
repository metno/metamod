<html><head><title>DBIx::Class::Manual::Cookbook</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:15 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SEARCHING'>SEARCHING</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Paged_results'>Paged results</a>
    <li class='indexItem indexItem2'><a href='#Complex_WHERE_clauses'>Complex WHERE clauses</a>
    <li class='indexItem indexItem2'><a href='#Retrieve_one_and_only_one_row_from_a_resultset'>Retrieve one and only one row from a resultset</a>
    <li class='indexItem indexItem2'><a href='#Arbitrary_SQL_through_a_custom_ResultSource'>Arbitrary SQL through a custom ResultSource</a>
    <li class='indexItem indexItem2'><a href='#Using_specific_columns'>Using specific columns</a>
    <li class='indexItem indexItem2'><a href='#Using_database_functions_or_stored_procedures'>Using database functions or stored procedures</a>
    <li class='indexItem indexItem2'><a href='#SELECT_DISTINCT_with_multiple_columns'>SELECT DISTINCT with multiple columns</a>
    <li class='indexItem indexItem2'><a href='#SELECT_COUNT(DISTINCT_colname)'>SELECT COUNT(DISTINCT colname)</a>
    <li class='indexItem indexItem2'><a href='#Grouping_results'>Grouping results</a>
    <li class='indexItem indexItem2'><a href='#Subqueries'>Subqueries</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Support'>Support</a>
      <li class='indexItem indexItem3'><a href='#Correlated_subqueries'>Correlated subqueries</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Predefined_searches'>Predefined searches</a>
    <li class='indexItem indexItem2'><a href='#Using_SQL_functions_on_the_left_hand_side_of_a_comparison'>Using SQL functions on the left hand side of a comparison</a>
    <li class='indexItem indexItem2'><a href='#Software_Limits'>Software Limits</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#JOINS_AND_PREFETCHING'>JOINS AND PREFETCHING</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Using_joins_and_prefetch'>Using joins and prefetch</a>
    <li class='indexItem indexItem2'><a href='#Multiple_joins'>Multiple joins</a>
    <li class='indexItem indexItem2'><a href='#Multi-step_joins'>Multi-step joins</a>
    <li class='indexItem indexItem2'><a href='#Multi-step_and_multiple_joins'>Multi-step and multiple joins</a>
    <li class='indexItem indexItem2'><a href='#Multi-step_prefetch'>Multi-step prefetch</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#ROW-LEVEL_OPERATIONS'>ROW-LEVEL OPERATIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Retrieving_a_result_object%27s_Schema'>Retrieving a result object&#39;s Schema</a>
    <li class='indexItem indexItem2'><a href='#Getting_the_value_of_the_primary_key_for_the_last_database_insert'>Getting the value of the primary key for the last database insert</a>
    <li class='indexItem indexItem2'><a href='#Stringification'>Stringification</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Stringification_Example'>Stringification Example</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Want_to_know_if_find_or_create_found_or_created_a_row%3F'>Want to know if find_or_create found or created a row?</a>
    <li class='indexItem indexItem2'><a href='#Static_sub-classing_DBIx%3A%3AClass_result_classes'>Static sub-classing DBIx::Class result classes</a>
    <li class='indexItem indexItem2'><a href='#Dynamic_Sub-classing_DBIx%3A%3AClass_proxy_classes'>Dynamic Sub-classing DBIx::Class proxy classes</a>
    <li class='indexItem indexItem2'><a href='#Skip_result_object_creation_for_faster_results'>Skip result object creation for faster results</a>
    <li class='indexItem indexItem2'><a href='#Get_raw_data_for_blindingly_fast_results'>Get raw data for blindingly fast results</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#RESULTSET_OPERATIONS'>RESULTSET OPERATIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Getting_Schema_from_a_ResultSet'>Getting Schema from a ResultSet</a>
    <li class='indexItem indexItem2'><a href='#Getting_Columns_Of_Data'>Getting Columns Of Data</a>
    <li class='indexItem indexItem2'><a href='#Creating_a_result_set_from_a_set_of_rows'>Creating a result set from a set of rows</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#USING_RELATIONSHIPS'>USING RELATIONSHIPS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Create_a_new_row_in_a_related_table'>Create a new row in a related table</a>
    <li class='indexItem indexItem2'><a href='#Search_in_a_related_table'>Search in a related table</a>
    <li class='indexItem indexItem2'><a href='#Delete_data_in_a_related_table'>Delete data in a related table</a>
    <li class='indexItem indexItem2'><a href='#Ordering_a_relationship_result_set'>Ordering a relationship result set</a>
    <li class='indexItem indexItem2'><a href='#Filtering_a_relationship_result_set'>Filtering a relationship result set</a>
    <li class='indexItem indexItem2'><a href='#Many-to-many_relationship_bridges'>Many-to-many relationship bridges</a>
    <li class='indexItem indexItem2'><a href='#Relationships_across_DB_schemas'>Relationships across DB schemas</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#TRANSACTIONS'>TRANSACTIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Transactions_with_txn_do'>Transactions with txn_do</a>
    <li class='indexItem indexItem2'><a href='#Nested_transactions_and_auto-savepoints'>Nested transactions and auto-savepoints</a>
    <li class='indexItem indexItem2'><a href='#Simple_Transactions_with_DBIx%3A%3AClass%3A%3AStorage%3A%3ATxnScopeGuard'>Simple Transactions with DBIx::Class::Storage::TxnScopeGuard</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SQL'>SQL</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Creating_Schemas_From_An_Existing_Database'>Creating Schemas From An Existing Database</a>
    <li class='indexItem indexItem2'><a href='#Creating_DDL_SQL'>Creating DDL SQL</a>
    <li class='indexItem indexItem2'><a href='#Select_from_dual'>Select from dual</a>
    <li class='indexItem indexItem2'><a href='#Adding_Indexes_And_Functions_To_Your_SQL'>Adding Indexes And Functions To Your SQL</a>
    <li class='indexItem indexItem2'><a href='#Schema_versioning'>Schema versioning</a>
    <li class='indexItem indexItem2'><a href='#Setting_quoting_for_the_generated_SQL'>Setting quoting for the generated SQL</a>
    <li class='indexItem indexItem2'><a href='#Working_with_PostgreSQL_array_types'>Working with PostgreSQL array types</a>
    <li class='indexItem indexItem2'><a href='#Formatting_DateTime_objects_in_queries'>Formatting DateTime objects in queries</a>
    <li class='indexItem indexItem2'><a href='#Using_Unicode'>Using Unicode</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#MySQL'>MySQL</a>
      <li class='indexItem indexItem3'><a href='#Oracle'>Oracle</a>
      <li class='indexItem indexItem3'><a href='#PostgreSQL'>PostgreSQL</a>
      <li class='indexItem indexItem3'><a href='#SQLite'>SQLite</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#BOOTSTRAPPING%2FMIGRATING'>BOOTSTRAPPING/MIGRATING</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Easy_migration_from_class-based_to_schema-based_setup'>Easy migration from class-based to schema-based setup</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#OVERLOADING_METHODS'>OVERLOADING METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Setting_default_values_for_a_row'>Setting default values for a row</a>
    <li class='indexItem indexItem2'><a href='#Changing_one_field_whenever_another_changes'>Changing one field whenever another changes</a>
    <li class='indexItem indexItem2'><a href='#Automatically_creating_related_objects'>Automatically creating related objects</a>
    <li class='indexItem indexItem2'><a href='#Wrapping%2Foverloading_a_column_accessor'>Wrapping/overloading a column accessor</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#DEBUGGING_AND_PROFILING'>DEBUGGING AND PROFILING</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#DBIx%3A%3AClass_objects_with_Data%3A%3ADumper'>DBIx::Class objects with Data::Dumper</a>
    <li class='indexItem indexItem2'><a href='#Profiling'>Profiling</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#IMPROVING_PERFORMANCE'>IMPROVING PERFORMANCE</a>
  <li class='indexItem indexItem1'><a href='#STARTUP_SPEED'>STARTUP SPEED</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Statically_Define_Your_Schema'>Statically Define Your Schema</a>
    <li class='indexItem indexItem2'><a href='#Move_Common_Startup_into_a_Base_Class'>Move Common Startup into a Base Class</a>
    <li class='indexItem indexItem2'><a href='#Explicitly_List_Schema_Result_Classes'>Explicitly List Schema Result Classes</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#MEMORY_USAGE'>MEMORY USAGE</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Cached_statements'>Cached statements</a>
  </ul>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>DBIx::Class::Manual::Cookbook - Miscellaneous recipes</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEARCHING"
>SEARCHING</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Paged_results"
>Paged results</a></h2>

<p>When you expect a large number of results,
you can ask <a href="../../../DBIx/Class.html" class="podlinkpod"
>DBIx::Class</a> for a paged resultset,
which will fetch only a defined number of records at a time:</p>

<pre>  my $rs = $schema-&#62;resultset(&#39;Artist&#39;)-&#62;search(
    undef,
    {
      page =&#62; 1,  # page to return (defaults to 1)
      rows =&#62; 10, # number of results per page
    },
  );

  return $rs-&#62;all(); # all records for page 1

  return $rs-&#62;page(2); # records for page 2</pre>

<p>You can get a <a href="../../../Data/Page.html" class="podlinkpod"
>Data::Page</a> object for the resultset (suitable for use in e.g. a template) using the <code>pager</code> method:</p>

<pre>  return $rs-&#62;pager();</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Complex_WHERE_clauses"
>Complex WHERE clauses</a></h2>

<p>Sometimes you need to formulate a query using specific operators:</p>

<pre>  my @albums = $schema-&#62;resultset(&#39;Album&#39;)-&#62;search({
    artist =&#62; { &#39;like&#39;, &#39;%Lamb%&#39; },
    title  =&#62; { &#39;like&#39;, &#39;%Fear of Fours%&#39; },
  });</pre>

<p>This results in something like the following <code>WHERE</code> clause:</p>

<pre>  WHERE artist LIKE ? AND title LIKE ?</pre>

<p>And the following bind values for the placeholders: <code>&#39;%Lamb%&#39;</code>, <code>&#39;%Fear of Fours%&#39;</code>.</p>

<p>Other queries might require slightly more complex logic:</p>

<pre>  my @albums = $schema-&#62;resultset(&#39;Album&#39;)-&#62;search({
    -or =&#62; [
      -and =&#62; [
        artist =&#62; { &#39;like&#39;, &#39;%Smashing Pumpkins%&#39; },
        title  =&#62; &#39;Siamese Dream&#39;,
      ],
      artist =&#62; &#39;Starchildren&#39;,
    ],
  });</pre>

<p>This results in the following <code>WHERE</code> clause:</p>

<pre>  WHERE ( artist LIKE &#39;%Smashing Pumpkins%&#39; AND title = &#39;Siamese Dream&#39; )
    OR artist = &#39;Starchildren&#39;</pre>

<p>For more information on generating complex queries, see <a href="../../../SQL/Abstract.html#WHERE_CLAUSES" class="podlinkpod"
>&#34;WHERE CLAUSES&#34; in SQL::Abstract</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Retrieve_one_and_only_one_row_from_a_resultset"
>Retrieve one and only one row from a resultset</a></h2>

<p>Sometimes you need only the first &#34;top&#34; row of a resultset. While this can be easily done with <a href="../../../DBIx/Class/ResultSet.html#first" class="podlinkpod"
>$rs-&#62;first</a>, it is suboptimal, as a full blown cursor for the resultset will be created and then immediately destroyed after fetching the first row object. <a href="../../../DBIx/Class/ResultSet.html#single" class="podlinkpod"
>$rs-&#62;single</a> is designed specifically for this case - it will grab the first returned result without even instantiating a cursor.</p>

<p>Before replacing all your calls to <code>first()</code> with <code>single()</code> please observe the following CAVEATS:</p>

<ul>
<li>While single() takes a search condition just like search() does, it does _not_ accept search attributes. However one can always chain a single() to a search():
<pre>  my $top_cd = $cd_rs-&#62;search({}, { order_by =&#62; &#39;rating&#39; })-&#62;single;</pre>
</li>

<li>Since single() is the engine behind find(), it is designed to fetch a single row per database query. Thus a warning will be issued when the underlying SELECT returns more than one row. Sometimes however this usage is valid: i.e. we have an arbitrary number of cd&#39;s but only one of them is at the top of the charts at any given time. If you know what you are doing, you can silence the warning by explicitly limiting the resultset size:
<pre>  my $top_cd = $cd_rs-&#62;search ({}, { order_by =&#62; &#39;rating&#39;, rows =&#62; 1 })-&#62;single;</pre>
</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Arbitrary_SQL_through_a_custom_ResultSource"
>Arbitrary SQL through a custom ResultSource</a></h2>

<p>Sometimes you have to run arbitrary SQL because your query is too complex (e.g. it contains Unions, Sub-Selects, Stored Procedures, etc.) or has to be optimized for your database in a special way, but you still want to get the results as a <a href="../../../DBIx/Class/ResultSet.html" class="podlinkpod"
>DBIx::Class::ResultSet</a>.</p>

<p>This is accomplished by defining a <a href="../../../DBIx/Class/ResultSource/View.html" class="podlinkpod"
>ResultSource::View</a> for your query, almost like you would define a regular ResultSource.</p>

<pre>  package My::Schema::Result::UserFriendsComplex;
  use strict;
  use warnings;
  use base qw/DBIx::Class::Core/;

  __PACKAGE__-&#62;table_class(&#39;DBIx::Class::ResultSource::View&#39;);

  # For the time being this is necessary even for virtual views
  __PACKAGE__-&#62;table($view_name);

  #
  # -&#62;add_columns, etc.
  #

  # do not attempt to deploy() this view
  __PACKAGE__-&#62;result_source_instance-&#62;is_virtual(1);

  __PACKAGE__-&#62;result_source_instance-&#62;view_definition(q[
    SELECT u.* FROM user u
    INNER JOIN user_friends f ON u.id = f.user_id
    WHERE f.friend_user_id = ?
    UNION
    SELECT u.* FROM user u
    INNER JOIN user_friends f ON u.id = f.friend_user_id
    WHERE f.user_id = ?
  ]);</pre>

<p>Next, you can execute your complex query using bind parameters like this:</p>

<pre>  my $friends = $schema-&#62;resultset( &#39;UserFriendsComplex&#39; )-&#62;search( {},
    {
      bind  =&#62; [ 12345, 12345 ]
    }
  );</pre>

<p>... and you&#39;ll get back a perfect <a href="../../../DBIx/Class/ResultSet.html" class="podlinkpod"
>DBIx::Class::ResultSet</a> (except, of course, that you cannot modify the rows it contains, e.g. cannot call <a href="#update" class="podlinkpod"
>&#34;update&#34;</a>, <a href="#delete" class="podlinkpod"
>&#34;delete&#34;</a>, ... on it).</p>

<p>Note that you cannot have bind parameters unless is_virtual is set to true.</p>

<ul>
<li>NOTE
<p>If you&#39;re using the old deprecated <code>$rsrc_instance-&#62;name(\&#39;( SELECT ...&#39;)</code> method for custom SQL execution, you are highly encouraged to update your code to use a virtual view as above. If you do not want to change your code, and just want to suppress the deprecation warning when you call <a href="../../../DBIx/Class/Schema.html#deploy" class="podlinkpod"
>&#34;deploy&#34; in DBIx::Class::Schema</a>, add this line to your source definition, so that <code>deploy</code> will exclude this &#34;table&#34;:</p>

<pre>  sub sqlt_deploy_hook { $_[1]-&#62;schema-&#62;drop_table ($_[1]) }</pre>
</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Using_specific_columns"
>Using specific columns</a></h2>

<p>When you only want specific columns from a table, you can use <code>columns</code> to specify which ones you need. This is useful to avoid loading columns with large amounts of data that you aren&#39;t about to use anyway:</p>

<pre>  my $rs = $schema-&#62;resultset(&#39;Artist&#39;)-&#62;search(
    undef,
    {
      columns =&#62; [qw/ name /]
    }
  );

  # Equivalent SQL:
  # SELECT artist.name FROM artist</pre>

<p>This is a shortcut for <code>select</code> and <code>as</code>, see below. <code>columns</code> cannot be used together with <code>select</code> and <code>as</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Using_database_functions_or_stored_procedures"
>Using database functions or stored procedures</a></h2>

<p>The combination of <code>select</code> and <code>as</code> can be used to return the result of a database function or stored procedure as a column value. You use <code>select</code> to specify the source for your column value (e.g. a column name, function, or stored procedure name). You then use <code>as</code> to set the column name you will use to access the returned value:</p>

<pre>  my $rs = $schema-&#62;resultset(&#39;Artist&#39;)-&#62;search(
    {},
    {
      select =&#62; [ &#39;name&#39;, { LENGTH =&#62; &#39;name&#39; } ],
      as     =&#62; [qw/ name name_length /],
    }
  );

  # Equivalent SQL:
  # SELECT name name, LENGTH( name )
  # FROM artist</pre>

<p>Note that the <code>as</code> attribute <b>has absolutely nothing to do</b> with the SQL syntax <code> SELECT foo AS bar </code> (see the documentation in <a href="../../../DBIx/Class/ResultSet.html#ATTRIBUTES" class="podlinkpod"
>&#34;ATTRIBUTES&#34; in DBIx::Class::ResultSet</a>). You can control the <code>AS</code> part of the generated SQL via the <code>-as</code> field attribute as follows:</p>

<pre>  my $rs = $schema-&#62;resultset(&#39;Artist&#39;)-&#62;search(
    {},
    {
      join =&#62; &#39;cds&#39;,
      distinct =&#62; 1,
      &#39;+select&#39; =&#62; [ { count =&#62; &#39;cds.cdid&#39;, -as =&#62; &#39;amount_of_cds&#39; } ],
      &#39;+as&#39; =&#62; [qw/num_cds/],
      order_by =&#62; { -desc =&#62; &#39;amount_of_cds&#39; },
    }
  );

  # Equivalent SQL
  # SELECT me.artistid, me.name, me.rank, me.charfield, COUNT( cds.cdid ) AS amount_of_cds
  #   FROM artist me LEFT JOIN cd cds ON cds.artist = me.artistid
  # GROUP BY me.artistid, me.name, me.rank, me.charfield
  # ORDER BY amount_of_cds DESC</pre>

<p>If your alias exists as a column in your base class (i.e. it was added with <a href="../../../DBIx/Class/ResultSource.html#add_columns" class="podlinkpod"
>add_columns</a>), you just access it as normal. Our <code>Artist</code> class has a <code>name</code> column, so we just use the <code>name</code> accessor:</p>

<pre>  my $artist = $rs-&#62;first();
  my $name = $artist-&#62;name();</pre>

<p>If on the other hand the alias does not correspond to an existing column, you have to fetch the value using the <code>get_column</code> accessor:</p>

<pre>  my $name_length = $artist-&#62;get_column(&#39;name_length&#39;);</pre>

<p>If you don&#39;t like using <code>get_column</code>, you can always create an accessor for any of your aliases using either of these:</p>

<pre>  # Define accessor manually:
  sub name_length { shift-&#62;get_column(&#39;name_length&#39;); }

  # Or use DBIx::Class::AccessorGroup:
  __PACKAGE__-&#62;mk_group_accessors(&#39;column&#39; =&#62; &#39;name_length&#39;);</pre>

<p>See also <a href="#Using_SQL_functions_on_the_left_hand_side_of_a_comparison" class="podlinkpod"
>&#34;Using SQL functions on the left hand side of a comparison&#34;</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="SELECT_DISTINCT_with_multiple_columns"
>SELECT DISTINCT with multiple columns</a></h2>

<pre>  my $rs = $schema-&#62;resultset(&#39;Artist&#39;)-&#62;search(
    {},
    {
      columns =&#62; [ qw/artist_id name rank/ ],
      distinct =&#62; 1
    }
  );

  my $rs = $schema-&#62;resultset(&#39;Artist&#39;)-&#62;search(
    {},
    {
      columns =&#62; [ qw/artist_id name rank/ ],
      group_by =&#62; [ qw/artist_id name rank/ ],
    }
  );

  # Equivalent SQL:
  # SELECT me.artist_id, me.name, me.rank
  # FROM artist me
  # GROUP BY artist_id, name, rank</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="SELECT_COUNT(DISTINCT_colname)"
>SELECT COUNT(DISTINCT colname)</a></h2>

<pre>  my $rs = $schema-&#62;resultset(&#39;Artist&#39;)-&#62;search(
    {},
    {
      columns =&#62; [ qw/name/ ],
      distinct =&#62; 1
    }
  );

  my $rs = $schema-&#62;resultset(&#39;Artist&#39;)-&#62;search(
    {},
    {
      columns =&#62; [ qw/name/ ],
      group_by =&#62; [ qw/name/ ],
    }
  );

  my $count = $rs-&#62;count;

  # Equivalent SQL:
  # SELECT COUNT( * ) FROM (SELECT me.name FROM artist me GROUP BY me.name) me:</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Grouping_results"
>Grouping results</a></h2>

<p><a href="../../../DBIx/Class.html" class="podlinkpod"
>DBIx::Class</a> supports <code>GROUP BY</code> as follows:</p>

<pre>  my $rs = $schema-&#62;resultset(&#39;Artist&#39;)-&#62;search(
    {},
    {
      join     =&#62; [qw/ cds /],
      select   =&#62; [ &#39;name&#39;, { count =&#62; &#39;cds.id&#39; } ],
      as       =&#62; [qw/ name cd_count /],
      group_by =&#62; [qw/ name /]
    }
  );

  # Equivalent SQL:
  # SELECT name, COUNT( cd.id ) FROM artist
  # LEFT JOIN cd ON artist.id = cd.artist
  # GROUP BY name</pre>

<p>Please see <a href="../../../DBIx/Class/ResultSet.html#ATTRIBUTES" class="podlinkpod"
>&#34;ATTRIBUTES&#34; in DBIx::Class::ResultSet</a> documentation if you are in any way unsure about the use of the attributes above (<code> join </code>, <code> select </code>, <code> as </code> and <code> group_by </code>).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Subqueries"
>Subqueries</a></h2>

<p>You can write subqueries relatively easily in DBIC.</p>

<pre>  my $inside_rs = $schema-&#62;resultset(&#39;Artist&#39;)-&#62;search({
    name =&#62; [ &#39;Billy Joel&#39;, &#39;Brittany Spears&#39; ],
  });

  my $rs = $schema-&#62;resultset(&#39;CD&#39;)-&#62;search({
    artist_id =&#62; { -in =&#62; $inside_rs-&#62;get_column(&#39;id&#39;)-&#62;as_query },
  });</pre>

<p>The usual operators ( &#39;=&#39;, &#39;!=&#39;, -in, -not_in, etc.) are supported.</p>

<p><b>NOTE</b>: You have to explicitly use &#39;=&#39; when doing an equality comparison. The following will <b>not</b> work:</p>

<pre>  my $rs = $schema-&#62;resultset(&#39;CD&#39;)-&#62;search({
    artist_id =&#62; $inside_rs-&#62;get_column(&#39;id&#39;)-&#62;as_query,  # does NOT work
  });</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Support"
>Support</a></h3>

<p>Subqueries are supported in the where clause (first hashref), and in the from, select, and +select attributes.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Correlated_subqueries"
>Correlated subqueries</a></h3>

<pre>  my $cdrs = $schema-&#62;resultset(&#39;CD&#39;);
  my $rs = $cdrs-&#62;search({
    year =&#62; {
      &#39;=&#39; =&#62; $cdrs-&#62;search(
        { artist_id =&#62; { -ident =&#62; &#39;me.artist_id&#39; } },
        { alias =&#62; &#39;sub_query&#39; }
      )-&#62;get_column(&#39;year&#39;)-&#62;max_rs-&#62;as_query,
    },
  });</pre>

<p>That creates the following SQL:</p>

<pre>  SELECT me.cdid, me.artist, me.title, me.year, me.genreid, me.single_track
    FROM cd me
  WHERE year = (
    SELECT MAX(sub_query.year)
      FROM cd sub_query
    WHERE artist_id = me.artist_id
  )</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Predefined_searches"
>Predefined searches</a></h2>

<p>You can define frequently used searches as methods by subclassing <a href="../../../DBIx/Class/ResultSet.html" class="podlinkpod"
>DBIx::Class::ResultSet</a>:</p>

<pre>  package My::DBIC::ResultSet::CD;
  use strict;
  use warnings;
  use base &#39;DBIx::Class::ResultSet&#39;;

  sub search_cds_ordered {
      my ($self) = @_;

      return $self-&#62;search(
          {},
          { order_by =&#62; &#39;name DESC&#39; },
      );
  }

  1;</pre>

<p>If you&#39;re using <a href="../../../DBIx/Class/Schema.html#load_namespaces" class="podlinkpod"
>&#34;load_namespaces&#34; in DBIx::Class::Schema</a>, simply place the file into the <code>ResultSet</code> directory next to your <code>Result</code> directory, and it will be automatically loaded.</p>

<p>If however you are still using <a href="../../../DBIx/Class/Schema.html#load_classes" class="podlinkpod"
>&#34;load_classes&#34; in DBIx::Class::Schema</a>, first tell DBIx::Class to create an instance of the ResultSet class for you, in your My::DBIC::Schema::CD class:</p>

<pre>  # class definition as normal
  use base &#39;DBIx::Class::Core&#39;;
  __PACKAGE__-&#62;table(&#39;cd&#39;);

  # tell DBIC to use the custom ResultSet class
  __PACKAGE__-&#62;resultset_class(&#39;My::DBIC::ResultSet::CD&#39;);</pre>

<p>Note that <code>resultset_class</code> must be called after <code>load_components</code> and <code>table</code>, or you will get errors about missing methods.</p>

<p>Then call your new method in your code:</p>

<pre>   my $ordered_cds = $schema-&#62;resultset(&#39;CD&#39;)-&#62;search_cds_ordered();</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Using_SQL_functions_on_the_left_hand_side_of_a_comparison"
>Using SQL functions on the left hand side of a comparison</a></h2>

<p>Using SQL functions on the left hand side of a comparison is generally not a good idea since it requires a scan of the entire table. (Unless your RDBMS supports indexes on expressions - including return values of functions - and you create an index on the return value of the function in question.) However, it can be accomplished with <code>DBIx::Class</code> when necessary by resorting to literal SQL:</p>

<pre>  $rs-&#62;search(
    \[ &#39;YEAR(date_of_birth) = ?&#39;, 1979 ]
  );

  # Equivalent SQL:
  # SELECT * FROM employee WHERE YEAR(date_of_birth) = ?</pre>

<p>To include the function as part of a larger search, use the &#39;-and&#39; keyword to collect the search conditions:</p>

<pre>  $rs-&#62;search({ -and =&#62; [
    name =&#62; &#39;Bob&#39;,
    \[ &#39;YEAR(date_of_birth) = ?&#39;, 1979 ]
  ]});

  # Equivalent SQL:
  # SELECT * FROM employee WHERE name = ? AND YEAR(date_of_birth) = ?</pre>

<p>Note: the syntax for specifying the bind value&#39;s datatype and value is explained in <a href="../../../DBIx/Class/ResultSet.html#DBIC_BIND_VALUES" class="podlinkpod"
>&#34;DBIC BIND VALUES&#34; in DBIx::Class::ResultSet</a>.</p>

<p>See also <a href="../../../SQL/Abstract.html#Literal_SQL_with_placeholders_and_bind_values_(subqueries)" class="podlinkpod"
>&#34;Literal SQL with placeholders and bind values (subqueries)&#34; in SQL::Abstract</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Software_Limits"
>Software Limits</a></h2>

<p>When your RDBMS does not have a working SQL limit mechanism (e.g. Sybase ASE) and <a href="../../../SQL/Abstract/Limit.html#GenericSubQ" class="podlinkpod"
>GenericSubQ</a> is either too slow or does not work at all, you can try the <a href="../../../DBIx/Class/ResultSet.html#software_limit" class="podlinkpod"
>software_limit</a> <a href="../../../DBIx/Class/ResultSet.html" class="podlinkpod"
>DBIx::Class::ResultSet</a> attribute, which skips over records to simulate limits in the Perl layer.</p>

<p>For example:</p>

<pre>  my $paged_rs = $rs-&#62;search({}, {
    rows =&#62; 25,
    page =&#62; 3,
    order_by =&#62; [ &#39;me.last_name&#39; ],
    software_limit =&#62; 1,
  });</pre>

<p>You can set it as a default for your schema by placing the following in your <code>Schema.pm</code>:</p>

<pre>  __PACKAGE__-&#62;default_resultset_attributes({ software_limit =&#62; 1 });</pre>

<p><b>WARNING:</b> If you are dealing with large resultsets and your <a href="../../../DBI.html" class="podlinkpod"
>DBI</a> or ODBC/ADO driver does not have proper cursor support (i.e. it loads the whole resultset into memory) then this feature will be extremely slow and use huge amounts of memory at best, and may cause your process to run out of memory and cause instability on your server at worst, beware!</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="JOINS_AND_PREFETCHING"
>JOINS AND PREFETCHING</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Using_joins_and_prefetch"
>Using joins and prefetch</a></h2>

<p>You can use the <code>join</code> attribute to allow searching on, or sorting your results by, one or more columns in a related table.</p>

<p>This requires that you have defined the <a href="../../../DBIx/Class/Relationship.html" class="podlinkpod"
>DBIx::Class::Relationship</a>. For example :</p>

<pre>  My::Schema::CD-&#62;has_many( artists =&#62; &#39;My::Schema::Artist&#39;, &#39;artist_id&#39;);</pre>

<p>To return all CDs matching a particular artist name, you specify the name of the relationship (&#39;artists&#39;):</p>

<pre>  my $rs = $schema-&#62;resultset(&#39;CD&#39;)-&#62;search(
    {
      &#39;artists.name&#39; =&#62; &#39;Bob Marley&#39;
    },
    {
      join =&#62; &#39;artists&#39;, # join the artist table
    }
  );

  # Equivalent SQL:
  # SELECT cd.* FROM cd
  # JOIN artist ON cd.artist = artist.id
  # WHERE artist.name = &#39;Bob Marley&#39;</pre>

<p>In that example both the join, and the condition use the relationship name rather than the table name (see <a href="../../../DBIx/Class/Manual/Joining.html" class="podlinkpod"
>DBIx::Class::Manual::Joining</a> for more details on aliasing ).</p>

<p>If required, you can now sort on any column in the related tables by including it in your <code>order_by</code> attribute, (again using the aliased relation name rather than table name) :</p>

<pre>  my $rs = $schema-&#62;resultset(&#39;CD&#39;)-&#62;search(
    {
      &#39;artists.name&#39; =&#62; &#39;Bob Marley&#39;
    },
    {
      join     =&#62; &#39;artists&#39;,
      order_by =&#62; [qw/ artists.name /]
    }
  );

  # Equivalent SQL:
  # SELECT cd.* FROM cd
  # JOIN artist ON cd.artist = artist.id
  # WHERE artist.name = &#39;Bob Marley&#39;
  # ORDER BY artist.name</pre>

<p>Note that the <code>join</code> attribute should only be used when you need to search or sort using columns in a related table. Joining related tables when you only need columns from the main table will make performance worse!</p>

<p>Now let&#39;s say you want to display a list of CDs, each with the name of the artist. The following will work fine:</p>

<pre>  while (my $cd = $rs-&#62;next) {
    print &#34;CD: &#34; . $cd-&#62;title . &#34;, Artist: &#34; . $cd-&#62;artist-&#62;name;
  }</pre>

<p>There is a problem however. We have searched both the <code>cd</code> and <code>artist</code> tables in our main query, but we have only returned data from the <code>cd</code> table. To get the artist name for any of the CD objects returned, <a href="../../../DBIx/Class.html" class="podlinkpod"
>DBIx::Class</a> will go back to the database:</p>

<pre>  SELECT artist.* FROM artist WHERE artist.id = ?</pre>

<p>A statement like the one above will run for each and every CD returned by our main query. Five CDs, five extra queries. A hundred CDs, one hundred extra queries!</p>

<p>Thankfully, <a href="../../../DBIx/Class.html" class="podlinkpod"
>DBIx::Class</a> has a <code>prefetch</code> attribute to solve this problem. This allows you to fetch results from related tables in advance:</p>

<pre>  my $rs = $schema-&#62;resultset(&#39;CD&#39;)-&#62;search(
    {
      &#39;artists.name&#39; =&#62; &#39;Bob Marley&#39;
    },
    {
      join     =&#62; &#39;artists&#39;,
      order_by =&#62; [qw/ artists.name /],
      prefetch =&#62; &#39;artists&#39; # return artist data too!
    }
  );

  # Equivalent SQL (note SELECT from both &#34;cd&#34; and &#34;artist&#34;):
  # SELECT cd.*, artist.* FROM cd
  # JOIN artist ON cd.artist = artist.id
  # WHERE artist.name = &#39;Bob Marley&#39;
  # ORDER BY artist.name</pre>

<p>The code to print the CD list remains the same:</p>

<pre>  while (my $cd = $rs-&#62;next) {
    print &#34;CD: &#34; . $cd-&#62;title . &#34;, Artist: &#34; . $cd-&#62;artist-&#62;name;
  }</pre>

<p><a href="../../../DBIx/Class.html" class="podlinkpod"
>DBIx::Class</a> has now prefetched all matching data from the <code>artist</code> table, so no additional SQL statements are executed. You now have a much more efficient query.</p>

<p>Also note that <code>prefetch</code> should only be used when you know you will definitely use data from a related table. Pre-fetching related tables when you only need columns from the main table will make performance worse!</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Multiple_joins"
>Multiple joins</a></h2>

<p>In the examples above, the <code>join</code> attribute was a scalar. If you pass an array reference instead, you can join to multiple tables. In this example, we want to limit the search further, using <code>LinerNotes</code>:</p>

<pre>  # Relationships defined elsewhere:
  # CD-&#62;belongs_to(&#39;artist&#39; =&#62; &#39;Artist&#39;);
  # CD-&#62;has_one(&#39;liner_notes&#39; =&#62; &#39;LinerNotes&#39;, &#39;cd&#39;);
  my $rs = $schema-&#62;resultset(&#39;CD&#39;)-&#62;search(
    {
      &#39;artist.name&#39; =&#62; &#39;Bob Marley&#39;
      &#39;liner_notes.notes&#39; =&#62; { &#39;like&#39;, &#39;%some text%&#39; },
    },
    {
      join     =&#62; [qw/ artist liner_notes /],
      order_by =&#62; [qw/ artist.name /],
    }
  );

  # Equivalent SQL:
  # SELECT cd.*, artist.*, liner_notes.* FROM cd
  # JOIN artist ON cd.artist = artist.id
  # JOIN liner_notes ON cd.id = liner_notes.cd
  # WHERE artist.name = &#39;Bob Marley&#39; AND liner_notes.notes LIKE &#39;%some text%&#39;
  # ORDER BY artist.name</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Multi-step_joins"
>Multi-step joins</a></h2>

<p>Sometimes you want to join more than one relationship deep. In this example, we want to find all <code>Artist</code> objects who have <code>CD</code>s whose <code>LinerNotes</code> contain a specific string:</p>

<pre>  # Relationships defined elsewhere:
  # Artist-&#62;has_many(&#39;cds&#39; =&#62; &#39;CD&#39;, &#39;artist&#39;);
  # CD-&#62;has_one(&#39;liner_notes&#39; =&#62; &#39;LinerNotes&#39;, &#39;cd&#39;);

  my $rs = $schema-&#62;resultset(&#39;Artist&#39;)-&#62;search(
    {
      &#39;liner_notes.notes&#39; =&#62; { &#39;like&#39;, &#39;%some text%&#39; },
    },
    {
      join =&#62; {
        &#39;cds&#39; =&#62; &#39;liner_notes&#39;
      }
    }
  );

  # Equivalent SQL:
  # SELECT artist.* FROM artist
  # LEFT JOIN cd ON artist.id = cd.artist
  # LEFT JOIN liner_notes ON cd.id = liner_notes.cd
  # WHERE liner_notes.notes LIKE &#39;%some text%&#39;</pre>

<p>Joins can be nested to an arbitrary level. So if we decide later that we want to reduce the number of Artists returned based on who wrote the liner notes:</p>

<pre>  # Relationship defined elsewhere:
  # LinerNotes-&#62;belongs_to(&#39;author&#39; =&#62; &#39;Person&#39;);

  my $rs = $schema-&#62;resultset(&#39;Artist&#39;)-&#62;search(
    {
      &#39;liner_notes.notes&#39; =&#62; { &#39;like&#39;, &#39;%some text%&#39; },
      &#39;author.name&#39; =&#62; &#39;A. Writer&#39;
    },
    {
      join =&#62; {
        &#39;cds&#39; =&#62; {
          &#39;liner_notes&#39; =&#62; &#39;author&#39;
        }
      }
    }
  );

  # Equivalent SQL:
  # SELECT artist.* FROM artist
  # LEFT JOIN cd ON artist.id = cd.artist
  # LEFT JOIN liner_notes ON cd.id = liner_notes.cd
  # LEFT JOIN author ON author.id = liner_notes.author
  # WHERE liner_notes.notes LIKE &#39;%some text%&#39;
  # AND author.name = &#39;A. Writer&#39;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Multi-step_and_multiple_joins"
>Multi-step and multiple joins</a></h2>

<p>With various combinations of array and hash references, you can join tables in any combination you desire. For example, to join Artist to CD and Concert, and join CD to LinerNotes:</p>

<pre>  # Relationships defined elsewhere:
  # Artist-&#62;has_many(&#39;concerts&#39; =&#62; &#39;Concert&#39;, &#39;artist&#39;);

  my $rs = $schema-&#62;resultset(&#39;Artist&#39;)-&#62;search(
    { },
    {
      join =&#62; [
        {
          cds =&#62; &#39;liner_notes&#39;
        },
        &#39;concerts&#39;
      ],
    }
  );

  # Equivalent SQL:
  # SELECT artist.* FROM artist
  # LEFT JOIN cd ON artist.id = cd.artist
  # LEFT JOIN liner_notes ON cd.id = liner_notes.cd
  # LEFT JOIN concert ON artist.id = concert.artist</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Multi-step_prefetch"
>Multi-step prefetch</a></h2>

<p><code>prefetch</code> can be nested more than one relationship deep using the same syntax as a multi-step join:</p>

<pre>  my $rs = $schema-&#62;resultset(&#39;Tag&#39;)-&#62;search(
    {},
    {
      prefetch =&#62; {
        cd =&#62; &#39;artist&#39;
      }
    }
  );

  # Equivalent SQL:
  # SELECT tag.*, cd.*, artist.* FROM tag
  # JOIN cd ON tag.cd = cd.id
  # JOIN artist ON cd.artist = artist.id</pre>

<p>Now accessing our <code>cd</code> and <code>artist</code> relationships does not need additional SQL statements:</p>

<pre>  my $tag = $rs-&#62;first;
  print $tag-&#62;cd-&#62;artist-&#62;name;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ROW-LEVEL_OPERATIONS"
>ROW-LEVEL OPERATIONS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Retrieving_a_result_object&#39;s_Schema"
>Retrieving a result object&#39;s Schema</a></h2>

<p>It is possible to get a Schema object from a result object like so:</p>

<pre>  my $schema = $cd-&#62;result_source-&#62;schema;
  # use the schema as normal:
  my $artist_rs = $schema-&#62;resultset(&#39;Artist&#39;);</pre>

<p>This can be useful when you don&#39;t want to pass around a Schema object to every method.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Getting_the_value_of_the_primary_key_for_the_last_database_insert"
>Getting the value of the primary key for the last database insert</a></h2>

<p>AKA getting last_insert_id</p>

<p>Thanks to the core component PK::Auto, this is straightforward:</p>

<pre>  my $foo = $rs-&#62;create(\%blah);
  # do more stuff
  my $id = $foo-&#62;id; # foo-&#62;my_primary_key_field will also work.</pre>

<p>If you are not using autoincrementing primary keys, this will probably not work, but then you already know the value of the last primary key anyway.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Stringification"
>Stringification</a></h2>

<p>Employ the standard stringification technique by using the <a href="../../../overload.html" class="podlinkpod"
>overload</a> module.</p>

<p>To make an object stringify itself as a single column, use something like this (replace <code>name</code> with the column/method of your choice):</p>

<pre>  use overload &#39;&#34;&#34;&#39; =&#62; sub { shift-&#62;name}, fallback =&#62; 1;</pre>

<p>For more complex stringification, you can use an anonymous subroutine:</p>

<pre>  use overload &#39;&#34;&#34;&#39; =&#62; sub { $_[0]-&#62;name . &#34;, &#34; .
                             $_[0]-&#62;address }, fallback =&#62; 1;</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Stringification_Example"
>Stringification Example</a></h3>

<p>Suppose we have two tables: <code>Product</code> and <code>Category</code>. The table specifications are:</p>

<pre>  Product(id, Description, category)
  Category(id, Description)</pre>

<p><code>category</code> is a foreign key into the Category table.</p>

<p>If you have a Product object <code>$obj</code> and write something like</p>

<pre>  print $obj-&#62;category</pre>

<p>things will not work as expected.</p>

<p>To obtain, for example, the category description, you should add this method to the class defining the Category table:</p>

<pre>  use overload &#34;&#34; =&#62; sub {
      my $self = shift;

      return $self-&#62;Description;
  }, fallback =&#62; 1;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Want_to_know_if_find_or_create_found_or_created_a_row?"
>Want to know if find_or_create found or created a row?</a></h2>

<p>Just use <code>find_or_new</code> instead, then check <code>in_storage</code>:</p>

<pre>  my $obj = $rs-&#62;find_or_new({ blah =&#62; &#39;blarg&#39; });
  unless ($obj-&#62;in_storage) {
    $obj-&#62;insert;
    # do whatever else you wanted if it was a new row
  }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Static_sub-classing_DBIx::Class_result_classes"
>Static sub-classing DBIx::Class result classes</a></h2>

<p>AKA adding additional relationships/methods/etc. to a model for a specific usage of the (shared) model.</p>

<p><b>Schema definition</b></p>

<pre>    package My::App::Schema;

    use base &#39;DBIx::Class::Schema&#39;;

    # load subclassed classes from My::App::Schema::Result/ResultSet
    __PACKAGE__-&#62;load_namespaces;

    # load classes from shared model
    load_classes({
        &#39;My::Shared::Model::Result&#39; =&#62; [qw/
            Foo
            Bar
        /]});

    1;</pre>

<p><b>Result-Subclass definition</b></p>

<pre>    package My::App::Schema::Result::Baz;

    use strict;
    use warnings;
    use base &#39;My::Shared::Model::Result::Baz&#39;;

    # WARNING: Make sure you call table() again in your subclass,
    # otherwise DBIx::Class::ResultSourceProxy::Table will not be called
    # and the class name is not correctly registered as a source
    __PACKAGE__-&#62;table(&#39;baz&#39;);

    sub additional_method {
        return &#34;I&#39;m an additional method only needed by this app&#34;;
    }

    1;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Dynamic_Sub-classing_DBIx::Class_proxy_classes"
>Dynamic Sub-classing DBIx::Class proxy classes</a></h2>

<p>AKA multi-class object inflation from one table</p>

<p><a href="../../../DBIx/Class.html" class="podlinkpod"
>DBIx::Class</a> classes are proxy classes, therefore some different techniques need to be employed for more than basic subclassing. In this example we have a single user table that carries a boolean bit for admin. We would like like to give the admin users objects (<a href="../../../DBIx/Class/Row.html" class="podlinkpod"
>DBIx::Class::Row</a>) the same methods as a regular user but also special admin only methods. It doesn&#39;t make sense to create two separate proxy-class files for this. We would be copying all the user methods into the Admin class. There is a cleaner way to accomplish this.</p>

<p>Overriding the <code>inflate_result</code> method within the User proxy-class gives us the effect we want. This method is called by <a href="../../../DBIx/Class/ResultSet.html" class="podlinkpod"
>DBIx::Class::ResultSet</a> when inflating a result from storage. So we grab the object being returned, inspect the values we are looking for, bless it if it&#39;s an admin object, and then return it. See the example below:</p>

<p><b>Schema Definition</b></p>

<pre>    package My::Schema;

    use base qw/DBIx::Class::Schema/;

    __PACKAGE__-&#62;load_namespaces;

    1;</pre>

<p><b>Proxy-Class definitions</b></p>

<pre>    package My::Schema::Result::User;

    use strict;
    use warnings;
    use base qw/DBIx::Class::Core/;

    ### Define what our admin class is, for ensure_class_loaded()
    my $admin_class = __PACKAGE__ . &#39;::Admin&#39;;

    __PACKAGE__-&#62;table(&#39;users&#39;);

    __PACKAGE__-&#62;add_columns(qw/user_id   email    password
                                firstname lastname active
                                admin/);

    __PACKAGE__-&#62;set_primary_key(&#39;user_id&#39;);

    sub inflate_result {
        my $self = shift;
        my $ret = $self-&#62;next::method(@_);
        if( $ret-&#62;admin ) {### If this is an admin, rebless for extra functions
            $self-&#62;ensure_class_loaded( $admin_class );
            bless $ret, $admin_class;
        }
        return $ret;
    }

    sub hello {
        print &#34;I am a regular user.\n&#34;;
        return ;
    }

    1;


    package My::Schema::Result::User::Admin;

    use strict;
    use warnings;
    use base qw/My::Schema::Result::User/;

    # This line is important
    __PACKAGE__-&#62;table(&#39;users&#39;);

    sub hello
    {
        print &#34;I am an admin.\n&#34;;
        return;
    }

    sub do_admin_stuff
    {
        print &#34;I am doing admin stuff\n&#34;;
        return ;
    }

    1;</pre>

<p><b>Test File</b> test.pl</p>

<pre>    use warnings;
    use strict;
    use My::Schema;

    my $user_data = { email    =&#62; &#39;someguy@place.com&#39;,
                      password =&#62; &#39;pass1&#39;,
                      admin    =&#62; 0 };

    my $admin_data = { email    =&#62; &#39;someadmin@adminplace.com&#39;,
                       password =&#62; &#39;pass2&#39;,
                       admin    =&#62; 1 };

    my $schema = My::Schema-&#62;connection(&#39;dbi:Pg:dbname=test&#39;);

    $schema-&#62;resultset(&#39;User&#39;)-&#62;create( $user_data );
    $schema-&#62;resultset(&#39;User&#39;)-&#62;create( $admin_data );

    ### Now we search for them
    my $user = $schema-&#62;resultset(&#39;User&#39;)-&#62;single( $user_data );
    my $admin = $schema-&#62;resultset(&#39;User&#39;)-&#62;single( $admin_data );

    print ref $user, &#34;\n&#34;;
    print ref $admin, &#34;\n&#34;;

    print $user-&#62;password , &#34;\n&#34;; # pass1
    print $admin-&#62;password , &#34;\n&#34;;# pass2; inherited from User
    print $user-&#62;hello , &#34;\n&#34;;# I am a regular user.
    print $admin-&#62;hello, &#34;\n&#34;;# I am an admin.

    ### The statement below will NOT print
    print &#34;I can do admin stuff\n&#34; if $user-&#62;can(&#39;do_admin_stuff&#39;);
    ### The statement below will print
    print &#34;I can do admin stuff\n&#34; if $admin-&#62;can(&#39;do_admin_stuff&#39;);</pre>

<p>Alternatively you can use <a href="../../../DBIx/Class/DynamicSubclass.html" class="podlinkpod"
>DBIx::Class::DynamicSubclass</a> that implements exactly the above functionality.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Skip_result_object_creation_for_faster_results"
>Skip result object creation for faster results</a></h2>

<p>DBIx::Class is not built for speed, it&#39;s built for convenience and ease of use, but sometimes you just need to get the data, and skip the fancy objects.</p>

<p>To do this simply use <a href="../../../DBIx/Class/ResultClass/HashRefInflator.html" class="podlinkpod"
>DBIx::Class::ResultClass::HashRefInflator</a>.</p>

<pre> my $rs = $schema-&#62;resultset(&#39;CD&#39;);

 $rs-&#62;result_class(&#39;DBIx::Class::ResultClass::HashRefInflator&#39;);

 my $hash_ref = $rs-&#62;find(1);</pre>

<p>Wasn&#39;t that easy?</p>

<p>Beware, changing the Result class using <a href="../../../DBIx/Class/ResultSet.html#result_class" class="podlinkpod"
>&#34;result_class&#34; in DBIx::Class::ResultSet</a> will replace any existing class completely including any special components loaded using load_components, eg <a href="../../../DBIx/Class/InflateColumn/DateTime.html" class="podlinkpod"
>DBIx::Class::InflateColumn::DateTime</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Get_raw_data_for_blindingly_fast_results"
>Get raw data for blindingly fast results</a></h2>

<p>If the <a href="../../../DBIx/Class/ResultClass/HashRefInflator.html" class="podlinkpod"
>HashRefInflator</a> solution above is not fast enough for you, you can use a DBIx::Class to return values exactly as they come out of the database with none of the convenience methods wrapped round them.</p>

<p>This is used like so:</p>

<pre>  my $cursor = $rs-&#62;cursor
  while (my @vals = $cursor-&#62;next) {
      # use $val[0..n] here
  }</pre>

<p>You will need to map the array offsets to particular columns (you can use the <a href="../../../DBIx/Class/ResultSet.html#select" class="podlinkpod"
>&#34;select&#34; in DBIx::Class::ResultSet</a> attribute of <a href="../../../DBIx/Class/ResultSet.html#search" class="podlinkpod"
>&#34;search&#34; in DBIx::Class::ResultSet</a> to force ordering).</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="RESULTSET_OPERATIONS"
>RESULTSET OPERATIONS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Getting_Schema_from_a_ResultSet"
>Getting Schema from a ResultSet</a></h2>

<p>To get the <a href="../../../DBIx/Class/Schema.html" class="podlinkpod"
>DBIx::Class::Schema</a> object from a ResultSet, do the following:</p>

<pre> $rs-&#62;result_source-&#62;schema</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Getting_Columns_Of_Data"
>Getting Columns Of Data</a></h2>

<p>AKA Aggregating Data</p>

<p>If you want to find the sum of a particular column there are several ways, the obvious one is to use search:</p>

<pre>  my $rs = $schema-&#62;resultset(&#39;Items&#39;)-&#62;search(
    {},
    {
       select =&#62; [ { sum =&#62; &#39;Cost&#39; } ],
       as     =&#62; [ &#39;total_cost&#39; ], # remember this &#39;as&#39; is for DBIx::Class::ResultSet not SQL
    }
  );
  my $tc = $rs-&#62;first-&#62;get_column(&#39;total_cost&#39;);</pre>

<p>Or, you can use the <a href="../../../DBIx/Class/ResultSetColumn.html" class="podlinkpod"
>DBIx::Class::ResultSetColumn</a>, which gets returned when you ask the <code>ResultSet</code> for a column using <code>get_column</code>:</p>

<pre>  my $cost = $schema-&#62;resultset(&#39;Items&#39;)-&#62;get_column(&#39;Cost&#39;);
  my $tc = $cost-&#62;sum;</pre>

<p>With this you can also do:</p>

<pre>  my $minvalue = $cost-&#62;min;
  my $maxvalue = $cost-&#62;max;</pre>

<p>Or just iterate through the values of this column only:</p>

<pre>  while ( my $c = $cost-&#62;next ) {
    print $c;
  }

  foreach my $c ($cost-&#62;all) {
    print $c;
  }</pre>

<p><code>ResultSetColumn</code> only has a limited number of built-in functions. If you need one that it doesn&#39;t have, then you can use the <code>func</code> method instead:</p>

<pre>  my $avg = $cost-&#62;func(&#39;AVERAGE&#39;);</pre>

<p>This will cause the following SQL statement to be run:</p>

<pre>  SELECT AVERAGE(Cost) FROM Items me</pre>

<p>Which will of course only work if your database supports this function. See <a href="../../../DBIx/Class/ResultSetColumn.html" class="podlinkpod"
>DBIx::Class::ResultSetColumn</a> for more documentation.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Creating_a_result_set_from_a_set_of_rows"
>Creating a result set from a set of rows</a></h2>

<p>Sometimes you have a (set of) result objects that you want to put into a resultset without the need to hit the DB again. You can do that by using the <a href="../../../DBIx/Class/Resultset.html#set_cache" class="podlinkpod"
>set_cache</a> method:</p>

<pre> my @uploadable_groups;
 while (my $group = $groups-&#62;next) {
   if ($group-&#62;can_upload($self)) {
     push @uploadable_groups, $group;
   }
 }
 my $new_rs = $self-&#62;result_source-&#62;resultset;
 $new_rs-&#62;set_cache(\@uploadable_groups);
 return $new_rs;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="USING_RELATIONSHIPS"
>USING RELATIONSHIPS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Create_a_new_row_in_a_related_table"
>Create a new row in a related table</a></h2>

<pre>  my $author = $book-&#62;create_related(&#39;author&#39;, { name =&#62; &#39;Fred&#39;});</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Search_in_a_related_table"
>Search in a related table</a></h2>

<p>Only searches for books named &#39;Titanic&#39; by the author in $author.</p>

<pre>  my $books_rs = $author-&#62;search_related(&#39;books&#39;, { name =&#62; &#39;Titanic&#39; });</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Delete_data_in_a_related_table"
>Delete data in a related table</a></h2>

<p>Deletes only the book named Titanic by the author in $author.</p>

<pre>  $author-&#62;delete_related(&#39;books&#39;, { name =&#62; &#39;Titanic&#39; });</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Ordering_a_relationship_result_set"
>Ordering a relationship result set</a></h2>

<p>If you always want a relation to be ordered, you can specify this when you create the relationship.</p>

<p>To order <code>$book-&#62;pages</code> by descending page_number, create the relation as follows:</p>

<pre>  __PACKAGE__-&#62;has_many(&#39;pages&#39; =&#62; &#39;Page&#39;, &#39;book&#39;, { order_by =&#62; { -desc =&#62; &#39;page_number&#39;} } );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Filtering_a_relationship_result_set"
>Filtering a relationship result set</a></h2>

<p>If you want to get a filtered result set, you can just add add to $attr as follows:</p>

<pre> __PACKAGE__-&#62;has_many(&#39;pages&#39; =&#62; &#39;Page&#39;, &#39;book&#39;, { where =&#62; { scrap =&#62; 0 } } );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Many-to-many_relationship_bridges"
>Many-to-many relationship bridges</a></h2>

<p>This is straightforward using <a href="../../../DBIx/Class/Relationship.html#many_to_many" class="podlinkpod"
>ManyToMany</a>:</p>

<pre>  package My::User;
  use base &#39;DBIx::Class::Core&#39;;
  __PACKAGE__-&#62;table(&#39;user&#39;);
  __PACKAGE__-&#62;add_columns(qw/id name/);
  __PACKAGE__-&#62;set_primary_key(&#39;id&#39;);
  __PACKAGE__-&#62;has_many(&#39;user_address&#39; =&#62; &#39;My::UserAddress&#39;, &#39;user&#39;);
  __PACKAGE__-&#62;many_to_many(&#39;addresses&#39; =&#62; &#39;user_address&#39;, &#39;address&#39;);

  package My::UserAddress;
  use base &#39;DBIx::Class::Core&#39;;
  __PACKAGE__-&#62;table(&#39;user_address&#39;);
  __PACKAGE__-&#62;add_columns(qw/user address/);
  __PACKAGE__-&#62;set_primary_key(qw/user address/);
  __PACKAGE__-&#62;belongs_to(&#39;user&#39; =&#62; &#39;My::User&#39;);
  __PACKAGE__-&#62;belongs_to(&#39;address&#39; =&#62; &#39;My::Address&#39;);

  package My::Address;
  use base &#39;DBIx::Class::Core&#39;;
  __PACKAGE__-&#62;table(&#39;address&#39;);
  __PACKAGE__-&#62;add_columns(qw/id street town area_code country/);
  __PACKAGE__-&#62;set_primary_key(&#39;id&#39;);
  __PACKAGE__-&#62;has_many(&#39;user_address&#39; =&#62; &#39;My::UserAddress&#39;, &#39;address&#39;);
  __PACKAGE__-&#62;many_to_many(&#39;users&#39; =&#62; &#39;user_address&#39;, &#39;user&#39;);

  $rs = $user-&#62;addresses(); # get all addresses for a user
  $rs = $address-&#62;users(); # get all users for an address

  my $address = $user-&#62;add_to_addresses(    # returns a My::Address instance,
                                            # NOT a My::UserAddress instance!
    {
      country =&#62; &#39;United Kingdom&#39;,
      area_code =&#62; &#39;XYZ&#39;,
      town =&#62; &#39;London&#39;,
      street =&#62; &#39;Sesame&#39;,
    }
  );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Relationships_across_DB_schemas"
>Relationships across DB schemas</a></h2>

<p>Mapping relationships across <a href="../../../DBIx/Class/Manual/Glossary.html#DB_schema" class="podlinkpod"
>DB schemas</a> is easy as long as the schemas themselves are all accessible via the same DBI connection. In most cases, this means that they are on the same database host as each other and your connecting database user has the proper permissions to them.</p>

<p>To accomplish this one only needs to specify the DB schema name in the table declaration, like so...</p>

<pre>  package MyDatabase::Main::Artist;
  use base qw/DBIx::Class::Core/;

  __PACKAGE__-&#62;table(&#39;database1.artist&#39;); # will use &#34;database1.artist&#34; in FROM clause

  __PACKAGE__-&#62;add_columns(qw/ artist_id name /);
  __PACKAGE__-&#62;set_primary_key(&#39;artist_id&#39;);
  __PACKAGE__-&#62;has_many(&#39;cds&#39; =&#62; &#39;MyDatabase::Main::Cd&#39;);

  1;</pre>

<p>Whatever string you specify there will be used to build the &#34;FROM&#34; clause in SQL queries.</p>

<p>The big drawback to this is you now have DB schema names hardcoded in your class files. This becomes especially troublesome if you have multiple instances of your application to support a change lifecycle (e.g. DEV, TEST, PROD) and the DB schemas are named based on the environment (e.g. database1_dev).</p>

<p>However, one can dynamically &#34;map&#34; to the proper DB schema by overriding the <a href="../../../DBIx/Class/Schama.html#connection" class="podlinkpod"
>connection</a> method in your Schema class and building a renaming facility, like so:</p>

<pre>  package MyDatabase::Schema;
  use Moose;

  extends &#39;DBIx::Class::Schema&#39;;

  around connection =&#62; sub {
    my ( $inner, $self, $dsn, $username, $pass, $attr ) = ( shift, @_ );

    my $postfix = delete $attr-&#62;{schema_name_postfix};

    $inner-&#62;(@_);

    if ( $postfix ) {
        $self-&#62;append_db_name($postfix);
    }
  };

  sub append_db_name {
    my ( $self, $postfix ) = @_;

    my @sources_with_db
        = grep
            { $_-&#62;name =~ /^\w+\./mx }
            map
                { $self-&#62;source($_) }
                $self-&#62;sources;

    foreach my $source (@sources_with_db) {
        my $name = $source-&#62;name;
        $name =~ s{^(\w+)\.}{${1}${postfix}\.}mx;

        $source-&#62;name($name);
    }
  }

  1;</pre>

<p>By overridding the <a href="../../../DBIx/Class/Schama.html#connection" class="podlinkpod"
>connection</a> method and extracting a custom option from the provided \%attr hashref one can then simply iterate over all the Schema&#39;s ResultSources, renaming them as needed.</p>

<p>To use this facility, simply add or modify the \%attr hashref that is passed to <a href="../../../DBIx/Class/Schama.html#connect" class="podlinkpod"
>connection</a>, as follows:</p>

<pre>  my $schema
    = MyDatabase::Schema-&#62;connect(
      $dsn,
      $user,
      $pass,
      {
        schema_name_postfix =&#62; &#39;_dev&#39;
        # ... Other options as desired ...
      })</pre>

<p>Obviously, one could accomplish even more advanced mapping via a hash map or a callback routine.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TRANSACTIONS"
>TRANSACTIONS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Transactions_with_txn_do"
>Transactions with txn_do</a></h2>

<p>As of version 0.04001, there is improved transaction support in <a href="../../../DBIx/Class/Storage.html" class="podlinkpod"
>DBIx::Class::Storage</a> and <a href="../../../DBIx/Class/Schema.html" class="podlinkpod"
>DBIx::Class::Schema</a>. Here is an example of the recommended way to use it:</p>

<pre>  my $genus = $schema-&#62;resultset(&#39;Genus&#39;)-&#62;find(12);

  my $coderef2 = sub {
    $genus-&#62;extinct(1);
    $genus-&#62;update;
  };

  my $coderef1 = sub {
    $genus-&#62;add_to_species({ name =&#62; &#39;troglodyte&#39; });
    $genus-&#62;wings(2);
    $genus-&#62;update;
    $schema-&#62;txn_do($coderef2); # Can have a nested transaction. Only the outer will actualy commit
    return $genus-&#62;species;
  };

  use Try::Tiny;
  my $rs;
  try {
    $rs = $schema-&#62;txn_do($coderef1);
  } catch {
    # Transaction failed
    die &#34;the sky is falling!&#34;           #
      if ($_ =~ /Rollback failed/);     # Rollback failed

    deal_with_failed_transaction();
  };</pre>

<p>Note: by default <code>txn_do</code> will re-run the coderef one more time if an error occurs due to client disconnection (e.g. the server is bounced). You need to make sure that your coderef can be invoked multiple times without terrible side effects.</p>

<p>Nested transactions will work as expected. That is, only the outermost transaction will actually issue a commit to the $dbh, and a rollback at any level of any transaction will cause the entire nested transaction to fail.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Nested_transactions_and_auto-savepoints"
>Nested transactions and auto-savepoints</a></h2>

<p>If savepoints are supported by your RDBMS, it is possible to achieve true nested transactions with minimal effort. To enable auto-savepoints via nested transactions, supply the <code>auto_savepoint = 1</code> connection attribute.</p>

<p>Here is an example of true nested transactions. In the example, we start a big task which will create several rows. Generation of data for each row is a fragile operation and might fail. If we fail creating something, depending on the type of failure, we want to abort the whole task, or only skip the failed row.</p>

<pre>  my $schema = MySchema-&#62;connect(&#34;dbi:Pg:dbname=my_db&#34;);

  # Start a transaction. Every database change from here on will only be
  # committed into the database if the try block succeeds.
  use Try::Tiny;
  my $exception;
  try {
    $schema-&#62;txn_do(sub {
      # SQL: BEGIN WORK;

      my $job = $schema-&#62;resultset(&#39;Job&#39;)-&#62;create({ name=&#62; &#39;big job&#39; });
      # SQL: INSERT INTO job ( name) VALUES ( &#39;big job&#39; );

      for (1..10) {

        # Start a nested transaction, which in fact sets a savepoint.
        try {
          $schema-&#62;txn_do(sub {
            # SQL: SAVEPOINT savepoint_0;

            my $thing = $schema-&#62;resultset(&#39;Thing&#39;)-&#62;create({ job=&#62;$job-&#62;id });
            # SQL: INSERT INTO thing ( job) VALUES ( 1 );

            if (rand &#62; 0.8) {
              # This will generate an error, thus setting $@

              $thing-&#62;update({force_fail=&#62;&#39;foo&#39;});
              # SQL: UPDATE thing SET force_fail = &#39;foo&#39;
              #      WHERE ( id = 42 );
            }
          });
        } catch {
          # SQL: ROLLBACK TO SAVEPOINT savepoint_0;

          # There was an error while creating a $thing. Depending on the error
          # we want to abort the whole transaction, or only rollback the
          # changes related to the creation of this $thing

          # Abort the whole job
          if ($_ =~ /horrible_problem/) {
            print &#34;something horrible happend, aborting job!&#34;;
            die $_;                # rethrow error
          }

          # Ignore this $thing, report the error, and continue with the
          # next $thing
          print &#34;Cannot create thing: $_&#34;;
        }
        # There was no error, so save all changes since the last
        # savepoint.

        # SQL: RELEASE SAVEPOINT savepoint_0;
      }
    });
  } catch {
    $exception = $_;
  };

  if ($exception) {
    # There was an error while handling the $job. Rollback all changes
    # since the transaction started, including the already committed
    # (&#39;released&#39;) savepoints. There will be neither a new $job nor any
    # $thing entry in the database.

    # SQL: ROLLBACK;

    print &#34;ERROR: $exception\n&#34;;
  }
  else {
    # There was no error while handling the $job. Commit all changes.
    # Only now other connections can see the newly created $job and
    # @things.

    # SQL: COMMIT;

    print &#34;Ok\n&#34;;
  }</pre>

<p>In this example it might be hard to see where the rollbacks, releases and commits are happening, but it works just the same as for plain <a href="../../../%3Ctxn_do.html" class="podlinkpod"
>&#60;txn_do</a>&#62;: If the <code>try</code>-block around <code>txn_do</code> fails, a rollback is issued. If the <code>try</code> succeeds, the transaction is committed (or the savepoint released).</p>

<p>While you can get more fine-grained control using <code>svp_begin</code>, <code>svp_release</code> and <code>svp_rollback</code>, it is strongly recommended to use <code>txn_do</code> with coderefs.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Simple_Transactions_with_DBIx::Class::Storage::TxnScopeGuard"
>Simple Transactions with DBIx::Class::Storage::TxnScopeGuard</a></h2>

<p>An easy way to use transactions is with <a href="../../../DBIx/Class/Storage/TxnScopeGuard.html" class="podlinkpod"
>DBIx::Class::Storage::TxnScopeGuard</a>. See <a href="#Automatically_creating_related_objects" class="podlinkpod"
>&#34;Automatically creating related objects&#34;</a> for an example.</p>

<p>Note that unlike txn_do, TxnScopeGuard will only make sure the connection is alive when issuing the <code>BEGIN</code> statement. It will not (and really can not) retry if the server goes away mid-operations, unlike <code>txn_do</code>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SQL"
>SQL</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Creating_Schemas_From_An_Existing_Database"
>Creating Schemas From An Existing Database</a></h2>

<p><a href="../../../DBIx/Class/Schema/Loader.html" class="podlinkpod"
>DBIx::Class::Schema::Loader</a> will connect to a database and create a <a href="../../../DBIx/Class/Schema.html" class="podlinkpod"
>DBIx::Class::Schema</a> and associated sources by examining the database.</p>

<p>The recommend way of achieving this is to use the <a href="../../../dbicdump.html" class="podlinkpod"
>dbicdump</a> utility or the <a href="../../../Catalyst.html" class="podlinkpod"
>Catalyst</a> helper, as described in <a href="../../../DBIx/Class/Manual/Intro.html#Using_DBIx%3A%3AClass%3A%3ASchema%3A%3ALoader" class="podlinkpod"
>Manual::Intro</a>.</p>

<p>Alternatively, use the <a href="../../../DBIx/Class/Schema/Loader.html#make_schema_at" class="podlinkpod"
>make_schema_at</a> method:</p>

<pre>  perl -MDBIx::Class::Schema::Loader=make_schema_at,dump_to_dir:./lib \
    -e &#39;make_schema_at(&#34;My::Schema&#34;, \
    { db_schema =&#62; &#39;myschema&#39;, components =&#62; [&#34;InflateColumn::DateTime&#34;] }, \
    [ &#34;dbi:Pg:dbname=foo&#34;, &#34;username&#34;, &#34;password&#34; ])&#39;</pre>

<p>This will create a tree of files rooted at <code>./lib/My/Schema/</code> containing source definitions for all the tables found in the <code>myschema</code> schema in the <code>foo</code> database.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Creating_DDL_SQL"
>Creating DDL SQL</a></h2>

<p>The following functionality requires you to have <a href="../../../SQL/Translator.html" class="podlinkpod"
>SQL::Translator</a> (also known as &#34;SQL Fairy&#34;) installed.</p>

<p>To create a set of database-specific .sql files for the above schema:</p>

<pre> my $schema = My::Schema-&#62;connect($dsn);
 $schema-&#62;create_ddl_dir([&#39;MySQL&#39;, &#39;SQLite&#39;, &#39;PostgreSQL&#39;],
                        &#39;0.1&#39;,
                        &#39;./dbscriptdir/&#39;
                        );</pre>

<p>By default this will create schema files in the current directory, for MySQL, SQLite and PostgreSQL, using the $VERSION from your Schema.pm.</p>

<p>To create a new database using the schema:</p>

<pre> my $schema = My::Schema-&#62;connect($dsn);
 $schema-&#62;deploy({ add_drop_table =&#62; 1});</pre>

<p>To import created .sql files using the mysql client:</p>

<pre>  mysql -h &#34;host&#34; -D &#34;database&#34; -u &#34;user&#34; -p &#60; My_Schema_1.0_MySQL.sql</pre>

<p>To create <code>ALTER TABLE</code> conversion scripts to update a database to a newer version of your schema at a later point, first set a new <code>$VERSION</code> in your Schema file, then:</p>

<pre> my $schema = My::Schema-&#62;connect($dsn);
 $schema-&#62;create_ddl_dir([&#39;MySQL&#39;, &#39;SQLite&#39;, &#39;PostgreSQL&#39;],
                         &#39;0.2&#39;,
                         &#39;/dbscriptdir/&#39;,
                         &#39;0.1&#39;
                         );</pre>

<p>This will produce new database-specific .sql files for the new version of the schema, plus scripts to convert from version 0.1 to 0.2. This requires that the files for 0.1 as created above are available in the given directory to diff against.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Select_from_dual"
>Select from dual</a></h2>

<p>Dummy tables are needed by some databases to allow calling functions or expressions that aren&#39;t based on table content, for examples of how this applies to various database types, see: <a href="http://troels.arvin.dk/db/rdbms/#other-dummy_table" class="podlinkurl"
>http://troels.arvin.dk/db/rdbms/#other-dummy_table</a>.</p>

<p>Note: If you&#39;re using Oracles dual table don&#39;t <b>ever</b> do anything other than a select, if you CRUD on your dual table you *will* break your database.</p>

<p>Make a table class as you would for any other table</p>

<pre>  package MyAppDB::Dual;
  use strict;
  use warnings;
  use base &#39;DBIx::Class::Core&#39;;
  __PACKAGE__-&#62;table(&#34;Dual&#34;);
  __PACKAGE__-&#62;add_columns(
    &#34;dummy&#34;,
    { data_type =&#62; &#34;VARCHAR2&#34;, is_nullable =&#62; 0, size =&#62; 1 },
  );</pre>

<p>Once you&#39;ve loaded your table class select from it using <code>select</code> and <code>as</code> instead of <code>columns</code></p>

<pre>  my $rs = $schema-&#62;resultset(&#39;Dual&#39;)-&#62;search(undef,
    { select =&#62; [ &#39;sydate&#39; ],
      as     =&#62; [ &#39;now&#39; ]
    },
  );</pre>

<p>All you have to do now is be careful how you access your resultset, the below will not work because there is no column called &#39;now&#39; in the Dual table class</p>

<pre>  while (my $dual = $rs-&#62;next) {
    print $dual-&#62;now.&#34;\n&#34;;
  }
  # Can&#39;t locate object method &#34;now&#34; via package &#34;MyAppDB::Dual&#34; at headshot.pl line 23.</pre>

<p>You could of course use &#39;dummy&#39; in <code>as</code> instead of &#39;now&#39;, or <code>add_columns</code> to your Dual class for whatever you wanted to select from dual, but that&#39;s just silly, instead use <code>get_column</code></p>

<pre>  while (my $dual = $rs-&#62;next) {
    print $dual-&#62;get_column(&#39;now&#39;).&#34;\n&#34;;
  }</pre>

<p>Or use <code>cursor</code></p>

<pre>  my $cursor = $rs-&#62;cursor;
  while (my @vals = $cursor-&#62;next) {
    print $vals[0].&#34;\n&#34;;
  }</pre>

<p>In case you&#39;re going to use this &#34;trick&#34; together with <a href="../../../DBIx/Class/Schema.html#deploy" class="podlinkpod"
>&#34;deploy&#34; in DBIx::Class::Schema</a> or <a href="../../../DBIx/Class/Schema.html#create_ddl_dir" class="podlinkpod"
>&#34;create_ddl_dir&#34; in DBIx::Class::Schema</a> a table called &#34;dual&#34; will be created in your current schema. This would overlap &#34;sys.dual&#34; and you could not fetch &#34;sysdate&#34; or &#34;sequence.nextval&#34; anymore from dual. To avoid this problem, just tell <a href="../../../SQL/Translator.html" class="podlinkpod"
>SQL::Translator</a> to not create table dual:</p>

<pre>    my $sqlt_args = {
        add_drop_table =&#62; 1,
        parser_args    =&#62; { sources =&#62; [ grep $_ ne &#39;Dual&#39;, schema-&#62;sources ] },
    };
    $schema-&#62;create_ddl_dir( [qw/Oracle/], undef, &#39;./sql&#39;, undef, $sqlt_args );</pre>

<p>Or use <a href="../../../DBIx/Class/ResultClass/HashRefInflator.html" class="podlinkpod"
>DBIx::Class::ResultClass::HashRefInflator</a></p>

<pre>  $rs-&#62;result_class(&#39;DBIx::Class::ResultClass::HashRefInflator&#39;);
  while ( my $dual = $rs-&#62;next ) {
    print $dual-&#62;{now}.&#34;\n&#34;;
  }</pre>

<p>Here are some example <code>select</code> conditions to illustrate the different syntax you could use for doing stuff like <code>oracles.heavily(nested(functions_can(&#39;take&#39;, &#39;lots&#39;), OF), &#39;args&#39;)</code></p>

<pre>  # get a sequence value
  select =&#62; [ &#39;A_SEQ.nextval&#39; ],

  # get create table sql
  select =&#62; [ { &#39;dbms_metadata.get_ddl&#39; =&#62; [ &#34;&#39;TABLE&#39;&#34;, &#34;&#39;ARTIST&#39;&#34; ]} ],

  # get a random num between 0 and 100
  select =&#62; [ { &#34;trunc&#34; =&#62; [ { &#34;dbms_random.value&#34; =&#62; [0,100] } ]} ],

  # what year is it?
  select =&#62; [ { &#39;extract&#39; =&#62; [ \&#39;year from sysdate&#39; ] } ],

  # do some math
  select =&#62; [ {&#39;round&#39; =&#62; [{&#39;cos&#39; =&#62; [ \&#39;180 * 3.14159265359/180&#39; ]}]}],

  # which day of the week were you born on?
  select =&#62; [{&#39;to_char&#39; =&#62; [{&#39;to_date&#39; =&#62; [ &#34;&#39;25-DEC-1980&#39;&#34;, &#34;&#39;dd-mon-yyyy&#39;&#34; ]}, &#34;&#39;day&#39;&#34;]}],

  # select 16 rows from dual
  select   =&#62; [ &#34;&#39;hello&#39;&#34; ],
  as       =&#62; [ &#39;world&#39; ],
  group_by =&#62; [ &#39;cube( 1, 2, 3, 4 )&#39; ],</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Adding_Indexes_And_Functions_To_Your_SQL"
>Adding Indexes And Functions To Your SQL</a></h2>

<p>Often you will want indexes on columns on your table to speed up searching. To do this, create a method called <code>sqlt_deploy_hook</code> in the relevant source class (refer to the advanced <a href="../../../DBIx/Class/ResultSource.html#sqlt_deploy_callback" class="podlinkpod"
>callback system</a> if you wish to share a hook between multiple sources):</p>

<pre> package My::Schema::Result::Artist;

 __PACKAGE__-&#62;table(&#39;artist&#39;);
 __PACKAGE__-&#62;add_columns(id =&#62; { ... }, name =&#62; { ... })

 sub sqlt_deploy_hook {
   my ($self, $sqlt_table) = @_;

   $sqlt_table-&#62;add_index(name =&#62; &#39;idx_name&#39;, fields =&#62; [&#39;name&#39;]);
 }

 1;</pre>

<p>Sometimes you might want to change the index depending on the type of the database for which SQL is being generated:</p>

<pre>  my ($db_type = $sqlt_table-&#62;schema-&#62;translator-&#62;producer_type)
    =~ s/^SQL::Translator::Producer:://;</pre>

<p>You can also add hooks to the schema level to stop certain tables being created:</p>

<pre> package My::Schema;

 ...

 sub sqlt_deploy_hook {
   my ($self, $sqlt_schema) = @_;

   $sqlt_schema-&#62;drop_table(&#39;table_name&#39;);
 }</pre>

<p>You could also add views, procedures or triggers to the output using <a href="../../../SQL/Translator/Schema.html#add_view" class="podlinkpod"
>&#34;add_view&#34; in SQL::Translator::Schema</a>, <a href="../../../SQL/Translator/Schema.html#add_procedure" class="podlinkpod"
>&#34;add_procedure&#34; in SQL::Translator::Schema</a> or <a href="../../../SQL/Translator/Schema.html#add_trigger" class="podlinkpod"
>&#34;add_trigger&#34; in SQL::Translator::Schema</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Schema_versioning"
>Schema versioning</a></h2>

<p>The following example shows simplistically how you might use DBIx::Class to deploy versioned schemas to your customers. The basic process is as follows:</p>

<ol>
<li>Create a DBIx::Class schema</li>

<li>Save the schema</li>

<li>Deploy to customers</li>

<li>Modify schema to change functionality</li>

<li>Deploy update to customers</li>
</ol>

<p><b>Create a DBIx::Class schema</b></p>

<p>This can either be done manually, or generated from an existing database as described under <a href="#Creating_Schemas_From_An_Existing_Database" class="podlinkpod"
>&#34;Creating Schemas From An Existing Database&#34;</a></p>

<p><b>Save the schema</b></p>

<p>Call <a href="../../../DBIx/Class/Schema.html#create_ddl_dir" class="podlinkpod"
>&#34;create_ddl_dir&#34; in DBIx::Class::Schema</a> as above under <a href="#Creating_DDL_SQL" class="podlinkpod"
>&#34;Creating DDL SQL&#34;</a>.</p>

<p><b>Deploy to customers</b></p>

<p>There are several ways you could deploy your schema. These are probably beyond the scope of this recipe, but might include:</p>

<ol>
<li>Require customer to apply manually using their RDBMS.</li>

<li>Package along with your app, making database dump/schema update/tests all part of your install.</li>
</ol>

<p><b>Modify the schema to change functionality</b></p>

<p>As your application evolves, it may be necessary to modify your schema to change functionality. Once the changes are made to your schema in DBIx::Class, export the modified schema and the conversion scripts as in <a href="#Creating_DDL_SQL" class="podlinkpod"
>&#34;Creating DDL SQL&#34;</a>.</p>

<p><b>Deploy update to customers</b></p>

<p>Add the <a href="../../../DBIx/Class/Schema/Versioned.html" class="podlinkpod"
>DBIx::Class::Schema::Versioned</a> schema component to your Schema class. This will add a new table to your database called <code>dbix_class_schema_vesion</code> which will keep track of which version is installed and warn if the user tries to run a newer schema version than the database thinks it has.</p>

<p>Alternatively, you can send the conversion SQL scripts to your customers as above.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Setting_quoting_for_the_generated_SQL"
>Setting quoting for the generated SQL</a></h2>

<p>If the database contains column names with spaces and/or reserved words, they need to be quoted in the SQL queries. This is done using:</p>

<pre> $schema-&#62;storage-&#62;sql_maker-&#62;quote_char([ qw/[ ]/] );
 $schema-&#62;storage-&#62;sql_maker-&#62;name_sep(&#39;.&#39;);</pre>

<p>The first sets the quote characters. Either a pair of matching brackets, or a <code>&#34;</code> or <code>&#39;</code>:</p>

<pre> $schema-&#62;storage-&#62;sql_maker-&#62;quote_char(&#39;&#34;&#39;);</pre>

<p>Check the documentation of your database for the correct quote characters to use. <code>name_sep</code> needs to be set to allow the SQL generator to put the quotes the correct place, and defaults to <code>.</code> if not supplied.</p>

<p>In most cases you should set these as part of the arguments passed to <a href="../../../DBIx/Class/Schema.html#connect" class="podlinkpod"
>&#34;connect&#34; in DBIx::Class::Schema</a>:</p>

<pre> my $schema = My::Schema-&#62;connect(
  &#39;dbi:mysql:my_db&#39;,
  &#39;db_user&#39;,
  &#39;db_password&#39;,
  {
    quote_char =&#62; &#39;&#34;&#39;,
    name_sep   =&#62; &#39;.&#39;
  }
 )</pre>

<p>In some cases, quoting will be required for all users of a schema. To enforce this, you can also overload the <code>connection</code> method for your schema class:</p>

<pre> sub connection {
     my $self = shift;
     my $rv = $self-&#62;next::method( @_ );
     $rv-&#62;storage-&#62;sql_maker-&#62;quote_char([ qw/[ ]/ ]);
     $rv-&#62;storage-&#62;sql_maker-&#62;name_sep(&#39;.&#39;);
     return $rv;
 }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Working_with_PostgreSQL_array_types"
>Working with PostgreSQL array types</a></h2>

<p>You can also assign values to PostgreSQL array columns by passing array references in the <code>\%columns</code> (<code>\%vals</code>) hashref of the <a href="../../../DBIx/Class/ResultSet.html#create" class="podlinkpod"
>&#34;create&#34; in DBIx::Class::ResultSet</a> and <a href="../../../DBIx/Class/Row.html#update" class="podlinkpod"
>&#34;update&#34; in DBIx::Class::Row</a> family of methods:</p>

<pre>  $resultset-&#62;create({
    numbers =&#62; [1, 2, 3]
  });

  $row-&#62;update(
    {
      numbers =&#62; [1, 2, 3]
    },
    {
      day =&#62; &#39;2008-11-24&#39;
    }
  );</pre>

<p>In conditions (e.g. <code>\%cond</code> in the <a href="../../../DBIx/Class/ResultSet.html#search" class="podlinkpod"
>&#34;search&#34; in DBIx::Class::ResultSet</a> family of methods) you cannot directly use array references (since this is interpreted as a list of values to be <code>OR</code>ed), but you can use the following syntax to force passing them as bind values:</p>

<pre>  $resultset-&#62;search(
    {
      numbers =&#62; \[ &#39;= ?&#39;, [numbers =&#62; [1, 2, 3]] ]
    }
  );</pre>

<p>See <a href="../../../SQL/Abstract.html#array_datatypes" class="podlinkpod"
>&#34;array_datatypes&#34; in SQL::Abstract</a> and <a href="../../../SQL/Abstract.html#Literal_SQL_with_placeholders_and_bind_values_(subqueries)" class="podlinkpod"
>&#34;Literal SQL with placeholders and bind values (subqueries)&#34; in SQL::Abstract</a> for more explanation. Note that <a href="../../../DBIx/Class.html" class="podlinkpod"
>DBIx::Class</a> sets <a href="../../../SQL/Abstract.html#bindtype" class="podlinkpod"
>&#34;bindtype&#34; in SQL::Abstract</a> to <code>columns</code>, so you must pass the bind values (the <code>[1, 2, 3]</code> arrayref in the above example) wrapped in arrayrefs together with the column name, like this: <code>[column_name =&#62; value]</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Formatting_DateTime_objects_in_queries"
>Formatting DateTime objects in queries</a></h2>

<p>To ensure <code>WHERE</code> conditions containing <a href="../../../DateTime.html" class="podlinkpod"
>DateTime</a> arguments are properly formatted to be understood by your RDBMS, you must use the <code>DateTime</code> formatter returned by <a href="../../../DBIx/Class/Storage/DBI.html#datetime_parser" class="podlinkpod"
>&#34;datetime_parser&#34; in DBIx::Class::Storage::DBI</a> to format any <a href="../../../DateTime.html" class="podlinkpod"
>DateTime</a> objects you pass to <a href="../../../DBIx/Class/ResultSet.html#search" class="podlinkpod"
>search</a> conditions. Any <a href="../../../DBIx/Class/Storage.html" class="podlinkpod"
>Storage</a> object attached to your <a href="../../../DBIx/Class/Schema.html" class="podlinkpod"
>Schema</a> provides a correct <code>DateTime</code> formatter, so all you have to do is:</p>

<pre>  my $dtf = $schema-&#62;storage-&#62;datetime_parser;
  my $rs = $schema-&#62;resultset(&#39;users&#39;)-&#62;search(
    {
      signup_date =&#62; {
        -between =&#62; [
          $dtf-&#62;format_datetime($dt_start),
          $dtf-&#62;format_datetime($dt_end),
        ],
      }
    },
  );</pre>

<p>Without doing this the query will contain the simple stringification of the <code>DateTime</code> object, which almost never matches the RDBMS expectations.</p>

<p>This kludge is necessary only for conditions passed to <a href="../../../DBIx/Class/ResultSet.html#search" class="podlinkpod"
>&#34;search&#34; in DBIx::Class::ResultSet</a>, whereas <a href="../../../DBIx/Class/ResultSet.html#create" class="podlinkpod"
>create</a>, <a href="../../../DBIx/Class/ResultSet.html#find" class="podlinkpod"
>find</a>, <a href="../../../DBIx/Class/Row.html#update" class="podlinkpod"
>&#34;update&#34; in DBIx::Class::Row</a> (but not <a href="../../../DBIx/Class/ResultSet.html#update" class="podlinkpod"
>&#34;update&#34; in DBIx::Class::ResultSet</a>) are all <a href="../../../DBIx/Class/InflateColumn.html" class="podlinkpod"
>DBIx::Class::InflateColumn</a>-aware and will do the right thing when supplied an inflated <code>DateTime</code> object.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Using_Unicode"
>Using Unicode</a></h2>

<p>When using unicode character data there are two alternatives - either your database supports unicode characters (including setting the utf8 flag on the returned string), or you need to encode/decode data appropriately each time a string field is inserted into or retrieved from the database. It is better to avoid encoding/decoding data and to use your database&#39;s own unicode capabilities if at all possible.</p>

<p>The <a href="../../../DBIx/Class/UTF8Columns.html" class="podlinkpod"
>DBIx::Class::UTF8Columns</a> component handles storing selected unicode columns in a database that does not directly support unicode. If used with a database that does correctly handle unicode then strange and unexpected data corrupt <b>will</b> occur.</p>

<p>The Catalyst Wiki Unicode page at <a href="http://wiki.catalystframework.org/wiki/tutorialsandhowtos/using_unicode" class="podlinkurl"
>http://wiki.catalystframework.org/wiki/tutorialsandhowtos/using_unicode</a> has additional information on the use of Unicode with Catalyst and DBIx::Class.</p>

<p>The following databases do correctly handle unicode data:-</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="MySQL"
>MySQL</a></h3>

<p>MySQL supports unicode, and will correctly flag utf8 data from the database if the <code>mysql_enable_utf8</code> is set in the connect options.</p>

<pre>  my $schema = My::Schema-&#62;connection(&#39;dbi:mysql:dbname=test&#39;,
                                      $user, $pass,
                                      { mysql_enable_utf8 =&#62; 1} );</pre>

<p>When set, a data retrieved from a textual column type (char, varchar, etc) will have the UTF-8 flag turned on if necessary. This enables character semantics on that string. You will also need to ensure that your database / table / column is configured to use UTF8. See Chapter 10 of the mysql manual for details.</p>

<p>See <a href="../../../DBD/mysql.html" class="podlinkpod"
>DBD::mysql</a> for further details.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Oracle"
>Oracle</a></h3>

<p>Information about Oracle support for unicode can be found in <a href="../../../DBD/Oracle.html#Unicode" class="podlinkpod"
>&#34;Unicode&#34; in DBD::Oracle</a>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="PostgreSQL"
>PostgreSQL</a></h3>

<p>PostgreSQL supports unicode if the character set is correctly set at database creation time. Additionally the <code>pg_enable_utf8</code> should be set to ensure unicode data is correctly marked.</p>

<pre>  my $schema = My::Schema-&#62;connection(&#39;dbi:Pg:dbname=test&#39;,
                                      $user, $pass,
                                      { pg_enable_utf8 =&#62; 1} );</pre>

<p>Further information can be found in <a href="../../../DBD/Pg.html" class="podlinkpod"
>DBD::Pg</a>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="SQLite"
>SQLite</a></h3>

<p>SQLite version 3 and above natively use unicode internally. To correctly mark unicode strings taken from the database, the <code>sqlite_unicode</code> flag should be set at connect time (in versions of <a href="../../../DBD/SQLite.html" class="podlinkpod"
>DBD::SQLite</a> prior to 1.27 this attribute was named <code>unicode</code>).</p>

<pre>  my $schema = My::Schema-&#62;connection(&#39;dbi:SQLite:/tmp/test.db&#39;,
                                      &#39;&#39;, &#39;&#39;,
                                      { sqlite_unicode =&#62; 1} );</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BOOTSTRAPPING/MIGRATING"
>BOOTSTRAPPING/MIGRATING</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Easy_migration_from_class-based_to_schema-based_setup"
>Easy migration from class-based to schema-based setup</a></h2>

<p>You want to start using the schema-based approach to <a href="../../../DBIx/Class.html" class="podlinkpod"
>DBIx::Class</a> (see <a href="../../../DBIx/Class/Manual/Intro.html#Setting_it_up_manually" class="podlinkpod"
>&#34;Setting it up manually&#34; in DBIx::Class::Manual::Intro</a>), but have an established class-based setup with lots of existing classes that you don&#39;t want to move by hand. Try this nifty script instead:</p>

<pre>  use MyDB;
  use SQL::Translator;

  my $schema = MyDB-&#62;schema_instance;

  my $translator           =  SQL::Translator-&#62;new(
      debug                =&#62; $debug          ||  0,
      trace                =&#62; $trace          ||  0,
      no_comments          =&#62; $no_comments    ||  0,
      show_warnings        =&#62; $show_warnings  ||  0,
      add_drop_table       =&#62; $add_drop_table ||  0,
      validate             =&#62; $validate       ||  0,
      parser_args          =&#62; {
         &#39;DBIx::Schema&#39;    =&#62; $schema,
                              },
      producer_args   =&#62; {
          &#39;prefix&#39;         =&#62; &#39;My::Schema&#39;,
                         },
  );

  $translator-&#62;parser(&#39;SQL::Translator::Parser::DBIx::Class&#39;);
  $translator-&#62;producer(&#39;SQL::Translator::Producer::DBIx::Class::File&#39;);

  my $output = $translator-&#62;translate(@args) or die
          &#34;Error: &#34; . $translator-&#62;error;

  print $output;</pre>

<p>You could use <a href="../../../Module/Find.html" class="podlinkpod"
>Module::Find</a> to search for all subclasses in the MyDB::* namespace, which is currently left as an exercise for the reader.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="OVERLOADING_METHODS"
>OVERLOADING METHODS</a></h1>

<p><a href="../../../DBIx/Class.html" class="podlinkpod"
>DBIx::Class</a> uses the <a href="../../../Class/C3.html" class="podlinkpod"
>Class::C3</a> package, which provides for redispatch of method calls, useful for things like default values and triggers. You have to use calls to <code>next::method</code> to overload methods. More information on using <a href="../../../Class/C3.html" class="podlinkpod"
>Class::C3</a> with <a href="../../../DBIx/Class.html" class="podlinkpod"
>DBIx::Class</a> can be found in <a href="../../../DBIx/Class/Manual/Component.html" class="podlinkpod"
>DBIx::Class::Manual::Component</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Setting_default_values_for_a_row"
>Setting default values for a row</a></h2>

<p>It&#39;s as simple as overriding the <code>new</code> method. Note the use of <code>next::method</code>.</p>

<pre>  sub new {
    my ( $class, $attrs ) = @_;

    $attrs-&#62;{foo} = &#39;bar&#39; unless defined $attrs-&#62;{foo};

    my $new = $class-&#62;next::method($attrs);

    return $new;
  }</pre>

<p>For more information about <code>next::method</code>, look in the <a href="../../../Class/C3.html" class="podlinkpod"
>Class::C3</a> documentation. See also <a href="../../../DBIx/Class/Manual/Component.html" class="podlinkpod"
>DBIx::Class::Manual::Component</a> for more ways to write your own base classes to do this.</p>

<p>People looking for ways to do &#34;triggers&#34; with DBIx::Class are probably just looking for this.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Changing_one_field_whenever_another_changes"
>Changing one field whenever another changes</a></h2>

<p>For example, say that you have three columns, <code>id</code>, <code>number</code>, and <code>squared</code>. You would like to make changes to <code>number</code> and have <code>squared</code> be automagically set to the value of <code>number</code> squared. You can accomplish this by wrapping the <code>number</code> accessor with the <code>around</code> method modifier, available through either <a href="../../../Class/Method/Modifiers.html" class="podlinkpod"
>Class::Method::Modifiers</a>, <a href="../../../Moose/Manual/MethodModifiers.html" class="podlinkpod"
>Moose</a> or <a href="../../../Moo.html" class="podlinkpod"
>Moose-like</a> modules):</p>

<pre>  around number =&#62; sub {
    my ($orig, $self) = (shift, shift);

    if (@_) {
      my $value = $_[0];
      $self-&#62;squared( $value * $value );
    }

    $self-&#62;$orig(@_);
  };</pre>

<p>Note that the hard work is done by the call to <code>$self-&#62;$orig</code>, which redispatches your call to store_column in the superclass(es).</p>

<p>Generally, if this is a calculation your database can easily do, try and avoid storing the calculated value, it is safer to calculate when needed, than rely on the data being in sync.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Automatically_creating_related_objects"
>Automatically creating related objects</a></h2>

<p>You might have a class <code>Artist</code> which has many <code>CD</code>s. Further, you want to create a <code>CD</code> object every time you insert an <code>Artist</code> object. You can accomplish this by overriding <code>insert</code> on your objects:</p>

<pre>  sub insert {
    my ( $self, @args ) = @_;
    $self-&#62;next::method(@args);
    $self-&#62;create_related (&#39;cds&#39;, \%initial_cd_data );
    return $self;
  }</pre>

<p>If you want to wrap the two inserts in a transaction (for consistency, an excellent idea), you can use the awesome <a href="../../../DBIx/Class/Storage/TxnScopeGuard.html" class="podlinkpod"
>DBIx::Class::Storage::TxnScopeGuard</a>:</p>

<pre>  sub insert {
    my ( $self, @args ) = @_;

    my $guard = $self-&#62;result_source-&#62;schema-&#62;txn_scope_guard;

    $self-&#62;next::method(@args);
    $self-&#62;create_related (&#39;cds&#39;, \%initial_cd_data );

    $guard-&#62;commit;

    return $self
  }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Wrapping/overloading_a_column_accessor"
>Wrapping/overloading a column accessor</a></h2>

<p><b>Problem:</b></p>

<p>Say you have a table &#34;Camera&#34; and want to associate a description with each camera. For most cameras, you&#39;ll be able to generate the description from the other columns. However, in a few special cases you may want to associate a custom description with a camera.</p>

<p><b>Solution:</b></p>

<p>In your database schema, define a description field in the &#34;Camera&#34; table that can contain text and null values.</p>

<p>In DBIC, we&#39;ll overload the column accessor to provide a sane default if no custom description is defined. The accessor will either return or generate the description, depending on whether the field is null or not.</p>

<p>First, in your &#34;Camera&#34; schema class, define the description field as follows:</p>

<pre>  __PACKAGE__-&#62;add_columns(description =&#62; { accessor =&#62; &#39;_description&#39; });</pre>

<p>Next, we&#39;ll define the accessor-wrapper subroutine:</p>

<pre>  sub description {
      my $self = shift;

      # If there is an update to the column, we&#39;ll let the original accessor
      # deal with it.
      return $self-&#62;_description(@_) if @_;

      # Fetch the column value.
      my $description = $self-&#62;_description;

      # If there&#39;s something in the description field, then just return that.
      return $description if defined $description &#38;&#38; length $descripton;

      # Otherwise, generate a description.
      return $self-&#62;generate_description;
  }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DEBUGGING_AND_PROFILING"
>DEBUGGING AND PROFILING</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="DBIx::Class_objects_with_Data::Dumper"
>DBIx::Class objects with Data::Dumper</a></h2>

<p><a href="../../../Data/Dumper.html" class="podlinkpod"
>Data::Dumper</a> can be a very useful tool for debugging, but sometimes it can be hard to find the pertinent data in all the data it can generate. Specifically, if one naively tries to use it like so,</p>

<pre>  use Data::Dumper;

  my $cd = $schema-&#62;resultset(&#39;CD&#39;)-&#62;find(1);
  print Dumper($cd);</pre>

<p>several pages worth of data from the CD object&#39;s schema and result source will be dumped to the screen. Since usually one is only interested in a few column values of the object, this is not very helpful.</p>

<p>Luckily, it is possible to modify the data before <a href="../../../Data/Dumper.html" class="podlinkpod"
>Data::Dumper</a> outputs it. Simply define a hook that <a href="../../../Data/Dumper.html" class="podlinkpod"
>Data::Dumper</a> will call on the object before dumping it. For example,</p>

<pre>  package My::DB::CD;

  sub _dumper_hook {
    $_[0] = bless {
      %{ $_[0] },
      result_source =&#62; undef,
    }, ref($_[0]);
  }

  [...]

  use Data::Dumper;

  local $Data::Dumper::Freezer = &#39;_dumper_hook&#39;;

  my $cd = $schema-&#62;resultset(&#39;CD&#39;)-&#62;find(1);
  print Dumper($cd);
         # dumps $cd without its ResultSource</pre>

<p>If the structure of your schema is such that there is a common base class for all your table classes, simply put a method similar to <code>_dumper_hook</code> in the base class and set <code>$Data::Dumper::Freezer</code> to its name and <a href="../../../Data/Dumper.html" class="podlinkpod"
>Data::Dumper</a> will automagically clean up your data before printing it. See <a href="../../../Data/Dumper.html#EXAMPLES" class="podlinkpod"
>&#34;EXAMPLES&#34; in Data::Dumper</a> for more information.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Profiling"
>Profiling</a></h2>

<p>When you enable <a href="../../../DBIx/Class/Storage.html" class="podlinkpod"
>DBIx::Class::Storage</a>&#39;s debugging it prints the SQL executed as well as notifications of query completion and transaction begin/commit. If you&#39;d like to profile the SQL you can subclass the <a href="../../../DBIx/Class/Storage/Statistics.html" class="podlinkpod"
>DBIx::Class::Storage::Statistics</a> class and write your own profiling mechanism:</p>

<pre>  package My::Profiler;
  use strict;

  use base &#39;DBIx::Class::Storage::Statistics&#39;;

  use Time::HiRes qw(time);

  my $start;

  sub query_start {
    my $self = shift();
    my $sql = shift();
    my @params = @_;

    $self-&#62;print(&#34;Executing $sql: &#34;.join(&#39;, &#39;, @params).&#34;\n&#34;);
    $start = time();
  }

  sub query_end {
    my $self = shift();
    my $sql = shift();
    my @params = @_;

    my $elapsed = sprintf(&#34;%0.4f&#34;, time() - $start);
    $self-&#62;print(&#34;Execution took $elapsed seconds.\n&#34;);
    $start = undef;
  }

  1;</pre>

<p>You can then install that class as the debugging object:</p>

<pre>  __PACKAGE__-&#62;storage-&#62;debugobj(new My::Profiler());
  __PACKAGE__-&#62;storage-&#62;debug(1);</pre>

<p>A more complicated example might involve storing each execution of SQL in an array:</p>

<pre>  sub query_end {
    my $self = shift();
    my $sql = shift();
    my @params = @_;

    my $elapsed = time() - $start;
    push(@{ $calls{$sql} }, {
        params =&#62; \@params,
        elapsed =&#62; $elapsed
    });
  }</pre>

<p>You could then create average, high and low execution times for an SQL statement and dig down to see if certain parameters cause aberrant behavior. You might want to check out <a href="../../../DBIx/Class/QueryLog.html" class="podlinkpod"
>DBIx::Class::QueryLog</a> as well.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="IMPROVING_PERFORMANCE"
>IMPROVING PERFORMANCE</a></h1>

<ul>
<li>Install <a href="../../../Class/XSAccessor.html" class="podlinkpod"
>Class::XSAccessor</a> to speed up <a href="../../../Class/Accessor/Grouped.html" class="podlinkpod"
>Class::Accessor::Grouped</a>.</li>

<li>On Perl 5.8 install <a href="../../../Class/C3/XS.html" class="podlinkpod"
>Class::C3::XS</a>.</li>

<li><a href="../../../DBIx/Class/ResultSet.html#prefetch" class="podlinkpod"
>prefetch</a> relationships, where possible. See <a href="#Using_joins_and_prefetch" class="podlinkpod"
>&#34;Using joins and prefetch&#34;</a>.</li>

<li>Use <a href="../../../DBIx/Class/ResultSet.html#populate" class="podlinkpod"
>populate</a> in void context to insert data when you don&#39;t need the resulting <a href="../../../DBIx/Class/Manual/ResultClass.html" class="podlinkpod"
>result</a> objects, if possible, but see the caveats.
<p>When inserting many rows, for best results, populate a large number of rows at a time, but not so large that the table is locked for an unacceptably long time.</p>

<p>If using <a href="../../../DBIx/Class/ResultSet.html#create" class="podlinkpod"
>create</a> instead, use a transaction and commit every <code>X</code> rows; where <code>X</code> gives you the best performance without locking the table for too long.</p>
</li>

<li>When selecting many rows, if you don&#39;t need full-blown <a href="../../../DBIx/Class/Row.html" class="podlinkpod"
>DBIx::Class::Row</a> objects, consider using <a href="../../../DBIx/Class/ResultClass/HashRefInflator.html" class="podlinkpod"
>DBIx::Class::ResultClass::HashRefInflator</a>.</li>

<li>See also <a href="#STARTUP_SPEED" class="podlinkpod"
>&#34;STARTUP SPEED&#34;</a> and <a href="#MEMORY_USAGE" class="podlinkpod"
>&#34;MEMORY USAGE&#34;</a> in this document.</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="STARTUP_SPEED"
>STARTUP SPEED</a></h1>

<p><a href="../../../DBIx/Class.html" class="podlinkpod"
>DBIx::Class</a> programs can have a significant startup delay as the ORM loads all the relevant classes. This section examines techniques for reducing the startup delay.</p>

<p>These tips are are listed in order of decreasing effectiveness - so the first tip, if applicable, should have the greatest effect on your application.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Statically_Define_Your_Schema"
>Statically Define Your Schema</a></h2>

<p>If you are using <a href="../../../DBIx/Class/Schema/Loader.html" class="podlinkpod"
>DBIx::Class::Schema::Loader</a> to build the classes dynamically based on the database schema then there will be a significant startup delay.</p>

<p>For production use a statically defined schema (which can be generated using <a href="../../../DBIx/Class/Schema/Loader.html" class="podlinkpod"
>DBIx::Class::Schema::Loader</a> to dump the database schema once - see <a href="../../../DBIx/Class/Schema/Loader.html#make_schema_at" class="podlinkpod"
>make_schema_at</a> and <a href="../../../DBIx/Class/Schema/Loader.html#dump_directory" class="podlinkpod"
>dump_directory</a> for more details on creating static schemas from a database).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Move_Common_Startup_into_a_Base_Class"
>Move Common Startup into a Base Class</a></h2>

<p>Typically <a href="../../../DBIx/Class.html" class="podlinkpod"
>DBIx::Class</a> result classes start off with</p>

<pre>    use base qw/DBIx::Class::Core/;
    __PACKAGE__-&#62;load_components(qw/InflateColumn::DateTime/);</pre>

<p>If this preamble is moved into a common base class:-</p>

<pre>    package MyDBICbase;

    use base qw/DBIx::Class::Core/;
    __PACKAGE__-&#62;load_components(qw/InflateColumn::DateTime/);
    1;</pre>

<p>and each result class then uses this as a base:-</p>

<pre>    use base qw/MyDBICbase/;</pre>

<p>then the load_components is only performed once, which can result in a considerable startup speedup for schemas with many classes.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Explicitly_List_Schema_Result_Classes"
>Explicitly List Schema Result Classes</a></h2>

<p>The schema class will normally contain</p>

<pre>    __PACKAGE__-&#62;load_classes();</pre>

<p>to load the result classes. This will use <a href="../../../Module/Find.html" class="podlinkpod"
>Module::Find</a> to find and load the appropriate modules. Explicitly defining the classes you wish to load will remove the overhead of <a href="../../../Module/Find.html" class="podlinkpod"
>Module::Find</a> and the related directory operations:</p>

<pre>    __PACKAGE__-&#62;load_classes(qw/ CD Artist Track /);</pre>

<p>If you are instead using the <a href="../../../DBIx/Class/Schema.html#load_namespaces" class="podlinkpod"
>load_namespaces</a> syntax to load the appropriate classes there is not a direct alternative avoiding <a href="../../../Module/Find.html" class="podlinkpod"
>Module::Find</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="MEMORY_USAGE"
>MEMORY USAGE</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Cached_statements"
>Cached statements</a></h2>

<p><a href="../../../DBIx/Class.html" class="podlinkpod"
>DBIx::Class</a> normally caches all statements with <a href="../../../DBI.html#prepare_cached" class="podlinkpod"
>prepare_cached()</a>. This is normally a good idea, but if too many statements are cached, the database may use too much memory and may eventually run out and fail entirely. If you suspect this may be the case, you may want to examine DBI&#39;s <a href="../../../DBI.html#CachedKidsCachedKids_(hash_ref)" class="podlinkpod"
>CachedKids</a> hash:</p>

<pre>    # print all currently cached prepared statements
    print for keys %{$schema-&#62;storage-&#62;dbh-&#62;{CachedKids}};
    # get a count of currently cached prepared statements
    my $count = scalar keys %{$schema-&#62;storage-&#62;dbh-&#62;{CachedKids}};</pre>

<p>If it&#39;s appropriate, you can simply clear these statements, automatically deallocating them in the database:</p>

<pre>    my $kids = $schema-&#62;storage-&#62;dbh-&#62;{CachedKids};
    delete @{$kids}{keys %$kids} if scalar keys %$kids &#62; 100;</pre>

<p>But what you probably want is to expire unused statements and not those that are used frequently. You can accomplish this with <a href="../../../Tie/Cache.html" class="podlinkpod"
>Tie::Cache</a> or <a href="../../../Tie/Cache/LRU.html" class="podlinkpod"
>Tie::Cache::LRU</a>:</p>

<pre>    use Tie::Cache;
    use DB::Main;
    my $schema = DB::Main-&#62;connect($dbi_dsn, $user, $pass, {
        on_connect_do =&#62; sub { tie %{shift-&#62;_dbh-&#62;{CachedKids}}, &#39;Tie::Cache&#39;, 100 },
    });</pre>
<p class="backlinkbottom"><b><a name="___bottom" href="../../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
