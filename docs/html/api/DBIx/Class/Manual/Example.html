<html><head><title>DBIx::Class::Manual::Example</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:15 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Installation'>Installation</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Create_the_database%2Ftables'>Create the database/tables</a>
      <li class='indexItem indexItem3'><a href='#Set_up_DBIx%3A%3AClass%3A%3ASchema'>Set up DBIx::Class::Schema</a>
      <li class='indexItem indexItem3'><a href='#Write_a_script_to_insert_some_records'>Write a script to insert some records</a>
      <li class='indexItem indexItem3'><a href='#Create_and_run_the_test_scripts'>Create and run the test scripts</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#Notes'>Notes</a>
  <li class='indexItem indexItem1'><a href='#TODO'>TODO</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>DBIx::Class::Manual::Example - Simple CD database example</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This tutorial will guide you through the process of setting up and testing a very basic CD database using SQLite,
with DBIx::Class::Schema as the database frontend.</p>

<p>The database consists of the following:</p>

<pre>  table &#39;artist&#39; with columns:  artistid, name
  table &#39;cd&#39;     with columns:  cdid, artist, title
  table &#39;track&#39;  with columns:  trackid, cd, title</pre>

<p>And these rules exists:</p>

<pre>  one artist can have many cds
  one cd belongs to one artist
  one cd can have many tracks
  one track belongs to one cd</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Installation"
>Installation</a></h2>

<p>Install DBIx::Class via CPAN should be sufficient.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Create_the_database/tables"
>Create the database/tables</a></h3>

<p>First make and change the directory:</p>

<pre>  mkdir app
  cd app
  mkdir db
  cd db</pre>

<p>This example uses SQLite which is a dependency of DBIx::Class, so you shouldn&#39;t have to install extra software.</p>

<p>Save the following into a example.sql in the directory db</p>

<pre>  CREATE TABLE artist (
    artistid INTEGER PRIMARY KEY,
    name TEXT NOT NULL
  );

  CREATE TABLE cd (
    cdid INTEGER PRIMARY KEY,
    artist INTEGER NOT NULL REFERENCES artist(artistid),
    title TEXT NOT NULL
  );

  CREATE TABLE track (
    trackid INTEGER PRIMARY KEY,
    cd INTEGER NOT NULL REFERENCES cd(cdid),
    title TEXT NOT NULL
  );</pre>

<p>and create the SQLite database file:</p>

<pre>  sqlite3 example.db &#60; example.sql</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Set_up_DBIx::Class::Schema"
>Set up DBIx::Class::Schema</a></h3>

<p>Change directory back from db to the directory app:</p>

<pre>  cd ../</pre>

<p>Now create some more directories:</p>

<pre>  mkdir MyDatabase
  mkdir MyDatabase/Main
  mkdir MyDatabase/Main/Result
  mkdir MyDatabase/Main/ResultSet</pre>

<p>Then, create the following DBIx::Class::Schema classes:</p>

<p>MyDatabase/Main.pm:</p>

<pre>  package MyDatabase::Main;
  use base qw/DBIx::Class::Schema/;
  __PACKAGE__-&#62;load_namespaces;

  1;</pre>

<p>MyDatabase/Main/Result/Artist.pm:</p>

<pre>  package MyDatabase::Main::Result::Artist;
  use base qw/DBIx::Class::Core/;
  __PACKAGE__-&#62;table(&#39;artist&#39;);
  __PACKAGE__-&#62;add_columns(qw/ artistid name /);
  __PACKAGE__-&#62;set_primary_key(&#39;artistid&#39;);
  __PACKAGE__-&#62;has_many(&#39;cds&#39; =&#62; &#39;MyDatabase::Main::Result::Cd&#39;);

  1;</pre>

<p>MyDatabase/Main/Result/Cd.pm:</p>

<pre>  package MyDatabase::Main::Result::Cd;
  use base qw/DBIx::Class::Core/;
  __PACKAGE__-&#62;load_components(qw/InflateColumn::DateTime/);
  __PACKAGE__-&#62;table(&#39;cd&#39;);
  __PACKAGE__-&#62;add_columns(qw/ cdid artist title/);
  __PACKAGE__-&#62;set_primary_key(&#39;cdid&#39;);
  __PACKAGE__-&#62;belongs_to(&#39;artist&#39; =&#62; &#39;MyDatabase::Main::Result::Artist&#39;);
  __PACKAGE__-&#62;has_many(&#39;tracks&#39; =&#62; &#39;MyDatabase::Main::Result::Track&#39;);

  1;</pre>

<p>MyDatabase/Main/Result/Track.pm:</p>

<pre>  package MyDatabase::Main::Result::Track;
  use base qw/DBIx::Class::Core/;
  __PACKAGE__-&#62;table(&#39;track&#39;);
  __PACKAGE__-&#62;add_columns(qw/ trackid cd title /);
  __PACKAGE__-&#62;set_primary_key(&#39;trackid&#39;);
  __PACKAGE__-&#62;belongs_to(&#39;cd&#39; =&#62; &#39;MyDatabase::Main::Result::Cd&#39;);

  1;</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Write_a_script_to_insert_some_records"
>Write a script to insert some records</a></h3>

<p>insertdb.pl</p>

<pre>  #!/usr/bin/perl

  use strict;
  use warnings;

  use MyDatabase::Main;

  my $schema = MyDatabase::Main-&#62;connect(&#39;dbi:SQLite:db/example.db&#39;);

  #  here&#39;s some of the SQL that is going to be generated by the schema
  #  INSERT INTO artist VALUES (NULL,&#39;Michael Jackson&#39;);
  #  INSERT INTO artist VALUES (NULL,&#39;Eminem&#39;);

  my @artists = ([&#39;Michael Jackson&#39;], [&#39;Eminem&#39;]);
  $schema-&#62;populate(&#39;Artist&#39;, [
     [qw/name/],
     @artists,
  ]);

  my %albums = (
    &#39;Thriller&#39; =&#62; &#39;Michael Jackson&#39;,
    &#39;Bad&#39; =&#62; &#39;Michael Jackson&#39;,
    &#39;The Marshall Mathers LP&#39; =&#62; &#39;Eminem&#39;,
  );

  my @cds;
  foreach my $lp (keys %albums) {
    my $artist = $schema-&#62;resultset(&#39;Artist&#39;)-&#62;find({
      name =&#62; $albums{$lp}
    });
    push @cds, [$lp, $artist-&#62;id];
  }

  $schema-&#62;populate(&#39;Cd&#39;, [
    [qw/title artist/],
    @cds,
  ]);


  my %tracks = (
    &#39;Beat It&#39;         =&#62; &#39;Thriller&#39;,
    &#39;Billie Jean&#39;     =&#62; &#39;Thriller&#39;,
    &#39;Dirty Diana&#39;     =&#62; &#39;Bad&#39;,
    &#39;Smooth Criminal&#39; =&#62; &#39;Bad&#39;,
    &#39;Leave Me Alone&#39;  =&#62; &#39;Bad&#39;,
    &#39;Stan&#39;            =&#62; &#39;The Marshall Mathers LP&#39;,
    &#39;The Way I Am&#39;    =&#62; &#39;The Marshall Mathers LP&#39;,
  );

  my @tracks;
  foreach my $track (keys %tracks) {
    my $cdname = $schema-&#62;resultset(&#39;Cd&#39;)-&#62;find({
      title =&#62; $tracks{$track},
    });
    push @tracks, [$cdname-&#62;id, $track];
  }

  $schema-&#62;populate(&#39;Track&#39;,[
    [qw/cd title/],
    @tracks,
  ]);</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Create_and_run_the_test_scripts"
>Create and run the test scripts</a></h3>

<p>testdb.pl:</p>

<pre>  #!/usr/bin/perl

  use strict;
  use warnings;

  use MyDatabase::Main;

  my $schema = MyDatabase::Main-&#62;connect(&#39;dbi:SQLite:db/example.db&#39;);
  # for other DSNs, e.g. MySQL, see the perldoc for the relevant dbd
  # driver, e.g perldoc L&#60;DBD::mysql&#62;.

  get_tracks_by_cd(&#39;Bad&#39;);
  get_tracks_by_artist(&#39;Michael Jackson&#39;);

  get_cd_by_track(&#39;Stan&#39;);
  get_cds_by_artist(&#39;Michael Jackson&#39;);

  get_artist_by_track(&#39;Dirty Diana&#39;);
  get_artist_by_cd(&#39;The Marshall Mathers LP&#39;);


  sub get_tracks_by_cd {
    my $cdtitle = shift;
    print &#34;get_tracks_by_cd($cdtitle):\n&#34;;
    my $rs = $schema-&#62;resultset(&#39;Track&#39;)-&#62;search(
      {
        &#39;cd.title&#39; =&#62; $cdtitle
      },
      {
        join     =&#62; [qw/ cd /],
      }
    );
    while (my $track = $rs-&#62;next) {
      print $track-&#62;title . &#34;\n&#34;;
    }
    print &#34;\n&#34;;
  }

  sub get_tracks_by_artist {
    my $artistname = shift;
    print &#34;get_tracks_by_artist($artistname):\n&#34;;
    my $rs = $schema-&#62;resultset(&#39;Track&#39;)-&#62;search(
      {
        &#39;artist.name&#39; =&#62; $artistname
      },
      {
        join =&#62; {
          &#39;cd&#39; =&#62; &#39;artist&#39;
        },
      }
    );
    while (my $track = $rs-&#62;next) {
      print $track-&#62;title . &#34;\n&#34;;
    }
    print &#34;\n&#34;;
  }


  sub get_cd_by_track {
    my $tracktitle = shift;
    print &#34;get_cd_by_track($tracktitle):\n&#34;;
    my $rs = $schema-&#62;resultset(&#39;Cd&#39;)-&#62;search(
      {
        &#39;tracks.title&#39; =&#62; $tracktitle
      },
      {
        join     =&#62; [qw/ tracks /],
      }
    );
    my $cd = $rs-&#62;first;
    print $cd-&#62;title . &#34;\n\n&#34;;
  }

  sub get_cds_by_artist {
    my $artistname = shift;
    print &#34;get_cds_by_artist($artistname):\n&#34;;
    my $rs = $schema-&#62;resultset(&#39;Cd&#39;)-&#62;search(
      {
        &#39;artist.name&#39; =&#62; $artistname
      },
      {
        join     =&#62; [qw/ artist /],
      }
    );
    while (my $cd = $rs-&#62;next) {
      print $cd-&#62;title . &#34;\n&#34;;
    }
    print &#34;\n&#34;;
  }



  sub get_artist_by_track {
    my $tracktitle = shift;
    print &#34;get_artist_by_track($tracktitle):\n&#34;;
    my $rs = $schema-&#62;resultset(&#39;Artist&#39;)-&#62;search(
      {
        &#39;tracks.title&#39; =&#62; $tracktitle
      },
      {
        join =&#62; {
          &#39;cds&#39; =&#62; &#39;tracks&#39;
        }
      }
    );
    my $artist = $rs-&#62;first;
    print $artist-&#62;name . &#34;\n\n&#34;;
  }

  sub get_artist_by_cd {
    my $cdtitle = shift;
    print &#34;get_artist_by_cd($cdtitle):\n&#34;;
    my $rs = $schema-&#62;resultset(&#39;Artist&#39;)-&#62;search(
      {
        &#39;cds.title&#39; =&#62; $cdtitle
      },
      {
        join     =&#62; [qw/ cds /],
      }
    );
    my $artist = $rs-&#62;first;
    print $artist-&#62;name . &#34;\n\n&#34;;
  }</pre>

<p>It should output:</p>

<pre>  get_tracks_by_cd(Bad):
  Dirty Diana
  Smooth Criminal
  Leave Me Alone

  get_tracks_by_artist(Michael Jackson):
  Beat it
  Billie Jean
  Dirty Diana
  Smooth Criminal
  Leave Me Alone

  get_cd_by_track(Stan):
  The Marshall Mathers LP

  get_cds_by_artist(Michael Jackson):
  Thriller
  Bad

  get_artist_by_track(Dirty Diana):
  Michael Jackson

  get_artist_by_cd(The Marshall Mathers LP):
  Eminem</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Notes"
>Notes</a></h1>

<p>A reference implementation of the database and scripts in this example are available in the main distribution for DBIx::Class under the directory <em>t/examples/Schema</em>.</p>

<p>With these scripts we&#39;re relying on @INC looking in the current working directory. You may want to add the MyDatabase namespaces to @INC in a different way when it comes to deployment.</p>

<p>The <em>testdb.pl</em> script is an excellent start for testing your database model.</p>

<p>This example uses <a href="../../../DBIx/Class/Schema.html#load_namespaces" class="podlinkpod"
>&#34;load_namespaces&#34; in DBIx::Class::Schema</a> to load in the appropriate <a href="../../../DBIx/Class/Row.html" class="podlinkpod"
>Row</a> classes from the MyDatabase::Main::Result namespace, and any required resultset classes from the MyDatabase::Main::ResultSet namespace (although we created the directory in the directions above we did not add, or need to add, any resultset classes).</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TODO"
>TODO</a></h1>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<pre>  sc_ from irc.perl.org#dbix-class
  Kieren Diment &#60;kd@totaldatasolution.com&#62;
  Nigel Metheringham &#60;nigelm@cpan.org&#62;</pre>
<p class="backlinkbottom"><b><a name="___bottom" href="../../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
