<html><head><title>Encode::Guess</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:17 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#ABSTRACT'>ABSTRACT</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#CAVEATS'>CAVEATS</a>
  <li class='indexItem indexItem1'><a href='#TO_DO'>TO DO</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Encode::Guess -- Guesses encoding from data</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  # if you are sure $data won&#39;t contain anything bogus

  use Encode;
  use Encode::Guess qw/euc-jp shiftjis 7bit-jis/;
  my $utf8 = decode(&#34;Guess&#34;, $data);
  my $data = encode(&#34;Guess&#34;, $utf8);   # this doesn&#39;t work!

  # more elaborate way
  use Encode::Guess;
  my $enc = guess_encoding($data, qw/euc-jp shiftjis 7bit-jis/);
  ref($enc) or die &#34;Can&#39;t guess: $enc&#34;; # trap error this way
  $utf8 = $enc-&#62;decode($data);
  # or
  $utf8 = decode($enc-&#62;name, $data)</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ABSTRACT"
>ABSTRACT</a></h1>

<p>Encode::Guess enables you to guess in what encoding a given data is encoded, or at least tries to.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>By default, it checks only ascii, utf8 and UTF-16/32 with BOM.</p>

<pre>  use Encode::Guess; # ascii/utf8/BOMed UTF</pre>

<p>To use it more practically, you have to give the names of encodings to check (<i>suspects</i> as follows). The name of suspects can either be canonical names or aliases.</p>

<p>CAVEAT: Unlike UTF-(16|32), BOM in utf8 is NOT AUTOMATICALLY STRIPPED.</p>

<pre> # tries all major Japanese Encodings as well
  use Encode::Guess qw/euc-jp shiftjis 7bit-jis/;</pre>

<p>If the <code>$Encode::Guess::NoUTFAutoGuess</code> variable is set to a true value, no heuristics will be applied to UTF8/16/32, and the result will be limited to the suspects and <code>ascii</code>.</p>

<dl>
<dt><a name="Encode::Guess-&#62;set_suspects"
>Encode::Guess-&#62;set_suspects</a></dt>

<dd>
<p>You can also change the internal suspects list via <code>set_suspects</code> method.</p>

<pre>  use Encode::Guess;
  Encode::Guess-&#62;set_suspects(qw/euc-jp shiftjis 7bit-jis/);</pre>

<dt><a name="Encode::Guess-&#62;add_suspects"
>Encode::Guess-&#62;add_suspects</a></dt>

<dd>
<p>Or you can use <code>add_suspects</code> method. The difference is that <code>set_suspects</code> flushes the current suspects list while <code>add_suspects</code> adds.</p>

<pre>  use Encode::Guess;
  Encode::Guess-&#62;add_suspects(qw/euc-jp shiftjis 7bit-jis/);
  # now the suspects are euc-jp,shiftjis,7bit-jis, AND
  # euc-kr,euc-cn, and big5-eten
  Encode::Guess-&#62;add_suspects(qw/euc-kr euc-cn big5-eten/);</pre>

<dt><a name="Encode::decode(&#34;Guess&#34;_...)"
>Encode::decode(&#34;Guess&#34; ...)</a></dt>

<dd>
<p>When you are content with suspects list, you can now</p>

<pre>  my $utf8 = Encode::decode(&#34;Guess&#34;, $data);</pre>

<dt><a name="Encode::Guess-&#62;guess($data)"
>Encode::Guess-&#62;guess($data)</a></dt>

<dd>
<p>But it will croak if:</p>

<ul>
<li>Two or more suspects remain</li>

<li>No suspects left</li>
</ul>

<p>So you should instead try this;</p>

<pre>  my $decoder = Encode::Guess-&#62;guess($data);</pre>

<p>On success, $decoder is an object that is documented in <a href="../Encode/Encoding.html" class="podlinkpod"
>Encode::Encoding</a>. So you can now do this;</p>

<pre>  my $utf8 = $decoder-&#62;decode($data);</pre>

<p>On failure, $decoder now contains an error message so the whole thing would be as follows;</p>

<pre>  my $decoder = Encode::Guess-&#62;guess($data);
  die $decoder unless ref($decoder);
  my $utf8 = $decoder-&#62;decode($data);</pre>

<dt><a name="guess_encoding($data,_[,_list_of_suspects])"
>guess_encoding($data, [, <i>list of suspects</i>])</a></dt>

<dd>
<p>You can also try <code>guess_encoding</code> function which is exported by default. It takes $data to check and it also takes the list of suspects by option. The optional suspect list is <i>not reflected</i> to the internal suspects list.</p>

<pre>  my $decoder = guess_encoding($data, qw/euc-jp euc-kr euc-cn/);
  die $decoder unless ref($decoder);
  my $utf8 = $decoder-&#62;decode($data);
  # check only ascii, utf8 and UTF-(16|32) with BOM
  my $decoder = guess_encoding($data);</pre>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CAVEATS"
>CAVEATS</a></h1>

<ul>
<li>Because of the algorithm used, ISO-8859 series and other single-byte encodings do not work well unless either one of ISO-8859 is the only one suspect (besides ascii and utf8).
<pre>  use Encode::Guess;
  # perhaps ok
  my $decoder = guess_encoding($data, &#39;latin1&#39;);
  # definitely NOT ok
  my $decoder = guess_encoding($data, qw/latin1 greek/);</pre>

<p>The reason is that Encode::Guess guesses encoding by trial and error. It first splits $data into lines and tries to decode the line for each suspect. It keeps it going until all but one encoding is eliminated out of suspects list. ISO-8859 series is just too successful for most cases (because it fills almost all code points in \x00-\xff).</p>
</li>

<li>Do not mix national standard encodings and the corresponding vendor encodings.
<pre>  # a very bad idea
  my $decoder
     = guess_encoding($data, qw/shiftjis MacJapanese cp932/);</pre>

<p>The reason is that vendor encoding is usually a superset of national standard so it becomes too ambiguous for most cases.</p>
</li>

<li>On the other hand, mixing various national standard encodings automagically works unless $data is too short to allow for guessing.
<pre> # This is ok if $data is long enough
 my $decoder =  
  guess_encoding($data, qw/euc-cn
                           euc-jp shiftjis 7bit-jis
                           euc-kr
                           big5-eten/);</pre>
</li>

<li>DO NOT PUT TOO MANY SUSPECTS! Don&#39;t you try something like this!
<pre>  my $decoder = guess_encoding($data, 
                               Encode-&#62;encodings(&#34;:all&#34;));</pre>
</li>
</ul>

<p>It is, after all, just a guess. You should alway be explicit when it comes to encodings. But there are some, especially Japanese, environment that guess-coding is a must. Use this module with care.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TO_DO"
>TO DO</a></h1>

<p>Encode::Guess does not work on EBCDIC platforms.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../Encode.html" class="podlinkpod"
>Encode</a>, <a href="../Encode/Encoding.html" class="podlinkpod"
>Encode::Encoding</a></p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
