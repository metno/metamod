<html><head><title>Devel::Cover::Tutorial</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:16 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#TUTORIAL'>TUTORIAL</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#1.0_Introduction'>1.0 Introduction</a>
    <li class='indexItem indexItem2'><a href='#2.0_Metrics'>2.0 Metrics</a>
    <li class='indexItem indexItem2'><a href='#2.1_Statement_coverage'>2.1 Statement coverage</a>
    <li class='indexItem indexItem2'><a href='#2.2_Branch_coverage'>2.2 Branch coverage</a>
    <li class='indexItem indexItem2'><a href='#2.3_Path_coverage'>2.3 Path coverage</a>
    <li class='indexItem indexItem2'><a href='#2.4_Expression_coverage'>2.4 Expression coverage</a>
    <li class='indexItem indexItem2'><a href='#3.0_Other_considerations'>3.0 Other considerations</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#LICENCE'>LICENCE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Devel::Cover::Tutorial - An introduction to code coverage</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>version 1.08</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TUTORIAL"
>TUTORIAL</a></h1>

<p>Here&#39;s part of a message I sent to perl-qa about code coverage metrics.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="1.0_Introduction"
>1.0 Introduction</a></h2>

<p>It is wise to remember the following quote from Dijkstra,
who said:</p>

<pre>  Testing never proves the absence of faults, it only shows their presence.</pre>

<p>In particular, code coverage is just one weapon in the software engineer&#39;s testing arsenal.</p>

<p>Any discussion of code coverage metrics is hampered by the fact that many authors use different terms to describe the same kind of coverage. Here, I shall provide only a brief introduction to some of the most common metrics.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="2.0_Metrics"
>2.0 Metrics</a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="2.1_Statement_coverage"
>2.1 Statement coverage</a></h2>

<p>This is the most basic form of code coverage. A statement is covered if it is executed. Note that statement != line of code. Multiple statements on a single line can confuse issues - the reporting if nothing else.</p>

<p>Where there are sequences of statements without branches it is not necessary to count the execution of every statement, just one will suffice, but people often like the count of every line to be reported, especially in summary statistics. However it is not clear to me that this is actually useful.</p>

<p>This type of coverage is fairly weak in that even with 100% statement coverage there may still be serious problems in a program which could be discovered through other types of metric.</p>

<p>It can be quite difficult to achieve 100% statement coverage. There may be sections of code designed to deal with error conditions, or rarely occurring events such as a signal received during a certain section of code. There may also be code that should never be executed:</p>

<pre>  if ($param &#62; 20)
  {
    die &#34;This should never happen!&#34;;
  }</pre>

<p>It can be useful to mark such code in some way and flag an error if it is executed.</p>

<p>Statement coverage, or something very similar, can be called statement execution, line, block, basic block or segment coverage. I tend to favour block coverage which does not attempt to extend its results to each statement.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="2.2_Branch_coverage"
>2.2 Branch coverage</a></h2>

<p>The goal of branch coverage is to ensure that whenever a program can jump, it jumps to all possible destinations. The most simple example is a complete if statement:</p>

<pre>  if ($x)
  {
    print &#34;a&#34;;
  }
  else
  {
    print &#34;b&#34;;
  }</pre>

<p>In such a simple example statement coverage is as powerful, but branch coverage should also allow for the case where the else part is missing:</p>

<pre>  if ($x)
  {
    print &#34;a&#34;;
  }</pre>

<p>Full coverage is only achieved here if $x is true on one occasion and false on another.</p>

<p>100% branch coverage implies 100% statement coverage.</p>

<p>Branch coverage is also called decision or all edges coverage.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="2.3_Path_coverage"
>2.3 Path coverage</a></h2>

<p>There are classes of errors that branch coverage cannot detect, such as:</p>

<pre>  $h = undef;
  if ($x)
  {
    $h = { a =&#62; 1 };
  }
  if ($y)
  {
    print $h-&#62;{a};
  }</pre>

<p>100% branch coverage can be achieved by setting ($x, $y) to (1, 1) and then to (0, 0). But if we have (0, 1) then things go bang.</p>

<p>The purpose of path coverage is to ensure that all paths through the program are taken. In any reasonably sized program there will be an enormous number of paths through the program and so in practice the paths can be limited to a single subroutine, if the subroutine is not too big, or simply to two consecutive branches.</p>

<p>In the above example there are four paths which correspond to the truth table for $x and $y. To achieve 100% path coverage they must all be taken. Note that missing elses count as paths.</p>

<p>In some cases it may be impossible to achieve 100% path coverage:</p>

<pre>  a if $x;
  b;
  c if $x;</pre>

<p>50% path coverage is the best you can get here.</p>

<p>Loops also contribute to paths, and pose their own problems which I&#39;ll ignore for now.</p>

<p>100% path coverage implies 100% branch coverage.</p>

<p>Path coverage and some of its close cousins, are also known as predicate, basis path and LCSAJ (Linear Code Sequence and Jump) coverage.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="2.4_Expression_coverage"
>2.4 Expression coverage</a></h2>

<p>When a boolean expression is evaluated it can be useful to ensure that all the terms in the expression are exercised. For example:</p>

<pre>  a if $x || $y</pre>

<p>The expression should be exercised with ($x, $y) set to (0, 0) (required for branch coverage), (0, 1) and (1, 0) (to ensure that $x and $y are independent) and possibly with (1, 1).</p>

<p>Expression coverage gets complicated, and difficult to achieve, as the expression gets complicated.</p>

<p>Expressions which are not directly a part of a branching construct should also be covered:</p>

<pre>  $z = $x || $y;
  a if $z;</pre>

<p>Expression coverage is also known as condition, condition-decision and multiple decision coverage.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="3.0_Other_considerations"
>3.0 Other considerations</a></h2>

<p>In order to get people to actually use code coverage it needs to be simple to use. It should also be simple to understand the results and to rectify any problems thrown up. Finally, if the overhead is too great it won&#39;t get used either.</p>

<p>So there&#39;s a basic tutorial on code coverage, or at least my version of it. Typing a few of these terms into google will probably provide a basis for future research.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENCE"
>LICENCE</a></h1>

<p>Copyright 2001-2013, Paul Johnson (paul@pjcj.net)</p>

<p>This software is free. It is licensed under the same terms as Perl itself.</p>

<p>The latest version of this software should be available from my homepage: http://www.pjcj.net</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
