<html><head><title>Digest::SHA1</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:16 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#FUNCTIONS'>FUNCTIONS</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Digest::SHA1 - Perl interface to the SHA-1 algorithm</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre> # Functional style
 use Digest::SHA1  qw(sha1 sha1_hex sha1_base64);

 $digest = sha1($data);
 $digest = sha1_hex($data);
 $digest = sha1_base64($data);
 $digest = sha1_transform($data);


 # OO style
 use Digest::SHA1;

 $sha1 = Digest::SHA1-&#62;new;

 $sha1-&#62;add($data);
 $sha1-&#62;addfile(*FILE);

 $sha1_copy = $sha1-&#62;clone;

 $digest = $sha1-&#62;digest;
 $digest = $sha1-&#62;hexdigest;
 $digest = $sha1-&#62;b64digest;
 $digest = $sha1-&#62;transform;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>The <code>Digest::SHA1</code> module allows you to use the NIST SHA-1 message digest algorithm from within Perl programs. The algorithm takes as input a message of arbitrary length and produces as output a 160-bit &#34;fingerprint&#34; or &#34;message digest&#34; of the input.</p>

<p>In 2005, security flaws were identified in SHA-1, namely that a possible mathematical weakness might exist, indicating that a stronger hash function would be desirable. The <a href="../Digest/SHA.html" class="podlinkpod"
>Digest::SHA</a> module implements the stronger algorithms in the SHA family.</p>

<p>The <code>Digest::SHA1</code> module provide a procedural interface for simple use, as well as an object oriented interface that can handle messages of arbitrary length and which can read files directly.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FUNCTIONS"
>FUNCTIONS</a></h1>

<p>The following functions can be exported from the <code>Digest::SHA1</code> module. No functions are exported by default.</p>

<dl>
<dt><a name="sha1($data,...)"
>sha1($data,...)</a></dt>

<dd>
<p>This function will concatenate all arguments, calculate the SHA-1 digest of this &#34;message&#34;, and return it in binary form. The returned string will be 20 bytes long.</p>

<p>The result of sha1(&#34;a&#34;, &#34;b&#34;, &#34;c&#34;) will be exactly the same as the result of sha1(&#34;abc&#34;).</p>

<dt><a name="sha1_hex($data,...)"
>sha1_hex($data,...)</a></dt>

<dd>
<p>Same as sha1(), but will return the digest in hexadecimal form. The length of the returned string will be 40 and it will only contain characters from this set: &#39;0&#39;..&#39;9&#39; and &#39;a&#39;..&#39;f&#39;.</p>

<dt><a name="sha1_base64($data,...)"
>sha1_base64($data,...)</a></dt>

<dd>
<p>Same as sha1(), but will return the digest as a base64 encoded string. The length of the returned string will be 27 and it will only contain characters from this set: &#39;A&#39;..&#39;Z&#39;, &#39;a&#39;..&#39;z&#39;, &#39;0&#39;..&#39;9&#39;, &#39;+&#39; and &#39;/&#39;.</p>

<p>Note that the base64 encoded string returned is not padded to be a multiple of 4 bytes long. If you want interoperability with other base64 encoded sha1 digests you might want to append the redundant string &#34;=&#34; to the result.</p>

<dt><a name="sha1_transform($data)"
>sha1_transform($data)</a></dt>

<dd>
<p>Implements the basic SHA1 transform on a 64 byte block. The $data argument and the returned $digest are in binary form. This algorithm is used in NIST FIPS 186-2</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<p>The object oriented interface to <code>Digest::SHA1</code> is described in this section. After a <code>Digest::SHA1</code> object has been created, you will add data to it and finally ask for the digest in a suitable format. A single object can be used to calculate multiple digests.</p>

<p>The following methods are provided:</p>

<dl>
<dt><a name="$sha1_=_Digest::SHA1-&#62;new"
>$sha1 = Digest::SHA1-&#62;new</a></dt>

<dd>
<p>The constructor returns a new <code>Digest::SHA1</code> object which encapsulate the state of the SHA-1 message-digest algorithm.</p>

<p>If called as an instance method (i.e. $sha1-&#62;new) it will just reset the state the object to the state of a newly created object. No new object is created in this case.</p>

<dt><a name="$sha1-&#62;reset"
>$sha1-&#62;reset</a></dt>

<dd>
<p>This is just an alias for $sha1-&#62;new.</p>

<dt><a name="$sha1-&#62;clone"
>$sha1-&#62;clone</a></dt>

<dd>
<p>This a copy of the $sha1 object. It is useful when you do not want to destroy the digests state, but need an intermediate value of the digest, e.g. when calculating digests iteratively on a continuous data stream. Example:</p>

<pre>    my $sha1 = Digest::SHA1-&#62;new;
    while (&#60;&#62;) {
        $sha1-&#62;add($_);
        print &#34;Line $.: &#34;, $sha1-&#62;clone-&#62;hexdigest, &#34;\n&#34;;
    }</pre>

<dt><a name="$sha1-&#62;add($data,...)"
>$sha1-&#62;add($data,...)</a></dt>

<dd>
<p>The $data provided as argument are appended to the message we calculate the digest for. The return value is the $sha1 object itself.</p>

<p>All these lines will have the same effect on the state of the $sha1 object:</p>

<pre>    $sha1-&#62;add(&#34;a&#34;); $sha1-&#62;add(&#34;b&#34;); $sha1-&#62;add(&#34;c&#34;);
    $sha1-&#62;add(&#34;a&#34;)-&#62;add(&#34;b&#34;)-&#62;add(&#34;c&#34;);
    $sha1-&#62;add(&#34;a&#34;, &#34;b&#34;, &#34;c&#34;);
    $sha1-&#62;add(&#34;abc&#34;);</pre>

<dt><a name="$sha1-&#62;addfile($io_handle)"
>$sha1-&#62;addfile($io_handle)</a></dt>

<dd>
<p>The $io_handle will be read until EOF and its content appended to the message we calculate the digest for. The return value is the $sha1 object itself.</p>

<p>The addfile() method will croak() if it fails reading data for some reason. If it croaks it is unpredictable what the state of the $sha1 object will be in. The addfile() method might have been able to read the file partially before it failed. It is probably wise to discard or reset the $sha1 object if this occurs.</p>

<p>In most cases you want to make sure that the $io_handle is in <code>binmode</code> before you pass it as argument to the addfile() method.</p>

<dt><a name="$sha1-&#62;add_bits($data,_$nbits)"
>$sha1-&#62;add_bits($data, $nbits)</a></dt>

<dd>
<dt><a name="$sha1-&#62;add_bits($bitstring)"
>$sha1-&#62;add_bits($bitstring)</a></dt>

<dd>
<p>This implementation of SHA-1 only supports byte oriented input so you might only add bits as multiples of 8. If you need bit level support please consider using the <code>Digest::SHA</code> module instead. The add_bits() method is provided here for compatibility with other digest implementations. See <a href="../Digest.html" class="podlinkpod"
>Digest</a> for description of the arguments that add_bits() take.</p>

<dt><a name="$sha1-&#62;digest"
>$sha1-&#62;digest</a></dt>

<dd>
<p>Return the binary digest for the message. The returned string will be 20 bytes long.</p>

<p>Note that the <code>digest</code> operation is effectively a destructive, read-once operation. Once it has been performed, the <code>Digest::SHA1</code> object is automatically <code>reset</code> and can be used to calculate another digest value. Call $sha1-&#62;clone-&#62;digest if you want to calculate the digest without reseting the digest state.</p>

<dt><a name="$sha1-&#62;hexdigest"
>$sha1-&#62;hexdigest</a></dt>

<dd>
<p>Same as $sha1-&#62;digest, but will return the digest in hexadecimal form. The length of the returned string will be 40 and it will only contain characters from this set: &#39;0&#39;..&#39;9&#39; and &#39;a&#39;..&#39;f&#39;.</p>

<dt><a name="$sha1-&#62;b64digest"
>$sha1-&#62;b64digest</a></dt>

<dd>
<p>Same as $sha1-&#62;digest, but will return the digest as a base64 encoded string. The length of the returned string will be 27 and it will only contain characters from this set: &#39;A&#39;..&#39;Z&#39;, &#39;a&#39;..&#39;z&#39;, &#39;0&#39;..&#39;9&#39;, &#39;+&#39; and &#39;/&#39;.</p>

<p>The base64 encoded string returned is not padded to be a multiple of 4 bytes long. If you want interoperability with other base64 encoded SHA-1 digests you might want to append the string &#34;=&#34; to the result.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../Digest.html" class="podlinkpod"
>Digest</a>, <a href="../Digest/HMAC_SHA1.html" class="podlinkpod"
>Digest::HMAC_SHA1</a>, <a href="../Digest/SHA.html" class="podlinkpod"
>Digest::SHA</a>, <a href="../Digest/MD5.html" class="podlinkpod"
>Digest::MD5</a></p>

<p>http://www.itl.nist.gov/fipspubs/fip180-1.htm</p>

<p>http://en.wikipedia.org/wiki/SHA_hash_functions</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<pre> Copyright 1999-2004 Gisle Aas.
 Copyright 1997 Uwe Hollerbach.</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<p>Peter C. Gutmann, Uwe Hollerbach &#60;uh@alumni.caltech.edu&#62;, Gisle Aas &#60;gisle@aas.no&#62;</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
