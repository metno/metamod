<html><head><title>Data::Visitor</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:04 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <li class='indexItem indexItem1'><a href='#RETURN_VALUE'>RETURN VALUE</a>
  <li class='indexItem indexItem1'><a href='#SUBCLASSING'>SUBCLASSING</a>
  <li class='indexItem indexItem1'><a href='#TODO'>TODO</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Data::Visitor - Visitor style traversal of Perl data structures</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>version 0.28</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>        # NOTE
        # You probably want to use Data::Visitor::Callback for trivial things

        package FooCounter;
        use Moose;

        extends qw(Data::Visitor);

        has number_of_foos =&#62; (
                isa =&#62; &#34;Int&#34;,
                is  =&#62; &#34;rw&#34;,
                default =&#62; 0,
        );

        sub visit_value {
                my ( $self, $data ) = @_;

                if ( defined $data and $data eq &#34;foo&#34; ) {
                        $self-&#62;number_of_foos( $self-&#62;number_of_foos + 1 );
                }

                return $data;
        }

        my $counter = FooCounter-&#62;new;

        $counter-&#62;visit( {
                this =&#62; &#34;that&#34;,
                some_foos =&#62; [ qw/foo foo bar foo/ ],
                the_other =&#62; &#34;foo&#34;,
        });

        $counter-&#62;number_of_foos; # this is now 4</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This module is a simple visitor implementation for Perl values.</p>

<p>It has a main dispatcher method, <code>visit</code>, which takes a single perl value and then calls the methods appropriate for that value.</p>

<p>It can recursively map (cloning as necessary) or just traverse most structures, with support for per object behavior, circular structures, visiting tied structures, and all ref types (hashes, arrays, scalars, code, globs).</p>

<p><a href="../Data/Visitor.html" class="podlinkpod"
>Data::Visitor</a> is meant to be subclassed, but also ships with a callback driven subclass, <a href="../Data/Visitor/Callback.html" class="podlinkpod"
>Data::Visitor::Callback</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<dl>
<dt><a name="visit_$data"
>visit $data</a></dt>

<dd>
<p>This method takes any Perl value as it&#39;s only argument, and dispatches to the various other visiting methods using <code>visit_no_rec_check</code>, based on the data&#39;s type.</p>

<p>If the value is a reference and has already been seen then <code>visit_seen</code> is called.</p>

<dt><a name="visit_seen_$data,_$first_result"
>visit_seen $data, $first_result</a></dt>

<dd>
<p>When an already seen value is encountered again it&#39;s typically replaced with the result of the first visitation of that value. The value and the result of the first visitation are passed as arguments.</p>

<p>Returns <code>$first_result</code>.</p>

<dt><a name="visit_no_rec_check_$data"
>visit_no_rec_check $data</a></dt>

<dd>
<p>Called for any value that has not yet been seen. Does the actual type based dispatch for <code>visit</code>.</p>

<p>Should not be called directly unless forcing a circular structure to be unfolded. Use with caution as this may cause infinite recursion.</p>

<dt><a name="visit_object_$object"
>visit_object $object</a></dt>

<dd>
<p>If the value is a blessed object, <code>visit</code> calls this method. The base implementation will just forward to <code>visit_value</code>.</p>

<dt><a name="visit_ref_$value"
>visit_ref $value</a></dt>

<dd>
<p>Generic recursive visitor. All non blessed values are given to this.</p>

<p><code>visit_object</code> can delegate to this method in order to visit the object anyway.</p>

<p>This will check if the visitor can handle <code>visit_$reftype</code> (lowercase), and if not delegate to <code>visit_value</code> instead.</p>

<dt><a name="visit_array_$array_ref"
>visit_array $array_ref</a></dt>

<dd>
<dt><a name="visit_hash_$hash_ref"
>visit_hash $hash_ref</a></dt>

<dd>
<dt><a name="visit_glob_$glob_ref"
>visit_glob $glob_ref</a></dt>

<dd>
<dt><a name="visit_code_$code_ref"
>visit_code $code_ref</a></dt>

<dd>
<dt><a name="visit_scalar_$scalar_ref"
>visit_scalar $scalar_ref</a></dt>

<dd>
<p>These methods are called for the corresponding container type.</p>

<dt><a name="visit_value_$value"
>visit_value $value</a></dt>

<dd>
<p>If the value is anything else, this method is called. The base implementation will return $value.</p>

<dt><a name="visit_hash_entries_$hash"
>visit_hash_entries $hash</a></dt>

<dd>
<dt><a name="visit_hash_entry_$key,_$value,_$hash"
>visit_hash_entry $key, $value, $hash</a></dt>

<dd>
<p>Delegates to <code>visit_hash_key</code> and <code>visit_hash_value</code>. The value is passed as <code>$_[2]</code> so that it is aliased.</p>

<dt><a name="visit_hash_key_$key,_$value,_$hash"
>visit_hash_key $key, $value, $hash</a></dt>

<dd>
<p>Calls <code>visit</code> on the key and returns it.</p>

<dt><a name="visit_hash_value_$value,_$key,_$hash"
>visit_hash_value $value, $key, $hash</a></dt>

<dd>
<p>The value will be aliased (passed as <code>$_[1]</code>).</p>

<dt><a name="visit_array_entries_$array"
>visit_array_entries $array</a></dt>

<dd>
<dt><a name="visit_array_entry_$value,_$index,_$array"
>visit_array_entry $value, $index, $array</a></dt>

<dd>
<p>Delegates to <code>visit</code> on value. The value is passed as <code>$_[1]</code> to retain aliasing.</p>

<dt><a name="visit_tied_$object,_$var"
>visit_tied $object, $var</a></dt>

<dd>
<p>When <code>tied_as_objects</code> is enabled and a tied variable (hash, array, glob or scalar) is encountered this method will be called on the tied object. If a valid mapped value is returned, the newly constructed result container will be tied to the return value and no iteration of the contents of the data will be made (since all storage is delegated to the tied object).</p>

<p>If a non blessed value is returned from <code>visit_tied</code> then the structure will be iterated normally, and the result container will not be tied at all.</p>

<p>This is because tying to the same class and performing the tie operations will not yield the same results in many cases.</p>

<dt><a name="retain_magic_$orig,_$copy"
>retain_magic $orig, $copy</a></dt>

<dd>
<p>Copies over magic from <code>$orig</code> to <code>$copy</code>.</p>

<p>Currently only handles <code>bless</code>. In the future this might be expanded using <a href="../Variable/Magic.html" class="podlinkpod"
>Variable::Magic</a> but it isn&#39;t clear what the correct semantics for magic copying should be.</p>

<dt><a name="trace"
>trace</a></dt>

<dd>
<p>Called if the <code>DEBUG</code> constant is set with a trace message.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="RETURN_VALUE"
>RETURN VALUE</a></h1>

<p>This object can be used as an <code>fmap</code> of sorts - providing an ad-hoc functor interface for Perl data structures.</p>

<p>In void context this functionality is ignored, but in any other context the default methods will all try to return a value of similar structure, with it&#39;s children also fmapped.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SUBCLASSING"
>SUBCLASSING</a></h1>

<p>Data::Visitor is a <a href="../Moose.html" class="podlinkpod"
>Moose</a> class, so it should be subclassed using Moose.</p>

<p>Then override the callback methods in any way you like. To retain visitor behavior, make sure to retain the functionality of <code>visit_array</code> and <code>visit_hash</code>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TODO"
>TODO</a></h1>

<ul>
<li>Add support for &#34;natural&#34; visiting of trees.</li>

<li>Expand <code>retain_magic</code> to support tying at the very least, or even more with <a href="../Variable/Magic.html" class="podlinkpod"
>Variable::Magic</a> if possible.</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../Data/Rmap.html" class="podlinkpod"
>Data::Rmap</a>, <a href="../Tree/Simple/VisitorFactory.html" class="podlinkpod"
>Tree::Simple::VisitorFactory</a>, <a href="../Data/Traverse.html" class="podlinkpod"
>Data::Traverse</a></p>

<p><a href="http://en.wikipedia.org/wiki/Visitor_pattern" class="podlinkurl"
>http://en.wikipedia.org/wiki/Visitor_pattern</a>, <a href="http://www.ninebynine.org/Software/Learning-Haskell-Notes.html#functors" class="podlinkurl"
>http://www.ninebynine.org/Software/Learning-Haskell-Notes.html#functors</a>, <a href="http://en.wikipedia.org/wiki/Functor" class="podlinkurl"
>http://en.wikipedia.org/wiki/Functor</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<ul>
<li>Yuval Kogman &#60;nothingmuch@woobling.org&#62;</li>

<li>Marcel Gr&#252;nauer &#60;marcel@cpan.org&#62;</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>This software is copyright (c) 2012 by Yuval Kogman.</p>

<p>This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
