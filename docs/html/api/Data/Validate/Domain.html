<html><head><title>Data::Validate::Domain</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:04 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#FUNCTIONS'>FUNCTIONS</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#ACKNOWLEDGEMENTS'>ACKNOWLEDGEMENTS</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Data::Validate::Domain - domain validation methods</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use Data::Validate::Domain qw(is_domain);
 
  # as a function 
  my $test = is_domain($suspect);
  die &#34;$test is not a domain&#34; unless defined $test;

  or

  my $test = is_domain($suspect,\%options);
  die &#34;$test is not a domain&#34; unless defined $test;
  

  # or as an object
  my $v = Data::Validate::Domain-&#62;new(%options);

  my $test = $v-&#62;is_domain($suspect);
  die &#34;$test is not a domain&#34; unless defined $test;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This module collects domain validation routines to make input validation, and untainting easier and more readable.</p>

<p>All functions return an untainted value if the test passes, and undef if it fails. This means that you should always check for a defined status explicitly. Don&#39;t assume the return will be true. (e.g. is_username(&#39;0&#39;))</p>

<p>The value to test is always the first (and often only) argument.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FUNCTIONS"
>FUNCTIONS</a></h1>

<dl>
<dt><a name="new_-_constructor_for_OO_usage"
><b>new</b> - constructor for OO usage</a></dt>

<dd>
<pre>  $obj = Data::Validate::Domain-&#62;new();
  my %options = (
                domain_allow_underscore =&#62; 1,
  );

  or

  my %options = (
                domain_allow_single_label =&#62; 1,
                domain_private_tld =&#62; {
                        &#39;privatetld1 &#39;   =&#62;      1,
                        &#39;privatetld2&#39;    =&#62;      1,
                }
  );

  or

  my %options = (
                domain_allow_single_label =&#62; 1,
                domain_private_tld        =&#62; qr /^(?:privatetld1|privatetld2)$/,
  );




  $obj = Data::Validate::Domain-&#62;new(%options);</pre>

<dl>
<dt><a name="Description"
><i>Description</i></a></dt>

<dd>
<p>Returns a Data::Validator::Domain object. This lets you access all the validator function calls as methods without importing them into your namespace or using the clumsy Data::Validate::Domain::function_name() format.</p>

<dt><a name="Options"
><i>Options</i></a></dt>

<dd>
<dl>
<dt><a name="domain_allow_underscore"
><b>domain_allow_underscore</b></a></dt>

<dd>
<p>According to RFC underscores are forbidden in &#34;hostnames&#34; but not &#34;domainnames&#34;. By default is_domain,is_domain_label, and is_hostname will fail if you include underscores, setting this to a true value with authorize the use of underscores in all functions.</p>

<dt><a name="domain_allow_single_label"
><b>domain_allow_single_label</b></a></dt>

<dd>
<p>By default is_domain will fail if you ask it to verify a domain that only has a single label i.e. &#39;neely.cx&#39; is good, but &#39;com&#39; would fail. If you set this option to a true value then is_domain will allow single label domains through. This is most likely to be useful in combination with <b>domain_private_tld</b></p>

<dt><a name="domain_private_tld"
><b>domain_private_tld</b></a></dt>

<dd>
<p>By default is_domain requires all domains to have a valid TLD (i.e. com, net, org, uk, etc), this is verified using the Net::Domain::TLD module. This behavior can be extended in two different ways. Either a hash reference can be supplied keyed by the additional TLD&#39;s, or you can supply a precompiled regular expression.</p>

<p>NOTE: The TLD is normalized to the lower case form prior to the check being done. This is done only for the TLD check, and does not alter the output in any way.</p>

<pre>        The hash reference example:     

                domain_private_tld =&#62; {
                        &#39;privatetld1 &#39;   =&#62;      1,
                        &#39;privatetld2&#39;    =&#62;      1,
                }

        The precompiled regualar expression example:

                domain_private_tld        =&#62; qr /^(?:privatetld1|privatetld2)$/,</pre>
</dd>
</dl>

<dt><a name="Returns"
><i>Returns</i></a></dt>

<dd>
<p>Returns a Data::Validate::Domain object</p>
</dd>
</dl>

<dt><a name="is_domain_-_does_the_value_look_like_a_domain_name?"
><b>is_domain</b> - does the value look like a domain name?</a></dt>

<dd>
<pre>  is_domain($value);
  or
  $obj-&#62;is_domain($value);
  or
  is_domain($value,\%options);
  or
  $obj-&#62;is_domain($value,\%options);</pre>

<dl>
<dt><a name="Description"
><i>Description</i></a></dt>

<dd>
<p>Returns the untainted domain name if the test value appears to be a well-formed domain name.</p>

<p>Note: See <b>new</b> for list of options and how those alter the behavior of this funciton.</p>

<dt><a name="Arguments"
><i>Arguments</i></a></dt>

<dd>
<dl>
<dt><a name="$value"
>$value</a></dt>

<dd>
<p>The potential domain to test.</p>
</dd>
</dl>

<dt><a name="Returns"
><i>Returns</i></a></dt>

<dd>
<p>Returns the untainted domain on success, undef on failure.</p>

<dt><a name="Notes,_Exceptions,_&#38;_Bugs"
><i>Notes, Exceptions, &#38; Bugs</i></a></dt>

<dd>
<p>The function does not make any attempt to check whether a domain actually exists. It only looks to see that the format is appropriate.</p>

<p>A dotted quad (such as 127.0.0.1) is not considered a domain and will return false. See <a href="../../Data/Validate/IP(3).html" class="podlinkpod"
>Data::Validate::IP(3)</a> for IP Validation.</p>

<p>Performs a lookup via Net::Domain::TLD to verify that the TLD is valid for this domain.</p>

<p>Does not consider &#34;domain.com.&#34; a valid format.</p>

<dt><a name="From_RFC_952"
><i>From RFC 952</i></a></dt>

<dd>
<pre>   A &#34;name&#34; (Net, Host, Gateway, or Domain name) is a text string up
   to 24 characters drawn from the alphabet (A-Z), digits (0-9), minus
   sign (-), and period (.).  Note that periods are only allowed when
   they serve to delimit components of &#34;domain style names&#34;.

   No blank or space characters are permitted as part of a
   name. No distinction is made between upper and lower case.  The first
   character must be an alpha character [Relaxed in RFC 1123] .  The last 
   character must not be a minus sign or period.</pre>

<dt><a name="From_RFC_1035"
><i>From RFC 1035</i></a></dt>

<dd>
<pre>    labels          63 octets or less
    names           255 octets or less

    [snip] limit the label to 63 octets or less.

    To simplify implementations, the total length of a domain name (i.e.,
    label octets and label length octets) is restricted to 255 octets or
    less.</pre>

<dt><a name="From_RFC_1123"
><i>From RFC 1123</i></a></dt>

<dd>
<pre>    One aspect of host name syntax is hereby changed: the
    restriction on the first character is relaxed to allow either a
    letter or a digit.  Host software MUST support this more liberal
    syntax.

    Host software MUST handle host names of up to 63 characters and
    SHOULD handle host names of up to 255 characters.</pre>
</dd>
</dl>

<dt><a name="is_hostname_-_does_the_value_look_like_a_hostname"
><b>is_hostname</b> - does the value look like a hostname</a></dt>

<dd>
<pre>  is_hostname($value);
  or
  $obj-&#62;is_hostname($value);
  or
  is_hostname($value,\%options);
  or
  $obj-&#62;is_hostname($value,\%options);</pre>

<dl>
<dt><a name="Description"
><i>Description</i></a></dt>

<dd>
<p>Returns the untainted hostname if the test value appears to be a well-formed hostname.</p>

<p>Note: See <b>new</b> for list of options and how those alter the behavior of this funciton.</p>

<dt><a name="Arguments"
><i>Arguments</i></a></dt>

<dd>
<dl>
<dt><a name="$value"
>$value</a></dt>

<dd>
<p>The potential hostname to test.</p>
</dd>
</dl>

<dt><a name="Returns"
><i>Returns</i></a></dt>

<dd>
<p>Returns the untainted hostname on success, undef on failure.</p>

<dt><a name="Notes,_Exceptions,_&#38;_Bugs"
><i>Notes, Exceptions, &#38; Bugs</i></a></dt>

<dd>
<p>The function does not make any attempt to check whether a hostname actually exists. It only looks to see that the format is appropriate.</p>

<p>Functions much like is_domain, except that it does not verify whether or not a valid TLD has been supplied and allows for there to only be a single component of the hostname (i.e www)</p>

<p>Hostnames might or might not have a valid TLD attached.</p>
</dd>
</dl>

<dt><a name="is_domain_label_-_does_the_value_look_like_a_domain_label?"
><b>is_domain_label</b> - does the value look like a domain label?</a></dt>

<dd>
<pre>  is_domain_label($value);
  or
  $obj-&#62;is_domain_label($value);
  or
  is_domain_label($value,\%options);
  or
  $obj-&#62;is_domain_label($value,\%options);</pre>

<dl>
<dt><a name="Description"
><i>Description</i></a></dt>

<dd>
<p>Returns the untainted domain label if the test value appears to be a well-formed domain label.</p>

<p>Note: See <b>new</b> for list of options and how those alter the behavior of this funciton.</p>

<dt><a name="Arguments"
><i>Arguments</i></a></dt>

<dd>
<dl>
<dt><a name="$value"
>$value</a></dt>

<dd>
<p>The potential ip to test.</p>
</dd>
</dl>

<dt><a name="Returns"
><i>Returns</i></a></dt>

<dd>
<p>Returns the untainted domain label on success, undef on failure.</p>

<dt><a name="Notes,_Exceptions,_&#38;_Bugs"
><i>Notes, Exceptions, &#38; Bugs</i></a></dt>

<dd>
<p>The function does not make any attempt to check whether a domain label actually exists. It only looks to see that the format is appropriate.</p>
</dd>
</dl>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><b>[RFC 1034] [RFC 1035] [RFC 2181] [RFC 1123]</b></p>

<dl>
<dt><a name="Data::Validate(3)"
><a href="../../Data/Validate(3).html" class="podlinkpod"
>Data::Validate(3)</a></a></dt>

<dd>
<dt><a name="Data::Validate::IP(3)"
><a href="../../Data/Validate/IP(3).html" class="podlinkpod"
>Data::Validate::IP(3)</a></a></dt>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Neil Neely &#60;<em>neil@neely.cx</em>&#62;.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ACKNOWLEDGEMENTS"
>ACKNOWLEDGEMENTS</a></h1>

<p>Thanks to Richard Sonnen &#60;<em>sonnen@richardsonnen.com</em>&#62; for writing the Data::Validate module.</p>

<p>Thanks to Len Reed &#60;<em>lreed@levanta.com</em>&#62; for helping develop the options mechanism for Data::Validate modules.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>Copyright (c) 2005-2007 Neil Neely.</p>

<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself, either Perl version 5.8.2 or, at your option, any later version of Perl 5 you may have available.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
