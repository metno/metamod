<html><head><title>Data::Compare::Plugins</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:04 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#FINDING_PLUGINS'>FINDING PLUGINS</a>
  <li class='indexItem indexItem1'><a href='#WRITING_PLUGINS'>WRITING PLUGINS</a>
  <li class='indexItem indexItem1'><a href='#DISTRIBUTION'>DISTRIBUTION</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Data::Compare::Plugins - how to extend Data::Compare</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Data::Compare natively handles several built-in data types - scalars,
references to scalars,
references to arrays,
references to hashes,
references to subroutines,
compiled regular expressions,
and globs.
For objects,
it tries to Do The Right Thing and compares the underlying data type.
However,
this is not always what you want.
This is especially true if you have complex objects which overload stringification and/or numification.</p>

<p>Hence we allow for plugins.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FINDING_PLUGINS"
>FINDING PLUGINS</a></h1>

<p>Data::Compare will try to load any module installed on your system under the various @INC/Data/Compare/Plugins/ directories.
If there is a problem loading any of them,
an appropriate warning will be issued.</p>

<p>Because of how we find plugins,
no plugins are available when running in &#34;taint&#34; mode.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="WRITING_PLUGINS"
>WRITING PLUGINS</a></h1>

<p>Internally,
plugins are <code>require</code>d into Data::Compare.
This means that they need to evaluate to true.
We make use of that true value.
Where normally you just put:</p>

<pre>    1;</pre>

<p>at the end of an included file, you should instead ensure that you return a reference to an array. This is treated as being true so satisfies perl, and is a damned sight more useful.</p>

<p>Inside that array should be either a description of what this plugin is to do, or references to several arrays containing such descriptions. A description consists of two or three items. First a string telling us what the first data-type handled by your plugin is. Second, (and optional, defaulting to the same as the first) the second data-type to compare. To handle comparisons to ordinary scalars, give the empty string for the data-type, ie:</p>

<pre>    [&#39;MyType&#39;, &#39;&#39;, sub { ...}]</pre>

<p>Third and last, we need a reference to the subroutine which does the comparison. That subroutine should expect to take two parameters, which will be of the specified type. It should return 1 if they compare the same, or 0 if they compare different.</p>

<p>Be aware that while you might give a description like:</p>

<pre>    [&#39;Type1&#39;, &#39;Type2&#39;, sub { ... }]</pre>

<p>this will handle both comparing Type1 to Type2, and comparing Type2 to Type1. ie, comparison is commutative.</p>

<p>If you want to use Data::Compare&#39;s own comparison function from within your handler (to, for example, compare a data structure that you have stored somewhere in your object) then you will need to call it as Data::Compare::Compare. However, you must be careful to avoid infinite recursion by calling D::C::Compare which in turn calls back to your handler.</p>

<p>The name of your plugins does not matter, only that it lives in one of those directories. Of course, giving it a sensible name means that the usual installation mechanisms will put it in the right place, and meaningful names will make it easier to debug your code.</p>

<p>For an example, look at the plugin that handles Scalar::Properties objects, which is distributed with Data::Compare.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DISTRIBUTION"
>DISTRIBUTION</a></h1>

<p>Provided that the above rules are followed I see no reason for you to not upload your plugin to the CPAN yourself. You will need to make Data::Compare a pre-requisite, so that the CPAN.pm installer does the right thing.</p>

<p>Alternatively, if you would prefer me to roll your plugin in with the Data::Compare distribution, I&#39;d be happy to do so provided that the code is clear and well-commented, and that you include tests and documentation.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../../Data/Compare.html" class="podlinkpod"
>Data::Compare</a></p>

<p><a href="../../Data/Compare/Plugins/Scalar/Properties.html" class="podlinkpod"
>Data::Compare::Plugins::Scalar::Properties</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Copyright (c) 2004 David Cantrell &#60;david@cantrell.org.uk&#62;. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
