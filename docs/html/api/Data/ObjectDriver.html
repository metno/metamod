<html><head><title>Data::ObjectDriver</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:04 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#METHODOLOGY'>METHODOLOGY</a>
  <li class='indexItem indexItem1'><a href='#HOW_IS_IT_DIFFERENT%3F'>HOW IS IT DIFFERENT?</a>
  <li class='indexItem indexItem1'><a href='#USAGE'>USAGE</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Class-%3Elookup(%24id)'>Class-&#62;lookup($id)</a>
    <li class='indexItem indexItem2'><a href='#Class-%3Elookup_multi(%5C%40ids)'>Class-&#62;lookup_multi(\@ids)</a>
    <li class='indexItem indexItem2'><a href='#Class-%3Esearch(%5C%25terms_%5B%2C_%5C%25options_%5D)'>Class-&#62;search(\%terms [, \%options ])</a>
    <li class='indexItem indexItem2'><a href='#Class-%3Esearch(%5C%40terms_%5B%2C_%5C%25options_%5D)'>Class-&#62;search(\@terms [, \%options ])</a>
    <li class='indexItem indexItem2'><a href='#Class-%3Eadd_trigger(%24trigger%2C_%5C%26callback)'>Class-&#62;add_trigger($trigger, \&#38;callback)</a>
    <li class='indexItem indexItem2'><a href='#Class-%3Ecall_trigger(%24trigger%2C_%5B%40callback_params%5D)'>Class-&#62;call_trigger($trigger, [@callback_params])</a>
    <li class='indexItem indexItem2'><a href='#%24obj-%3Esave'>$obj-&#62;save</a>
    <li class='indexItem indexItem2'><a href='#%24obj-%3Eremove'>$obj-&#62;remove</a>
    <li class='indexItem indexItem2'><a href='#Class-%3Eremove(%5C%25terms%2C_%5C%25args)'>Class-&#62;remove(\%terms, \%args)</a>
    <li class='indexItem indexItem2'><a href='#Class-%3Ebulk_insert(%5Bcol1%2C_col2%5D%2C_%5B%5Bd1%2Cd2%5D%2C_%5Bd1%2Cd2%5D%5D)%3B'>Class-&#62;bulk_insert([col1, col2], [[d1,d2], [d1,d2]]);</a>
    <li class='indexItem indexItem2'><a href='#%24obj-%3Eadd_trigger(%24trigger%2C_%5C%26callback)'>$obj-&#62;add_trigger($trigger, \&#38;callback)</a>
    <li class='indexItem indexItem2'><a href='#%24obj-%3Ecall_trigger(%24trigger%2C_%5B%40callback_params%5D)'>$obj-&#62;call_trigger($trigger, [@callback_params])</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#TRIGGERS'>TRIGGERS</a>
  <li class='indexItem indexItem1'><a href='#PROFILING'>PROFILING</a>
  <li class='indexItem indexItem1'><a href='#TRANSACTIONS'>TRANSACTIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Example'>Example</a>
    <li class='indexItem indexItem2'><a href='#Driver_implementation'>Driver implementation</a>
    <li class='indexItem indexItem2'><a href='#Nested_transactions'>Nested transactions</a>
    <li class='indexItem indexItem2'><a href='#Transactions_and_DBI'>Transactions and DBI</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#EXAMPLES'>EXAMPLES</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#A_Partitioned%2C_Caching_Driver'>A Partitioned, Caching Driver</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SUPPORTED_DATABASES'>SUPPORTED DATABASES</a>
  <li class='indexItem indexItem1'><a href='#LICENSE'>LICENSE</a>
  <li class='indexItem indexItem1'><a href='#MAILING_LIST%2C_CODE_%26_MORE_INFORMATION'>MAILING LIST, CODE &#38; MORE INFORMATION</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR_%26_COPYRIGHT'>AUTHOR &#38; COPYRIGHT</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Data::ObjectDriver - Simple,
transparent data interface,
with caching</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    ## Set up your database driver code.
    package FoodDriver;
    sub driver {
        Data::ObjectDriver::Driver::DBI-&#62;new(
            dsn      =&#62; &#39;dbi:mysql:dbname&#39;,
            username =&#62; &#39;username&#39;,
            password =&#62; &#39;password&#39;,
        )
    }

    ## Set up the classes for your recipe and ingredient objects.
    package Recipe;
    use base qw( Data::ObjectDriver::BaseObject );
    __PACKAGE__-&#62;install_properties({
        columns     =&#62; [ &#39;recipe_id&#39;, &#39;title&#39; ],
        datasource  =&#62; &#39;recipe&#39;,
        primary_key =&#62; &#39;recipe_id&#39;,
        driver      =&#62; FoodDriver-&#62;driver,
    });

    package Ingredient;
    use base qw( Data::ObjectDriver::BaseObject );
    __PACKAGE__-&#62;install_properties({
        columns     =&#62; [ &#39;ingredient_id&#39;, &#39;recipe_id&#39;, &#39;name&#39;, &#39;quantity&#39; ],
        datasource  =&#62; &#39;ingredient&#39;,
        primary_key =&#62; [ &#39;recipe_id&#39;, &#39;ingredient_id&#39; ],
        driver      =&#62; FoodDriver-&#62;driver,
    });

    ## And now, use them!
    my $recipe = Recipe-&#62;new;
    $recipe-&#62;title(&#39;Banana Milkshake&#39;);
    $recipe-&#62;save;

    my $ingredient = Ingredient-&#62;new;
    $ingredient-&#62;recipe_id($recipe-&#62;id);
    $ingredient-&#62;name(&#39;Bananas&#39;);
    $ingredient-&#62;quantity(5);
    $ingredient-&#62;save;

    ## Needs more bananas!
    $ingredient-&#62;quantity(10);
    $ingredient-&#62;save;

    ## Shorthand constructor
    my $ingredient = Ingredient-&#62;new(recipe_id=&#62; $recipe-&#62;id,
                                     name =&#62; &#39;Milk&#39;,
                                     quantity =&#62; 2);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p><i>Data::ObjectDriver</i> is an object relational mapper, meaning that it maps object-oriented design concepts onto a relational database.</p>

<p>It&#39;s inspired by, and descended from, the <i>MT::ObjectDriver</i> classes in Six Apart&#39;s Movable Type and TypePad weblogging products. But it adds in caching and partitioning layers, allowing you to spread data across multiple physical databases, without your application code needing to know where the data is stored.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODOLOGY"
>METHODOLOGY</a></h1>

<p><i>Data::ObjectDriver</i> provides you with a framework for building database-backed applications. It provides built-in support for object caching and database partitioning, and uses a layered approach to allow building very sophisticated database interfaces without a lot of code.</p>

<p>You can build a driver that uses any number of caching layers, plus a partitioning layer, then a final layer that actually knows how to load data from a backend datastore.</p>

<p>For example, the following code:</p>

<pre>    my $driver = Data::ObjectDriver::Driver::Cache::Memcached-&#62;new(
            cache    =&#62; Cache::Memcached-&#62;new(
                            servers =&#62; [ &#39;127.0.0.1:11211&#39; ],
                        ),
            fallback =&#62; Data::ObjectDriver::Driver::Partition-&#62;new(
                            get_driver =&#62; \&#38;get_driver,
                        ),
    );</pre>

<p>creates a new driver that supports both caching (using memcached) and partitioning.</p>

<p>It&#39;s useful to demonstrate the flow of a sample request through this driver framework. The following code:</p>

<pre>    my $ingredient = Ingredient-&#62;lookup([ $recipe-&#62;recipe_id, 1 ]);</pre>

<p>would take the following path through the <i>Data::ObjectDriver</i> framework:</p>

<ol>
<li>The caching layer would look up the object with the given primary key in all of the specified memcached servers.
<p>If the object was found in the cache, it would be returned immediately.</p>

<p>If the object was not found in the cache, the caching layer would fall back to the driver listed in the <i>fallback</i> setting: the partitioning layer.</p>
</li>

<li>The partitioning layer does not know how to look up objects by itself--all it knows how to do is to give back a driver that <i>does</i> know how to look up objects in a backend datastore.
<p>In our example above, imagine that we&#39;re partitioning our ingredient data based on the recipe that the ingredient is found in. For example, all of the ingredients for a &#34;Banana Milkshake&#34; would be found in one partition; all of the ingredients for a &#34;Chocolate Sundae&#34; might be found in another partition.</p>

<p>So the partitioning layer needs to tell us which partition to look in to load the ingredients for <i>$recipe-&#62;recipe_id</i>. If we store a <i>partition_id</i> column along with each <i>$recipe</i> object, that information can be loaded very easily, and the partitioning layer will then instantiate a <i>DBI</i> driver that knows how to load an ingredient from that recipe.</p>
</li>

<li>Using the <i>DBI</i> driver that the partitioning layer created, <i>Data::ObjectDriver</i> can look up the ingredient with the specified primary key. It will return that key back up the chain, giving each layer a chance to do something with it.</li>

<li>The caching layer, when it receives the object loaded in Step 3, will store the object in memcached.</li>

<li>The object will be passed back to the caller. Subsequent lookups of that same object will come from the cache.</li>
</ol>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="HOW_IS_IT_DIFFERENT?"
>HOW IS IT DIFFERENT?</a></h1>

<p><i>Data::ObjectDriver</i> differs from other similar frameworks (e.g. <a href="../Class/DBI.html" class="podlinkpod"
>Class::DBI</a>) in a couple of ways:</p>

<ul>
<li>It has built-in support for caching.</li>

<li>It has built-in support for data partitioning.</li>

<li>Drivers are attached to classes, not to the application as a whole.
<p>This is essential for partitioning, because your partition drivers need to know how to load a specific class of data.</p>

<p>But it can also be useful for caching, because you may find that it doesn&#39;t make sense to cache certain classes of data that change constantly.</p>
</li>

<li>The driver class != the base object class.
<p>All of the object classes you declare will descend from <i>Data::ObjectDriver::BaseObject</i>, and all of the drivers you instantiate or subclass will descend from <i>Data::ObjectDriver</i> itself.</p>

<p>This provides a useful distinction between your data/classes, and the drivers that describe how to <b>act</b> on that data, meaning that an object based on <i>Data::ObjectDriver::BaseObject</i> is not tied to any particular type of driver.</p>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="USAGE"
>USAGE</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Class-&#62;lookup($id)"
>Class-&#62;lookup($id)</a></h2>

<p>Looks up/retrieves a single object with the primary key <i>$id</i>, and returns the object.</p>

<p><i>$id</i> can be either a scalar or a reference to an array, in the case of a class with a multiple column primary key.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Class-&#62;lookup_multi(\@ids)"
>Class-&#62;lookup_multi(\@ids)</a></h2>

<p>Looks up/retrieves multiple objects with the IDs <i>\@ids</i>, which should be a reference to an array of IDs. As in the case of <i>lookup</i>, an ID can be either a scalar or a reference to an array.</p>

<p>Returns a reference to an array of objects <b>in the same order</b> as the IDs you passed in. Any objects that could not successfully be loaded will be represented in that array as an <code>undef</code> element.</p>

<p>So, for example, if you wanted to load 2 objects with the primary keys <code>[ 5, 3 ]</code> and <code>[ 4, 2 ]</code>, you&#39;d call <i>lookup_multi</i> like this:</p>

<pre>    Class-&#62;lookup_multi([
        [ 5, 3 ],
        [ 4, 2 ],
    ]);</pre>

<p>And if the first object in that list could not be loaded successfully, you&#39;d get back a reference to an array like this:</p>

<pre>    [
        undef,
        $object
    ]</pre>

<p>where <i>$object</i> is an instance of <i>Class</i>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Class-&#62;search(\%terms_[,_\%options_])"
>Class-&#62;search(\%terms [, \%options ])</a></h2>

<p>Searches for objects matching the terms <i>%terms</i>. In list context, returns an array of matching objects; in scalar context, returns a reference to a subroutine that acts as an iterator object, like so:</p>

<pre>    my $iter = Ingredient-&#62;search({ recipe_id =&#62; 5 });
    while (my $ingredient = $iter-&#62;()) {
        ...
    }</pre>

<p><code>$iter</code> is blessed in <a href="../Data/ObjectDriver/Iterator.html" class="podlinkpod"
>Data::ObjectDriver::Iterator</a> package, so the above could also be written:</p>

<pre>    my $iter = Ingredient-&#62;search({ recipe_id =&#62; 5 });
    while (my $ingredient = $iter-&#62;next()) {
        ...
    }</pre>

<p>The keys in <i>%terms</i> should be column names for the database table modeled by <i>Class</i> (and the values should be the desired values for those columns).</p>

<p><i>%options</i> can contain:</p>

<ul>
<li>sort
<p>The name of a column to use to sort the result set.</p>

<p>Optional.</p>
</li>

<li>direction
<p>The direction in which you want to sort the result set. Must be either <code>ascend</code> or <code>descend</code>.</p>

<p>Optional.</p>
</li>

<li>limit
<p>The value for a <i>LIMIT</i> clause, to limit the size of the result set.</p>

<p>Optional.</p>
</li>

<li>offset
<p>The offset to start at when limiting the result set.</p>

<p>Optional.</p>
</li>

<li>fetchonly
<p>A reference to an array of column names to fetch in the <i>SELECT</i> statement.</p>

<p>Optional; the default is to fetch the values of all of the columns.</p>
</li>

<li>for_update
<p>If set to a true value, the <i>SELECT</i> statement generated will include a <i>FOR UPDATE</i> clause.</p>
</li>

<li>comment
<p>A sql comment to watermark the SQL query.</p>
</li>

<li>window_size
<p>Used when requesting an iterator for the search method and selecting a large result set or a result set of unknown size. In such a case, no LIMIT clause is assigned, which can load all available objects into memory. Specifying <code>window_size</code> will load objects in manageable chunks. This will also cause any caching driver to be bypassed for issuing the search itself. Objects are still placed into the cache upon load.</p>

<p>This attribute is ignored when the search method is invoked in an array context, or if a <code>limit</code> attribute is also specified that is smaller than the <code>window_size</code>.</p>
</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Class-&#62;search(\@terms_[,_\%options_])"
>Class-&#62;search(\@terms [, \%options ])</a></h2>

<p>This is an alternative calling signature for the search method documented above. When providing an array of terms, it allows for constructing complex expressions that mix &#39;and&#39; and &#39;or&#39; clauses. For example:</p>

<pre>    my $iter = Ingredient-&#62;search([ { recipe_id =&#62; 5 },
        -or =&#62; { calories =&#62; { value =&#62; 300, op =&#62; &#39;&#60;&#39; } } ]);
    while (my $ingredient = $iter-&#62;()) {
        ...
    }</pre>

<p>Supported logic operators are: &#39;-and&#39;, &#39;-or&#39;, &#39;-and_not&#39;, &#39;-or_not&#39;.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Class-&#62;add_trigger($trigger,_\&#38;callback)"
>Class-&#62;add_trigger($trigger, \&#38;callback)</a></h2>

<p>Adds a trigger to all objects of class <i>Class</i>, such that when the event <i>$trigger</i> occurs to any of the objects, subroutine <code>&#38;callback</code> is run. Note that triggers will not occur for instances of <i>subclasses</i> of <i>Class</i>, only of <i>Class</i> itself. See TRIGGERS for the available triggers.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Class-&#62;call_trigger($trigger,_[@callback_params])"
>Class-&#62;call_trigger($trigger, [@callback_params])</a></h2>

<p>Invokes the triggers watching class <i>Class</i>. The parameters to send to the callbacks (in addition to <i>Class</i>) are specified in <i>@callback_params</i>. See TRIGGERS for the available triggers.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$obj-&#62;save"
>$obj-&#62;save</a></h2>

<p>Saves the object <i>$obj</i> to the database.</p>

<p>If the object is not yet in the database, <i>save</i> will automatically generate a primary key and insert the record into the database table. Otherwise, it will update the existing record.</p>

<p>If an error occurs, <i>save</i> will <i>croak</i>.</p>

<p>Internally, <i>save</i> calls <i>update</i> for records that already exist in the database, and <i>insert</i> for those that don&#39;t.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$obj-&#62;remove"
>$obj-&#62;remove</a></h2>

<p>Removes the object <i>$obj</i> from the database.</p>

<p>If an error occurs, <i>remove</i> will <i>croak</i>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Class-&#62;remove(\%terms,_\%args)"
>Class-&#62;remove(\%terms, \%args)</a></h2>

<p>Removes objects found with the <i>%terms</i>. So it&#39;s a shortcut of:</p>

<pre>  my @obj = Class-&#62;search(\%terms, \%args);
  for my $obj (@obj) {
      $obj-&#62;remove;
  }</pre>

<p>However, when you pass <code>nofetch</code> option set to <code>%args</code>, it won&#39;t create objects with <code>search</code>, but issues <i>DELETE</i> SQL directly to the database.</p>

<pre>  ## issues &#34;DELETE FROM tbl WHERE user_id = 2&#34;
  Class-&#62;remove({ user_id =&#62; 2 }, { nofetch =&#62; 1 });</pre>

<p>This might be much faster and useful for tables without Primary Key, but beware that in this case <b>Triggers won&#39;t be fired</b> because no objects are instanciated.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Class-&#62;bulk_insert([col1,_col2],_[[d1,d2],_[d1,d2]]);"
>Class-&#62;bulk_insert([col1, col2], [[d1,d2], [d1,d2]]);</a></h2>

<p>Bulk inserts data into the underlying table. The first argument is an array reference of columns names as specified in install_properties</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$obj-&#62;add_trigger($trigger,_\&#38;callback)"
>$obj-&#62;add_trigger($trigger, \&#38;callback)</a></h2>

<p>Adds a trigger to the object <i>$obj</i>, such that when the event <i>$trigger</i> occurs to the object, subroutine <code>&#38;callback</code> is run. See TRIGGERS for the available triggers. Triggers are invoked in the order in which they are added.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$obj-&#62;call_trigger($trigger,_[@callback_params])"
>$obj-&#62;call_trigger($trigger, [@callback_params])</a></h2>

<p>Invokes the triggers watching all objects of <i>$obj</i>&#39;s class and the object <i>$obj</i> specifically for trigger event <i>$trigger</i>. The additional parameters besides <i>$obj</i>, if any, are passed as <i>@callback_params</i>. See TRIGGERS for the available triggers.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TRIGGERS"
>TRIGGERS</a></h1>

<p><i>Data::ObjectDriver</i> provides a trigger mechanism by which callbacks can be called at certain points in the life cycle of an object. These can be set on a class as a whole or individual objects (see USAGE).</p>

<p>Triggers can be added and called for these events:</p>

<ul>
<li>pre_save -&#62; ($obj, $orig_obj)
<p>Callbacks on the <i>pre_save</i> trigger are called when the object is about to be saved to the database. For example, use this callback to translate special code strings into numbers for storage in an integer column in the database. Note that this hook is also called when you <code>remove</code> the object.</p>

<p>Modifications to <i>$obj</i> will affect the values passed to subsequent triggers and saved in the database, but not the original object on which the <i>save</i> method was invoked.</p>
</li>

<li>post_save -&#62; ($obj, $orig_obj)
<p>Callbaks on the <i>post_save</i> triggers are called after the object is saved to the database. Use this trigger when your hook needs primary key which is automatically assigned (like auto_increment and sequence). Note that this hooks is <b>NOT</b> called when you remove the object.</p>
</li>

<li>pre_insert/post_insert/pre_update/post_update/pre_remove/post_remove -&#62; ($obj, $orig_obj)
<p>Those triggers are fired before and after $obj is created, updated and deleted.</p>
</li>

<li>post_load -&#62; ($obj)
<p>Callbacks on the <i>post_load</i> trigger are called when an object is being created from a database query, such as with the <i>lookup</i> and <i>search</i> class methods. For example, use this callback to translate the numbers your <i>pre_save</i> callback caused to be saved <i>back</i> into string codes.</p>

<p>Modifications to <i>$obj</i> will affect the object passed to subsequent triggers and returned from the loading method.</p>

<p>Note <i>pre_load</i> should only be used as a trigger on a class, as the object to which the load is occuring was not previously available for triggers to be added.</p>
</li>

<li>pre_search -&#62; ($class, $terms, $args)
<p>Callbacks on the <i>pre_search</i> trigger are called when a content addressed query for objects of class <i>$class</i> is performed with the <i>search</i> method. For example, use this callback to translate the entry in <i>$terms</i> for your code string field to its appropriate integer value.</p>

<p>Modifications to <i>$terms</i> and <i>$args</i> will affect the parameters to subsequent triggers and what objects are loaded, but not the original hash references used in the <i>search</i> query.</p>

<p>Note <i>pre_search</i> should only be used as a trigger on a class, as <i>search</i> is never invoked on specific objects.</p>

<blockquote>
<p>The return values from your callbacks are ignored.</p>

<p>Note that the invocation of callbacks is the responsibility of the object driver. If you implement a driver that does not delegate to <i>Data::ObjectDriver::Driver::DBI</i>, it is <i>your</i> responsibility to invoke the appropriate callbacks with the <i>call_trigger</i> method.</p>
</blockquote>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PROFILING"
>PROFILING</a></h1>

<p>For performance tuning, you can turn on query profiling by setting <i>$Data::ObjectDriver::PROFILE</i> to a true value. Or, alternatively, you can set the <i>DOD_PROFILE</i> environment variable to a true value before starting your application.</p>

<p>To obtain the profile statistics, get the global <i>Data::ObjectDriver::Profiler</i> instance:</p>

<pre>    my $profiler = Data::ObjectDriver-&#62;profiler;</pre>

<p>Then see the documentation for <i>Data::ObjectDriver::Profiler</i> to see the methods on that class.</p>

<p>In some applications there are phases of execution in which no I/O operations should occur, but sometimes it&#39;s difficult to tell when, where, or if those I/O operations are happening. One approach to surfacing these situations is to set, either globally or locally, the $Data::ObjectDriver::RESTRICT_IO flag. If set, this will tell Data::ObjectDriver to die with some context rather than executing network calls for data.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TRANSACTIONS"
>TRANSACTIONS</a></h1>

<p>Transactions are supported by Data::ObjectDriver&#39;s default drivers. So each Driver is capable to deal with transactional state independently. Additionally &#60;Data::ObjectDriver::BaseObject&#62; class know how to turn transactions switch on for all objects.</p>

<p>In the case of a global transaction all drivers used during this time are put in a transactional state until the end of the transaction.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Example"
>Example</a></h2>

<pre>    ## start a transaction
    Data::ObjectDriver::BaseObject-&#62;begin_work;

    $recipe = Recipe-&#62;new;
    $recipe-&#62;title(&#39;lasagnes&#39;);
    $recipe-&#62;save;

    my $ingredient = Ingredient-&#62;new;
    $ingredient-&#62;recipe_id($recipe-&#62;recipe_id);
    $ingredient-&#62;name(&#34;more layers&#34;);
    $ingredient-&#62;insert;
    $ingredient-&#62;remove;

    if ($you_are_sure) {
        Data::ObjectDriver::BaseObject-&#62;commit;
    }
    else {
        ## erase all trace of the above
        Data::ObjectDriver::BaseObject-&#62;rollback;
    }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Driver_implementation"
>Driver implementation</a></h2>

<p>Drivers have to implement the following methods:</p>

<ul>
<li>begin_work to initialize a transaction</li>

<li>rollback</li>

<li>commmit</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Nested_transactions"
>Nested transactions</a></h2>

<p>Are not supported and will result in warnings and the inner transactions to be ignored. Be sure to <b>end</b> each transaction and not to let et long running transaction open (i.e you should execute a rollback or commit for each open begin_work).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Transactions_and_DBI"
>Transactions and DBI</a></h2>

<p>In order to make transactions work properly you have to make sure that the <code>$dbh</code> for each DBI drivers are shared among drivers using the same database (basically dsn).</p>

<p>One way of doing that is to define a get_dbh() subref in each DBI driver to return the same dbh if the dsn and attributes of the connection are identical.</p>

<p>The other way is to use the new configuration flag on the DBI driver that has been added specifically for this purpose: <code>reuse_dbh</code>.</p>

<pre>    ## example coming from the test suite
    __PACKAGE__-&#62;install_properties({
        columns =&#62; [ &#39;recipe_id&#39;, &#39;partition_id&#39;, &#39;title&#39; ],
        datasource =&#62; &#39;recipes&#39;,
        primary_key =&#62; &#39;recipe_id&#39;,
        driver =&#62; Data::ObjectDriver::Driver::Cache::Cache-&#62;new(
            cache =&#62; Cache::Memory-&#62;new,
            fallback =&#62; Data::ObjectDriver::Driver::DBI-&#62;new(
                dsn      =&#62; &#39;dbi:SQLite:dbname=global.db&#39;,
                reuse_dbh =&#62; 1,  ## be sure that the corresponding dbh is shared
            ),
        ),
    });</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXAMPLES"
>EXAMPLES</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="A_Partitioned,_Caching_Driver"
>A Partitioned, Caching Driver</a></h2>

<pre>    package Ingredient;
    use strict;
    use base qw( Data::ObjectDriver::BaseObject );

    use Data::ObjectDriver::Driver::DBI;
    use Data::ObjectDriver::Driver::Partition;
    use Data::ObjectDriver::Driver::Cache::Cache;
    use Cache::Memory;
    use Carp;

    our $IDs;

    __PACKAGE__-&#62;install_properties({
        columns     =&#62; [ &#39;ingredient_id&#39;, &#39;recipe_id&#39;, &#39;name&#39;, &#39;quantity&#39;, ],
        datasource  =&#62; &#39;ingredients&#39;,
        primary_key =&#62; [ &#39;recipe_id&#39;, &#39;ingredient_id&#39; ],
        driver      =&#62;
            Data::ObjectDriver::Driver::Cache::Cache-&#62;new(
                cache    =&#62; Cache::Memory-&#62;new( namespace =&#62; __PACKAGE__ ),
                fallback =&#62;
                    Data::ObjectDriver::Driver::Partition-&#62;new(
                        get_driver   =&#62; \&#38;get_driver,
                        pk_generator =&#62; \&#38;generate_pk,
                    ),
            ),
    });

    sub get_driver {
        my($terms) = @_;
        my $recipe;
        if (ref $terms eq &#39;HASH&#39;) {
            my $recipe_id = $terms-&#62;{recipe_id}
                or Carp::croak(&#34;recipe_id is required&#34;);
            $recipe = Recipe-&#62;lookup($recipe_id);
        } elsif (ref $terms eq &#39;ARRAY&#39;) {
            $recipe = Recipe-&#62;lookup($terms-&#62;[0]);
        }
        Carp::croak(&#34;Unknown recipe&#34;) unless $recipe;
        Data::ObjectDriver::Driver::DBI-&#62;new(
            dsn          =&#62; &#39;dbi:mysql:database=cluster&#39; . $recipe-&#62;cluster_id,
            username     =&#62; &#39;foo&#39;,
            pk_generator =&#62; \&#38;generate_pk,
        );
    }

    sub generate_pk {
        my($obj) = @_;
        $obj-&#62;ingredient_id(++$IDs{$obj-&#62;recipe_id});
        1;
    }

    1;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SUPPORTED_DATABASES"
>SUPPORTED DATABASES</a></h1>

<p><i>Data::ObjectDriver</i> is very modular and it&#39;s not very diffucult to add new drivers.</p>

<ul>
<li>MySQL is well supported and has been heavily tested.</li>

<li>PostgreSQL has been been used in production and should just work, too.</li>

<li>SQLite is supported, but YMMV depending on the version. This is the backend used for the test suite.</li>

<li>Oracle support has been added in 0.06</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENSE"
>LICENSE</a></h1>

<p><i>Data::ObjectDriver</i> is free software; you may redistribute it and/or modify it under the same terms as Perl itself.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="MAILING_LIST,_CODE_&#38;_MORE_INFORMATION"
>MAILING LIST, CODE &#38; MORE INFORMATION</a></h1>

<p><i>Data::ObjectDriver</i> developers can be reached via the following group: <a href="http://groups.google.com/group/data-objectdriver" class="podlinkurl"
>http://groups.google.com/group/data-objectdriver</a></p>

<p>Bugs should be reported using the CPAN RT system, patches are encouraged when reporting bugs.</p>

<p><a href="http://code.sixapart.com/" class="podlinkurl"
>http://code.sixapart.com/</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR_&#38;_COPYRIGHT"
>AUTHOR &#38; COPYRIGHT</a></h1>

<p>Except where otherwise noted, <i>Data::ObjectDriver</i> is Copyright 2005-2006 Six Apart, cpan@sixapart.com. All rights reserved.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
