<html><head><title>Data::FormValidator::Constraints</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:04 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#FV_length_between(1%2C23)'>FV_length_between(1,23)</a>
    <li class='indexItem indexItem2'><a href='#FV_max_length(23)'>FV_max_length(23)</a>
    <li class='indexItem indexItem2'><a href='#FV_min_length(1)'>FV_min_length(1)</a>
    <li class='indexItem indexItem2'><a href='#FV_eq_with'>FV_eq_with</a>
    <li class='indexItem indexItem2'><a href='#FV_num_values'>FV_num_values</a>
    <li class='indexItem indexItem2'><a href='#FV_num_values_between'>FV_num_values_between</a>
    <li class='indexItem indexItem2'><a href='#email'>email</a>
    <li class='indexItem indexItem2'><a href='#state_or_province'>state_or_province</a>
    <li class='indexItem indexItem2'><a href='#state'>state</a>
    <li class='indexItem indexItem2'><a href='#province'>province</a>
    <li class='indexItem indexItem2'><a href='#zip_or_postcode'>zip_or_postcode</a>
    <li class='indexItem indexItem2'><a href='#postcode'>postcode</a>
    <li class='indexItem indexItem2'><a href='#zip'>zip</a>
    <li class='indexItem indexItem2'><a href='#phone'>phone</a>
    <li class='indexItem indexItem2'><a href='#american_phone'>american_phone</a>
    <li class='indexItem indexItem2'><a href='#cc_number'>cc_number</a>
    <li class='indexItem indexItem2'><a href='#cc_exp'>cc_exp</a>
    <li class='indexItem indexItem2'><a href='#cc_type'>cc_type</a>
    <li class='indexItem indexItem2'><a href='#ip_address'>ip_address</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#RENAMING_BUILT-IN_CONSTAINTS'>RENAMING BUILT-IN CONSTAINTS</a>
  <li class='indexItem indexItem1'><a href='#REGEXP%3A%3ACOMMON_SUPPORT'>REGEXP::COMMON SUPPORT</a>
  <li class='indexItem indexItem1'><a href='#PROCEDURAL_INTERFACE'>PROCEDURAL INTERFACE</a>
  <li class='indexItem indexItem1'><a href='#WRITING_YOUR_OWN_CONSTRAINT_ROUTINES'>WRITING YOUR OWN CONSTRAINT ROUTINES</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#New_School_Constraints_Overview'>New School Constraints Overview</a>
    <li class='indexItem indexItem2'><a href='#Old_School_Constraints'>Old School Constraints</a>
    <li class='indexItem indexItem2'><a href='#Methods_available_for_use_inside_of_constraints'>Methods available for use inside of constraints</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#get_input_data()'>get_input_data()</a>
      <li class='indexItem indexItem3'><a href='#get_filtered_data()'>get_filtered_data()</a>
      <li class='indexItem indexItem3'><a href='#get_current_constraint_field()'>get_current_constraint_field()</a>
      <li class='indexItem indexItem3'><a href='#get_current_constraint_value()'>get_current_constraint_value()</a>
      <li class='indexItem indexItem3'><a href='#get_current_constraint_name()'>get_current_constraint_name()</a>
      <li class='indexItem indexItem3'><a href='#untainted_constraint_value()'>untainted_constraint_value()</a>
      <li class='indexItem indexItem3'><a href='#name_this()'>name_this()</a>
      <li class='indexItem indexItem3'><a href='#set_current_constraint_name()'>set_current_constraint_name()</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#BACKWARDS_COMPATIBILITY'>BACKWARDS COMPATIBILITY</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Constraints_available_in_other_modules'>Constraints available in other modules</a>
    <li class='indexItem indexItem2'><a href='#Related_modules_in_this_package'>Related modules in this package</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#CREDITS'>CREDITS</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Data::FormValidator::Constraints - Basic sets of constraints on input profile.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre> use Data::FormValidator::Constraints qw(:closures);</pre>

<p>In an Data::FormValidator profile:</p>

<pre>    constraint_methods =&#62; {
        email   =&#62; email(),
        phone   =&#62; american_phone(),
        first_names =&#62;  {
           constraint_method =&#62; FV_max_length(3),
           name =&#62; &#39;my_custom_name&#39;,
       },
    },
    msgs =&#62; {
       constraints =&#62; {
            my_custom_name =&#62; &#39;My message&#39;,
       },
    },</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>These are the builtin constraints that can be specified by name in the input profiles.</p>

<p>Be sure to check out the SEE ALSO section for even more pre-packaged constraints you can use.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="FV_length_between(1,23)"
>FV_length_between(1,23)</a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="FV_max_length(23)"
>FV_max_length(23)</a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="FV_min_length(1)"
>FV_min_length(1)</a></h2>

<pre>  use Data::FormValidator::Constraints qw(
    FV_length_between
    FV_min_length
    FV_max_length
  );

  constraint_methods =&#62; {

    # specify a min and max, inclusive
    last_name        =&#62; FV_length_between(1,23),

  }</pre>

<p>Specify a length constraint for a field.</p>

<p>These constraints have a different naming convention because they are higher-order functions. They take input and return a code reference to a standard constraint method. A constraint name of <code>length_between</code>, <code>min_length</code>, or <code>max_length</code> will be set, corresponding to the function name you choose.</p>

<p>The checks are all inclusive, so a max length of &#39;100&#39; will allow the length 100.</p>

<p>Length is measured in perl characters as opposed to bytes or anything else.</p>

<p>This constraint <i>will</i> untaint your data if you have untainting turned on. However, a length check alone may not be enough to insure the safety of the data you are receiving. Using additional constraints to check the data is encouraged.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="FV_eq_with"
>FV_eq_with</a></h2>

<pre>  use Data::FormValidator::Constraints qw( FV_eq_with );

  constraint_methods =&#62; {
    password  =&#62; FV_eq_with(&#39;password_confirm&#39;),
  }</pre>

<p>Compares the current field to another field. A constraint name of <code>eq_with</code> will be set.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="FV_num_values"
>FV_num_values</a></h2>

<pre>    use Data::FormValidator::Constraints qw ( FV_num_values );

    constraint_methods =&#62; {
        attachments =&#62; FV_num_values(4),
    }</pre>

<p>Checks the number of values in the array named by this param. Note that this is useful for making sure that only one value was passed for a given param (by supplying a size argument of 1). A constraint name of <code>num_values</code> will be set.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="FV_num_values_between"
>FV_num_values_between</a></h2>

<pre>    use Data::FormValidator::Constraints qw ( FV_num_values_between );

    constraint_methods =&#62; {
        attachments =&#62; FV_num_values_between(1,4),
    }</pre>

<p>Checks that the number of values in the array named by this param is between the supplied bounds (inclusively). A constraint name of <code>num_values_between</code> will be set.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="email"
>email</a></h2>

<p>Checks if the email LOOKS LIKE an email address. This should be sufficient 99% of the time.</p>

<p>Look elsewhere if you want something super fancy that matches every possible variation that is valid in the RFC, or runs out and checks some MX records.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="state_or_province"
>state_or_province</a></h2>

<p>This one checks if the input correspond to an american state or a canadian province.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="state"
>state</a></h2>

<p>This one checks if the input is a valid two letter abbreviation of an American state.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="province"
>province</a></h2>

<p>This checks if the input is a two letter Canadian province abbreviation.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="zip_or_postcode"
>zip_or_postcode</a></h2>

<p>This constraints checks if the input is an American zipcode or a Canadian postal code.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="postcode"
>postcode</a></h2>

<p>This constraints checks if the input is a valid Canadian postal code.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="zip"
>zip</a></h2>

<p>This input validator checks if the input is a valid american zipcode : 5 digits followed by an optional mailbox number.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="phone"
>phone</a></h2>

<p>This one checks if the input looks like a phone number, (if it contains at least 6 digits.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="american_phone"
>american_phone</a></h2>

<p>This constraints checks if the number is a possible North American style of phone number : (XXX) XXX-XXXX. It has to contains 7 or more digits.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="cc_number"
>cc_number</a></h2>

<p>This constraint references the value of a credit card type field.</p>

<pre> constraint_methods =&#62; {
    cc_no      =&#62; cc_number({fields =&#62; [&#39;cc_type&#39;]}),
  }</pre>

<p>The number is checked only for plausibility, it checks if the number could be valid for a type of card by checking the checksum and looking at the number of digits and the number of digits of the number.</p>

<p>This functions is only good at catching typos. IT DOESN&#39;T CHECK IF THERE IS AN ACCOUNT ASSOCIATED WITH THE NUMBER.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="cc_exp"
>cc_exp</a></h2>

<p>This one checks if the input is in the format MM/YY or MM/YYYY and if the MM part is a valid month (1-12) and if that date is not in the past.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="cc_type"
>cc_type</a></h2>

<p>This one checks if the input field starts by M(asterCard), V(isa), A(merican express) or D(iscovery).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ip_address"
>ip_address</a></h2>

<p>This checks if the input is formatted like a dotted decimal IP address (v4). For other kinds of IP address method, See <a href="../../Regexp/Common/net.html" class="podlinkpod"
>Regexp::Common::net</a> which provides several more options. <a href="#REGEXP%3A%3ACOMMON_SUPPORT" class="podlinkpod"
>&#34;REGEXP::COMMON SUPPORT&#34;</a> explains how we easily integrate with Regexp::Common.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="RENAMING_BUILT-IN_CONSTAINTS"
>RENAMING BUILT-IN CONSTAINTS</a></h1>

<p>If you&#39;d like, you can rename any of the built-in constraints. Just define the constraint_method and name in a hashref, like this:</p>

<pre>        constraint_methods =&#62; {
            first_names =&#62;  {
                constraint_method =&#62; FV_max_length(3),
                name =&#62; &#39;custom_length&#39;,
            }
        },</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="REGEXP::COMMON_SUPPORT"
>REGEXP::COMMON SUPPORT</a></h1>

<p>Data::FormValidator also includes built-in support for using any of regular expressions in <a href="../../Regexp/Common.html" class="podlinkpod"
>Regexp::Common</a> as named constraints. Simply use the name of regular expression you want. This works whether you want to untaint the data or not. For example:</p>

<pre> use Data::FormValidator::Constraints qw(:regexp_common);

 constraint_methods =&#62; {
    my_ip_address =&#62; FV_net_IPv4(),

    # An example with parameters
    other_ip      =&#62; FV_net_IPv4(-sep=&#62;&#39; &#39;),
 }</pre>

<p>Notice that the routines are named with the prefix &#34;FV_&#34; instead of &#34;RE_&#34; now. This is simply a visual cue that these are slightly modified versions. We&#39;ve made a wrapper for each Regexp::Common routine so that it can be used as a named constraint like this.</p>

<p>Be sure to check out the <a href="../../Regexp/Common.html" class="podlinkpod"
>Regexp::Common</a> syntax for how its syntax works. It will make more sense to add future regular expressions to Regexp::Common rather than to Data::FormValidator.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PROCEDURAL_INTERFACE"
>PROCEDURAL INTERFACE</a></h1>

<p>You may also call these functions directly through the procedural interface by either importing them directly or importing the whole <i>:validators</i> group. This is useful if you want to use the built-in validators out of the usual profile specification interface.</p>

<p>For example, if you want to access the <i>email</i> validator directly, you could either do:</p>

<pre>    use Data::FormValidator::Constraints (qw/valid_email/);
    or
    use Data::FormValidator::Constraints (:validators);

    if (valid_email($email)) {
      # do something with the email address
    }</pre>

<p>Notice that when you call validators directly, you&#39;ll need to prefix the validator name with &#34;valid_&#34;</p>

<p>Each validator also has a version that returns the untainted value if the validation succeeded. You may call these functions directly through the procedural interface by either importing them directly or importing the <i>:matchers</i> group. For example if you want to untaint a value with the <i>email</i> validator directly you may:</p>

<pre>    if ($email = match_email($email)) {
        system(&#34;echo $email&#34;);
    }
    else {
        die &#34;Unable to validate email&#34;;
    }</pre>

<p>Notice that when you call validators directly and want them to return an untainted value, you&#39;ll need to prefix the validator name with &#34;match_&#34;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="WRITING_YOUR_OWN_CONSTRAINT_ROUTINES"
>WRITING YOUR OWN CONSTRAINT ROUTINES</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="New_School_Constraints_Overview"
>New School Constraints Overview</a></h2>

<p>This is the current recommended way to write constraints. See also <a href="#Old_School_Constraints" class="podlinkpod"
>&#34;Old School Constraints&#34;</a>.</p>

<p>The most flexible way to create constraints to use closures-- a normal seeming outer subroutine which returns a customized DFV method subroutine as a result. It&#39;s easy to do. These &#34;constraint methods&#34; can be named whatever you like, and imported normally into the name space where the profile is located.</p>

<p>Let&#39;s look at an example.</p>

<pre>  # Near your profile
  # Of course, you don&#39;t have to export/import if your constraints are in the same
  # package as the profile.
  use My::Constraints &#39;coolness&#39;;

  # In your profile
  constraint_methods =&#62; {
    email            =&#62; email(),
    prospective_date =&#62; coolness( 40, 60,
        {fields =&#62; [qw/personality smarts good_looks/]}
    ),
  }</pre>

<p>Let&#39;s look at how this complex <code>coolness</code> constraint method works. The interface asks for users to define minimum and maximum coolness values, as well as declaring three data field names that we should peek into to look their values.</p>

<p>Here&#39;s what the code might look like:</p>

<pre>  sub coolness {
    my ($min_cool,$max_cool, $attrs) = @_;
    my ($personality,$smarts,$looks) = @{ $attrs-&#62;{fields} } if $attrs-&#62;{fields};
    return sub {
        my $dfv = shift;

        # Name it to refer to in the &#39;msgs&#39; system.
        $dfv-&#62;name_this(&#39;coolness&#39;);

        # value of &#39;prospective_date&#39; parameter
        my $val = $dfv-&#62;get_current_constraint_value();

        # get other data to refer to
        my $data = $dfv-&#62;get_filtered_data;

        my $has_all_three = ($data-&#62;{$personality} &#38;&#38; $data-&#62;{$smarts} &#38;&#38; $data-&#62;{$looks});
        return ( ($val &#62;= $min_cool) &#38;&#38; ($val &#60;= $max_cool) &#38;&#38; $has_all_three );
    }
  }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Old_School_Constraints"
>Old School Constraints</a></h2>

<p>Here is documentation on how old school constraints are created. These are supported, but the new school style documented above is recommended.</p>

<p>See also the <code>validator_packages</code> option in the input profile, for loading sets of old school constraints from other packages.</p>

<p>Old school constraint routines are named two ways. Some are named with the prefix <code>match_</code> while others start with <code>valid_</code>. The difference is that the <code>match_</code> routines are built to untaint the data and return a safe version of it if it validates, while <code>valid_</code> routines simply return a true value if the validation succeeds and false otherwise.</p>

<p>It is preferable to write <code>match_</code> routines that untaint data for the extra security benefits. Plus, Data::FormValidator will AUTOLOAD a <code>valid_</code> version if anyone tries to use it, so you only need to write one routine to cover both cases.</p>

<p>Usually constraint routines only need one input, the value being specified. However, sometimes more than one value is needed.</p>

<p><b>Example</b>:</p>

<pre>        image_field  =&#62; {
            constraint_method  =&#62; &#39;max_image_dimensions&#39;,
            params =&#62; [\100,\200],
        },</pre>

<p>Using that syntax, the first parameter that will be passed to the routine is the Data::FormValidator object. The remaining parameters will come from the <code>params</code> array. Strings will be replaced by the values of fields with the same names, and references will be passed directly.</p>

<p>In addition to <code>constraint_method</code>, there is also an even older technique using the name <code>constraint</code> instead. Routines that are designed to work with <code>constraint</code> <i>don&#39;t</i> have access to Data::FormValidator object, which means users need to pass in the name of the field being validated. Besides adding unnecessary syntax to the user interface, it won&#39;t work in conjunction with <code>constraint_regexp_map</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Methods_available_for_use_inside_of_constraints"
>Methods available for use inside of constraints</a></h2>

<p>A few useful methods to use on the Data::FormValidator::Results object are available to you to use inside of your routine.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="get_input_data()"
>get_input_data()</a></h3>

<p>Returns the raw input data. This may be a CGI object if that&#39;s what was used in the constraint routine.</p>

<p><b>Examples:</b></p>

<pre> # Raw and uncensored
 my $data = $self-&#62;get_input_data;

 # tamed to be a hashref, if it wasn&#39;t already
 my $data = $self-&#62;get_input_data( as_hashref =&#62; 1 );</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="get_filtered_data()"
>get_filtered_data()</a></h3>

<pre> my $data = $self-&#62;get_filtered_data;</pre>

<p>Returns the valid filtered data as a hashref, regardless of whether it started out as a CGI.pm compatible object. Multiple values are expressed as array references.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="get_current_constraint_field()"
>get_current_constraint_field()</a></h3>

<p>Returns the name of the current field being tested in the constraint.</p>

<p><b>Example</b>:</p>

<pre> my $field = $self-&#62;get_current_constraint_field;</pre>

<p>This reduces the number of parameters that need to be passed into the routine and allows multi-valued constraints to be used with <code>constraint_regexp_map</code>.</p>

<p>For complete examples of multi-valued constraints, see <a href="../../Data/FormValidator/Constraints/Upload.html" class="podlinkpod"
>Data::FormValidator::Constraints::Upload</a></p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="get_current_constraint_value()"
>get_current_constraint_value()</a></h3>

<p>Returns the name of the current value being tested in the constraint.</p>

<p><b>Example</b>:</p>

<pre> my $value = $self-&#62;get_current_constraint_value;</pre>

<p>This reduces the number of parameters that need to be passed into the routine and allows multi-valued constraints to be used with <code>constraint_regexp_map</code>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="get_current_constraint_name()"
>get_current_constraint_name()</a></h3>

<p>Returns the name of the current constraint being applied</p>

<p><b>Example</b>:</p>

<pre> my $value = $self-&#62;get_current_constraint_name;</pre>

<p>This is useful for building a constraint on the fly based on its name. It&#39;s used internally as part of the interface to the <a href="../../Regexp/Commmon.html" class="podlinkpod"
>Regexp::Commmon</a> regular expressions.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="untainted_constraint_value()"
>untainted_constraint_value()</a></h3>

<pre>   return $dfv-&#62;untainted_constraint_value($match);</pre>

<p>If you have written a constraint which untaints, use this method to return the untainted result. It will prepare the right result whether the user has requested untainting or not.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="name_this()"
>name_this()</a></h3>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="set_current_constraint_name()"
>set_current_constraint_name()</a></h3>

<p>Sets the name of the current constraint being applied.</p>

<p><b>Example</b>:</p>

<pre> sub my_constraint {
    my @outer_params = @_;
    return sub {
        my $dfv = shift;
        $dfv-&#62;set_current_constraint_name(&#39;my_constraint&#39;);
        my @params = @outer_params;
        # do something constraining here...
    }
 }</pre>

<p>By returning a closure which uses this method, you can build an advanced named constraint in your profile, before you actually have access to the DFV object that will be used later. See Data::FormValidator::Constraints::Upload for an example.</p>

<p><code>name_this</code> is a provided as a shorter synonym.</p>

<p>The <code>meta()</code> method may also be useful to communicate meta data that may have been found. See <a href="../../Data/FormValidator/Results.html" class="podlinkpod"
>Data::FormValidator::Results</a> for documentation of that method.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BACKWARDS_COMPATIBILITY"
>BACKWARDS COMPATIBILITY</a></h1>

<p>Prior to Data::FormValidator 4.00, constraints were specified a bit differently. This older style is still supported.</p>

<p>It was not necessary to explicitly load some constraints into your name space, and the names were given as strings, like this:</p>

<pre>    constraints  =&#62; {
        email         =&#62; &#39;email&#39;,
        fax           =&#62; &#39;american_phone&#39;,
        phone         =&#62; &#39;american_phone&#39;,
        state         =&#62; &#39;state&#39;,
        my_ip_address =&#62; &#39;RE_net_IPv4&#39;,
        other_ip =&#62; {
            constraint =&#62; &#39;RE_net_IPv4&#39;,
            params =&#62; [ \&#39;-sep&#39;=&#62; \&#39; &#39; ],
        },
        my_cc_no      =&#62; {
            constraint =&#62; &#39;cc_number&#39;,
            params =&#62; [qw/cc_no cc_type/],
        }
    },</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Constraints_available_in_other_modules"
>Constraints available in other modules</a></h2>

<dl>
<dt><a name="Data::FormValidator::Constraints::Upload_-_validate_the_bytes,_format_and_dimensions_of_file_uploads"
><a href="../../Data/FormValidator/Constraints/Upload.html" class="podlinkpod"
>Data::FormValidator::Constraints::Upload</a> - validate the bytes, format and dimensions of file uploads</a></dt>

<dd>
<dt><a 
><a href="../../Data/FormValidator/Constraints/DateTime.html" class="podlinkpod"
>Data::FormValidator::Constraints::DateTime</a> - A newer DateTime constraint module. May save you a step of transforming the date into a more useful format after it&#39;s validated.</a></dt>

<dd>
<dt><a name="Data::FormValidator::Constraints::Dates_-_the_original_DFV_date_constraint_module._Try_the_newer_one_first!"
><a href="../../Data/FormValidator/Constraints/Dates.html" class="podlinkpod"
>Data::FormValidator::Constraints::Dates</a> - the original DFV date constraint module. Try the newer one first!</a></dt>

<dd>
<dt><a name="Data::FormValidator::Constraints::Japanese_-_Japan-specific_constraints"
><a href="../../Data/FormValidator/Constraints/Japanese.html" class="podlinkpod"
>Data::FormValidator::Constraints::Japanese</a> - Japan-specific constraints</a></dt>

<dd>
<dt><a 
><a href="../../Data/FormValidator/Constraints/MethodsFactory.html" class="podlinkpod"
>Data::FormValidator::Constraints::MethodsFactory</a> - a useful collection of tools generate more complex constraints. Recommended!</a></dt>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Related_modules_in_this_package"
>Related modules in this package</a></h2>

<dl>
<dt><a name="Data::FormValidator::Filters_-_transform_data_before_constraints_are_applied"
><a href="../../Data/FormValidator/Filters.html" class="podlinkpod"
>Data::FormValidator::Filters</a> - transform data before constraints are applied</a></dt>

<dd>
<dt><a 
><a href="../../Data/FormValidator/ConstraintsFactory.html" class="podlinkpod"
>Data::FormValidator::ConstraintsFactory</a> - This is a historical collection of constraints that suffer from cumbersome names. They are worth reviewing though-- <code>make_and_constraint</code> will allow to validate against a list of constraints and shortcircuit if the first one fails. That&#39;s perfect if the second constraint depends on the first one having passed. For a modern version of this toolkit, see <a href="../../Data/FormValidator/Constraints/MethodsFactory.html" class="podlinkpod"
>Data::FormValidator::Constraints::MethodsFactory</a>.</a></dt>

<dd>
<dt><a name="Data::FormValidator"
><a href="../../Data/FormValidator.html" class="podlinkpod"
>Data::FormValidator</a></a></dt>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CREDITS"
>CREDITS</a></h1>

<p>Some of those input validation functions have been taken from MiniVend by Michael J. Heins</p>

<p>The credit card checksum validation was taken from contribution by Bruce Albrecht to the MiniVend program.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<pre>    Francis J. Lacoste
    Michael J. Heins
    Bruce Albrecht
    Mark Stosberg</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright (c) 1999 iNsu Innovations Inc. All rights reserved.</p>

<p>Parts Copyright 1996-1999 by Michael J. Heins Parts Copyright 1996-1999 by Bruce Albrecht Parts Copyright 2005-2009 by Mark Stosberg</p>

<p>This program is free software; you can redistribute it and/or modify it under the terms as perl itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
