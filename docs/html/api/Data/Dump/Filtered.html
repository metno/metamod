<html><head><title>Data::Dump::Filtered</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:04 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Filter_callback'>Filter callback</a>
    <li class='indexItem indexItem2'><a href='#Filter_context'>Filter context</a>
    <li class='indexItem indexItem2'><a href='#Filter_return_hash'>Filter return hash</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Data::Dump::Filtered - Pretty printing with filtering</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>The following functions are provided:</p>

<dl>
<dt><a name="add_dump_filter(_\&#38;filter_)"
>add_dump_filter( \&#38;filter )</a></dt>

<dd>
<p>This registers a filter function to be used by the regular Data::Dump::dump() function.
By default no filters are active.</p>

<p>Since registering filters has a global effect is might be more appropriate to use the dump_filtered() function instead.</p>

<dt><a name="remove_dump_filter(_\&#38;filter_)"
>remove_dump_filter( \&#38;filter )</a></dt>

<dd>
<p>Unregister the given callback function as filter callback.
This undoes the effect of <a href="../../add_filter.html" class="podlinkpod"
>add_filter</a>.</p>

<dt><a name="dump_filtered(...,_\&#38;filter_)"
>dump_filtered(...,
\&#38;filter )</a></dt>

<dd>
<p>Works like Data::Dump::dump(),
but the last argument should be a filter callback function.
As objects are visited the filter callback is invoked at it might influence how objects are dumped.</p>

<p>Any filters registered with <a href="../../add_filter().html" class="podlinkpod"
>add_filter()</a> are ignored when this interface is invoked.
Actually,
passing <code>undef</code> as \&#38;filter is allowed and <code>dump_filtered(...,
undef)</code> is the official way to force unfiltered dumps.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Filter_callback"
>Filter callback</a></h2>

<p>A filter callback is a function that will be invoked with 2 arguments; a context object and reference to the object currently visited.
The return value should either be a hash reference or <code>undef</code>.</p>

<pre>    sub filter_callback {
        my($ctx, $object_ref) = @_;
        ...
        return { ... }
    }</pre>

<p>If the filter callback returns <code>undef</code> (or nothing) then normal processing and formatting of the visited object happens. If the filter callback returns a hash it might replace or annotate the representation of the current object.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Filter_context"
>Filter context</a></h2>

<p>The context object provide methods that can be used to determine what kind of object is currently visited and where it&#39;s located. The context object has the following interface:</p>

<dl>
<dt><a name="$ctx-&#62;object_ref"
>$ctx-&#62;object_ref</a></dt>

<dd>
<p>Alternative way to obtain a reference to the current object</p>

<dt><a name="$ctx-&#62;class"
>$ctx-&#62;class</a></dt>

<dd>
<p>If the object is blessed this return the class. Returns &#34;&#34; for objects not blessed.</p>

<dt><a name="$ctx-&#62;reftype"
>$ctx-&#62;reftype</a></dt>

<dd>
<p>Returns what kind of object this is. It&#39;s a string like &#34;SCALAR&#34;, &#34;ARRAY&#34;, &#34;HASH&#34;, &#34;CODE&#34;,...</p>

<dt><a name="$ctx-&#62;is_ref"
>$ctx-&#62;is_ref</a></dt>

<dd>
<p>Returns true if a reference was provided.</p>

<dt><a name="$ctx-&#62;is_blessed"
>$ctx-&#62;is_blessed</a></dt>

<dd>
<p>Returns true if the object is blessed. Actually, this is just an alias for <code>$ctx-&#62;class</code>.</p>

<dt><a name="$ctx-&#62;is_array"
>$ctx-&#62;is_array</a></dt>

<dd>
<p>Returns true if the object is an array</p>

<dt><a name="$ctx-&#62;is_hash"
>$ctx-&#62;is_hash</a></dt>

<dd>
<p>Returns true if the object is a hash</p>

<dt><a name="$ctx-&#62;is_scalar"
>$ctx-&#62;is_scalar</a></dt>

<dd>
<p>Returns true if the object is a scalar (a string or a number)</p>

<dt><a name="$ctx-&#62;is_code"
>$ctx-&#62;is_code</a></dt>

<dd>
<p>Returns true if the object is a function (aka subroutine)</p>

<dt><a name="$ctx-&#62;container_class"
>$ctx-&#62;container_class</a></dt>

<dd>
<p>Returns the class of the innermost container that contains this object. Returns &#34;&#34; if there is no blessed container.</p>

<dt><a name="$ctx-&#62;container_self"
>$ctx-&#62;container_self</a></dt>

<dd>
<p>Returns an textual expression relative to the container object that names this object. The variable <code>$self</code> in this expression is the container itself.</p>

<dt><a name="$ctx-&#62;object_isa(_$class_)"
>$ctx-&#62;object_isa( $class )</a></dt>

<dd>
<p>Returns TRUE if the current object is of the given class or is of a subclass.</p>

<dt><a name="$ctx-&#62;container_isa(_$class_)"
>$ctx-&#62;container_isa( $class )</a></dt>

<dd>
<p>Returns TRUE if the innermost container is of the given class or is of a subclass.</p>

<dt><a name="$ctx-&#62;depth"
>$ctx-&#62;depth</a></dt>

<dd>
<p>Returns how many levels deep have we recursed into the structure (from the original dump_filtered() arguments).</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Filter_return_hash"
>Filter return hash</a></h2>

<p>The following elements has significance in the returned hash:</p>

<dl>
<dt><a name="dump_=&#62;_$string"
>dump =&#62; $string</a></dt>

<dd>
<p>incorporate the given string as the representation for the current value</p>

<dt><a name="object_=&#62;_$value"
>object =&#62; $value</a></dt>

<dd>
<p>dump the given value instead of the one visited and passed in as $object. Basically the same as specifying <code>dump =&#62; Data::Dump::dump($value)</code>.</p>

<dt><a name="comment_=&#62;_$comment"
>comment =&#62; $comment</a></dt>

<dd>
<p>prefix the value with the given comment string</p>

<dt><a name="bless_=&#62;_$class"
>bless =&#62; $class</a></dt>

<dd>
<p>make it look as if the current object is of the given $class instead of the class it really has (if any). The internals of the object is dumped in the regular way. The $class can be the empty string to make Data::Dump pretend the object wasn&#39;t blessed at all.</p>

<dt><a name="hide_keys_=&#62;_[&#39;key1&#39;,_&#39;key2&#39;,...]"
>hide_keys =&#62; [&#39;key1&#39;, &#39;key2&#39;,...]</a></dt>

<dd>
<dt><a name="hide_keys_=&#62;_\&#38;code"
>hide_keys =&#62; \&#38;code</a></dt>

<dd>
<p>If the $object is a hash dump is as normal but pretend that the listed keys did not exist. If the argument is a function then the function is called to determine if the given key should be hidden.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../../Data/Dump.html" class="podlinkpod"
>Data::Dump</a></p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
