<html><head><title>Data::ObjectDriver::Driver::Partition</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:04 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#SUGGESTED_PRACTICES'>SUGGESTED PRACTICES</a>
  <li class='indexItem indexItem1'><a href='#USAGE'>USAGE</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Data%3A%3AObjectDriver%3A%3ADriver%3A%3APartition-%3Enew(%25params)'>Data::ObjectDriver::Driver::Partition-&#62;new(%params)</a>
    <li class='indexItem indexItem2'><a href='#%24driver-%3Esearch(%24class%2C_%24terms%2C_%24args)'>$driver-&#62;search($class, $terms, $args)</a>
    <li class='indexItem indexItem2'><a href='#%24driver-%3Elookup(%24class%2C_%24id)'>$driver-&#62;lookup($class, $id)</a>
    <li class='indexItem indexItem2'><a href='#%24driver-%3Elookup_multi(%24class%2C_%40ids)'>$driver-&#62;lookup_multi($class, @ids)</a>
    <li class='indexItem indexItem2'><a href='#%24driver-%3Eexists(%24obj)'>$driver-&#62;exists($obj)</a>
    <li class='indexItem indexItem2'><a href='#%24driver-%3Einsert(%24obj)'>$driver-&#62;insert($obj)</a>
    <li class='indexItem indexItem2'><a href='#%24driver-%3Eupdate(%24obj)'>$driver-&#62;update($obj)</a>
    <li class='indexItem indexItem2'><a href='#%24driver-%3Eremove(%24obj)'>$driver-&#62;remove($obj)</a>
    <li class='indexItem indexItem2'><a href='#%24driver-%3Efetch_data(%24what)'>$driver-&#62;fetch_data($what)</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#DIAGNOSTICS'>DIAGNOSTICS</a>
  <li class='indexItem indexItem1'><a href='#BUGS_AND_LIMITATIONS'>BUGS AND LIMITATIONS</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#LICENSE'>LICENSE</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR_%26_COPYRIGHT'>AUTHOR &#38; COPYRIGHT</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Data::ObjectDriver::Driver::Partition - base class for partitioned object drivers</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    package SomeObject;

    __PACKAGE__-&#62;install_properties({
        ...
        primary_key =&#62; &#39;id&#39;,
        driver      =&#62; Data::ObjectDriver::Driver::Partition-&#62;new(get_driver =&#62; \&#38;find_partition),
    });

    # Say we have a list of 5 arrayrefs of the DBI driver information.
    my @DBI_INFO;

    sub find_partition {
        my ($part_key, $args) = @_;

        my $id;

        if (ref $terms &#38;&#38; ref $terms eq &#39;HASH&#39;) {
            # This is a search($terms, $args) call.
            my $terms = $part_key;
            $id = $terms-&#62;{id}
                or croak &#34;Can&#39;t determine partition from a search() with no id field&#34;;
        }
        else {
            # This is a lookup($id) or some method invoked on an object where we know the ID.
            my $id = $part_key;
        }

        # &#34;ID modulo N&#34; is not a good partitioning strategy, but serves as an example.
        my $partition = $id % 5;
        return Data::ObjectDriver::Driver::DBI-&#62;new( @{ $DBI_INFO[$partition] } );
    }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p><i>Data::ObjectDriver::Driver::Partition</i> provides the basic structure for partitioning objects into different databases. Using partitions, you can horizontally scale your application by using different database servers to hold sets of data.</p>

<p>To partition data, you need a certain criteria to determine which partition data goes in. Partition drivers use a <code>get_driver</code> function to find the database driver for the correct partition, given either the arguments to a <code>search()</code> or the object&#39;s primary key for a <code>lookup()</code>, <code>update()</code>, etc where the key is known.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SUGGESTED_PRACTICES"
>SUGGESTED PRACTICES</a></h1>

<p>While you can use any stable, predictable method of selecting the partition for an object, the most flexible way is to keep an unpartitioned table that maps object keys to their partitions. You can then look up the appropriate record in your get_driver method to find the partition.</p>

<p>For many applications, you can partition several classes of data based on the ID of the user account that &#34;owns&#34; them. In this case, you would include the user ID as the first part of a complex primary key.</p>

<p>Because multiple objects can use the same partitioning scheme, often <i>Data::ObjectDriver::Driver::Partition</i> is subclassed to define the <code>get_driver</code> function once and automatically specify it to the <i>Data::ObjectDriver::Driver::Partition</i> constructor.</p>

<p>Note these practices are codified into the <i>Data::ObjectDriver::Driver::SimplePartition</i> class.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="USAGE"
>USAGE</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Data::ObjectDriver::Driver::Partition-&#62;new(%params)"
><code>Data::ObjectDriver::Driver::Partition-&#62;new(%params)</code></a></h2>

<p>Creates a new partitioning driver. The required members of <code>%params</code> are:</p>

<ul>
<li><code>get_driver</code>
<p>A reference to a function to be used to retrieve for a given object or set of search terms. Your function is invoked as either:</p>

<ul>
<li><code>get_driver(\%terms, \%args)</code>
<p>Return a driver based on the given <code>search()</code> parameters.</p>
</li>

<li><code>get_driver($id)</code>
<p>Return a driver based on the given object ID. Note that <code>$id</code> may be an arrayref, if the class was defined with a complex primary key.</p>
</li>
</ul>
</li>

<li><code>pk_generator</code>
<p>A reference to a function that, given a data object, generates a primary key for it. This is the same <code>pk_generator</code> given to <code>Data::ObjectDriver</code>&#39;s constructor.</p>
</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$driver-&#62;search($class,_$terms,_$args)"
><code>$driver-&#62;search($class, $terms, $args)</code></a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$driver-&#62;lookup($class,_$id)"
><code>$driver-&#62;lookup($class, $id)</code></a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$driver-&#62;lookup_multi($class,_@ids)"
><code>$driver-&#62;lookup_multi($class, @ids)</code></a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$driver-&#62;exists($obj)"
><code>$driver-&#62;exists($obj)</code></a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$driver-&#62;insert($obj)"
><code>$driver-&#62;insert($obj)</code></a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$driver-&#62;update($obj)"
><code>$driver-&#62;update($obj)</code></a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$driver-&#62;remove($obj)"
><code>$driver-&#62;remove($obj)</code></a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$driver-&#62;fetch_data($what)"
><code>$driver-&#62;fetch_data($what)</code></a></h2>

<p>Performs the named action, by passing these methods through to the appropriate database driver as determined by <code>$driver</code>&#39;s <code>get_driver</code> function.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DIAGNOSTICS"
>DIAGNOSTICS</a></h1>

<p>No errors are created by <i>Data::ObjectDriver::Driver::Partition</i> itself. Errors may come from a specific partitioning subclass or the driver for a particular database.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS_AND_LIMITATIONS"
>BUGS AND LIMITATIONS</a></h1>

<p>There are no known bugs in this module.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><i>Data::ObjectDriver::Driver::SimplePartition</i></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENSE"
>LICENSE</a></h1>

<p><i>Data::ObjectDriver</i> is free software; you may redistribute it and/or modify it under the same terms as Perl itself.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR_&#38;_COPYRIGHT"
>AUTHOR &#38; COPYRIGHT</a></h1>

<p>Except where otherwise noted, <i>Data::ObjectDriver</i> is Copyright 2005-2006 Six Apart, cpan@sixapart.com. All rights reserved.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
