<html><head><title>Data::ObjectDriver::SQL</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:04 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#ATTRIBUTES'>ATTRIBUTES</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#select_(arrayref)'>select (arrayref)</a>
    <li class='indexItem indexItem2'><a href='#distinct_(boolean)'>distinct (boolean)</a>
    <li class='indexItem indexItem2'><a href='#select_map_(hashref)'>select_map (hashref)</a>
    <li class='indexItem indexItem2'><a href='#select_map_reverse_(hashref)'>select_map_reverse (hashref)</a>
    <li class='indexItem indexItem2'><a href='#from_(arrayref)'>from (arrayref)</a>
    <li class='indexItem indexItem2'><a href='#joins_(arrayref_of_hashrefs_containing_scalars_and_hashrefs)'>joins (arrayref of hashrefs containing scalars and hashrefs)</a>
    <li class='indexItem indexItem2'><a href='#where_(arrayref)'>where (arrayref)</a>
    <li class='indexItem indexItem2'><a href='#where_values_(hashref_of_variant_structures)'>where_values (hashref of variant structures)</a>
    <li class='indexItem indexItem2'><a href='#bind_(arrayref)'>bind (arrayref)</a>
    <li class='indexItem indexItem2'><a href='#limit_(scalar)'>limit (scalar)</a>
    <li class='indexItem indexItem2'><a href='#offset_(scalar)'>offset (scalar)</a>
    <li class='indexItem indexItem2'><a href='#group_(hashref%2C_or_an_arrayref_of_hashrefs)'>group (hashref, or an arrayref of hashrefs)</a>
    <li class='indexItem indexItem2'><a href='#having_(arrayref)'>having (arrayref)</a>
    <li class='indexItem indexItem2'><a href='#order_(hashref%2C_or_an_arrayref_of_hashrefs)'>order (hashref, or an arrayref of hashrefs)</a>
    <li class='indexItem indexItem2'><a href='#%24sql-%3Ecomment(%5B_%24comment_%5D)'>$sql-&#62;comment([ $comment ])</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#USAGE'>USAGE</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Data%3A%3AObjectDriver%3A%3ASQL-%3Enew()'>Data::ObjectDriver::SQL-&#62;new()</a>
    <li class='indexItem indexItem2'><a href='#%24sql-%3Eadd_select(%24column_%5B%2C_%24term_%5D)'>$sql-&#62;add_select($column [, $term ])</a>
    <li class='indexItem indexItem2'><a href='#%24sql-%3Eadd_join(%24table%2C_%5C%40joins)'>$sql-&#62;add_join($table, \@joins)</a>
    <li class='indexItem indexItem2'><a href='#%24sql-%3Eadd_index_hint(%24table%2C_%24index)'>$sql-&#62;add_index_hint($table, $index)</a>
    <li class='indexItem indexItem2'><a href='#%24sql-%3Eadd_where(%24column%2C_%24value)'>$sql-&#62;add_where($column, $value)</a>
    <li class='indexItem indexItem2'><a href='#%24sql-%3Eadd_complex_where(%5C%40list)'>$sql-&#62;add_complex_where(\@list)</a>
    <li class='indexItem indexItem2'><a href='#%24sql-%3Ehas_where(%24column%2C_%5B%24value%5D)'>$sql-&#62;has_where($column, [$value])</a>
    <li class='indexItem indexItem2'><a href='#%24sql-%3Eadd_having(%24column%2C_%24value)'>$sql-&#62;add_having($column, $value)</a>
    <li class='indexItem indexItem2'><a href='#%24sql-%3Eadd_index_hint(%24table%2C_%5C%40hints)'>$sql-&#62;add_index_hint($table, \@hints)</a>
    <li class='indexItem indexItem2'><a href='#%24sql-%3Eas_sql()'>$sql-&#62;as_sql()</a>
    <li class='indexItem indexItem2'><a href='#%24sql-%3Eas_sql_having()'>$sql-&#62;as_sql_having()</a>
    <li class='indexItem indexItem2'><a href='#%24sql-%3Eas_sql_where()'>$sql-&#62;as_sql_where()</a>
    <li class='indexItem indexItem2'><a href='#%24sql-%3Eas_limit()'>$sql-&#62;as_limit()</a>
    <li class='indexItem indexItem2'><a href='#%24sql-%3Eas_aggregate(%24set)'>$sql-&#62;as_aggregate($set)</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#DIAGNOSTICS'>DIAGNOSTICS</a>
  <li class='indexItem indexItem1'><a href='#BUGS_AND_LIMITATIONS'>BUGS AND LIMITATIONS</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#LICENSE'>LICENSE</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR_%26_COPYRIGHT'>AUTHOR &#38; COPYRIGHT</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Data::ObjectDriver::SQL - an SQL statement</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    my $sql = Data::ObjectDriver::SQL-&#62;new();
    $sql-&#62;select([ &#39;id&#39;, &#39;name&#39;, &#39;bucket_id&#39;, &#39;note_id&#39; ]);
    $sql-&#62;from([ &#39;foo&#39; ]);
    $sql-&#62;add_where(&#39;name&#39;,      &#39;fred&#39;);
    $sql-&#62;add_where(&#39;bucket_id&#39;, { op =&#62; &#39;!=&#39;, value =&#62; 47 });
    $sql-&#62;add_where(&#39;note_id&#39;,   \&#39;IS NULL&#39;);
    $sql-&#62;limit(1);

    my $sth = $dbh-&#62;prepare($sql-&#62;as_sql);
    $sth-&#62;execute(@{ $sql-&#62;{bind} });
    my @values = $sth-&#62;selectrow_array();

    my $obj = SomeObject-&#62;new();
    $obj-&#62;set_columns(...);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p><i>Data::ObjectDriver::SQL</i> represents an SQL statement. SQL statements are used internally to <code>Data::ObjectDriver::Driver::DBI</code> object drivers to convert database operations (<code>search()</code>, <code>update()</code>, etc) into database operations, but sometimes you just gotta use SQL.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ATTRIBUTES"
>ATTRIBUTES</a></h1>

<p><i>Data::ObjectDriver::SQL</i> sports several data attributes that represent the parts of the modeled SQL statement. These attributes all have accessor and mutator methods. Note that some attributes have more convenient methods of modification (for example, <code>add_where()</code> for the <code>where</code> attribute).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="select_(arrayref)"
><code>select</code> (arrayref)</a></h2>

<p>The database columns to select in a <code>SELECT</code> query.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="distinct_(boolean)"
><code>distinct</code> (boolean)</a></h2>

<p>Whether the <code>SELECT</code> query should return DISTINCT rows only.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="select_map_(hashref)"
><code>select_map</code> (hashref)</a></h2>

<p>The map of database column names to object fields in a <code>SELECT</code> query. Use this mapping to convert members of the <code>select</code> list to column names.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="select_map_reverse_(hashref)"
><code>select_map_reverse</code> (hashref)</a></h2>

<p>The map of object fields to database column names in a <code>SELECT</code> query. Use this map to reverse the <code>select_map</code> mapping where needed.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="from_(arrayref)"
><code>from</code> (arrayref)</a></h2>

<p>The list of tables from which to query results in a <code>SELECT</code> query.</p>

<p>Note if you perform a <code>SELECT</code> query with multiple tables, the rows will be selected as Cartesian products that you&#39;ll need to reduce with <code>WHERE</code> clauses. Your query might be better served with real joins specified through the <code>joins</code> attribute of your statement.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="joins_(arrayref_of_hashrefs_containing_scalars_and_hashrefs)"
><code>joins</code> (arrayref of hashrefs containing scalars and hashrefs)</a></h2>

<p>The list of <code>JOIN</code> clauses to use in the table list of the statement. Each clause is a hashref containing these members:</p>

<ul>
<li><code>table</code>
<p>The name of the table in <code>from</code> being joined.</p>
</li>

<li><code>joins</code> (arrayref)
<p>The list of joins to perform on the table named in <code>table</code>. Each member of <code>joins</code> is a hashref containing:</p>

<ul>
<li><code>type</code>
<p>The type of join to use. That is, the SQL string to use before the word <code>JOIN</code> in the join expression; for example, <code>INNER</code> or <code>NATURAL RIGHT OUTER</code>). This member is optional. When not specified, the default plain <code>JOIN</code> join is specified.</p>
</li>

<li><code>table</code>
<p>The name of the table to which to join.</p>
</li>

<li><code>condition</code>
<p>The SQL expression across which to perform the join, as a string.</p>
</li>
</ul>
</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="where_(arrayref)"
><code>where</code> (arrayref)</a></h2>

<p>The list of <code>WHERE</code> clauses that apply to the SQL statement. Individual members of the list are strings of SQL. All members of this attribute must be true for a record to be included as a result; that is, the list members are <code>AND</code>ed together to form the full <code>WHERE</code> clause.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="where_values_(hashref_of_variant_structures)"
><code>where_values</code> (hashref of variant structures)</a></h2>

<p>The set of data structures used to generate the <code>WHERE</code> clause SQL found in the <code>where</code> attributes, keyed on the associated column names.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="bind_(arrayref)"
><code>bind</code> (arrayref)</a></h2>

<p>The list of values to bind to the query when performed. That is, the list of values to be replaced for the <code>?</code>es in the SQL.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="limit_(scalar)"
><code>limit</code> (scalar)</a></h2>

<p>The maximum number of results on which to perform the query.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="offset_(scalar)"
><code>offset</code> (scalar)</a></h2>

<p>The number of records to skip before performing the query. Combined with a <code>limit</code> and application logic to increase the offset in subsequent queries, you can paginate a set of records with a moving window containing <code>limit</code> records.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="group_(hashref,_or_an_arrayref_of_hashrefs)"
><code>group</code> (hashref, or an arrayref of hashrefs)</a></h2>

<p>The fields on which to group the results. Grouping fields are hashrefs containing these members:</p>

<ul>
<li><code>column</code>
<p>Name of the column on which to group.</p>
</li>
</ul>

<p>Note you can set a single grouping field, or use an arrayref containing multiple grouping fields.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="having_(arrayref)"
><code>having</code> (arrayref)</a></h2>

<p>The list of clauses to specify in the <code>HAVING</code> portion of a <code>GROUP ... HAVING</code> clause. Individual clauses are simple strings containing the conditional expression, as in <code>where</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="order_(hashref,_or_an_arrayref_of_hashrefs)"
><code>order</code> (hashref, or an arrayref of hashrefs)</a></h2>

<p>Returns or sets the fields by which to order the results. Ordering fields are hashrefs containing these members:</p>

<ul>
<li><code>column</code>
<p>Name of the column by which to order.</p>
</li>

<li><code>desc</code>
<p>The SQL keyword to use to specify the ordering. For example, use <code>DESC</code> to specify a descending order. This member is optional.</p>
</li>
</ul>

<p>Note you can set a single ordering field, or use an arrayref containing multiple ordering fields.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$sql-&#62;comment([_$comment_])"
><code>$sql-&#62;comment([ $comment ])</code></a></h2>

<p>Returns or sets a simple comment to the SQL statement</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="USAGE"
>USAGE</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Data::ObjectDriver::SQL-&#62;new()"
><code>Data::ObjectDriver::SQL-&#62;new()</code></a></h2>

<p>Creates a new, empty SQL statement.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$sql-&#62;add_select($column_[,_$term_])"
><code>$sql-&#62;add_select($column [, $term ])</code></a></h2>

<p>Adds the database column <code>$column</code> to the list of fields to return in a <code>SELECT</code> query. The requested object member will be indicated to be <code>$term</code> in the statement&#39;s <code>select_map</code> and <code>select_map_reverse</code> attributes.</p>

<p><code>$term</code> is optional, and defaults to the same value as <code>$column</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$sql-&#62;add_join($table,_\@joins)"
><code>$sql-&#62;add_join($table, \@joins)</code></a></h2>

<p>Adds the join statement indicated by <code>$table</code> and <code>\@joins</code> to the list of <code>JOIN</code> table references for the statement. The structure for the set of joins are as described for the <code>joins</code> attribute member above.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$sql-&#62;add_index_hint($table,_$index)"
><code>$sql-&#62;add_index_hint($table, $index)</code></a></h2>

<p>Specifies a particular index to use for a particular table.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$sql-&#62;add_where($column,_$value)"
><code>$sql-&#62;add_where($column, $value)</code></a></h2>

<p>Adds a condition on the value of the database column <code>$column</code> to the statement&#39;s <code>WHERE</code> clause. A record will be tested against the below conditions according to what type of data structure <code>$value</code> is:</p>

<ul>
<li>a scalar
<p>The value of <code>$column</code> must equal <code>$value</code>.</p>
</li>

<li>a reference to a scalar
<p>The value of <code>$column</code> must evaluate true against the SQL given in <code>$$value</code>. For example, if <code>$$value</code> were <code>IS NULL</code>, <code>$column</code> must be <code>NULL</code> for a record to pass.</p>
</li>

<li>a hashref
<p>The value of <code>$column</code> must compare against the condition represented by <code>$value</code>, which can contain the members:</p>

<ul>
<li><code>value</code>
<p>The value with which to compare (required).</p>
</li>

<li><code>op</code>
<p>The SQL operator with which to compare <code>value</code> and the value of <code>$column</code> (required).</p>
</li>

<li><code>column</code>
<p>The column name for the comparison. If this is present, it overrides the column name <code>$column</code>, allowing you to build more complex conditions like <code>((foo = 1 AND bar = 2) OR (baz = 3))</code>.</p>
</li>
</ul>

<p>For example, if <code>value</code> were <code>NULL</code> and <code>op</code> were <code>IS</code>, a record&#39;s <code>$column</code> column would have to be <code>NULL</code> to match.</p>
</li>

<li>an arrayref of scalars
<p>The value of <code>$column</code> may equal any of the members of <code>@$value</code>. The generated SQL performs the comparison with as an <code>IN</code> expression.</p>
</li>

<li>an arrayref of (mostly) references
<p>The value of <code>$column</code> must compare against <i>any</i> of the expressions represented in <code>@$value</code>. Each member of the list can be any of the structures described here as possible forms of <code>$value</code>.</p>

<p>If the first member of the <code>@$value</code> array is the scalar string <code>-and</code>, <i>all</i> subsequent members of &#60;@$value&#62; must be met for the record to match. Note this is not very useful unless contained as one option of a larger <code>OR</code> alternation.</p>
</li>
</ul>

<p>All individual conditions specified with <code>add_where()</code> must be true for a record to be a result of the query.</p>

<p>Beware that you can create a circular reference that will recursively generate an infinite SQL statement (for example, by specifying a arrayref <code>$value</code> that itself contains <code>$value</code>). As <code>add_where()</code> evaluates your expressions before storing the conditions in the <code>where</code> attribute as a generated SQL string, this will occur when calling <code>add_where()</code>, not <code>as_sql()</code>. So don&#39;t do that.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$sql-&#62;add_complex_where(\@list)"
><code>$sql-&#62;add_complex_where(\@list)</code></a></h2>

<p>This method accepts an array reference of clauses that are glued together with logical operators. With it, you can express where clauses that mix logical operators together to produce more complex queries. For instance:</p>

<pre>    [ { foo =&#62; 1, bar =&#62; 2 }, -or =&#62; { baz =&#62; 3 } ]</pre>

<p>The values given for the columns support all the variants documented for the <code>add_where()</code> method above. Logical operators used inbetween the hashref elements can be one of: &#39;-or&#39;, &#39;-and&#39;, &#39;-or_not&#39;, &#39;-and_not&#39;.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$sql-&#62;has_where($column,_[$value])"
><code>$sql-&#62;has_where($column, [$value])</code></a></h2>

<p>Returns whether a where clause for the column <code>$column</code> was added to the statement with the <code>add_where()</code> method.</p>

<p>The <code>$value</code> argument is currently ignored.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$sql-&#62;add_having($column,_$value)"
><code>$sql-&#62;add_having($column, $value)</code></a></h2>

<p>Adds an expression to the <code>HAVING</code> portion of the statement&#39;s <code>GROUP ... HAVING</code> clause. The expression compares <code>$column</code> using <code>$value</code>, which can be any of the structures described above for the <code>add_where()</code> method.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$sql-&#62;add_index_hint($table,_\@hints)"
><code>$sql-&#62;add_index_hint($table, \@hints)</code></a></h2>

<p>Addes the index hint into a <code>SELECT</code> query. The structure for the set of <code>\@hints</code> are arrayref of hashrefs containing these members:</p>

<ul>
<li><code>type</code> (scalar)
<p>The name of the type. &#34;USE&#34;, &#34;IGNORE or &#34;FORCE&#34;.</p>
</li>

<li><code>list</code> (arrayref)
<p>The list of name of indexes which to use.</p>
</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$sql-&#62;as_sql()"
><code>$sql-&#62;as_sql()</code></a></h2>

<p>Returns the SQL fully representing the SQL statement <code>$sql</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$sql-&#62;as_sql_having()"
><code>$sql-&#62;as_sql_having()</code></a></h2>

<p>Returns the SQL representing the <code>HAVING</code> portion of <code>$sql</code>&#39;s <code>GROUP ... HAVING</code> clause.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$sql-&#62;as_sql_where()"
><code>$sql-&#62;as_sql_where()</code></a></h2>

<p>Returns the SQL representing <code>$sql</code>&#39;s <code>WHERE</code> clause.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$sql-&#62;as_limit()"
><code>$sql-&#62;as_limit()</code></a></h2>

<p>Returns the SQL for the <code>LIMIT ... OFFSET</code> clause of the statement.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$sql-&#62;as_aggregate($set)"
><code>$sql-&#62;as_aggregate($set)</code></a></h2>

<p>Returns the SQL representing the aggregation clause of type <code>$set</code> for the SQL statement <code>$sql</code>. Reasonable values of <code>$set</code> are <code>ORDER</code> and <code>GROUP</code>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DIAGNOSTICS"
>DIAGNOSTICS</a></h1>

<ul>
<li><code>Invalid/unsafe column name <i>column</i></code>
<p>The column name you specified to <code>add_where()</code> contained characters that are not allowed in database column names. Only word characters and periods are allowed. Perhaps you didn&#39;t filter punctuation out of a generated column name correctly.</p>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS_AND_LIMITATIONS"
>BUGS AND LIMITATIONS</a></h1>

<p><i>Data::ObjectDriver::SQL</i> does not provide the functionality for turning SQL statements into instances of object classes.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENSE"
>LICENSE</a></h1>

<p><i>Data::ObjectDriver</i> is free software; you may redistribute it and/or modify it under the same terms as Perl itself.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR_&#38;_COPYRIGHT"
>AUTHOR &#38; COPYRIGHT</a></h1>

<p>Except where otherwise noted, <i>Data::ObjectDriver</i> is Copyright 2005-2006 Six Apart, cpan@sixapart.com. All rights reserved.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
