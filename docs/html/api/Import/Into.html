<html><head><title>Import::Into</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:18 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#CONTRIBUTORS'>CONTRIBUTORS</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
  <li class='indexItem indexItem1'><a href='#LICENSE'>LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Import::Into - import packages into other packages</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  package My::MultiExporter;

  use Import::Into;

  use Thing1 ();
  use Thing2 ();

  sub import {
    my $target = caller;
    Thing1-&#62;import::into($target);
    Thing2-&#62;import::into($target, qw(import arguments));
  }</pre>

<p>Note: you don&#39;t need to do anything more clever than this provided you document that people wanting to re-export your module should also be using <a href="../Import/Into.html" class="podlinkpod"
>Import::Into</a>. In fact, for a single module you can simply do:</p>

<pre>  sub import {
    ...
    Thing1-&#62;import::into(scalar caller);
  }</pre>

<p>Notably, this works:</p>

<pre>  use base qw(Exporter);

  sub import {
    shift-&#62;export_to_level(1);
    Thing1-&#62;import::into(scalar caller);
  }</pre>

<p>Note 2: You do <b>not</b> need to do anything to Thing1 to be able to call <code>import::into</code> on it. This is a global method, and is callable on any package (and in fact on any object as well, although it&#39;s rarer that you&#39;d want to do that).</p>

<p>Finally, we also provide an <code>unimport::out_of</code> to allow the exporting of the effect of <code>no</code>:</p>

<pre>  # unimport::out_of was added in 1.1.0 (1.001000)
  sub unimport {
    Moose-&#62;unimport::out_of(scalar caller); # no MyThing == no Moose
  }</pre>

<p>If how and why this all works is of interest to you, please read on to the description immediately below.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Writing exporters is a pain. Some use <a href="../Exporter.html" class="podlinkpod"
>Exporter</a>, some use <a href="../Sub/Exporter.html" class="podlinkpod"
>Sub::Exporter</a>, some use <a href="../Moose/Exporter.html" class="podlinkpod"
>Moose::Exporter</a>, some use <a href="../Exporter/Declare.html" class="podlinkpod"
>Exporter::Declare</a> ... and some things are pragmas.</p>

<p>If you want to re-export other things, you have to know which is which. <a href="../Exporter.html" class="podlinkpod"
>Exporter</a> subclasses provide export_to_level, but if they overrode their import method all bets are off. <a href="../Sub/Exporter.html" class="podlinkpod"
>Sub::Exporter</a> provides an into parameter but figuring out something used it isn&#39;t trivial. Pragmas need to have their <code>import</code> method called directly since they affect the current unit of compilation.</p>

<p>It&#39;s ... annoying.</p>

<p>However, there is an approach that actually works for all of these types.</p>

<pre>  eval &#34;package $target; use $thing;&#34;</pre>

<p>will work for anything checking caller, which is everything except pragmas. But it doesn&#39;t work for pragmas - pragmas need:</p>

<pre>  $thing-&#62;import;</pre>

<p>because they&#39;re designed to affect the code currently being compiled - so within an eval, that&#39;s the scope of the eval itself, not the module that just <code>use</code>d you - so</p>

<pre>  sub import {
    eval &#34;use strict;&#34;
  }</pre>

<p>doesn&#39;t do what you wanted, but</p>

<pre>  sub import {
    strict-&#62;import;
  }</pre>

<p>will apply <a href="../strict.html" class="podlinkpod"
>strict</a> to the calling file correctly.</p>

<p>Of course, now you have two new problems - first, that you still need to know if something&#39;s a pragma, and second that you can&#39;t use either of these approaches alone on something like <a href="../Moose.html" class="podlinkpod"
>Moose</a> or <a href="../Moo.html" class="podlinkpod"
>Moo</a> that&#39;s both an exporter and a pragma.</p>

<p>So, the complete solution is:</p>

<pre>  my $sub = eval &#34;package $target; sub { shift-&#62;import(\@_) }&#34;;
  $sub-&#62;($thing, @import_args);</pre>

<p>which means that import is called from the right place for pragmas to take effect, and from the right package for caller checking to work - and so behaves correctly for all types of exporter, for pragmas, and for hybrids.</p>

<p>Remembering all this, however, is excessively irritating. So I wrote a module so I didn&#39;t have to anymore. Loading <a href="../Import/Into.html" class="podlinkpod"
>Import::Into</a> creates a global method <code>import::into</code> which you can call on any package to import it into another package. So now you can simply write:</p>

<pre>  use Import::Into;

  $thing-&#62;import::into($target, @import_args);</pre>

<p>This works because of how perl resolves method calls - a call to a simple method name is resolved against the package of the class or object, so</p>

<pre>  $thing-&#62;method_name(@args);</pre>

<p>is roughly equivalent to:</p>

<pre>  my $code_ref = $thing-&#62;can(&#39;method_name&#39;);
  $code_ref-&#62;($thing, @args);</pre>

<p>while if a <code>::</code> is found, the lookup is made relative to the package name (i.e. everything before the last <code>::</code>) so</p>

<pre>  $thing-&#62;Package::Name::method_name(@args);</pre>

<p>is roughly equivalent to:</p>

<pre>  my $code_ref = Package::Name-&#62;can(&#39;method_name&#39;);
  $code_ref-&#62;($thing, @args);</pre>

<p>So since <a href="../Import/Into.html" class="podlinkpod"
>Import::Into</a> defines a method <code>into</code> in package <code>import</code> the syntax reliably calls that.</p>

<p>For more craziness of this order, have a look at the article I wrote at <a href="http://shadow.cat/blog/matt-s-trout/madness-with-methods" class="podlinkurl"
>http://shadow.cat/blog/matt-s-trout/madness-with-methods</a> which covers coderef abuse and the <code>${\...}</code> syntax.</p>

<p>Final note: You do still need to ensure that you already loaded <code>$thing</code> - if you&#39;re receiving this from a parameter, I recommend using <a href="../Module/Runtime.html" class="podlinkpod"
>Module::Runtime</a>:</p>

<pre>  use Import::Into;
  use Module::Runtime qw(use_module);

  use_module($thing)-&#62;import::into($target, @import_args);</pre>

<p>And that&#39;s it.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>mst - Matt S. Trout (cpan:MSTROUT) &#60;mst@shadowcat.co.uk&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CONTRIBUTORS"
>CONTRIBUTORS</a></h1>

<p>None yet - maybe this software is perfect! (ahahahahahahahahaha)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright (c) 2012 the Import::Into <a href="#AUTHOR" class="podlinkpod"
>&#34;AUTHOR&#34;</a> and <a href="#CONTRIBUTORS" class="podlinkpod"
>&#34;CONTRIBUTORS&#34;</a> as listed above.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENSE"
>LICENSE</a></h1>

<p>This library is free software and may be distributed under the same terms as perl itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
