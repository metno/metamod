<html><head><title>Archive::Zip::MemberRead</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:02 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Archive::Zip::MemberRead - A wrapper that lets you read Zip archive members as if they were files.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use Archive::Zip;
  use Archive::Zip::MemberRead;
  $zip = Archive::Zip-&#62;new(&#34;file.zip&#34;);
  $fh  = Archive::Zip::MemberRead-&#62;new($zip, &#34;subdir/abc.txt&#34;);
  while (defined($line = $fh-&#62;getline()))
  {
      print $fh-&#62;input_line_number . &#34;#: $line\n&#34;;
  }

  $read = $fh-&#62;read($buffer, 32*1024);
  print &#34;Read $read bytes as :$buffer:\n&#34;;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>The Archive::Zip::MemberRead module lets you read Zip archive member data just like you read data from files.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<dl>
<dt><a name="Archive::Zip::Member::readFileHandle()"
>Archive::Zip::Member::readFileHandle()</a></dt>

<dd>
<p>You can get a <code>Archive::Zip::MemberRead</code> from an archive member by calling <code>readFileHandle()</code>:</p>

<pre>  my $member = $zip-&#62;memberNamed(&#39;abc/def.c&#39;);
  my $fh = $member-&#62;readFileHandle();
  while (defined($line = $fh-&#62;getline()))
  {
      # ...
  }
  $fh-&#62;close();</pre>

<dt><a name="Archive::Zip::MemberRead-&#62;new($zip,_$fileName)"
>Archive::Zip::MemberRead-&#62;new($zip, $fileName)</a></dt>

<dd>
<dt><a name="Archive::Zip::MemberRead-&#62;new($zip,_$member)"
>Archive::Zip::MemberRead-&#62;new($zip, $member)</a></dt>

<dd>
<dt><a name="Archive::Zip::MemberRead-&#62;new($member)"
>Archive::Zip::MemberRead-&#62;new($member)</a></dt>

<dd>
<p>Construct a new Archive::Zip::MemberRead on the specified member.</p>

<pre>  my $fh = Archive::Zip::MemberRead-&#62;new($zip, &#39;fred.c&#39;)</pre>

<dt><a name="setLineEnd(expr)"
>setLineEnd(expr)</a></dt>

<dd>
<p>Set the line end character to use. This is set to \n by default except on Windows systems where it is set to \r\n. You will only need to set this on systems which are not Windows or Unix based and require a line end diffrent from \n. This is a class method so call as <code>Archive::Zip::MemberRead</code>-&#62;<code>setLineEnd($nl)</code></p>

<dt><a name="rewind()"
>rewind()</a></dt>

<dd>
<p>Rewinds an <code>Archive::Zip::MemberRead</code> so that you can read from it again starting at the beginning.</p>

<dt><a name="input_record_separator(expr)"
>input_record_separator(expr)</a></dt>

<dd>
<p>If the argumnet is given, input_record_separator for this instance is set to it. The current setting (which may be the global $/) is always returned.</p>

<dt><a name="input_line_number()"
>input_line_number()</a></dt>

<dd>
<p>Returns the current line number, but only if you&#39;re using <code>getline()</code>. Using <code>read()</code> will not update the line number.</p>

<dt><a name="close()"
>close()</a></dt>

<dd>
<p>Closes the given file handle.</p>

<dt><a name="buffer_size([_$size_])"
>buffer_size([ $size ])</a></dt>

<dd>
<p>Gets or sets the buffer size used for reads. Default is the chunk size used by Archive::Zip.</p>

<dt><a name="getline()"
>getline()</a></dt>

<dd>
<p>Returns the next line from the currently open member. Makes sense only for text files. A read error is considered fatal enough to die. Returns undef on eof. All subsequent calls would return undef, unless a rewind() is called. Note: The line returned has the input_record_separator (default: newline) removed.</p>

<dt><a name="read($buffer,_$num_bytes_to_read)"
>read($buffer, $num_bytes_to_read)</a></dt>

<dd>
<p>Simulates a normal <code>read()</code> system call. Returns the no. of bytes read. <code>undef</code> on error, 0 on eof, <i>e.g.</i>:</p>

<pre>  $fh = Archive::Zip::MemberRead-&#62;new($zip, &#34;sreeji/secrets.bin&#34;);
  while (1)
  {
    $read = $fh-&#62;read($buffer, 1024);
    die &#34;FATAL ERROR reading my secrets !\n&#34; if (!defined($read));
    last if (!$read);
    # Do processing.
    ....
   }</pre>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Sreeji K. Das, &#60;sreeji_k@yahoo.com&#62; See <a href="../../Archive/Zip.html" class="podlinkpod"
>Archive::Zip</a> by Ned Konz without which this module does not make any sense!</p>

<p>Minor mods by Ned Konz.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright 2002 Sreeji K. Das.</p>

<p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
