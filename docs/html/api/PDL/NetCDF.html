<html><head><title>PDL::NetCDF</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:24 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#FUNCTIONS'>FUNCTIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#isNetcdf4'>isNetcdf4</a>
    <li class='indexItem indexItem2'><a href='#defaultFormat'>defaultFormat</a>
    <li class='indexItem indexItem2'><a href='#new'>new</a>
    <li class='indexItem indexItem2'><a href='#getFormat'>getFormat</a>
    <li class='indexItem indexItem2'><a href='#put'>put</a>
    <li class='indexItem indexItem2'><a href='#putslice'>putslice</a>
    <li class='indexItem indexItem2'><a href='#sync'>sync</a>
    <li class='indexItem indexItem2'><a href='#get'>get</a>
    <li class='indexItem indexItem2'><a href='#putatt'>putatt</a>
    <li class='indexItem indexItem2'><a href='#getatt'>getatt</a>
    <li class='indexItem indexItem2'><a href='#getDeflateShuffle'>getDeflateShuffle</a>
    <li class='indexItem indexItem2'><a href='#getvariabletype'>getvariabletype</a>
    <li class='indexItem indexItem2'><a href='#puttext'>puttext</a>
    <li class='indexItem indexItem2'><a href='#gettext'>gettext</a>
    <li class='indexItem indexItem2'><a href='#dimsize'>dimsize</a>
    <li class='indexItem indexItem2'><a href='#close'>close</a>
    <li class='indexItem indexItem2'><a href='#getdimensionnames_(%5B%24varname%5D)'>getdimensionnames ([$varname])</a>
    <li class='indexItem indexItem2'><a href='#getattributenames'>getattributenames</a>
    <li class='indexItem indexItem2'><a href='#getvariablenames'>getvariablenames</a>
    <li class='indexItem indexItem2'><a href='#setrec'>setrec</a>
    <li class='indexItem indexItem2'><a href='#getrec'>getrec</a>
    <li class='indexItem indexItem2'><a href='#putrec'>putrec</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#WRITING_NetCDF-FILES_EFFICIENTLY'>WRITING NetCDF-FILES EFFICIENTLY</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#CONTRIBUTORS'>CONTRIBUTORS</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>PDL::NetCDF - Object-oriented interface between NetCDF files and PDL objects.</p>

<p>Perl extension to allow interface to NetCDF portable binary gridded files via PDL objects.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use PDL;
  use PDL::NetCDF;
  use PDL::Char;

  my $ncobj = PDL::NetCDF-&#62;new (&#34;test.nc&#34;, {REVERSE_DIMS =&#62; 1});  # New file
  my $pdl = pdl [[1, 2, 3], [4, 5, 6]];

  # Specify variable name to put PDL in, plus names of the dimensions.  Dimension         
  # lengths are taken from the PDL, in this case, dim1 = 2 and dim2 = 3.      
  $ncobj-&#62;put (&#39;var1&#39;, [&#39;dim1&#39;, &#39;dim2&#39;], $pdl);
  # or for netcdf4 files
  # $ncobj-&#62;put (&#39;var1&#39;, [&#39;dim1&#39;, &#39;dim2&#39;], $pdl, {DEFLATE =&#62; 9});  

  # get the deflate level (for any fileformat)
  my ($deflate, $shuffle) = $ncobj-&#62;getDeflateShuffle(&#39;var1&#39;);

  # $pdlout = [[1, 2, 3], [4, 5, 6]]
  my $pdlout = $ncobj-&#62;get (&#39;var1&#39;);

  # Store textual NetCDF arrays using perl strings:  (This is a bit primitive, but works)
  my $str = &#34;Station1  Station2  Station3  &#34;;
  $obj-&#62;puttext(&#39;textvar&#39;, [&#39;n_station&#39;, &#39;n_string&#39;], [3,10], $str);
  my $outstr = $obj-&#62;gettext(&#39;textvar&#39;);
  # $outstr = &#34;Station1  Station2  Station3  &#34;


  # Now textual NetCDF arrays can be stored with PDL::Char style PDLs.  This is much
  # more natural and flexible than the above method.
  $str = PDL::Char-&#62;new ([&#39;Station1&#39;, &#39;Station2&#39;, &#39;Station3&#39;]);
  $obj-&#62;put (&#39;stations&#39;, [&#39;dim_station&#39;, &#39;dim_charlen&#39;], $str);
  $outstr = $obj-&#62;get(&#39;stations&#39;);
  print $outstr;
  # Prints: [&#39;Station1&#39;, &#39;Station2&#39;, &#39;Station3&#39;]
  # For more info on PDL::Char variables see PDL::Char(3), or perldoc PDL::Char

  # $dim1size = 2
  my $dim1size = $ncobj-&#62;dimsize(&#39;dim1&#39;);

  # A slice of the netCDF variable.
  # [0,0] is the starting point, [1,2] is the count.
  # $slice = [1,2]
  my $slice  = $ncobj-&#62;get (&#39;var1&#39;, [0,0], [1,2]);

  # Attach a double attribute of size 3 to var1
  $ncobj-&#62;putatt (double([1,2,3]), &#39;double_attribute&#39;, &#39;var1&#39;);

  # $attr1 = [1,2,3]
  my $attr1 = $ncobj-&#62;getatt (&#39;double_attribute&#39;, &#39;var1&#39;);

  # $type = PDL::double
  my $type = $ncobj-&#62;getvariabletype(&#39;var1&#39;);

  # Write a textual, global attribute.  &#39;attr_name&#39; is the attribute name.
  $ncobj-&#62;putatt (&#39;The text of the global attribute&#39;, &#39;attr_name&#39;);          

  # $attr2 = &#39;The text of the global attribute&#39;
  my $attr2 = $ncobj-&#62;getatt (&#39;attr_name&#39;);

  # Close the netCDF file.  The file is also automatically closed in a DESTROY block
  # when it passes out of scope.  This just makes is explicit.
  $ncobj-&#62;close;</pre>

<p>For (much) more information on NetCDF, see</p>

<p>http://www.unidata.ucar.edu/packages/netcdf/index.html</p>

<p>Also see the test file, test.pl in this distribution for some working examples.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This is the PDL interface to the Unidata NetCDF library. It uses the netCDF version 3 library to make a subset of netCDF functionality available to PDL users in a clean, object-oriented interface.</p>

<p>Another NetCDF perl interface, which allows access to the entire range of netCDF functionality (but in a non-object-oriented style which uses perl arrays instead of PDLs) is available through Unidata at http://www.unidata.ucar.edu/packages/netcdf/index.html).</p>

<p>The NetCDF standard allows N-dimensional binary data to be efficiently stored, annotated and exchanged between many platforms.</p>

<p>When one creates a new netCDF object, this object is associated with one netCDF file.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FUNCTIONS"
>FUNCTIONS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="isNetcdf4"
>isNetcdf4</a></h2>

<p>Check if compiled against netcdf4</p>

<p>Arguments: none</p>

<pre>  if (PDL::NetCDF::isNetcdf4) {
        # open netcdf4 file
  }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="defaultFormat"
>defaultFormat</a></h2>

<p>Get or change the default format when creating a netcdf-file. This can be overwritten by the NC_FORMAT option for new. Possible values are: PDL::NetCDF::NC_FORMAT_CLASSIC, PDL::NetCDF::NC_FORMAT_64BIT, PDL::NetCDF::NC_FORMAT_NETCDF4, PDL::NetCDF::NC_FORMAT_NETCDF4_CLASSIC</p>

<pre> Arguments:
 1) new format (constant)
 Return:
 old format as one of the NC_FORMAT_* constants</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="new"
>new</a></h2>

<p>Create an object representing a netCDF file.</p>

<pre> Arguments:  
 1) The name of the file.
 2) optional:  A hashref containing options.  Currently defined are:
    TEMPLATE:
    An existing netCDF object for a file with
    identical layout.  This allows one to read in many similar netCDF
    files without incurring the overhead of reading in all variable
    and dimension names and IDs each time.  Caution:  Undefined
    weirdness may occur if you pass the netCDF object from a dissimilar
    file!
    MODE:
    use sysopen file-opening arguments, O_RDONLY, O_RDWR, O_CREAT, O_EXCL
    when used, this will overwrite the &#39;&#62;file.nc&#39; type of opening
    see L&#60;perlopentut&#62; for usage of O_RDONLY...
    REVERSE_DIMS:
    this will turn the order of the dimension-names of
    netcdf-files. Even with this option the &#39;put&#39; function will write
    variables in FORTRAN order (as before) and will reverse the
    dimension names so they fit this order.  With this option, the
    &#39;putslice&#39; function will write varibles in the same way as &#39;put&#39;.
    You should use this option if your planning to work with other
    netcdf-programs (ncview, NCL) or if you are planning to combine
    putslice and slice.  You should _not_ use this option, if you need
    compatibility to older versions of PDL::NetCDF.
    NC_FORMAT:
    set the file format for a new netcdf file, see defaultFormat()
    SLOW_CHAR_FETCH:
    If this option is set, then a &#39;get&#39; into a PDL::Char will be done
    one string at a time instead of all text data at once.  This
    is necessary if there are NULLs (hex 0) values embedded in the string
    arrays.  This takes longer, but gives the correct results.  If
    the fetch of a string array yields only the first element, try setting
    this option.</pre>

<p>Example:</p>

<pre>  my $nc = PDL::NetCDF-&#62;new (&#34;file1.nc&#34;, {REVERSE_DIMS =&#62; 1});
  ...
  foreach my $ncfile (@a_bunch_of_similar_format_netcdf_files) {
    $nc = PDL::NetCDF-&#62;new(&#34;file2.nc&#34;, {TEMPLATE =&#62; $nc});  # These calls to &#39;new&#39; are *much* faster
    ...
  }

  # opening using MODE
  use Fcntl; # define O_CREAT...
  # opening a completely new file (deleting if it exists!)
  my $newnc = PDL::NetCDF-&#62;new (&#34;file2.nc&#34;, {MODE =&#62; O_CREAT|O_RDWR,
                                             REVERSE_DIMS =&#62; 1, NC_FORMAT =&#62; PDL::NetCDF::NC_FORMAT_NETCDF4});
  # opening existing file for reading and writing
  $nc = PDL::NetCDF-&#62;new (&#34;file2.nc&#34;, {MODE =&#62; O_RDWR}
                        REVERSE_DIMS =&#62; 1});
  # opening existing file for reading only
  $nc = PDL::NetCDF-&#62;new (&#34;file2.nc&#34;, {MODE =&#62; O_RDONLY,
                                       REVERSE_DIMS =&#62; 1});</pre>

<p>If this file exists and you want to write to it, prepend the name with the &#39;&#62;&#39; character: &#34;&#62;name.nc&#34;</p>

<p>Returns: The netCDF object. Barfs if there is an error.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="getFormat"
>getFormat</a></h2>

<p>Get the format of a netcdf file</p>

<p>Arguments: none</p>

<p>Returns: @ integer equal to one of the PDL::NetCDF::NC_FORMAT_* constants.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="put"
>put</a></h2>

<p>Put a PDL matrix to a netCDF variable.</p>

<p>Arguments:</p>

<p>1) The name of the variable to create</p>

<p>2) A reference to a list of dimension names for this variable</p>

<p>3) The PDL to put. It must have the same number of dimensions as specified in the dimension name list.</p>

<p>4) Optional options hashref: {SHUFFLE =&#62; 1, DEFLATE =&#62; 7, COMPRESS =&#62; 0}</p>

<p>Returns: None.</p>

<pre>  my $pdl = pdl [[1, 2, 3], [4, 5, 6]];

  # Specify variable name to put PDL in, plus names of the dimensions.  Dimension         
  # lengths are taken from the PDL, in this case, dim1 = 2 and dim2 = 3.      
  $ncobj-&#62;put (&#39;var1&#39;, [&#39;dim1&#39;, &#39;dim2&#39;], $pdl);                                               
                                            
  # Now textual NetCDF arrays can be stored with PDL::Char style PDLs.  
  $str = PDL::Char-&#62;new ([&#39;Station1&#39;, &#39;Station2&#39;, &#39;Station3&#39;]);
  $obj-&#62;put (&#39;stations&#39;, [&#39;dim_station&#39;, &#39;dim_charlen&#39;], $str);
  $outstr = $obj-&#62;get(&#39;stations&#39;);
  print $outstr;
  # Prints: [&#39;Station1&#39;, &#39;Station2&#39;, &#39;Station3&#39;]
  # For more info on PDL::Char variables see PDL::Char(3), or perldoc PDL::Char</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="putslice"
>putslice</a></h2>

<p>Put a PDL matrix to a slice of a NetCDF variable</p>

<p>Arguments:</p>

<p>1) The name of the variable to create</p>

<p>2) A reference to a list of dimension names for this variable</p>

<p>3) A reference to a list of dimensions for this variable</p>

<p>4) A reference to a list which specifies the N dimensional starting point of the slice.</p>

<p>5) A reference to a list which specifies the N dimensional count of the slice.</p>

<p>6) The PDL to put. It must conform to the size specified by the 4th and 5th arguments. The 2nd and 3rd argument are optional if the variable is already defined in the netcdf object.</p>

<p>7) Optional options: {DEFLATE =&#62; 7, SHUFFLE =&#62; 0/1} will use gzip compression (level 7) on that variable and shuffle will not/will use the shuffle filter. These options are only valid for netcdf4 files. If you are unsure, test with ($nc-&#62;getFormat &#62;= PDL::NetCDF::NC_FORMAT::NC_FORMAT_NETCDF4)</p>

<p>Returns: None.</p>

<pre>  my $pdl = pdl [[1, 2, 3], [4, 5, 6]];

  # Specify variable name to put PDL in, plus names of the dimensions.  Dimension         
  # lengths are taken from the PDL, in this case, dim1 = 2 and dim2 = 3.      
  $ncobj-&#62;putslice (&#39;var1&#39;, [&#39;dim1&#39;, &#39;dim2&#39;, &#39;dim3&#39;], [2,3,3], [0,0,0], [2,3,1], $pdl);                                               
  $ncobj-&#62;putslice (&#39;var1&#39;, [], [], [0,0,2], [2,3,1], $pdl);                                               

  my $pdl2 = $ncobj-&#62;get(&#39;var1&#39;);

  print $pdl2;

  [
 [
  [          1 9.96921e+36           1]
  [          2 9.96921e+36           2]
  [          3 9.96921e+36           3]
 ]
 [
  [          4 9.96921e+36           4]
  [          5 9.96921e+36           5]
  [          6 9.96921e+36           6]
 ]
]

 note that the netcdf missing value (not 0) is filled in.    </pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="sync"
>sync</a></h2>

<p>Syncronize the data to the disk. Use this if you want to read the file from another process without closing the file. This makes only sense after put, puttext, putslice, putatt operations</p>

<p>Returns: nothing. Barfs on error.</p>

<pre>  $ncobj-&#62;sync</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get"
>get</a></h2>

<p>Get a PDL matrix from a netCDF variable.</p>

<p>Arguments:</p>

<p>1) The name of the netCDF variable to fetch. If this is the only argument, then the entire variable will be returned.</p>

<p>To fetch a slice of the netCDF variable, optional 2nd and 3rd argments must be specified:</p>

<p>2) A pdl which specifies the N dimensional starting point of the slice.</p>

<p>3) A pdl which specifies the N dimensional count of the slice.</p>

<p>Also, an options hashref may be passed. The only option currently is &#39;NOCOMPRESS&#39; which tells PDL::NetCDF to *not* try to uncompress an compressed variable. See the COMPRESS option on &#39;put&#39; and &#39;putslice&#39; for more info.</p>

<p>Returns: The PDL representing the netCDF variable. Barfs on error.</p>

<pre>  # A slice of the netCDF variable.
  # [0,0] is the starting point, [1,2] is the count.
  my $slice  = $ncobj-&#62;get (&#39;var1&#39;, [0,0], [1,2], {NOCOMPRESS =&#62; 1});

  # If var1 contains this:  [[1, 2, 3], [4, 5, 6]]
  # Then $slice contains: [1,2] (Size &#39;1&#39; dimensions are eliminated).</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="putatt"
>putatt</a></h2>

<p>putatt -- Attach a numerical or textual attribute to a NetCDF variable or the entire file.</p>

<p>Arguments:</p>

<p>1) The attribute. Either: A one dimensional PDL (perhaps contining only one number) or a string.</p>

<p>2) The name to give the attribute in the netCDF file. Many attribute names have pre-defined meanings. See the netCDF documentation for more details.</p>

<p>3) Optionally, you may specify the name of the pre-defined netCDF variable to associate this attribute with. If this is left off, the attribute is a global one, pertaining to the entire netCDF file.</p>

<p>Returns: Nothing. Barfs on error.</p>

<pre>  # Attach a double attribute of size 3 to var1
  $ncobj-&#62;putatt (double([1,2,3]), &#39;double_attribute&#39;, &#39;var1&#39;);

  # Write a textual, global attribute.  &#39;attr_name&#39; is the attribute name.
  $ncobj-&#62;putatt (&#39;The text of the global attribute&#39;, &#39;attr_name&#39;);          </pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="getatt"
>getatt</a></h2>

<p>Get an attribute from a netCDF object.</p>

<p>Arguments:</p>

<p>1) The name of the attribute (a text string).</p>

<p>2) The name of the variable this attribute is attached to. If this argument is not specified, this function returns a global attribute of the input name.</p>

<pre>  # Get a global attribute
  my $attr2 = $ncobj-&#62;getatt (&#39;attr_name&#39;);

  # Get an attribute associated with the varibale &#39;var1&#39;
  my $attr1 = $ncobj-&#62;getatt (&#39;double_attribute&#39;, &#39;var1&#39;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="getDeflateShuffle"
>getDeflateShuffle</a></h2>

<p>Get the deflate level and the shuffle flag for a variable.</p>

<p>Can be called on all files, although only netcdf4 files support shuffle and deflate.</p>

<p>Arguments:</p>

<p>1) The name of the variable.</p>

<p>Returns:</p>

<p>($deflate, $shuffle)</p>

<pre>  my ($deflate, $shuffle) = $nc-&#62;getDeflateShuffle(&#39;varName&#39;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="getvariabletype"
>getvariabletype</a></h2>

<p>Get a type of a variable from a netCDF object.</p>

<p>Arguments:</p>

<p>1) The name of the variable.</p>

<p>Returns: PDL::type or undef, when variable not defined</p>

<pre>  # Get a type
  my $type = $ncobj-&#62;getvariabletype (&#39;var1&#39;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="puttext"
>puttext</a></h2>

<p>Put a perl text string into a multi-dimensional NetCDF array.</p>

<p>Arguments:</p>

<p>1) The name of the variable to be created (a text string).</p>

<p>2) A reference to a perl list of dimension names to use in creating this NetCDF array.</p>

<p>3) A reference to a perl list of dimension lengths.</p>

<p>4) A perl string to put into the netCDF array. If the NetCDF array is 3 x 10, then the string must have 30 charactars.</p>

<p>5) Optional nc4 options: {DEFLATE =&#62; 7, SHUFFLE =&#62; 0}</p>

<pre>  my $str = &#34;Station1  Station2  Station3  &#34;;
  $obj-&#62;puttext(&#39;textvar&#39;, [&#39;n_station&#39;, &#39;n_string&#39;], [3,10], $str);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="gettext"
>gettext</a></h2>

<p>Get a multi-dimensional NetCDF array into a perl string.</p>

<p>Arguments:</p>

<p>1) The name of the NetCDF variable.</p>

<pre>  my $outstr = $obj-&#62;gettext(&#39;textvar&#39;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="dimsize"
>dimsize</a></h2>

<p>Get the size of a dimension from a netCDF object.</p>

<p>Arguments:</p>

<p>1) The name of the dimension.</p>

<p>Returns: The size of the dimension.</p>

<pre>  my $dim1size = $ncobj-&#62;dimsize(&#39;dim1&#39;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="close"
>close</a></h2>

<p>Close a NetCDF object, writing out the file.</p>

<p>Arguments: None</p>

<p>Returns: Nothing</p>

<p>This closing of the netCDF file can be done explicitly though the &#39;close&#39; method. Alternatively, a DESTROY block does an automatic close whenever the netCDF object passes out of scope.</p>

<pre>  $ncobj-&#62;close();</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="getdimensionnames_([$varname])"
>getdimensionnames ([$varname])</a></h2>

<p>Get all the dimension names from an open NetCDF object. If a variable name is specified, just return dimension names for *that* variable.</p>

<p>Arguments: none</p>

<p>Returns: An array reference of dimension names</p>

<pre>  my $varlist = $ncobj-&#62;getdimensionnames();
  foreach(@$varlist){
    print &#34;Found dim $_\n&#34;;
  }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="getattributenames"
>getattributenames</a></h2>

<p>Get the attribute names for a given variable from an open NetCDF object.</p>

<p>Arguments: Optional variable name, with no arguments it will return the objects global netcdf attributes.</p>

<p>Returns: An array reference of attribute names</p>

<pre>  my $attlist = $ncobj-&#62;getattributenames(&#39;var1&#39;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="getvariablenames"
>getvariablenames</a></h2>

<p>Get all the variable names for an open NetCDF object.</p>

<p>Arguments: none.</p>

<p>Returns: An array reference of variable names</p>

<pre>  my $varlist = $ncobj-&#62;getvariablenames();</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="setrec"
>setrec</a></h2>

<p>Set up a &#39;record&#39; of several 1D netCDF variables with the same dimension. Once this is set up, quick reading/writing of one element from all variables can be put/get from/to a perl list.</p>

<p>Arguments:</p>

<pre> 1) The names of all the netCDF variables to group into a record</pre>

<p>Returns: A record name to use in future putrec/getrec calls</p>

<pre>  my $rec = $ncobj-&#62;setrec(&#39;var1&#39;, &#39;var2&#39;, &#39;var3&#39;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="getrec"
>getrec</a></h2>

<p>Gets a &#39;record&#39; (one value from each of several 1D netCDF variables) previously set up using &#39;setrec&#39;. These values are returned in a perl list.</p>

<p>Arguments:</p>

<pre> 1) The name of the record set up in &#39;setrec&#39;.
 2) The index to fetch.</pre>

<p>Returns: A perl list of all values. Note that these variables can be of different types: float, double, integer, string.</p>

<pre>  my @rec = $ncobj-&#62;getrec($rec, 5);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="putrec"
>putrec</a></h2>

<p>Puts a &#39;record&#39; (one value from each of several 1D netCDF variables) previously set up using &#39;setrec&#39;. These values are supplied as a perl list reference.</p>

<p>Arguments:</p>

<pre> 1) The name of the record set up in &#39;setrec&#39;.
 2) The index to set.
 3) A perl list ref containing the values.</pre>

<p>Returns: None.</p>

<pre>  $ncobj-&#62;putrec($rec, 5, \@values);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="WRITING_NetCDF-FILES_EFFICIENTLY"
>WRITING NetCDF-FILES EFFICIENTLY</a></h1>

<p>Writing several variables to NetCDF-files can take a long time. When a new variable is attached by <code>put</code> to a file, the attribute header has to be written. This might force the internal netcdf-library to restructure the complete file, and thus might take very much IO-resources. By pre-defining the dimensions, attributes, and variables, much time can be saved. Essentially the rule of thumb is to define and write the data in the order it will be laid out in the file. Talking PDL::NetCDF, this means the following:</p>

<dl>
<dt><a name="Open_the_netcdf_file"
>Open the netcdf file</a></dt>

<dd>
<pre>    my $nc = new PDL::NetCDF(&#39;test.nc&#39;, {MODE =&#62; O_CREAT|O_RDWR,
                                         REVERSE_DIMS =&#62; 1});</pre>

<dt><a name="Write_the_global_attributes"
>Write the global attributes</a></dt>

<dd>
<pre>    $nc-&#62;putatt (double([1,2,3]), &#39;double_attribute&#39;);</pre>

<dt><a name="Define_all_variables,_make_use_of_the_NC_UNLIMITED_dimension"
>Define all variables, make use of the NC_UNLIMITED dimension</a></dt>

<dd>
<pre>   # here it is possible to choose float/double/short/long
   $pdl_init = long ([]);  
   for (my $i=0; $i&#60;$it; $i++) {
       my $out2 = $nc-&#62;putslice(&#34;VAR$i&#34;,
                             [&#39;x&#39;,&#39;y&#39;,&#39;z&#39;,&#39;t&#39;],
                             [150,100,20,PDL::NetCDF::NC_UNLIMITED()],
                             [0,0,0,0],[1,0,0,0],$pdl_init);
   }</pre>

<dt><a name="Write_the_variable-attributes"
>Write the variable-attributes</a></dt>

<dd>
<pre>   $nc-&#62;putatt (&#34;var-attr&#34;, &#39;attribute&#39;, &#39;VAR0&#39;); </pre>

<dt><a name="Write_data_with_putslice"
>Write data with putslice</a></dt>

<dd>
<pre>    $nc-&#62;putslice(&#34;VAR5&#34;,[],[],[0,0,0,0],[$datapdl-&#62;dims],$datapdl);</pre>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Doug Hunt, dhunt\@ucar.edu.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="CONTRIBUTORS"
>CONTRIBUTORS</a></h2>

<p>Heiko Klein, heiko.klein\@met.no Edward Baudrez, Royal Meteorological Institute of Belgium, edward.baudrez\@meteo.be</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>perl(1), PDL(1), netcdf(3).</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
