<html><head><title>PDL::IO::Misc</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:24 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#FUNCTIONS'>FUNCTIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#bswap2'>bswap2</a>
    <li class='indexItem indexItem2'><a href='#bswap4'>bswap4</a>
    <li class='indexItem indexItem2'><a href='#bswap8'>bswap8</a>
    <li class='indexItem indexItem2'><a href='#rcols'>rcols</a>
    <li class='indexItem indexItem2'><a href='#wcols'>wcols</a>
    <li class='indexItem indexItem2'><a href='#swcols'>swcols</a>
    <li class='indexItem indexItem2'><a href='#rgrep'>rgrep</a>
    <li class='indexItem indexItem2'><a href='#rdsa'>rdsa</a>
    <li class='indexItem indexItem2'><a href='#isbigendian'>isbigendian</a>
    <li class='indexItem indexItem2'><a href='#rasc'>rasc</a>
    <li class='indexItem indexItem2'><a href='#rcube'>rcube</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>PDL::IO::Misc - misc IO routines for PDL</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Some basic I/O functionality: FITS,
tables,
byte-swapping</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre> use PDL::IO::Misc;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FUNCTIONS"
>FUNCTIONS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="bswap2"
>bswap2</a></h2>

<pre>  Signature: (x(); )</pre>

<p>Swaps pairs of bytes in argument x()</p>

<p>bswap2 does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="bswap4"
>bswap4</a></h2>

<pre>  Signature: (x(); )</pre>

<p>Swaps quads of bytes in argument x()</p>

<p>bswap4 does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="bswap8"
>bswap8</a></h2>

<pre>  Signature: (x(); )</pre>

<p>Swaps octets of bytes in argument x()</p>

<p>bswap8 does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="rcols"
>rcols</a></h2>

<p>Read specified ASCII cols from a file into piddles and perl arrays (also see <a href="#rgrep()" class="podlinkpod"
>&#34;rgrep()&#34;</a>).</p>

<pre>  Usage:
    ($x,$y,...) = rcols( *HANDLE|&#34;filename&#34;, { EXCLUDE =&#62; &#39;/^!/&#39; }, $col1, $col2, ... )
             $x = rcols( *HANDLE|&#34;filename&#34;, { EXCLUDE =&#62; &#39;/^!/&#39; }, [] )
    ($x,$y,...) = rcols( *HANDLE|&#34;filename&#34;, $col1, $col2, ..., { EXCLUDE =&#62; &#39;/^!/&#39; } )
    ($x,$y,...) = rcols( *HANDLE|&#34;filename&#34;, &#34;/foo/&#34;, $col1, $col2, ... )</pre>

<p>For each column number specified, a 1D output PDL will be generated. Anonymous arrays of column numbers generate 2D output piddles with dim0 for the column data and dim1 equal to the number of colums in the anonymous array(s).</p>

<p>An empty anonymous array as column specification will produce a single output data piddle with dim(1) equal to the number of columns available.</p>

<p>There are two calling conventions - the old version, where a pattern can be specified after the filename/handle, and the new version where options are given as as hash reference. This reference can be given as either the second or last argument.</p>

<p>The default behaviour is to ignore lines beginning with a # character and lines that only consist of whitespace. Options exist to only read from lines that match, or do not match, supplied patterns, and to set the types of the created piddles.</p>

<p>Can take file name or *HANDLE, and if no explicit column numbers are specified, all are assumed. For the allowed types, see <a href="../../PDL/Core.html#Datatype_conversions" class="podlinkpod"
>&#34;Datatype_conversions&#34; in PDL::Core</a>.</p>

<p>Options (case insensitive):</p>

<pre>  EXCLUDE or IGNORE
  - ignore lines matching this pattern (default B&#60;&#39;/^#/&#39;&#62;).
  
  INCLUDE or KEEP
  - only use lines which match this pattern (default B&#60;&#39;&#39;&#62;).
  
  LINES   
  - a string pattern specifying which line numbers to use.
  Line numbers start at 0 and the syntax is &#39;a:b:c&#39; to use
  every c&#39;th matching line between a and b (default B&#60;&#39;&#39;&#62;).
  
  DEFTYPE
  - default data type for stored data (if not specified, use the type 
  stored in C&#60;$PDL::IO::Misc::deftype&#62;, which starts off as B&#60;double&#62;).
  
  TYPES
  - reference to an array of data types, one element for each column 
  to be read in.  Any missing columns use the DEFTYPE value (default B&#60;[]&#62;).
  
  COLSEP
  - splits on this string/pattern/qr{} between colums of data. Defaults to
  $PDL::IO::Misc::defcolsep.
  
  PERLCOLS
  - an array of column numbers which are to be read into perl arrays
  rather than piddles.  Any columns not specified in the explicit list
  of columns to read will be returned after the explicit columns.
  (default B&#60;undef&#62;).

  COLIDS
  - if defined to an array reference, it will be assigned the column
  ID values obtained by splitting the first line of the file in the
  identical fashion to the column data.

  CHUNKSIZE
  - the number of input data elements to batch together before appending
  to each output data piddle (Default value is 100).  If CHUNKSIZE is
  greater than the number of lines of data to read, the entire file is
  slurped in, lines split, and perl lists of column data are generated.
  At the end, effectively pdl(@column_data) produces any result piddles.

  VERBOSE
  - be verbose about IO processing (default C&#60;$PDL::vebose&#62;)</pre>

<p>For example:</p>

<pre>  $x      = PDL-&#62;rcols &#39;file1&#39;;         # file1 has only one column of data
  $x      = PDL-&#62;rcols &#39;file2&#39;, [];     # file2 can have multiple columns, still 1 piddle output
                                        # (empty array ref spec means all possible data fields)

  ($x,$y) = rcols &#39;table.csv&#39;, { COLSEP =&#62; &#39;,&#39; };  # read CSV data file
  ($x,$y) = rcols *STDOUT;  # default separator for lines like &#39;32 24&#39;

  # read in lines containing the string foo, where the first
  # example also ignores lines that begin with a # character.
  ($x,$y,$z) = rcols &#39;file2&#39;, 0,4,5, { INCLUDE =&#62; &#39;/foo/&#39; };
  ($x,$y,$z) = rcols &#39;file2&#39;, 0,4,5, { INCLUDE =&#62; &#39;/foo/&#39;, EXCLUDE =&#62; &#39;&#39; };

  # ignore the first 27 lines of the file, reading in as ushort&#39;s
  ($x,$y) = rcols &#39;file3&#39;, { LINES =&#62; &#39;27:-1&#39;, DEFTYPE =&#62; ushort };
  ($x,$y) = rcols &#39;file3&#39;, { LINES =&#62; &#39;27:&#39;, TYPES =&#62; [ ushort, ushort ] };

  # read in the first column as a perl array and the next two as piddles
  # with the perl column returned after the piddle outputs
  ($x,$y,$name) = rcols &#39;file4&#39;, 1, 2   , { PERLCOLS =&#62; [ 0 ] };
  printf &#34;Number of names read in = %d\n&#34;, 1 + $#$name;

  # read in the first column as a perl array and the next two as piddles
  # with PERLCOLS changing the type of the first returned value to perl list ref
  ($name,$x,$y) = rcols &#39;file4&#39;, 0, 1, 2, { PERLCOLS =&#62; [ 0 ] };

  # read in the first column as a perl array returned first followed by the
  # the next two data columns in the file as a single Nx2 piddle 
  ($name,$xy) = rcols &#39;file4&#39;, 0, [1, 2], { PERLCOLS =&#62; [ 0 ] };


  NOTES:

  1. Quotes are required on patterns or use the qr{} quote regexp syntax.
  
  2. Columns are separated by whitespace by default, use the COLSEP option
     separator to specify an alternate split pattern or string or specify an
     alternate default separator by setting C&#60;$PDL::IO::Misc::defcolsep&#62; .
  
  3. Legacy support is present to use C&#60;$PDL::IO::Misc::colsep&#62; to set the
     column separator but C&#60;$PDL::IO::Misc::colsep&#62; is not defined by default.
     If you set the variable to a defined value it will get picked up.
  
  4. LINES =&#62; &#39;-1:0:3&#39; may not work as you expect, since lines are skipped
     when read in, then the whole array reversed.

  5. For consistancy with wcols and rcols 1D usage, column data is loaded
     into the rows of the pdls (i.e., dim(0) is the elements read per column
     in the file and dim(1) is the number of columns of data read.</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="wcols"
>wcols</a></h2>

<pre>  Write ASCII columns into file from 1D or 2D piddles and/or 1D listrefs efficiently.</pre>

<p>Can take file name or *HANDLE, and if no file/filehandle is given defaults to STDOUT.</p>

<pre>  Options (case insensitive):
  
    HEADER - prints this string before the data. If the string
             is not terminated by a newline, one is added. (default B&#60;&#39;&#39;&#62;).
  
    COLSEP - prints this string between colums of data. Defaults to
             $PDL::IO::Misc::defcolsep.

    FORMAT - A printf-style format string that is cycled through
             column output for user controlled formatting.</pre>

<pre> Usage: wcols $data1, $data2, $data3,..., *HANDLE|&#34;outfile&#34;, [\%options];  # or
        wcols $format_string, $data1, $data2, $data3,..., *HANDLE|&#34;outfile&#34;, [\%options];

   where the $dataN args are either 1D piddles, 1D perl array refs,
   or 2D piddles (as might be returned from rcols() with the [] column
   syntax and/or using the PERLCOLS option).  dim(0) of all piddles
   written must be the same size.  The printf-style $format_string,
   if given, overrides a any FORMAT key settings in the option hash </pre>

<p>e.g.,</p>

<pre>  $x = random(4); $y = ones(4);
  wcols $x, $y+2, &#39;foo.dat&#39;;
  wcols $x, $y+2, *STDERR;
  wcols $x, $y+2, &#39;|wc&#39;;

  $a = sequence(3); $b = zeros(3); $c = random(3);
  wcols $a,$b,$c; # Orthogonal version of &#39;print $a,$b,$c&#39; :-)

  wcols &#34;%10.3f&#34;, $a,$b; # Formatted
  wcols &#34;%10.3f %10.5g&#34;, $a,$b; # Individual column formatting

  $a = sequence(3); $b = zeros(3); $units = [ &#39;m/sec&#39;, &#39;kg&#39;, &#39;MPH&#39; ];
  wcols $a,$b, { HEADER =&#62; &#34;#   a   b&#34; };
  wcols $a,$b, { Header =&#62; &#34;#   a   b&#34;, Colsep =&#62; &#39;, &#39; };  # case insensitive option names!
  wcols &#34; %4.1f  %4.1f  %s&#34;,$a,$b,$units, { header =&#62; &#34;# Day  Time  Units&#34; };

  $a52 = sequence(5,2); $b = ones(5); $c = [ 1, 2, 4 ];
  wcols $a52;         # now can write out 2D pdls (2 columns data in output)
  wcols $b, $a52, $c  # ...and mix and match with 1D listrefs as well

  NOTES:
  
  1. Columns are separated by whitespace by default, use
     C&#60;$PDL::IO::Misc::defcolsep&#62; to modify the default value or
     the COLSEP option
  
  2. Support for the C&#60;$PDL::IO::Misc::colsep&#62; global value
     of PDL-2.4.6 and earlier is maintained but the initial value
     of the global is undef until you set it.  The value will be
     then be picked up and used as if defcolsep were specified.

  3. Dim 0 corresponds to the column data dimension for both
     rcols and wcols.  This makes wcols the reverse operation
     of rcols.</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="swcols"
>swcols</a></h2>

<p>generate string list from <code>sprintf</code> format specifier and a list of piddles</p>

<p><code>swcols</code> takes an (optional) format specifier of the printf sort and a list of 1D piddles as input. It returns a perl array (or array reference if called in scalar context) where each element of the array is the string generated by printing the corresponding element of the piddle(s) using the format specified. If no format is specified it uses the default print format.</p>

<pre> Usage: @str = swcols format, pdl1,pdl2,pdl3,...;
    or  $str = swcols format, pdl1,pdl2,pdl3,...;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="rgrep"
>rgrep</a></h2>

<pre>  Read columns into piddles using full regexp pattern matching.
  

  Options:
  
  UNDEFINED: This option determines what will be done for undefined 
  values. For instance when reading a comma-separated file of the type 
  C&#60;1,2,,4&#62; where the C&#60;,,&#62; indicates a missing value. 
  
  The default value is to assign C&#60;$PDL::undefval&#62; to undefined values,
  but if C&#60;UNDEFINED&#62; is set this is used instead. This would normally 
  be set to a number, but if it is set to C&#60;Bad&#62; and PDL is compiled
  with Badvalue support (see L&#60;PDL::Bad/&#62;) then undefined values are set to
  the appropriate badvalue and the column is marked as bad.
  
  DEFTYPE: Sets the default type of the columns - see the documentation for
   L&#60;/rcols()&#62;
  
  TYPES:   A reference to a Perl array with types for each column - see 
  the documentation for L&#60;/rcols()&#62;
  
  BUFFERSIZE: The number of lines to extend the piddle by. It might speed
  up the reading a little bit by setting this to the number of lines in the
  file, but in general L&#60;/rasc()&#62; is a better choice</pre>

<p>Usage</p>

<pre> ($x,$y,...) = rgrep(sub, *HANDLE|&#34;filename&#34;)</pre>

<p>e.g.</p>

<pre> ($a,$b) = rgrep {/Foo (.*) Bar (.*) Mumble/} $file;</pre>

<p>i.e. the vectors <code>$a</code> and <code>$b</code> get the progressive values of <code>$1</code>, <code>$2</code> etc.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="rdsa"
>rdsa</a></h2>

<pre>  Read a FIGARO/NDF format file.

  Requires non-PDL DSA module. Contact Frossie (frossie@jach.hawaii.edu)</pre>

<p>Usage:</p>

<pre> ([$xaxis],$data) = rdsa($file)</pre>

<pre> $a = rdsa &#39;file.sdf&#39;</pre>

<p>Not yet tested with PDL-1.9X versions</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="isbigendian"
>isbigendian</a></h2>

<pre>  Determine endianness of machine - returns 0 or 1 accordingly</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="rasc"
>rasc</a></h2>

<pre>  Simple function to slurp in ASCII numbers quite quickly,
  although error handling is marginal (to nonexistent).</pre>

<pre>  $pdl-&#62;rasc(&#34;filename&#34;|FILEHANDLE [,$noElements]);

      Where:
        filename is the name of the ASCII file to read or open file handle
        $noElements is the optional number of elements in the file to read.
            (If not present, all of the file will be read to fill up $pdl).
        $pdl can be of type float or double (for more precision).</pre>

<pre>  #  (test.num is an ascii file with 20 numbers. One number per line.)
  $in = PDL-&#62;null;
  $num = 20;
  $in-&#62;rasc(&#39;test.num&#39;,20);
  $imm = zeroes(float,20,2);
  $imm-&#62;rasc(&#39;test.num&#39;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="rcube"
>rcube</a></h2>

<pre> Read list of files directly into a large data cube (for efficiency)</pre>

<pre> $cube = rcube \&#38;reader_function, @files;</pre>

<pre> $cube = rcube \&#38;rfits, glob(&#34;*.fits&#34;);</pre>

<p>This IO function allows direct reading of files into a large data cube, Obviously one could use cat() but this is more memory efficient.</p>

<p>The reading function (e.g. rfits, readfraw) (passed as a reference) and files are the arguments.</p>

<p>The cube is created as the same X,Y dims and datatype as the first image specified. The Z dim is simply the number of images.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Copyright (C) Karl Glazebrook 1997, Craig DeForest 2001, 2003, and Chris Marshall 2010. All rights reserved. There is no warranty. You are allowed to redistribute this software / documentation under certain conditions. For details, see the file COPYING in the PDL distribution. If this file is separated from the PDL distribution, the copyright notice should be included in the file.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
