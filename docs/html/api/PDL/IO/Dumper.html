<html><head><title>PDL::IO::Dumper</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:24 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#Bugs'>Bugs</a>
  <li class='indexItem indexItem1'><a href='#Author%2C_copyright%2C_no_warranty'>Author, copyright, no warranty</a>
  <li class='indexItem indexItem1'><a href='#HISTORY'>HISTORY</a>
  <li class='indexItem indexItem1'><a href='#FUNCTIONS'>FUNCTIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#sdump'>sdump</a>
    <li class='indexItem indexItem2'><a href='#fdump'>fdump</a>
    <li class='indexItem indexItem2'><a href='#frestore'>frestore</a>
    <li class='indexItem indexItem2'><a href='#deep_copy'>deep_copy</a>
    <li class='indexItem indexItem2'><a href='#PDL%3A%3AIO%3A%3ADumper%3A%3Abig_PDL'>PDL::IO::Dumper::big_PDL</a>
    <li class='indexItem indexItem2'><a href='#PDL%3A%3AIO%3A%3ADumper%3A%3Astringify_PDL'>PDL::IO::Dumper::stringify_PDL</a>
    <li class='indexItem indexItem2'><a href='#PDL%3A%3AIO%3A%3ADumper%3A%3Auudecode_PDL'>PDL::IO::Dumper::uudecode_PDL</a>
    <li class='indexItem indexItem2'><a href='#PDL%3A%3AIO%3A%3ADumper%3A%3Adump_PDL'>PDL::IO::Dumper::dump_PDL</a>
    <li class='indexItem indexItem2'><a href='#PDL%3A%3AIO%3A%3ADumper%3A%3Afind_PDLs'>PDL::IO::Dumper::find_PDLs</a>
  </ul>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>PDL::IO::Dumper -- data dumping for structs with PDLs</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This package allows you cleanly to save and restore complex data structures which include PDLs,
as ASCII strings and/or transportable ASCII files.
It exports four functions into your namespace: sdump,
fdump,
frestore,
and deep_copy.</p>

<p>PDL::IO::Dumper traverses the same types of structure that Data::Dumper knows about,
because it uses a call to Data::Dumper.
Unlike Data::Dumper it doesn&#39;t crash when accessing PDLs.</p>

<p>The PDL::IO::Dumper routines have a slightly different syntax than Data::Dumper does: you may only dump a single scalar perl expression rather than an arbitrary one.
Of course,
the scalar may be a ref to whatever humongous pile of spaghetti you want,
so that&#39;s no big loss.</p>

<p>The output string is intended to be about as readable as Dumper&#39;s output is for non-PDL expressions.
To that end,
small PDLs (up to 8 elements) are stored as inline perl expressions,
midsized PDLs (up to 200 elements) are stored as perl expressions above the main data structure,
and large PDLs are stored as FITS files that are uuencoded and included in the dump string.
(You have to have access to either uuencode(1) or the CPAN module Convert::UU for this to work).</p>

<p>No attempt is made to shrink the output string -- for example,
inlined PDL expressions all include explicit reshape() and typecast commands,
and uuencoding expands stuff by a factor of about 1.5.
So your data structures will grow when you dump them.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Bugs"
>Bugs</a></h1>

<p>It&#39;s still possible to break this code and cause it to dump core,
for the same reason that Data::Dumper crashes.
In particular,
other external-hook variables aren&#39;t recognized (for that a more universal Dumper would be needed) and will still exercise the Data::Dumper crash.
This is by choice: (A) it&#39;s difficult to recognize which objects are actually external,
and (B) most everyday objects are quite safe.</p>

<p>Another shortfall of Data::Dumper is that it doesn&#39;t recognize tied objects.
This might be a Good Thing or a Bad Thing depending on your point of view,
but it means that PDL::IO::Dumper includes a kludge to handle the tied Astro::FITS::Header objects associated with FITS headers (see the rfits documentation in PDL::IO::Misc for details).</p>

<p>There&#39;s currently no reference recursion detection,
so a non-treelike reference topology will cause Dumper to buzz forever.
That will likely be fixed in a future version.
Meanwhile a warning message finds likely cases.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Author,_copyright,_no_warranty"
>Author,
copyright,
no warranty</a></h1>

<p>Copyright 2002,
Craig DeForest.</p>

<p>This code may be distributed under the same terms as Perl itself (license available at <a href="http://ww.perl.org" class="podlinkurl"
>http://ww.perl.org</a>).
Copying,
reverse engineering,
distribution,
and modification are explicitly allowed so long as this notice is preserved intact and modified versions are clearly marked as such.</p>

<p>This package comes with NO WARRANTY.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="HISTORY"
>HISTORY</a></h1>

<ul>
<li>1.0: initial release</li>

<li>1.1 (26-Feb-2002): Shorter form for short PDLs; more readability</li>

<li>1.2 (28-Feb-2002): Added deep_copy() -- exported convenience function for &#34;eval sdump&#34;</li>

<li>1.3 (15-May-2002): Added checking for tied objects in gethdr() [workaround for hole in Data::Dumper]</li>

<li>1.4 (15-Jan-2003): Added support for Convert::UU as well as command-line uu{en|de}code</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FUNCTIONS"
>FUNCTIONS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="sdump"
>sdump</a></h2>

<p>Dump a data structure to a string.</p>

<pre>  use PDL::IO::Dumper;
  $s = sdump(&#60;VAR&#62;);
  ...
  &#60;VAR&#62; = eval $s;</pre>

<p>sdump dumps a single complex data structure into a string. You restore the data structure by eval-ing the string. Since eval is a builtin, no convenience routine exists to use it.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="fdump"
>fdump</a></h2>

<p>Dump a data structure to a file</p>

<pre>  use PDL::IO::Dumper;
  fdump(&#60;VAR&#62;,$filename);
  ...
  &#60;VAR&#62; = frestore($filename);</pre>

<p>fdump dumps a single complex data structure to a file. You restore the data structure by eval-ing the perl code put in the file. A convenience routine (frestore) exists to do it for you.</p>

<p>I suggest using the extension &#39;.pld&#39; or (for non-broken OS&#39;s) &#39;.pdld&#39; to distinguish Dumper files. That way they are reminiscent of .pl files for perl, while still looking a little different so you can pick them out. You can certainly feed a dump file straight into perl (for syntax checking) but it will not do much for you, just build your data structure and exit.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="frestore"
>frestore</a></h2>

<p>Restore a dumped file</p>

<pre>  use PDL::IO::Dumper;
  fdump(&#60;VAR&#62;,$filename);
  ...
  &#60;VAR&#62; = frestore($filename);</pre>

<p>frestore() is a convenience function that just reads in the named file and executes it in an eval. It&#39;s paired with fdump().</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="deep_copy"
>deep_copy</a></h2>

<p>Convenience function copies a complete perl data structure by the brute force method of &#34;eval sdump&#34;.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="PDL::IO::Dumper::big_PDL"
>PDL::IO::Dumper::big_PDL</a></h2>

<p>Identify whether a PDL is ``big&#39;&#39; [Internal routine]</p>

<p>Internal routine takes a PDL and returns a boolean indicating whether it&#39;s small enough for direct insertion into the dump string. If 0, it can be inserted. Larger numbers yield larger scopes of PDL. 1 implies that it should be broken out but can be handled with a couple of perl commands; 2 implies full uudecode treatment.</p>

<p>PDLs with Astro::FITS::Header objects as headers are taken to be FITS files and are always treated as huge, regardless of size.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="PDL::IO::Dumper::stringify_PDL"
>PDL::IO::Dumper::stringify_PDL</a></h2>

<p>Turn a PDL into a 1-part perl expr [Internal routine]</p>

<p>Internal routine that takes a PDL and returns a perl string that evals to the PDL. It should be used with care because it doesn&#39;t dump headers and it doesn&#39;t check number of elements. The point here is that numbers are dumped with the correct precision for their storage class. Things we don&#39;t know about get stringified element-by-element by their builtin class, which is probably not a bad guess.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="PDL::IO::Dumper::uudecode_PDL"
>PDL::IO::Dumper::uudecode_PDL</a></h2>

<p>Recover a PDL from a uuencoded string [Internal routine]</p>

<p>This routine encapsulates uudecoding of the dumped string for large piddles. It&#39;s separate to encapsulate the decision about which method of uudecoding to try (both the built-in Convert::UU and the shell command uudecode(1) are supported).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="PDL::IO::Dumper::dump_PDL"
>PDL::IO::Dumper::dump_PDL</a></h2>

<p>Generate 1- or 2-part expr for a PDL [Internal routine]</p>

<p>Internal routine that produces commands defining a PDL. You supply (&#60;PDL&#62;, &#60;name&#62;) and get back two strings: a prepended command string and an expr that evaluates to the final PDL. PDL is the PDL you want to dump. &#60;inline&#62; is a flag whether dump_PDL is being called inline or before the inline dump string (0 for before; 1 for in). &#60;name&#62; is the name of the variable to be assigned (for medium and large PDLs, which are defined before the dump string and assigned unique IDs).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="PDL::IO::Dumper::find_PDLs"
>PDL::IO::Dumper::find_PDLs</a></h2>

<p>Walk a data structure and dump PDLs [Internal routine]</p>

<p>Walks the original data structure and generates appropriate exprs for each PDL. The exprs are inserted into the Data::Dumper output string. You shouldn&#39;t call this unless you know what you&#39;re doing. (see sdump, above).</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
