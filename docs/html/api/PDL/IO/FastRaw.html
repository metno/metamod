<html><head><title>PDL::IO::FastRaw</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:24 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Example%3A_Converting_ASCII_to_raw'>Example: Converting ASCII to raw</a>
    <li class='indexItem indexItem2'><a href='#Example%3A_readfraw'>Example: readfraw</a>
    <li class='indexItem indexItem2'><a href='#Example%3A_Custom_headers'>Example: Custom headers</a>
    <li class='indexItem indexItem2'><a href='#Example%3A_Using_mapfraw'>Example: Using mapfraw</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#FUNCTIONS'>FUNCTIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#readfraw'>readfraw</a>
    <li class='indexItem indexItem2'><a href='#writefraw'>writefraw</a>
    <li class='indexItem indexItem2'><a href='#mapfraw'>mapfraw</a>
    <li class='indexItem indexItem2'><a href='#maptextfraw'>maptextfraw</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>PDL::IO::FastRaw -- A simple,
fast and convenient io format for PerlDL.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>This documentation refers to PDL::IO::FastRaw version 0.0.2,
I guess.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre> use PDL;
 use PDL::IO::FastRaw;

 writefraw($pdl,&#34;fname&#34;);         # write a raw file

 $pdl2 = readfraw(&#34;fname&#34;);       # read a raw file
 $pdl2 = PDL-&#62;readfraw(&#34;fname&#34;);

 $pdl3 = mapfraw(&#34;fname2&#34;,{ReadOnly =&#62; 1}); # mmap a file, don&#39;t read yet

 $pdl4 = maptextfraw(&#34;fname3&#34;,{...}); # map a text file into a 1-D pdl.</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This is a very simple and fast io format for PerlDL. The disk data consists of two files, a header metadata file in ASCII and a binary file consisting simply of consecutive bytes, shorts or whatever.</p>

<p>It is hoped that this will not only make for a simple PerlDL module for saving and retrieving these files but also make it easy for other programs to use these files.</p>

<p>The format of the ASCII header is simply</p>

<pre>        &#60;typeid&#62;
        &#60;ndims&#62;
        &#60;dim0&#62; &#60;dim1&#62; ...</pre>

<p>You should probably stick with the default header name. You may want to specify your own header, however, such as when you have a large collection of data files with identical dimensions and data types. Under these circumstances, simply specify the <code>Header</code> option in the options hash.</p>

<p>The binary files are in general NOT interchangeable between different architectures since the binary file is simply dumped from the memory region of the piddle. This is what makes the approach efficient.</p>

<p>It is also possible to mmap the file which can give a large speedup in certain situations as well as save a lot of memory by using a disk file as virtual memory. When a file is mapped, parts of it are read only as they are accessed in the memory (or as the kernel decides: if you are reading the pages in order, it may well preread some for you).</p>

<p>Note that memory savings and copy-on-write are operating-system dependent - see Core.xs and your operating system documentation for exact semantics of whatever. Basically, if you write to a mmapped file without <code>ReadOnly</code>, the change will be reflected in the file immediately. <code>ReadOnly</code> doesn&#39;t really make it impossible to write to the piddle but maps the memory privately so the file will not be changed when you change the piddle. Be aware though that mmapping a 40Mb file without <code>ReadOnly</code> spends no virtual memory but with <code>ReadOnly</code> it does reserve 40Mb.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Example:_Converting_ASCII_to_raw"
>Example: Converting ASCII to raw</a></h2>

<p>You have a whole slew of data files in ASCII from an experiment that you ran in your lab. You&#39;re still tweaking the analysis and plots, so you&#39;d like if your data could load as fast as possible. Eventually you&#39;ll read the data into your scripts using <code>readfraw</code>, but the first thing you might do is create a script that converts all the data files to raw files:</p>

<pre> #!/usr/bin/perl
 # Assumes that the data files end with a .asc or .dat extension
 # and saves the raw file output with a .bdat extension.
 # call with
 #  &#62;./convert_to_raw.pl file1.dat file2.dat ...
 # or
 #  &#62;./convert_to_raw.pl *.dat
 
 use PDL;
 use PDL::IO::FastRaw;  # for saving raw files
 use PDL::IO::Misc;             # for reading ASCII files with rcols
 while(shift) {                 # run through the entire supplied list of file names
         ($newName = $_) =~ s/\.(asc|dat)/.bdat/;
         print &#34;Saving contents of $_ to $newName\n&#34;;
         $data = rcols($_);
         writefraw($data, $newName);
 }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Example:_readfraw"
>Example: readfraw</a></h2>

<p>Now that you&#39;ve gotten your data into a raw file format, you can start working on your analysis scripts. If you scripts used <code>rcols</code> in the past, the reading portion of the script should go much, much faster now:</p>

<pre> #!/usr/bin/perl
 # My plotting script.
 # Assume I&#39;ve specified the files to plot on the command line like
 #  &#62;./plot_script.pl file1.bdat file2.bdat ...
 # or
 #  &#62;./plot_script.pl *.bdat
 
 use PDL;
 use PDL::IO::FastRaw;
 while(shift) {                 # run through the entire supplied list of file names
         $data = readfraw($_);
         my_plot_func($data);
 }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Example:_Custom_headers"
>Example: Custom headers</a></h2>

<p>In the first example, I allow <code>writefraw</code> to use the standard header file name, which would be <code>file.bdat.hdr</code>. However, I often measure time series that have identical length, so all of those header files are redundant. To fix that, I simply pass the Header option to the <code>writefraw</code> command. A modified script would look like this:</p>

<pre> #!/usr/bin/perl
 # Assumes that the data files end with a .asc or .dat extension
 # and saves the raw file output with a .bdat extension.
 # call with
 #  &#62;./convert_to_raw.pl [-hHeaderFile] &#60;fileglob&#62; [-hHeaderFile] &#60;fileglob&#62; ...
 
 use PDL;
 use PDL::IO::FastRaw;  # for saving raw files
 use PDL::IO::Misc;             # for reading ASCII files with rcols
 my $header_file = undef;
 CL_OPTION: while($_ = shift @ARGV) {   # run through the entire list of command-line options
         if(/-h(.*)/) {
                 $header_file = $1;
                 next CL_OPTION;
         }
         ($newName = $_) =~ s/\.(asc|dat)/.bdat/;
         print &#34;Saving contents of $_ to $newName\n&#34;;
         $data = rcols($_);
         writefraw($data, $newName, {Header =&#62; $header_file});
 }</pre>

<p>Modifying the read script is left as an exercise for the reader. :]</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Example:_Using_mapfraw"
>Example: Using mapfraw</a></h2>

<p>Sometimes you&#39;ll want to use <code>mapfraw</code> rather than the read/write functions. In fact, the original author of the module doesn&#39;t use the read/write functions anymore, prefering to always use <code>mapfraw</code>. How would you go about doing this?</p>

<p>Assuming you&#39;ve already saved your data into the raw format, the only change you would have to make to the script in example 2 would be to change the call to <code>readfraw</code> to <code>mapfraw</code>. That&#39;s it. You will probably see differences in performance, though I (David Mertens) couldn&#39;t tell you about them because I haven&#39;t played around with <code>mapfraw</code> much myself.</p>

<p>What if you eschew the use of <code>writefraw</code> and prefer to only use <code>mapfraw</code>? How would you save your data to a raw format? In that case, you would have to create a <code>mapfraw</code> piddle with the correct dimensions first using</p>

<pre> $piddle_on_hd = mapfraw(&#39;fname&#39;, {Creat =&#62; 1, Dims =&#62; [dim1, dim2, ...]});</pre>

<p>Note that you must specify the dimensions and you must tell <code>mapfraw</code> to create the new piddle for you by setting the <code>Creat</code> option to a true value, not <code>Create</code> (note the missing final &#39;e&#39;).</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FUNCTIONS"
>FUNCTIONS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="readfraw"
>readfraw</a></h2>

<p>Read a raw format binary file</p>

<pre> $pdl2 = readfraw(&#34;fname&#34;);
 $pdl2 = PDL-&#62;readfraw(&#34;fname&#34;);
 $pdl2 = readfraw(&#34;fname&#34;, {Header =&#62; &#39;headerfname&#39;});</pre>

<p>The <code>readfraw</code> command supports the following option:</p>

<dl>
<dt><a name="Header"
>Header</a></dt>

<dd>
<p>Specify the header file name.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="writefraw"
>writefraw</a></h2>

<p>Write a raw format binary file</p>

<pre> writefraw($pdl,&#34;fname&#34;);
 writefraw($pdl,&#34;fname&#34;, {Header =&#62; &#39;headerfname&#39;});</pre>

<p>The <code>writefraw</code> command supports the following option:</p>

<dl>
<dt><a name="Header"
>Header</a></dt>

<dd>
<p>Specify the header file name.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="mapfraw"
>mapfraw</a></h2>

<p>Memory map a raw format binary file (see the module docs also)</p>

<pre> $pdl3 = mapfraw(&#34;fname2&#34;,{ReadOnly =&#62; 1});</pre>

<p>The <code>mapfraw</code> command supports the following options (not all combinations make sense):</p>

<dl>
<dt><a name="Dims,_Datatype"
>Dims, Datatype</a></dt>

<dd>
<p>If creating a new file or if you want to specify your own header data for the file, you can give an array reference and a scalar, respectively.</p>

<dt><a name="Creat"
>Creat</a></dt>

<dd>
<p>Create the file. Also writes out a header for the file.</p>

<dt><a name="Trunc"
>Trunc</a></dt>

<dd>
<p>Set the file size. Automatically enabled with <code>Creat</code>. NOTE: This also clears the file to all zeroes.</p>

<dt><a name="ReadOnly"
>ReadOnly</a></dt>

<dd>
<p>Disallow writing to the file.</p>

<dt><a name="Header"
>Header</a></dt>

<dd>
<p>Specify the header file name.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="maptextfraw"
>maptextfraw</a></h2>

<p>Memory map a text file (see the module docs also).</p>

<p>Note that this function maps the raw format so if you are using an operating system which does strange things to e.g. line delimiters upon reading a text file, you get the raw (binary) representation.</p>

<p>The file doesn&#39;t really need to be text but it is just mapped as one large binary chunk.</p>

<p>This function is just a convenience wrapper which firsts <code>stat</code>s the file and sets the dimensions and datatype.</p>

<pre> $pdl4 = maptextfraw(&#34;fname&#34;, {options}</pre>

<p>The options other than Dims, Datatype of <code>mapfraw</code> are supported.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>Should be documented better. <code>writefraw</code> and <code>readfraw</code> should also have options (the author nowadays only uses <code>mapfraw</code> ;)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Copyright (C) Tuomas J. Lukka 1997. All rights reserved. There is no warranty. You are allowed to redistribute this software / documentation under certain conditions. For details, see the file COPYING in the PDL distribution. If this file is separated from the PDL distribution, the copyright notice should be included in the file.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
