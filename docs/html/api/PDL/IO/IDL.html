<html><head><title>PDL::IO::IDL</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:24 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#NOTES'>NOTES</a>
  <li class='indexItem indexItem1'><a href='#FUNCTIONS'>FUNCTIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#ridl'>ridl</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#AUTHOR%2C_LICENSE%2C_NO_WARRANTY'>AUTHOR, LICENSE, NO WARRANTY</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>PDL::IO::IDL -- I/O of IDL Save Files</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>PDL::IO::IDL allows you to read and write IDL(tm) data files.</p>

<p>Currently,
only reading is implemented.
Scalars,
arrays,
and structures are all supported.
Heap pointers,
compiled code,
and objects are not supported.
Of those three,
only heap pointers are likely to be supported in the future.</p>

<p>This code was not developed by RSI,
makers of IDL.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NOTES"
>NOTES</a></h1>

<p>These things seem to work:</p>

<dl>
<dt><a name="BYTE,_SHORT,_LONG,_FLOAT,_and_DOUBLE_numeric_types_and_arrays"
>BYTE,
SHORT,
LONG,
FLOAT,
and DOUBLE numeric types and arrays</a></dt>

<dd>
<p>All of these types seem to work fine.
The corresponding variable is stored as a PDL in the hash element with the same name as the original variable in the file.
Arrays are byteswapped as needed and are read in so that the dim list has the same indexing order within PDL as it did within IDL.</p>

<dt><a name="STRINGs_and_arrays_of_STRINGs"
>STRINGs and arrays of STRINGs</a></dt>

<dd>
<p>String types are stored as Perl list refs,
in the hash element with the same name as the original variable in the file.</p>

<dt><a name="Structures"
>Structures</a></dt>

<dd>
<p>Structures are stored as hash refs.
The elements of the hash may be accessed as values within the hash.</p>

<dt><a name="Common_blocks"
>Common blocks</a></dt>

<dd>
<p>Variables that are notated as being in a common block are read as normal.
Common-block names are collected in the special hash value &#39;+common&#39;,
which contains a hash each keyword of which is the name of a common block and each value of which is an array of variable names.</p>
</dd>
</dl>

<p>These things are known to be not working and may one day be fixed:</p>

<dl>
<dt><a name="COMPLEX_numbers"
>COMPLEX numbers</a></dt>

<dd>
<p>These could be implemented as 2-arrays or as PDL::Complex values,
but aren&#39;t yet.</p>

<dt><a name="PTR_types"
>PTR types</a></dt>

<dd>
<p>These could be implemented as perl refs but currently aren&#39;t.</p>

<dt><a name="writing"
>writing</a></dt>

<dd>
<p>Maybe one day -- but why bother writing a broken file format?
NetCDF is better.</p>
</dd>
</dl>

<p>These things are known to be not working and will probably never be fixed</p>

<dl>
<dt><a name="Compiled_code"
>Compiled code</a></dt>

<dd>
<p>Decompiling IDL code is a violation of the IDL end-user license.
To implement this,
someone who does not hold an IDL license would have to reverse-engineer a set of .SAV files sent to that person by someone else with an IDL license.</p>

<dt><a name="Objects"
>Objects</a></dt>

<dd>
<p>IDL objects contain compiled code.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FUNCTIONS"
>FUNCTIONS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ridl"
>ridl</a></h2>

<p>$a = ridl(&#34;foo.sav&#34;);</p>

<p>Read an IDL save file from a file.</p>

<p>Upon successful completion,
$a is a hash ref containing all of the variables that are present in the save file,
indexed by original variable name.</p>

<p>IDL identifiers are case insensitive; they&#39;re all converted to upper-case in the hash that gets returned.
This may be adjustable at a future date.
Furthermore,
because IDL identifiers can&#39;t contain special characters,
some fields that start with &#39;+&#39; are used to store metadata about the file itself.</p>

<p>Numeric arrays are stored as PDLs,
structures are stored as hashes,
and string and structure arrays are stored as perl lists.
Named structure types don&#39;t exist in perl in the same way that they do in IDL,
so named structures are described in the &#39;structs&#39; field of the global metadata.
Anonymous structures are treated as simple hashes.
Named structures are also simple hashes,
but they also contain a field &#39;+name&#39; that refers to the name of the structure type.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR,_LICENSE,_NO_WARRANTY"
>AUTHOR,
LICENSE,
NO WARRANTY</a></h1>

<p>THIS CODE IS PROVIDED WITH NO WARRANTY and may be distributed and/or modified under the same terms as PDL itself.</p>

<p>This code is based on the analysis of the IDL save file format published by Craig Markwardt in 2002.</p>

<p>IDL is a trademark of Research Systems Incorporated (RSI).
The PDL development team,
and authors of this code,
are not affiliated with RSI.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
