<html><head><title>PDL::IO::Pnm</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:24 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#FUNCTIONS'>FUNCTIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#rpnm'>rpnm</a>
    <li class='indexItem indexItem2'><a href='#wpnm'>wpnm</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#FUNCTIONS'>FUNCTIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#pnminraw'>pnminraw</a>
    <li class='indexItem indexItem2'><a href='#pnminascii'>pnminascii</a>
    <li class='indexItem indexItem2'><a href='#pnmout'>pnmout</a>
  </ul>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>PDL::IO::Pnm -- pnm format I/O for PDL</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use PDL::IO::Pnm;
  $im = wpnm $pdl, $file, $format[, $raw];
  rpnm $stack-&#62;slice(&#39;:,:,:,(0)&#39;),&#34;PDL.ppm&#34;;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>pnm I/O for PDL.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FUNCTIONS"
>FUNCTIONS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="rpnm"
>rpnm</a></h2>

<p>Read a pnm (portable bitmap/pixmap, pbm/ppm) file into a piddle.</p>

<pre>  Usage:  $im = rpnm $file;</pre>

<p>Reads a file in pnm format (ascii or raw) into a pdl (magic numbers P1-P6). Based on the input format it returns pdls with arrays of size (width,height) if binary or grey value data (pbm and pgm) or (3,width,height) if rgb data (ppm). This also means for a palette image that the distinction between an image and its lookup table is lost which can be a problem in cases (but can hardly be avoided when using netpbm/pbmplus). Datatype is dependent on the maximum grey/color-component value (for raw and binary formats always PDL_B). rpnm tries to read chopped files by zero padding the missing data (well it currently doesn&#39;t, it barfs; I&#39;ll probably fix it when it becomes a problem for me ;). You can also read directly into an existing pdl that has to have the right size(!). This can come in handy when you want to read a sequence of images into a datacube.</p>

<p>For details about the formats see appropriate manpages that come with the netpbm/pbmplus packages.</p>

<pre>  $stack = zeroes(byte,3,500,300,4);
  rpnm $stack-&#62;slice(&#39;:,:,:,(0)&#39;),&#34;PDL.ppm&#34;;</pre>

<p>reads an rgb image (that had better be of size (500,300)) into the first plane of a 3D RGB datacube (=4D pdl datacube). You can also do inplace transpose/inversion that way.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="wpnm"
>wpnm</a></h2>

<p>Write a pnm (portable bitmap/pixmap, pbm/ppm) file into a file.</p>

<pre>  Usage:  $im = wpnm $pdl, $file, $format[, $raw];</pre>

<p>Writes data in a pdl into pnm format (ascii or raw) (magic numbers P1-P6). The $format is required (normally produced by <b>wpic</b>) and routine just checks if data is compatible with that format. All conversions should already have been done. If possible, usage of <b>wpic</b> is preferred. Currently RAW format is chosen if compliant with range of input data. Explicit control of ASCII/RAW is possible through the optional $raw argument. If RAW is set to zero it will enforce ASCII mode. Enforcing RAW is somewhat meaningless as the routine will always try to write RAW format if the data range allows (but maybe it should reduce to a RAW supported type when RAW == &#39;RAW&#39;?). For details about the formats consult appropriate manpages that come with the netpbm/pbmplus packages.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>The stderr of the converters is redirected to a file. The filename is currently generated in a probably non-portable way. A method that avoids a file (and is portable) would be prefered.</p>

<p><code>rpnm</code> currently relies on the fact that the header is separated from the image data by a newline. This is not required by the p[bgp]m formats (in fact any whitespace is allowed) but most of the pnm writers seem to comply with that. Truncated files are currently treated ungracefully (<code>rpnm</code> just barfs).</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Copyright (C) 1996,1997 Christian Soeller &#60;c.soeller@auckland.ac.nz&#62; All rights reserved. There is no warranty. You are allowed to redistribute this software / documentation under certain conditions. For details, see the file COPYING in the PDL distribution. If this file is separated from the PDL distribution, the copyright notice should be included in the file.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FUNCTIONS"
>FUNCTIONS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="pnminraw"
>pnminraw</a></h2>

<pre>  Signature: (type(); byte+ [o] im(m,n); int ms =&#62; m; int ns =&#62; n;
                        int isbin; char* fd)</pre>

<p>Read in a raw pnm file.</p>

<p>read a raw pnm file. The <code>type</code> argument is only there to determine the type of the operation when creating <code>im</code> or trigger the appropriate type conversion (maybe we want a byte+ here so that <code>im</code> follows <i>strictly</i> the type of <code>type</code>).</p>

<p>pnminraw does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="pnminascii"
>pnminascii</a></h2>

<pre>  Signature: (type(); byte+ [o] im(m,n); int ms =&#62; m; int ns =&#62; n;
                        int format; char* fd)</pre>

<p>Read in an ascii pnm file.</p>

<p>pnminascii does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="pnmout"
>pnmout</a></h2>

<pre>  Signature: (a(m); int israw; int isbin; char *fd)</pre>

<p>Write a line of pnm data.</p>

<p>This function is implemented this way so that threading works naturally.</p>

<p>pnmout does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
