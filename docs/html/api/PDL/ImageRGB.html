<html><head><title>PDL::ImageRGB</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:24 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#FUNCTIONS'>FUNCTIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#cquant'>cquant</a>
    <li class='indexItem indexItem2'><a href='#interlrgb'>interlrgb</a>
    <li class='indexItem indexItem2'><a href='#rgbtogr'>rgbtogr</a>
    <li class='indexItem indexItem2'><a href='#bytescl'>bytescl</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>PDL::ImageRGB -- some utility functions for RGB image data handling</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Collection of a few commonly used routines involved in handling of RGB,
palette and grayscale images.
Not much more than a start.
Should be a good place to exercise some of the thread/map/clump PP stuff.</p>

<p>Other stuff that should/could go here:</p>

<ul>
<li>color space conversion</li>

<li>common image filters</li>

<li>image rebinning</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre> use PDL::ImageRGB;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FUNCTIONS"
>FUNCTIONS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="cquant"
>cquant</a></h2>

<p>quantize and reduce colours in 8-bit images</p>

<pre>    ($out, $lut) = cquant($image [,$ncols]);</pre>

<p>This function does color reduction for &#60;=8bit displays and accepts 8bit RGB and 8bit palette images. It does this through an interface to the ppm_quant routine from the pbmplus package that implements the median cut routine which intellegently selects the &#39;best&#39; colors to represent your image on a &#60;= 8bit display (based on the median cut algorithm). Optional args: $ncols sets the maximum nunmber of colours used for the output image (defaults to 256). There are images where a different color reduction scheme gives better results (it seems this is true for images containing large areas with very smoothly changing colours).</p>

<p>Returns a list containing the new palette image (type PDL_Byte) and the RGB colormap.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="interlrgb"
>interlrgb</a></h2>

<p>Make an RGB image from a palette image and its lookup table.</p>

<pre>    $rgb = $palette_im-&#62;interlrgb($lut)</pre>

<p>Input should be of an integer type and the lookup table (3,x,...). Will perform the lookup for any N-dimensional input pdl (i.e. 0D, 1D, 2D, ...). Uses the index command but will not dataflow by default. If you want it to dataflow the dataflow_forward flag must be set in the $lut piddle (you can do that by saying $lut-&#62;set_dataflow_f(1)).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="rgbtogr"
>rgbtogr</a></h2>

<p>Converts an RGB image to a grey scale using standard transform</p>

<pre>   $gr = $rgb-&#62;rgbtogr</pre>

<p>Performs a conversion of an RGB input image (3,x,....) to a greyscale image (x,.....) using standard formula:</p>

<pre>   Grey = 0.301 R + 0.586 G + 0.113 B</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="bytescl"
>bytescl</a></h2>

<p>Scales a pdl into a specified data range (default 0-255)</p>

<pre>        $scale = $im-&#62;bytescl([$top])</pre>

<p>By default $top=255, otherwise you have to give the desired top value as an argument to <code>bytescl</code>. Normally <code>bytescl</code> doesn&#39;t rescale data that fits already in the bounds 0..$top (it only does the type conversion if required). If you want to force it to rescale so that the max of the output is at $top and the min at 0 you give a negative $top value to indicate this.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>This package doesn&#39;t yet contain enough useful functions!</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Copyright 1997 Christian Soeller &#60;c.soeller@auckland.ac.nz&#62; All rights reserved. There is no warranty. You are allowed to redistribute this software / documentation under certain conditions. For details, see the file COPYING in the PDL distribution. If this file is separated from the PDL distribution, the copyright notice should be included in the file.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
