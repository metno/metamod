<html><head><title>PDL::Core</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:23 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#VECTORIZATION%2FTHREADING%3A_METHOD_AND_NOMENCLATURE'>VECTORIZATION/THREADING: METHOD AND NOMENCLATURE</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Threading_rules'>Threading rules</a>
    <li class='indexItem indexItem2'><a href='#Null_PDLs'>Null PDLs</a>
    <li class='indexItem indexItem2'><a href='#Empty_PDLs'>Empty PDLs</a>
    <li class='indexItem indexItem2'><a href='#Thread_rules_and_assignments'>Thread rules and assignments</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#VARIABLES'>VARIABLES</a>
  <ul   class='indexList indexList2'>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#%24PDL%3A%3Adebug'>$PDL::debug</a>
      <li class='indexItem indexItem3'><a href='#%24PDL%3A%3Averbose'>$PDL::verbose</a>
      <li class='indexItem indexItem3'><a href='#%24PDL%3A%3Ause_commas'>$PDL::use_commas</a>
      <li class='indexItem indexItem3'><a href='#%24PDL%3A%3Afloatformat%2C_%24PDL%3A%3Adoubleformat'>$PDL::floatformat, $PDL::doubleformat</a>
      <li class='indexItem indexItem3'><a href='#%24PDL%3A%3Aundefval'>$PDL::undefval</a>
      <li class='indexItem indexItem3'><a href='#%24PDL%3A%3Atoolongtoprint'>$PDL::toolongtoprint</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#FUNCTIONS'>FUNCTIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#barf'>barf</a>
    <li class='indexItem indexItem2'><a href='#pdl'>pdl</a>
    <li class='indexItem indexItem2'><a href='#null'>null</a>
    <li class='indexItem indexItem2'><a href='#nullcreate'>nullcreate</a>
    <li class='indexItem indexItem2'><a href='#nelem'>nelem</a>
    <li class='indexItem indexItem2'><a href='#dims'>dims</a>
    <li class='indexItem indexItem2'><a href='#shape'>shape</a>
    <li class='indexItem indexItem2'><a href='#ndims'>ndims</a>
    <li class='indexItem indexItem2'><a href='#getndims'>getndims</a>
    <li class='indexItem indexItem2'><a href='#dim'>dim</a>
    <li class='indexItem indexItem2'><a href='#getdim'>getdim</a>
    <li class='indexItem indexItem2'><a href='#topdl'>topdl</a>
    <li class='indexItem indexItem2'><a href='#PDL%3A%3Aget_datatype'>PDL::get_datatype</a>
    <li class='indexItem indexItem2'><a href='#howbig'>howbig</a>
    <li class='indexItem indexItem2'><a href='#get_dataref'>get_dataref</a>
    <li class='indexItem indexItem2'><a href='#upd_data'>upd_data</a>
    <li class='indexItem indexItem2'><a href='#PDL%3A%3Athreadids'>PDL::threadids</a>
    <li class='indexItem indexItem2'><a href='#doflow'>doflow</a>
    <li class='indexItem indexItem2'><a href='#flows'>flows</a>
    <li class='indexItem indexItem2'><a href='#PDL%3A%3Anew'>PDL::new</a>
    <li class='indexItem indexItem2'><a href='#copy'>copy</a>
    <li class='indexItem indexItem2'><a href='#PDL%3A%3Ahdr_copy'>PDL::hdr_copy</a>
    <li class='indexItem indexItem2'><a href='#PDL%3A%3Aunwind'>PDL::unwind</a>
    <li class='indexItem indexItem2'><a href='#PDL%3A%3Amake_physical'>PDL::make_physical</a>
    <li class='indexItem indexItem2'><a href='#dummy'>dummy</a>
    <li class='indexItem indexItem2'><a href='#clump'>clump</a>
    <li class='indexItem indexItem2'><a href='#thread_define'>thread_define</a>
    <li class='indexItem indexItem2'><a href='#PDL%3A%3Athread'>PDL::thread</a>
    <li class='indexItem indexItem2'><a href='#diagonal'>diagonal</a>
    <li class='indexItem indexItem2'><a href='#PDL%3A%3Athread1'>PDL::thread1</a>
    <li class='indexItem indexItem2'><a href='#PDL%3A%3Athread2'>PDL::thread2</a>
    <li class='indexItem indexItem2'><a href='#PDL%3A%3Athread3'>PDL::thread3</a>
    <li class='indexItem indexItem2'><a href='#sever'>sever</a>
    <li class='indexItem indexItem2'><a href='#PDL%3A%3Ainfo'>PDL::info</a>
    <li class='indexItem indexItem2'><a href='#approx'>approx</a>
    <li class='indexItem indexItem2'><a href='#mslice'>mslice</a>
    <li class='indexItem indexItem2'><a href='#nslice_if_pdl'>nslice_if_pdl</a>
    <li class='indexItem indexItem2'><a href='#nslice'>nslice</a>
    <li class='indexItem indexItem2'><a href='#inplace'>inplace</a>
    <li class='indexItem indexItem2'><a href='#is_inplace'>is_inplace</a>
    <li class='indexItem indexItem2'><a href='#set_inplace'>set_inplace</a>
    <li class='indexItem indexItem2'><a href='#new_or_inplace'>new_or_inplace</a>
    <li class='indexItem indexItem2'><a href='#PDL%3A%3Anew_from_specification'>PDL::new_from_specification</a>
    <li class='indexItem indexItem2'><a href='#isnull'>isnull</a>
    <li class='indexItem indexItem2'><a href='#isempty'>isempty</a>
    <li class='indexItem indexItem2'><a href='#zeroes'>zeroes</a>
    <li class='indexItem indexItem2'><a href='#zeros'>zeros</a>
    <li class='indexItem indexItem2'><a href='#ones'>ones</a>
    <li class='indexItem indexItem2'><a href='#reshape'>reshape</a>
    <li class='indexItem indexItem2'><a href='#squeeze'>squeeze</a>
    <li class='indexItem indexItem2'><a href='#flat'>flat</a>
    <li class='indexItem indexItem2'><a href='#convert'>convert</a>
    <li class='indexItem indexItem2'><a href='#Datatype_conversions'>Datatype_conversions</a>
    <li class='indexItem indexItem2'><a href='#byte'>byte</a>
    <li class='indexItem indexItem2'><a href='#short'>short</a>
    <li class='indexItem indexItem2'><a href='#ushort'>ushort</a>
    <li class='indexItem indexItem2'><a href='#long'>long</a>
    <li class='indexItem indexItem2'><a href='#longlong'>longlong</a>
    <li class='indexItem indexItem2'><a href='#float'>float</a>
    <li class='indexItem indexItem2'><a href='#double'>double</a>
    <li class='indexItem indexItem2'><a href='#type'>type</a>
    <li class='indexItem indexItem2'><a href='#list'>list</a>
    <li class='indexItem indexItem2'><a href='#unpdl'>unpdl</a>
    <li class='indexItem indexItem2'><a href='#listindices'>listindices</a>
    <li class='indexItem indexItem2'><a href='#set'>set</a>
    <li class='indexItem indexItem2'><a href='#at'>at</a>
    <li class='indexItem indexItem2'><a href='#sclr'>sclr</a>
    <li class='indexItem indexItem2'><a href='#cat'>cat</a>
    <li class='indexItem indexItem2'><a href='#dog'>dog</a>
    <li class='indexItem indexItem2'><a href='#gethdr'>gethdr</a>
    <li class='indexItem indexItem2'><a href='#hdr'>hdr</a>
    <li class='indexItem indexItem2'><a href='#fhdr'>fhdr</a>
    <li class='indexItem indexItem2'><a href='#sethdr'>sethdr</a>
    <li class='indexItem indexItem2'><a href='#hdrcpy'>hdrcpy</a>
    <li class='indexItem indexItem2'><a href='#hcpy'>hcpy</a>
    <li class='indexItem indexItem2'><a href='#set_autopthread_targ'>set_autopthread_targ</a>
    <li class='indexItem indexItem2'><a href='#get_autopthread_targ'>get_autopthread_targ</a>
    <li class='indexItem indexItem2'><a href='#get_autopthread_actual'>get_autopthread_actual</a>
    <li class='indexItem indexItem2'><a href='#set_autopthread_size'>set_autopthread_size</a>
    <li class='indexItem indexItem2'><a href='#get_autopthread_size'>get_autopthread_size</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>PDL::Core - fundamental PDL functionality and vectorization/threading</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Methods and functions for type conversions,
PDL creation,
type conversion,
threading etc.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre> use PDL::Core;             # Normal routines
 use PDL::Core &#39;:Internal&#39;; # Hairy routines</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VECTORIZATION/THREADING:_METHOD_AND_NOMENCLATURE"
>VECTORIZATION/THREADING: METHOD AND NOMENCLATURE</a></h1>

<p>PDL provides vectorized operations via a built-in engine. Vectorization is called &#34;threading&#34; for historical reasons. The threading engine implements simple rules for each operation.</p>

<p>Each PDL object has a &#34;shape&#34; that is a generalized N-dimensional rectangle defined by a &#34;dim list&#34; of sizes in an arbitrary set of dimensions. A PDL with shape 2x3 has 6 elements and is said to be two-dimensional, or may be referred to as a 2x3-PDL. The dimensions are indexed numerically starting at 0, so a 2x3-PDL has a dimension 0 (or &#34;dim 0&#34;) with size 2 and a 1 dimension (or &#34;dim 1&#34;) with size 3.</p>

<p>PDL generalizes *all* mathematical operations with the notion of &#34;active dims&#34;: each operator has zero or more active dims that are used in carrying out the operation. Simple scalar operations like scalar multiplication (&#39;*&#39;) have 0 active dims. More complicated operators can have more active dims. For example, matrix multiplication (&#39;x&#39;) has 2 active dims. Additional dims are automatically vectorized across -- e.g. multiplying a 2x5-PDL with a 2x5-PDL requires 10 simple multiplication operations, and yields a 2x5-PDL result.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Threading_rules"
>Threading rules</a></h2>

<p>In any PDL expression, the active dims appropriate for each operator are used starting at the 0 dim and working forward through the dim list of each object. All additional dims after the active dims are &#34;thread dims&#34;. The thread dims do not have to agree exactly: they are coerced to agree according to simple rules:</p>

<ul>
<li>Null PDLs match any dim list (see below).</li>

<li>Dims with sizes other than 1 must all agree in size.</li>

<li>Dims of size 1 are expanded as necessary.</li>

<li>Missing dims are expanded appropriately.</li>
</ul>

<p>The &#34;size 1&#34; rule implements &#34;generalized scalar&#34; operation, by analogy to scalar multiplication. The &#34;missing dims&#34; rule acknowledges the ambiguity between a missing dim and a dim of size 1.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Null_PDLs"
>Null PDLs</a></h2>

<p>PDLs on the left-hand side of assignment can have the special value &#34;Null&#34;. A null PDL has no dim list and no set size; its shape is determined by the computed shape of the expression being assigned to it. Null PDLs contain no values and can only be assigned to. When assigned to (e.g. via the <code>.=</code> operator), they cease to be null PDLs.</p>

<p>To create a null PDL, use <code>PDL-&#62;null()</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Empty_PDLs"
>Empty PDLs</a></h2>

<p>PDLs can represent the empty set using &#34;structured Empty&#34; variables. An empty PDL is not a null PDL.</p>

<p>Any dim of a PDL can be set explicitly to size 0. If so, the PDL contains zero values (because the total number of values is the product of all the sizes in the PDL&#39;s shape or dimlist).</p>

<p>Scalar PDLs are zero-dimensional and have no entries in the dim list, so they cannot be empty. 1-D and higher PDLs can be empty. Empty PDLs are useful for set operations, and are most commonly encountered in the output from selection operators such as <a href="../PDL/Primitive.html" class="podlinkpod"
>which</a> and <a href="../PDL/Primitive.html" class="podlinkpod"
>whichND</a>. Not all empty PDLs have the same threading properties -- e.g. a 2x0-PDL represents a collection of 2-vectors that happens to contain no elements, while a simple 0-PDL represents a collection of scalar values (that also happens to contain no elements).</p>

<p>Note that 0 dims are not adjustable via the threading rules -- a dim with size 0 can only match a corresponding dim of size 0 or 1.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Thread_rules_and_assignments"
>Thread rules and assignments</a></h2>

<p>Versions of PDL through 2.4.10 have some irregularity with threading and assignments. Currently the threading engine performs a full expansion of both sides of the computed assignment operator <code>.=</code> (which assigns values to a pre-existing PDL). This leads to counter-intuitive behavior in some cases:</p>

<ul>
<li>Generalized scalars and computed assignment
<p>If the PDL on the left-hand side of <code>.=</code> has a dim of size 1, it can be treated as a generalized scalar, as in:</p>

<pre>    $a = sequence(2,3);
    $b = zeroes(1,3);
    $b .= $a;</pre>

<p>In this case, <code>$b</code> is automatically treated as a 2x3-PDL during the threading operation, but half of the values from <code>$a</code> silently disappear. The output is, as Kernighan and Ritchie would say, &#34;undefined&#34;.</p>

<p>Further, if the value on the right of <code>.=</code> is empty, then <code>.=</code> becomes a silent no-op:</p>

<pre>    $a = zeroes(0);
    $b = zeroes(1);
    $b .= $a+1;
    print $b;</pre>

<p>will print <code>[0]</code>. In this case, &#34;$a+1&#34; is empty, and &#34;$b&#34; is a generalized scalar that is adjusted to be empty, so the assignment is carried out for zero elements (a no-op).</p>

<p>Both of these behaviors are considered harmful and should not be relied upon: they may be patched away in a future version of PDL.</p>
</li>

<li>Empty PDLs and generalized scalars
<p>Generalized scalars (PDLs with a dim of size 1) can match any size in the corresponding dim, including 0. Thus,</p>

<pre>    $a = ones(2,0);
    $b = sequence(2,1);
    $c = $a * $b;
    print $c;</pre>

<p>prints <code>Empty[2,0]</code>.</p>

<p>This behavior is counterintuitive but desirable, and will be preserved in future versions of PDL.</p>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VARIABLES"
>VARIABLES</a></h1>

<p>These are important variables of <b>global</b> scope and are placed in the PDL namespace.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="$PDL::debug"
><code>$PDL::debug</code></a></h3>

<blockquote>
<p>When true, PDL debugging information is printed.</p>
</blockquote>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="$PDL::verbose"
><code>$PDL::verbose</code></a></h3>

<blockquote>
<p>When true, PDL functions provide chatty information.</p>
</blockquote>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="$PDL::use_commas"
><code>$PDL::use_commas</code></a></h3>

<blockquote>
<p>Whether to insert commas when printing pdls</p>
</blockquote>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="$PDL::floatformat,_$PDL::doubleformat"
><code>$PDL::floatformat</code>, <code>$PDL::doubleformat</code></a></h3>

<blockquote>
<p>The default print format for floats and doubles, repectively. The default default values are:</p>

<pre>  $PDL::floatformat  = &#34;%7g&#34;;
  $PDL::doubleformat = &#34;%10.8g&#34;;</pre>
</blockquote>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="$PDL::undefval"
><code>$PDL::undefval</code></a></h3>

<blockquote>
<p>The value to use instead of <code>undef</code> when creating pdls.</p>
</blockquote>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="$PDL::toolongtoprint"
><code>$PDL::toolongtoprint</code></a></h3>

<blockquote>
<p>The maximal size pdls to print (defaults to 10000 elements)</p>
</blockquote>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FUNCTIONS"
>FUNCTIONS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="barf"
>barf</a></h2>

<p>Standard error reporting routine for PDL.</p>

<p><code>barf()</code> is the routine PDL modules should call to report errors. This is because <code>barf()</code> will report the error as coming from the correct line in the module user&#39;s script rather than in the PDL module.</p>

<p>For now, barf just calls Carp::confess()</p>

<p>Remember <code>barf()</code> is your friend. *Use* it!</p>

<p>At the perl level:</p>

<pre> barf(&#34;User has too low an IQ!&#34;);</pre>

<p>In C or XS code:</p>

<pre> barf(&#34;You have made %d errors&#34;, count);</pre>

<p>Note: this is one of the few functions ALWAYS exported by PDL::Core</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="pdl"
>pdl</a></h2>

<p>PDL constructor - creates new piddle from perl scalars/arrays, piddles, and strings</p>

<pre> $a = pdl(SCALAR|ARRAY REFERENCE|ARRAY|STRING);</pre>

<pre> $a = pdl [1..10];             # 1D array
 $a = pdl ([1..10]);           # 1D array
 $a = pdl (1,2,3,4);           # Ditto
 $b = pdl [[1,2,3],[4,5,6]];   # 2D 3x2 array
 $b = pdl &#34;[[1,2,3],[4,5,6]]&#34;; # Ditto (slower)
 $b = pdl &#34;[1 2 3; 4 5 6]&#34;;    # Ditto
 $b = pdl q[1 2 3; 4 5 6];     # Ditto, using the q quote operator
 $b = pdl &#34;1 2 3; 4 5 6&#34;;      # Ditto, less obvious, but still works
 $b = pdl 42                   # 0-dimensional scalar
 $c = pdl $a;                  # Make a new copy
 $a = pdl([1,2,3],[4,5,6]);    # 2D
 $a = pdl([[1,2,3],[4,5,6]]);  # 2D</pre>

<p>Note the last two are equivalent - a list is automatically converted to a list reference for syntactic convenience. i.e. you can omit the outer <code>[]</code></p>

<p>You can mix and match arrays, array refs, and PDLs in your argument list, and <code>pdl</code> will sort them out. You get back a PDL whose last (slowest running) dim runs across the top level of the list you hand in, and whose first (fastest running) dim runs across the deepest level that you supply. At the moment, you cannot mix and match those arguments with string arguments, though we can&#39;t imagine a situation in which you would really want to do that.</p>

<p>The string version of pdl also allows you to use the strings <code>bad</code>, <code>inf</code>, and <code>nan</code>, and it will insert the values that you mean (and set the bad flag if you use <code>bad</code>). You can mix and match case, though you shouldn&#39;t. Here are some examples:</p>

<pre> $bad = pdl q[1 2 3 bad 5 6];  # Set fourth element to the bad value
 $bad = pdl q[1 2 3 BAD 5 6];  # ditto
 $bad = pdl q[1 2 inf bad 5];  # now third element is IEEE infinite value
 $bad = pdl q[nan 2 inf -inf]; # first value is IEEE nan value</pre>

<p>The default constructor uses IEEE double-precision floating point numbers. You can use other types, but you will get a warning if you try to use <code>nan</code> with integer types (it will be replaced with the <code>bad</code> value) and you will get a fatal error if you try to use <code>inf</code>.</p>

<p>Throwing a PDL into the mix has the same effect as throwing in a list ref:</p>

<pre>  pdl(pdl(1,2),[3,4])</pre>

<p>is the same as</p>

<pre>  pdl([1,2],[3,4]).</pre>

<p>All of the dimensions in the list are &#34;padded-out&#34; with undefval to meet the widest dim in the list, so (e.g.)</p>

<pre>  $a = pdl([[1,2,3],[2]])</pre>

<p>gives you the same answer as</p>

<pre>  $a = pdl([[1,2,3],[2,undef,undef]]);</pre>

<p><code>pdl()</code> is a functional synonym for the &#39;new&#39; constructor, e.g.:</p>

<pre> $x = new PDL [1..10];</pre>

<p>In order to control how undefs are handled in converting from perl lists to PDLs, one can set the variable <code>$PDL::undefval</code>. For example:</p>

<pre> $foo = [[1,2,undef],[undef,3,4]];
 $PDL::undefval = -999;
 $f = pdl $foo;
 print $f
 [
  [   1    2 -999]
  [-999    3    4]
 ]</pre>

<p><code>$PDL::undefval</code> defaults to zero.</p>

<p>As a final note, if you include an Empty PDL in the list of objects to construct into a PDL, it is kept as a placeholder pane -- so if you feed in (say) 7 objects, you get a size of 7 in the 0th dim of the output PDL. The placeholder panes are completely padded out. But if you feed in only a single Empty PDL, you get back the Empty PDL (no padding).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="null"
>null</a></h2>

<p>Returns a &#39;null&#39; piddle.</p>

<pre> $x = null;</pre>

<p><code>null()</code> has a special meaning to <a href="../PDL/PP.html" class="podlinkpod"
>PDL::PP</a>. It is used to flag a special kind of empty piddle, which can grow to appropriate dimensions to store a result (as opposed to storing a result in an existing piddle).</p>

<pre> pdl&#62; sumover sequence(10,10), $ans=null;p $ans
 [45 145 245 345 445 545 645 745 845 945]</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="nullcreate"
>nullcreate</a></h2>

<p>Returns a &#39;null&#39; piddle.</p>

<pre> $x = PDL-&#62;nullcreate($arg)</pre>

<p>This is an routine used by many of the threading primitives (i.e. <a href="../PDL/Ufunc.html#sumover" class="podlinkpod"
>sumover</a>, <a href="../PDL/Ufunc.html#minimum" class="podlinkpod"
>minimum</a>, etc.) to generate a null piddle for the function&#39;s output that will behave properly for derived (or subclassed) PDL objects.</p>

<p>For the above usage: If <code>$arg</code> is a PDL, or a derived PDL, then <code>$arg-&#62;null</code> is returned. If <code>$arg</code> is a scalar (i.e. a zero-dimensional PDL) then <code>PDL-&#62;null</code> is returned.</p>

<pre> PDL::Derived-&#62;nullcreate(10)
   returns PDL::Derived-&#62;null.
 PDL-&#62;nullcreate($pdlderived)
   returns $pdlderived-&#62;null.</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="nelem"
>nelem</a></h2>

<p>Return the number of elements in a piddle</p>

<pre> $n = nelem($piddle); $n = $piddle-&#62;nelem;</pre>

<pre> $mean = sum($data)/nelem($data);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="dims"
>dims</a></h2>

<p>Return piddle dimensions as a perl list</p>

<pre> @dims = $piddle-&#62;dims;  @dims = dims($piddle);</pre>

<pre> pdl&#62; p @tmp = dims zeroes 10,3,22
 10 3 22</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="shape"
>shape</a></h2>

<p>Return piddle dimensions as a perl list</p>

<pre> $shape = $piddle-&#62;shape;  $shape = shape($piddle);</pre>

<pre> pdl&#62; p $shape = shape zeroes 10,3,22
 [10 3 22]</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ndims"
>ndims</a></h2>

<p>Returns the number of dimensions in a piddle. Alias for <a href="../PDL/Core.html#getndims" class="podlinkpod"
>getndims</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="getndims"
>getndims</a></h2>

<p>Returns the number of dimensions in a piddle</p>

<pre> $ndims = $piddle-&#62;getndims;</pre>

<pre> pdl&#62; p zeroes(10,3,22)-&#62;getndims
 3</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="dim"
>dim</a></h2>

<p>Returns the size of the given dimension of a piddle. Alias for <a href="../PDL/Core.html#getdim" class="podlinkpod"
>getdim</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="getdim"
>getdim</a></h2>

<p>Returns the size of the given dimension.</p>

<pre> $dim0 = $piddle-&#62;getdim(0);</pre>

<pre> pdl&#62; p zeroes(10,3,22)-&#62;getdim(1)
 3</pre>

<p>Negative indices count from the end of the dims array. Indices beyond the end will return a size of 1. This reflects the idea that any pdl is equivalent to an infinitely dimensional array in which only a finite number of dimensions have a size different from one. For example, in that sense a 3D piddle of shape [3,5,2] is equivalent to a [3,5,2,1,1,1,1,1,....] piddle. Accordingly,</p>

<pre>  print $a-&#62;getdim(10000);</pre>

<p>will print 1 for most practically encountered piddles.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="topdl"
>topdl</a></h2>

<p>alternate piddle constructor - ensures arg is a piddle</p>

<pre> $a = topdl(SCALAR|ARRAY REFERENCE|ARRAY);</pre>

<p>The difference between <a href="#pdl" class="podlinkpod"
>pdl()</a> and <code>topdl()</code> is that the latter will just &#39;fall through&#39; if the argument is already a piddle. It will return a reference and <i>NOT</i> a new copy.</p>

<p>This is particulary useful if you are writing a function which is doing some fiddling with internals and assumes a piddle argument (e.g. for method calls). Using <code>topdl()</code> will ensure nothing breaks if passed with &#39;2&#39;.</p>

<p>Note that <code>topdl()</code> is not exported by default (see example below for usage).</p>

<pre> use PDL::Core &#39;:Internal&#39;; # use the internal routines of
                            # the Core module

 $a = topdl 43;             # $a is piddle with value &#39;43&#39;
 $b = topdl $piddle;        # fall through
 $a = topdl (1,2,3,4);      # Convert 1D array</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="PDL::get_datatype"
>PDL::get_datatype</a></h2>

<p>Internal: Return the numeric value identifying the piddle datatype</p>

<pre> $x = $piddle-&#62;get_datatype;</pre>

<p>Mainly used for internal routines.</p>

<p>NOTE: get_datatype returns &#39;just a number&#39; not any special type object, unlike <a href="#type" class="podlinkpod"
>type</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="howbig"
>howbig</a></h2>

<p>Returns the sizeof a piddle datatype in bytes.</p>

<p>Note that <code>howbig()</code> is not exported by default (see example below for usage).</p>

<pre> use PDL::Core &#39;:Internal&#39;; # use the internal routines of
                            # the Core module

 $size = howbig($piddle-&#62;get_datatype);</pre>

<p>Mainly used for internal routines.</p>

<p>NOTE: NOT a method! This is because get_datatype returns &#39;just a number&#39; not any special object.</p>

<pre> pdl&#62; p howbig(ushort([1..10])-&#62;get_datatype)
 2</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_dataref"
>get_dataref</a></h2>

<p>Return the internal data for a piddle, as a perl SCALAR ref.</p>

<p>Most piddles hold their internal data in a packed perl string, to take advantage of perl&#39;s memory management. This gives you direct access to the string, which is handy when you need to manipulate the binary data directly (e.g. for file I/O). If you modify the string, you&#39;ll need to call <a href="../upd_data.html" class="podlinkpod"
>upd_data</a> afterward, to make sure that the piddle points to the new location of the underlying perl variable.</p>

<p>Calling <code>get_dataref</code> automatically physicalizes your piddle (see <a href="#PDL%3A%3Amake_physical" class="podlinkpod"
>make_physical</a>). You definitely don&#39;t want to do anything to the SV to truncate or deallocate the string, unless you correspondingly call <a href="#reshape" class="podlinkpod"
>reshape</a> to make the PDL match its new data dimension.</p>

<p>You definitely don&#39;t want to use get_dataref unless you know what you are doing (or are trying to find out): you can end up scrozzling memory if you shrink or eliminate the string representation of the variable. Here be dragons.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="upd_data"
>upd_data</a></h2>

<p>Update the data pointer in a piddle to match its perl SV.</p>

<p>This is useful if you&#39;ve been monkeying with the packed string representation of the PDL, which you probably shouldn&#39;t be doing anyway. (see <a href="../get_dataref.html" class="podlinkpod"
>get_dataref</a>.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="PDL::threadids"
>PDL::threadids</a></h2>

<p>Returns the piddle thread IDs as a perl list</p>

<p>Note that <code>threadids()</code> is not exported by default (see example below for usage).</p>

<pre> use PDL::Core &#39;:Internal&#39;; # use the internal routines of
                            # the Core module

 @ids = threadids $piddle;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="doflow"
>doflow</a></h2>

<p>Turn on/off dataflow</p>

<pre> $x-&#62;doflow;  doflow($x);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="flows"
>flows</a></h2>

<p>Whether or not a piddle is indulging in dataflow</p>

<pre> something if $x-&#62;flows; $hmm = flows($x);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="PDL::new"
>PDL::new</a></h2>

<p>new piddle constructor method</p>

<pre> $x = PDL-&#62;new(SCALAR|ARRAY|ARRAY REF|STRING);</pre>

<pre> $x = PDL-&#62;new(42);             # new from a Perl scalar
 $x = new PDL 42;               # ditto
 $y = PDL-&#62;new(@list_of_vals);  # new from Perl list
 $y = new PDL @list_of_vals;    # ditto
 $z = PDL-&#62;new(\@list_of_vals); # new from Perl list reference
 $w = PDL-&#62;new(&#34;[1 2 3]&#34;);      # new from Perl string, using
                                # Matlab constructor syntax</pre>

<p>Constructs piddle from perl numbers and lists and strings with Matlab/Octave style constructor syntax.</p>

<p>The string input is fairly versatile though not performance optimized. The goal is to make it easy to copy and paste code from PDL output and to offer a familiar Matlab syntax for piddle construction. As of May, 2010, it is a new feature, so feel free to report bugs or suggest new features. See documentation for <a href="../pdl.html" class="podlinkpod"
>pdl</a> for more examples of usage.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="copy"
>copy</a></h2>

<p>Make a physical copy of a piddle</p>

<pre> $new = $old-&#62;copy;</pre>

<p>Since <code>$new = $old</code> just makes a new reference, the <code>copy</code> method is provided to allow real independent copies to be made.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="PDL::hdr_copy"
>PDL::hdr_copy</a></h2>

<p>Return an explicit copy of the header of a PDL.</p>

<p>hdr_copy is just a wrapper for the internal routine _hdr_copy, which takes the hash ref itself. That is the routine which is used to make copies of the header during normal operations if the hdrcpy() flag of a PDL is set.</p>

<p>General-purpose deep copies are expensive in perl, so some simple optimization happens:</p>

<p>If the header is a tied array or a blessed hash ref with an associated method called <code>copy</code>, then that -&#62;copy method is called. Otherwise, all elements of the hash are explicitly copied. References are recursively deep copied.</p>

<p>This routine seems to leak memory.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="PDL::unwind"
>PDL::unwind</a></h2>

<p>Return a piddle which is the same as the argument except that all threadids have been removed.</p>

<pre> $y = $x-&#62;unwind;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="PDL::make_physical"
>PDL::make_physical</a></h2>

<p>Make sure the data portion of a piddle can be accessed from XS code.</p>

<pre> $a-&#62;make_physical;
 $a-&#62;call_my_xs_method;</pre>

<p>Ensures that a piddle gets its own allocated copy of data. This obviously implies that there are certain piddles which do not have their own data. These are so called <i>virtual</i> piddles that make use of the <i>vaffine</i> optimisation (see <a href="../PDL/Indexing.html" class="podlinkpod"
>PDL::Indexing</a>). They do not have their own copy of data but instead store only access information to some (or all) of another piddle&#39;s data.</p>

<p>Note: this function should not be used unless absolutely neccessary since otherwise memory requirements might be severly increased. Instead of writing your own XS code with the need to call <code>make_physical</code> you might want to consider using the PDL preprocessor (see <a href="../PDL/PP.html" class="podlinkpod"
>PDL::PP</a>) which can be used to transparently access virtual piddles without the need to physicalise them (though there are exceptions).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="dummy"
>dummy</a></h2>

<p>Insert a &#39;dummy dimension&#39; of given length (defaults to 1)</p>

<p>No relation to the &#39;Dungeon Dimensions&#39; in Discworld!</p>

<p>Negative positions specify relative to last dimension, i.e. <code>dummy(-1)</code> appends one dimension at end, <code>dummy(-2)</code> inserts a dummy dimension in front of the last dim, etc.</p>

<p>If you specify a dimension position larger than the existing dimension list of your PDL, the PDL gets automagically padded with extra dummy dimensions so that you get the dim you asked for, in the slot you asked for. This could cause you trouble if, for example, you ask for $a-&#62;dummy(5000,1) because $a will get 5,000 dimensions, each of rank 1.</p>

<p>Because padding at the beginning of the dimension list moves existing dimensions from slot to slot, it&#39;s considered unsafe, so automagic padding doesn&#39;t work for large negative indices -- only for large positive indices.</p>

<pre> $y = $x-&#62;dummy($position[,$dimsize]);</pre>

<pre> pdl&#62; p sequence(3)-&#62;dummy(0,3)
 [
  [0 0 0]
  [1 1 1]
  [2 2 2]
 ]

 pdl&#62; p sequence(3)-&#62;dummy(3,2)
 [
  [
   [0 1 2]
  ]
  [
   [0 1 2]
  ]
 ]

 pdl&#62; p sequence(3)-&#62;dummy(-3,2)
 Runtime error: PDL: For safety, &#60;pos&#62; &#60; -(dims+1) forbidden in dummy.  min=-2, pos=-3</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="clump"
>clump</a></h2>

<p>&#34;clumps&#34; several dimensions into one large dimension</p>

<p>If called with one argument <code>$n</code> clumps the first <code>$n</code> dimensions into one. For example, if <code>$a</code> has dimensions <code>(5,3,4)</code> then after</p>

<pre> $b = $a-&#62;clump(2);   # Clump 2 first dimensions</pre>

<p>the variable <code>$b</code> will have dimensions <code>(15,4)</code> and the element <code>$b-&#62;at(7,3)</code> refers to the element <code>$a-&#62;at(1,2,3)</code>.</p>

<p>Use <code>clump(-1)</code> to flatten a piddle. The method <a href="../PDL/Core.html#flat" class="podlinkpod"
>flat</a> is provided as a convenient alias.</p>

<p>Clumping with a negative dimension in general leaves that many dimensions behind -- e.g. clump(-2) clumps all of the first few dimensions into a single one, leaving a 2-D piddle.</p>

<p>If <code>clump</code> is called with an index list with more than one element it is treated as a list of dimensions that should be clumped together into one. The resulting clumped dim is placed at the position of the lowest index in the list. This convention ensures that <code>clump</code> does the expected thing in the usual cases. The following example demonstrates typical usage:</p>

<pre>  $a = sequence 2,3,3,3,5; # 5D piddle
  $c = $a-&#62;clump(1..3);    # clump all the dims 1 to 3 into one
  print $c-&#62;info;          # resulting 3D piddle has clumped dim at pos 1
 PDL: Double D [2,27,5]</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="thread_define"
>thread_define</a></h2>

<p>define functions that support threading at the perl level</p>

<pre> thread_define &#39;tline(a(n);b(n))&#39;, over {
  line $_[0], $_[1]; # make line compliant with threading
 };</pre>

<p><code>thread_define</code> provides some support for threading (see <a href="../PDL/Indexing.html" class="podlinkpod"
>PDL::Indexing</a>) at the perl level. It allows you to do things for which you normally would have resorted to PDL::PP (see <a href="../PDL/PP.html" class="podlinkpod"
>PDL::PP</a>); however, it is most useful to wrap existing perl functions so that the new routine supports PDL threading.</p>

<p><code>thread_define</code> is used to define new <i>threading aware</i> functions. Its first argument is a symbolic repesentation of the new function to be defined. The string is composed of the name of the new function followed by its signature (see <a href="../PDL/Indexing.html" class="podlinkpod"
>PDL::Indexing</a> and <a href="../PDL/PP.html" class="podlinkpod"
>PDL::PP</a>) in parentheses. The second argument is a subroutine that will be called with the slices of the actual runtime arguments as specified by its signature. Correct dimension sizes and minimal number of dimensions for all arguments will be checked (assuming the rules of PDL threading, see <a href="../PDL/Indexing.html" class="podlinkpod"
>PDL::Indexing</a>).</p>

<p>The actual work is done by the <code>signature</code> class which parses the signature string, does runtime dimension checks and the routine <code>threadover</code> that generates the loop over all appropriate slices of pdl arguments and creates pdls as needed.</p>

<p>Similar to <code>pp_def</code> and its <code>OtherPars</code> option it is possible to define the new function so that it accepts normal perl args as well as piddles. You do this by using the <code>NOtherPars</code> parameter in the signature. The number of <code>NOtherPars</code> specified will be passed unaltered into the subroutine given as the second argument of <code>thread_define</code>. Let&#39;s illustrate this with an example:</p>

<pre> PDL::thread_define &#39;triangles(inda();indb();indc()), NOtherPars =&#62; 2&#39;,
  PDL::over {
    ${$_[3]} .= $_[4].join(&#39;,&#39;,map {$_-&#62;at} @_[0..2]).&#34;,-1,\n&#34;;
  };</pre>

<p>This defines a function <code>triangles</code> that takes 3 piddles as input plus 2 arguments which are passed into the routine unaltered. This routine is used to collect lists of indices into a perl scalar that is passed by reference. Each line is preceded by a prefix passed as <code>$_[4]</code>. Here is typical usage:</p>

<pre> $txt = &#39;&#39;;
 triangles(pdl(1,2,3),pdl(1),pdl(0),\$txt,&#34; &#34;x10);
 print $txt;</pre>

<p>resulting in the following output</p>

<pre> 1,1,0,-1,
 2,1,0,-1,
 3,1,0,-1,</pre>

<p>which is used in <a href="../PDL/Graphics/TriD/VRML.html" class="podlinkpod"
>PDL::Graphics::TriD::VRML</a> to generate VRML output.</p>

<p>Currently, this is probably not much more than a POP (proof of principle) but is hoped to be useful enough for some real life work.</p>

<p>Check <a href="../PDL/PP.html" class="podlinkpod"
>PDL::PP</a> for the format of the signature. Currently, the <code>[t]</code> qualifier and all type qualifiers are ignored.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="PDL::thread"
>PDL::thread</a></h2>

<p>Use explicit threading over specified dimensions (see also <a href="../PDL/Indexing.html" class="podlinkpod"
>PDL::Indexing</a>)</p>

<pre> $b = $a-&#62;thread($dim,[$dim1,...])</pre>

<pre> $a = zeroes 3,4,5;
 $b = $a-&#62;thread(2,0);</pre>

<p>Same as <a href="#PDL%3A%3Athread1" class="podlinkpod"
>PDL::thread1</a>, i.e. uses thread id 1.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="diagonal"
>diagonal</a></h2>

<p>Returns the multidimensional diagonal over the specified dimensions.</p>

<pre> $d = $x-&#62;diagonal(dim1, dim2,...)</pre>

<pre> pdl&#62; $a = zeroes(3,3,3);
 pdl&#62; ($b = $a-&#62;diagonal(0,1))++;
 pdl&#62; p $a
 [
  [
   [1 0 0]
   [0 1 0]
   [0 0 1]
  ]
  [
   [1 0 0]
   [0 1 0]
   [0 0 1]
  ]
  [
   [1 0 0]
   [0 1 0]
   [0 0 1]
  ]
 ]</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="PDL::thread1"
>PDL::thread1</a></h2>

<p>Explicit threading over specified dims using thread id 1.</p>

<pre> $xx = $x-&#62;thread1(3,1)</pre>

<pre> Wibble</pre>

<p>Convenience function interfacing to <a href="../PDL/Slices.html#threadI" class="podlinkpod"
>PDL::Slices::threadI</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="PDL::thread2"
>PDL::thread2</a></h2>

<p>Explicit threading over specified dims using thread id 2.</p>

<pre> $xx = $x-&#62;thread2(3,1)</pre>

<pre> Wibble</pre>

<p>Convenience function interfacing to <a href="../PDL/Slices.html#threadI" class="podlinkpod"
>PDL::Slices::threadI</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="PDL::thread3"
>PDL::thread3</a></h2>

<p>Explicit threading over specified dims using thread id 3.</p>

<pre> $xx = $x-&#62;thread3(3,1)</pre>

<pre> Wibble</pre>

<p>Convenience function interfacing to <a href="../PDL/Slices.html#threadI" class="podlinkpod"
>PDL::Slices::threadI</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="sever"
>sever</a></h2>

<p>sever any links of this piddle to parent piddles</p>

<p>In PDL it is possible for a piddle to be just another view into another piddle&#39;s data. In that case we call this piddle a <i>virtual piddle</i> and the original piddle owning the data its parent. In other languages these alternate views sometimes run by names such as <i>alias</i> or <i>smart reference</i>.</p>

<p>Typical functions that return such piddles are <code>slice</code>, <code>xchg</code>, <code>index</code>, etc. Sometimes, however, you would like to separate the <i>virtual piddle</i> from its parent&#39;s data and just give it a life of its own (so that manipulation of its data doesn&#39;t change the parent). This is simply achieved by using <code>sever</code>. For example,</p>

<pre>   $a = $pdl-&#62;index(pdl(0,3,7))-&#62;sever;
   $a++;       # important: $pdl is not modified!</pre>

<p>In many (but not all) circumstances it acts therefore similar to <a href="../PDL/Core.html#copy" class="podlinkpod"
>copy</a>. However, in general performance is better with <code>sever</code> and secondly, <code>sever</code> doesn&#39;t lead to futile copying when used on piddles that already have their own data. On the other hand, if you really want to make sure to work on a copy of a piddle use <a href="../PDL/Core.html#copy" class="podlinkpod"
>copy</a>.</p>

<pre>   $a = zeroes(20);
   $a-&#62;sever;   # NOOP since $a is already its own boss!</pre>

<p>Again note: <code>sever</code> <i>is not</i> the same as <a href="../PDL/Core.html#copy" class="podlinkpod"
>copy</a>! For example,</p>

<pre>   $a = zeroes(1); # $a does not have a parent, i.e. it is not a slice etc
   $b = $a-&#62;sever; # $b is now pointing to the same piddle as $a
   $b++;
   print $a;
 [1]</pre>

<p>but</p>

<pre>   $a = zeroes(1);
   $b = $a-&#62;copy; # $b is now pointing to a new piddle
   $b++;
   print $a;
 [0]</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="PDL::info"
>PDL::info</a></h2>

<p>Return formatted information about a piddle.</p>

<pre> $x-&#62;info($format_string);</pre>

<pre> print $x-&#62;info(&#34;Type: %T Dim: %-15D State: %S&#34;);</pre>

<p>Returns a string with info about a piddle. Takes an optional argument to specify the format of information a la sprintf. Format specifiers are in the form <code>%&#60;width&#62;&#60;letter&#62;</code> where the width is optional and the letter is one of</p>

<dl>
<dt><a name="T"
>T</a></dt>

<dd>
<p>Type</p>

<dt><a name="D"
>D</a></dt>

<dd>
<p>Formatted Dimensions</p>

<dt><a name="F"
>F</a></dt>

<dd>
<p>Dataflow status</p>

<dt><a name="S"
>S</a></dt>

<dd>
<p>Some internal flags (P=physical,V=Vaffine,C=changed,B=may contain bad data)</p>

<dt><a name="C"
>C</a></dt>

<dd>
<p>Class of this piddle, i.e. <code>ref $pdl</code></p>

<dt><a name="A"
>A</a></dt>

<dd>
<p>Address of the piddle struct as a unique identifier</p>

<dt><a name="M"
>M</a></dt>

<dd>
<p>Calculated memory consumption of this piddle&#39;s data area</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="approx"
>approx</a></h2>

<p>test for approximately equal values (relaxed <code>==</code>)</p>

<pre>  # ok if all corresponding values in
  # piddles are within 1e-8 of each other
  print &#34;ok\n&#34; if all approx $a, $b, 1e-8;</pre>

<p><code>approx</code> is a relaxed form of the <code>==</code> operator and often more appropriate for floating point types (<code>float</code> and <code>double</code>).</p>

<p>Usage:</p>

<pre>  $res = approx $a, $b [, $eps]</pre>

<p>The optional parameter <code>$eps</code> is remembered across invocations and initially set to 1e-6, e.g.</p>

<pre>  approx $a, $b;         # last $eps used (1e-6 initially)
  approx $a, $b, 1e-10;  # 1e-10
  approx $a, $b;         # also 1e-10</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="mslice"
>mslice</a></h2>

<p>Convenience interface to <a href="../PDL/Slices.html#slice" class="podlinkpod"
>slice</a>, allowing easier inclusion of dimensions in perl code.</p>

<pre> $a = $x-&#62;mslice(...);</pre>

<pre> # below is the same as $x-&#62;slice(&#34;5:7,:,3:4:2&#34;)
 $a = $x-&#62;mslice([5,7],X,[3,4,2]);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="nslice_if_pdl"
>nslice_if_pdl</a></h2>

<p>If <code>$self</code> is a PDL, then calls <code>nslice</code> with all but the last argument, otherwise $self-&#62;($_[-1]) is called where $_[-1} is the original argument string found during PDL::NiceSlice filtering.</p>

<pre> $a = $x-&#62;nslice_if_pdl(...,&#39;(args)&#39;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="nslice"
>nslice</a></h2>

<p>Internally used interface to <a href="../PDL/Slices.html#slice" class="podlinkpod"
>slice</a> and <a href="../PDL/Slices.html#dice" class="podlinkpod"
>dice</a> that is the runtime part of the <a href="../PDL/NiceSlice.html" class="podlinkpod"
>PDL::NiceSlice</a> implementation.</p>

<pre> $a = $x-&#62;nslice(...);</pre>

<pre> # below is the same as $x-&#62;slice(&#34;5:7,:,3:4:2&#34;)
 $a = $x-&#62;nslice([5,7],X,[3,4,2]);</pre>

<p>It implements a superset of <a href="../PDL/Core.html#mslice" class="podlinkpod"
>mslice</a>&#39;s features. Should probably not be used in your scripts. Rather resort to the <a href="../PDL/NiceSlice.html" class="podlinkpod"
>PDL::NiceSlice</a> interface.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="inplace"
>inplace</a></h2>

<p>Flag a piddle so that the next operation is done &#39;in place&#39;</p>

<pre> somefunc($x-&#62;inplace); somefunc(inplace $x);</pre>

<p>In most cases one likes to use the syntax <code>$y = f($x)</code>, however in many case the operation <code>f()</code> can be done correctly &#39;in place&#39;, i.e. without making a new copy of the data for output. To make it easy to use this, we write <code>f()</code> in such a way that it operates in-place, and use <code>inplace</code> to hint that a new copy should be disabled. This also makes for clear syntax.</p>

<p>Obviously this will not work for all functions, and if in doubt see the function&#39;s documentation. However one can assume this is true for all elemental functions (i.e. those which just operate array element by array element like <code>log10</code>).</p>

<pre> pdl&#62; $x = xvals zeroes 10;
 pdl&#62; log10(inplace $x)
 pdl&#62; p $x
 [-inf 0    0.30103 0.47712125 0.60205999    0.69897 0.77815125 0.84509804 0.90308999 0.95424251]</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="is_inplace"
>is_inplace</a></h2>

<p>Test the in-place flag on a piddle</p>

<pre>  $out = ($in-&#62;is_inplace) ? $in : zeroes($in);
  $in-&#62;set_inplace(0)</pre>

<p>Provides access to the <a href="#inplace" class="podlinkpod"
>inplace</a> hint flag, within the perl millieu. That way functions you write can be inplace aware... If given an argument the inplace flag will be set or unset depending on the value at the same time. Can be used for shortcut tests that delete the inplace flag while testing:</p>

<pre>  $out = ($in-&#62;is_inplace(0)) ? $in : zeroes($in); # test &#38; unset!</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="set_inplace"
>set_inplace</a></h2>

<p>Set the in-place flag on a piddle</p>

<pre>  $out = ($in-&#62;is_inplace) ? $in : zeroes($in);
  $in-&#62;set_inplace(0);</pre>

<p>Provides access to the <a href="#inplace" class="podlinkpod"
>inplace</a> hint flag, within the perl millieu. Useful mainly for turning it OFF, as <a href="#inplace" class="podlinkpod"
>inplace</a> turns it ON more conveniently.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="new_or_inplace"
>new_or_inplace</a></h2>

<pre>    $a = new_or_inplace(shift());
    $a = new_or_inplace(shift(),$preferred_type);</pre>

<p>Return back either the argument pdl or a copy of it depending on whether it be flagged in-place or no. Handy for building inplace-aware functions.</p>

<p>If you specify a preferred type (must be one of the usual PDL type strings, a list ref containing several of them, or a string containing several of them), then the copy is coerced into the first preferred type listed if it is not already one of the preferred types.</p>

<p>Note that if the inplace flag is set, no coersion happens even if you specify a preferred type.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="PDL::new_from_specification"
>PDL::new_from_specification</a></h2>

<p>Internal method: create piddle by specification</p>

<p>This is the argument processing method called by <a href="#zeroes" class="podlinkpod"
>zeroes</a> and some other functions which constructs piddles from argument lists of the form:</p>

<pre> [type], $nx, $ny, $nz,...</pre>

<p>For <code>$nx</code>, <code>$ny</code>, etc. 0 and 1D piddles are allowed. Giving those has the same effect as if saying <code>$arg-&#62;list</code>, e.g.</p>

<pre>   1, pdl(5,2), 4</pre>

<p>is equivalent to</p>

<pre>   1, 5, 2, 4</pre>

<p>Note, however, that in all functions using <code>new_from_specification</code> calling <code>func $piddle</code> will probably not do what you want. So to play safe use (e.g. with zeroes)</p>

<pre>  $pdl = zeroes $dimpdl-&#62;list;</pre>

<p>Calling</p>

<pre>  $pdl = zeroes $dimpdl;</pre>

<p>will rather be equivalent to</p>

<pre>  $pdl = zeroes $dimpdl-&#62;dims;</pre>

<p>However,</p>

<pre>  $pdl = zeroes ushort, $dimpdl;</pre>

<p>will again do what you intended since it is interpreted as if you had said</p>

<pre>  $pdl = zeroes ushort, $dimpdl-&#62;list;</pre>

<p>This is unfortunate and confusing but no good solution seems obvious that would not break existing scripts.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="isnull"
>isnull</a></h2>

<p>Test whether a piddle is null</p>

<pre> croak(&#34;Input piddle mustn&#39;t be null!&#34;)
     if $input_piddle-&#62;isnull;</pre>

<p>This function returns 1 if the piddle is null, zero if it is not. The purpose of null piddles is to &#34;tell&#34; any PDL::PP methods to allocate new memory for an output piddle, but only when that PDL::PP method is called in full-arg form. Of course, there&#39;s no reason you couldn&#39;t commandeer the special value for your own purposes, for which this test function would prove most helpful. But in general, you shouldn&#39;t need to test for a piddle&#39;s nullness.</p>

<p>See <a href="#Null_PDLs" class="podlinkpod"
>&#34;Null PDLs&#34;</a> for more information.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="isempty"
>isempty</a></h2>

<p>Test whether a piddle is empty</p>

<pre> print &#34;The piddle has zero dimension\n&#34; if $pdl-&#62;isempty;</pre>

<p>This function returns 1 if the piddle has zero elements. This is useful in particular when using the indexing function which. In the case of no match to a specified criterion, the returned piddle has zero dimension.</p>

<pre> pdl&#62; $a=sequence(10)
 pdl&#62; $i=which($a &#60; -1)
 pdl&#62; print &#34;I found no matches!\n&#34; if ($i-&#62;isempty);
 I found no matches!</pre>

<p>Note that having zero elements is rather different from the concept of being a null piddle, see the <a href="../PDL/FAQ.html" class="podlinkpod"
>PDL::FAQ</a> and <a href="../PDL/Indexing.html" class="podlinkpod"
>PDL::Indexing</a> manpages for discussions of this.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="zeroes"
>zeroes</a></h2>

<p>construct a zero filled piddle from dimension list or template piddle.</p>

<p>Various forms of usage,</p>

<p>(i) by specification or (ii) by template piddle:</p>

<pre> # usage type (i):
 $a = zeroes([type], $nx, $ny, $nz,...);
 $a = PDL-&#62;zeroes([type], $nx, $ny, $nz,...);
 $a = $pdl-&#62;zeroes([type], $nx, $ny, $nz,...);
 # usage type (ii):
 $a = zeroes $b;
 $a = $b-&#62;zeroes
 zeroes inplace $a;     # Equivalent to   $a .= 0;
 $a-&#62;inplace-&#62;zeroes;   #  &#34;&#34;</pre>

<pre> pdl&#62; $z = zeroes 4,3
 pdl&#62; p $z
 [
  [0 0 0 0]
  [0 0 0 0]
  [0 0 0 0]
 ]
 pdl&#62; $z = zeroes ushort, 3,2 # Create ushort array
 [ushort() etc. with no arg returns a PDL::Types token]</pre>

<p>See also <a href="#PDL%3A%3Anew_from_specification" class="podlinkpod"
>new_from_specification</a> for details on using piddles in the dimensions list.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="zeros"
>zeros</a></h2>

<p>construct a zero filled piddle (see zeroes for usage)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ones"
>ones</a></h2>

<p>construct a one filled piddle</p>

<pre> $a = ones([type], $nx, $ny, $nz,...);
 etc. (see &#39;zeroes&#39;)</pre>

<pre> see zeroes() and add one</pre>

<p>See also <a href="#PDL%3A%3Anew_from_specification" class="podlinkpod"
>new_from_specification</a> for details on using piddles in the dimensions list.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="reshape"
>reshape</a></h2>

<p>Change the shape (i.e. dimensions) of a piddle, preserving contents.</p>

<pre> $x-&#62;reshape(NEWDIMS); reshape($x, NEWDIMS);</pre>

<p>The data elements are preserved, obviously they will wrap differently and get truncated if the new array is shorter. If the new array is longer it will be zero-padded.</p>

<p>***Potential incompatibility with earlier versions of PDL**** If the list of <code>NEWDIMS</code> is empty <code>reshape</code> will just drop all dimensions of size 1 (preserving the number of elements):</p>

<pre>  $a = sequence(3,4,5);
  $b = $a(1,3);
  $b-&#62;reshape();
  print $b-&#62;info;
 PDL: Double D [5]</pre>

<p>Dimensions of size 1 will also be dropped if <code>reshape</code> is invoked with the argument -1:</p>

<pre>  $b = $a-&#62;reshape(-1);</pre>

<p>As opposed to <code>reshape</code> without arguments, <code>reshape(-1)</code> preserves dataflow:</p>

<pre>  $a = ones(2,1,2);
  $b = $a(0)-&#62;reshape(-1);
  $b++;
  print $a;
 [
  [
   [2 1]
  ]
  [
   [2 1]
  ]
 ]</pre>

<p>Note: an explicit copy of slices is generally forced - this is the only way (for now) of stopping a crash if <code>$x</code> is a slice. Important: Physical piddles are changed inplace!</p>

<pre> pdl&#62; $x = sequence(10)
 pdl&#62; reshape $x,3,4; p $x
 [
  [0 1 2]
  [3 4 5]
  [6 7 8]
  [9 0 0]
 ]
 pdl&#62; reshape $x,5; p $x
 [0 1 2 3 4]</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="squeeze"
>squeeze</a></h2>

<p>eliminate all singleton dimensions (dims of size 1)</p>

<pre> $b = $a(0,0)-&#62;squeeze;</pre>

<p>Alias for <code>reshape(-1)</code>. Removes all singleton dimensions and preserves dataflow. A more concise interface is provided by <a href="../PDL/NiceSlice.html" class="podlinkpod"
>PDL::NiceSlice</a> via modifiers:</p>

<pre> use PDL::NiceSlice;
 $b = $a(0,0;-); # same as $a(0,0)-&#62;squeeze</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="flat"
>flat</a></h2>

<p>flatten a piddle (alias for <code>$pdl-&#62;clump(-1)</code>)</p>

<pre>  $srt = $pdl-&#62;flat-&#62;qsort;</pre>

<p>Useful method to make a 1D piddle from an arbitrarily sized input piddle. Data flows back and forth as usual with slicing routines. Falls through if argument already &#60;= 1D.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="convert"
>convert</a></h2>

<p>Generic datatype conversion function</p>

<pre> $y = convert($x, $newtypenum);</pre>

<pre> $y = convert $x, long
 $y = convert $x, ushort</pre>

<p><code>$newtype</code> is a type <b>number</b>, for convenience they are returned by <code>long()</code> etc when called without arguments.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Datatype_conversions"
>Datatype_conversions</a></h2>

<p>byte|short|ushort|long|longlong|float|double (shorthands to convert datatypes)</p>

<pre> $y = double $x; $y = ushort [1..10];
 # all of the above listed shorthands behave similarly</pre>

<p>When called with a piddle argument, they convert to the specific datatype.</p>

<p>When called with a numeric, list, listref, or string argument they construct a new piddle. This is a convenience to avoid having to be long-winded and say <code>$x = long(pdl(42))</code></p>

<p>Thus one can say:</p>

<pre> $a = float(1,2,3,4);           # 1D
 $a = float q[1 2 3; 4 5 6];    # 2D
 $a = float([1,2,3],[4,5,6]);   # 2D
 $a = float([[1,2,3],[4,5,6]]); # 2D</pre>

<p>Note the last three give identical results, and the last two are exactly equivalent - a list is automatically converted to a list reference for syntactic convenience. i.e. you can omit the outer <code>[]</code></p>

<p>When called with no arguments, these functions return a special type token. This allows syntactical sugar like:</p>

<pre> $x = ones byte, 1000,1000;</pre>

<p>This example creates a large piddle directly as byte datatype in order to save memory.</p>

<p>In order to control how undefs are handled in converting from perl lists to PDLs, one can set the variable <code>$PDL::undefval</code>; see the function <a href="#pdl" class="podlinkpod"
>pdl()</a> for more details.</p>

<pre> pdl&#62; p $x=sqrt float [1..10]
 [1 1.41421 1.73205 2 2.23607 2.44949 2.64575 2.82843 3 3.16228]
 pdl&#62; p byte $x
 [1 1 1 2 2 2 2 2 3 3]</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="byte"
>byte</a></h2>

<p>Convert to byte datatype - see &#39;Datatype_conversions&#39;</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="short"
>short</a></h2>

<p>Convert to short datatype - see &#39;Datatype_conversions&#39;</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ushort"
>ushort</a></h2>

<p>Convert to ushort datatype - see &#39;Datatype_conversions&#39;</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="long"
>long</a></h2>

<p>Convert to long datatype - see &#39;Datatype_conversions&#39;</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="longlong"
>longlong</a></h2>

<p>Convert to longlong datatype - see &#39;Datatype_conversions&#39;</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="float"
>float</a></h2>

<p>Convert to float datatype - see &#39;Datatype_conversions&#39;</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="double"
>double</a></h2>

<p>Convert to double datatype - see &#39;Datatype_conversions&#39;</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="type"
>type</a></h2>

<p>return the type of a piddle as a blessed type object</p>

<p>A convenience function for use with the piddle constructors, e.g.</p>

<pre> $b = PDL-&#62;zeroes($a-&#62;type,$a-&#62;dims,3);
 die &#34;must be float&#34; unless $a-&#62;type == float;</pre>

<p>See also the discussion of the <code>PDL::Type</code> class in <a href="../PDL/Types.html" class="podlinkpod"
>PDL::Types</a>. Note that the <code>PDL::Type</code> objects have overloaded comparison and stringify operators so that you can compare and print types:</p>

<pre> $a = $a-&#62;float if $a-&#62;type &#60; float;
 $t = $a-&#62;type; print &#34;Type is $t\&#34;;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="list"
>list</a></h2>

<p>Convert piddle to perl list</p>

<pre> @tmp = list $x;</pre>

<p>Obviously this is grossly inefficient for the large datasets PDL is designed to handle. This was provided as a get out while PDL matured. It should now be mostly superseded by superior constructs, such as PP/threading. However it is still occasionally useful and is provied for backwards compatibility.</p>

<pre> for (list $x) {
   # Do something on each value...
 }</pre>

<p>list converts any bad values into the string &#39;BAD&#39;.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="unpdl"
>unpdl</a></h2>

<p>Convert piddle to nested Perl array references</p>

<pre> $arrayref = unpdl $x;</pre>

<p>This function returns a reference to a Perl list-of-lists structure equivalent to the input piddle (within the limitation that while values of elements should be preserved, the detailed datatypes will not as perl itself basically has &#34;number&#34; data rather than byte, short, int... E.g., <code>sum($x - pdl( $x-&#62;unpdl ))</code> should equal 0.</p>

<p>Obviously this is grossly inefficient in memory and processing for the large datasets PDL is designed to handle. Sometimes, however, you really want to move your data back to Perl, and with proper dimensionality, unlike <code>list</code>.</p>

<pre> use JSON;
 my $json = encode_json unpdl $pdl;</pre>

<p>unpdl converts any bad values into the string &#39;BAD&#39;.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="listindices"
>listindices</a></h2>

<p>Convert piddle indices to perl list</p>

<pre> @tmp = listindices $x;</pre>

<p><code>@tmp</code> now contains the values <code>0..nelem($x)</code>.</p>

<p>Obviously this is grossly inefficient for the large datasets PDL is designed to handle. This was provided as a get out while PDL matured. It should now be mostly superseded by superior constructs, such as PP/threading. However it is still occasionally useful and is provied for backwards compatibility.</p>

<pre> for $i (listindices $x) {
   # Do something on each value...
 }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="set"
>set</a></h2>

<p>Set a single value inside a piddle</p>

<pre> set $piddle, @position, $value</pre>

<p><code>@position</code> is a coordinate list, of size equal to the number of dimensions in the piddle. Occasionally useful, mainly provided for backwards compatibility as superseded by use of <a href="../PDL/Slices.html#slice" class="podlinkpod"
>slice</a> and assigment operator <code>.=</code>.</p>

<pre> pdl&#62; $x = sequence 3,4
 pdl&#62; set $x, 2,1,99
 pdl&#62; p $x
 [
  [ 0  1  2]
  [ 3  4 99]
  [ 6  7  8]
  [ 9 10 11]
 ]</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="at"
>at</a></h2>

<p>Returns a single value inside a piddle as perl scalar.</p>

<pre> $z = at($piddle, @position); $z=$piddle-&#62;at(@position);</pre>

<p><code>@position</code> is a coordinate list, of size equal to the number of dimensions in the piddle. Occasionally useful in a general context, quite useful too inside PDL internals.</p>

<pre> pdl&#62; $x = sequence 3,4
 pdl&#62; p $x-&#62;at(1,2)
 7</pre>

<p>at converts any bad values into the string &#39;BAD&#39;.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="sclr"
>sclr</a></h2>

<p>return a single value from a piddle as a scalar</p>

<pre>  $val = $a(10)-&#62;sclr;
  $val = sclr inner($a,$b);</pre>

<p>The <code>sclr</code> method is useful to turn a piddle into a normal Perl scalar. Its main advantage over using <code>at</code> for this purpose is the fact that you do not need to worry if the piddle is 0D, 1D or higher dimensional. Using <code>at</code> you have to supply the correct number of zeroes, e.g.</p>

<pre>  $a = sequence(10);
  $b = $a-&#62;slice(&#39;4&#39;);
  print $b-&#62;sclr; # no problem
  print $b-&#62;at(); # error: needs at least one zero</pre>

<p><code>sclr</code> is generally used when a Perl scalar is required instead of a one-element piddle. If the input is a multielement piddle the first value is returned as a Perl scalar. You can optionally switch on checks to ensure that the input piddle has only one element:</p>

<pre>  PDL-&#62;sclr({Check =&#62; &#39;warn&#39;}); # carp if called with multi-el pdls
  PDL-&#62;sclr({Check =&#62; &#39;barf&#39;}); # croak if called with multi-el pdls</pre>

<p>are the commands to switch on warnings or raise an error if a multielement piddle is passed as input. Note that these options can only be set when <code>sclr</code> is called as a class method (see example above). Use</p>

<pre>  PDL-&#62;sclr({Check=&#62;0});</pre>

<p>to switch these checks off again (default setting); When called as a class method the resulting check mode is returned (0: no checking, 1: warn, 2: barf).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="cat"
>cat</a></h2>

<p>concatenate piddles to N+1 dimensional piddle</p>

<p>Takes a list of N piddles of same shape as argument, returns a single piddle of dimension N+1</p>

<pre> pdl&#62; $x = cat ones(3,3),zeroes(3,3),rvals(3,3); p $x
 [
  [
   [1 1 1]
   [1 1 1]
   [1 1 1]
  ]
  [
   [0 0 0]
   [0 0 0]
   [0 0 0]
  ]
  [
   [1 1 1]
   [1 0 1]
   [1 1 1]
  ]
 ]</pre>

<p>The output piddle is set bad if any input piddles have their bad flag set.</p>

<p>Similar functions include <a href="../PDL/Primitive.html#append" class="podlinkpod"
>append</a> and <a href="../PDL/Primitive.html#glue" class="podlinkpod"
>glue</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="dog"
>dog</a></h2>

<p>Opposite of &#39;cat&#39; :). Split N dim piddle to list of N-1 dim piddles</p>

<p>Takes a single N-dimensional piddle and splits it into a list of N-1 dimensional piddles. The breakup is done along the last dimension. Note the dataflown connection is still preserved by default, e.g.:</p>

<pre> pdl&#62; $p = ones 3,3,3
 pdl&#62; ($a,$b,$c) = dog $p
 pdl&#62; $b++; p $p
 [
  [
   [1 1 1]
   [1 1 1]
   [1 1 1]
  ]
  [
   [2 2 2]
   [2 2 2]
   [2 2 2]
  ]
  [
   [1 1 1]
   [1 1 1]
   [1 1 1]
  ]
 ]</pre>

<pre> Break =&#62; 1   Break dataflow connection (new copy)</pre>

<p>The output piddles are set bad if the original piddle has its bad flag set.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="gethdr"
>gethdr</a></h2>

<p>Retrieve header information from a piddle</p>

<pre> $pdl=rfits(&#39;file.fits&#39;);
 $h=$pdl-&#62;gethdr;
 print &#34;Number of pixels in the X-direction=$$h{NAXIS1}\n&#34;;</pre>

<p>The <code>gethdr</code> function retrieves whatever header information is contained within a piddle. The header can be set with <a href="#sethdr" class="podlinkpod"
>sethdr</a> and is always a hash reference or undef.</p>

<p><code>gethdr</code> returns undef if the piddle has not yet had a header defined; compare with <code>hdr</code> and <code>fhdr</code>, which are guaranteed to return a defined value.</p>

<p>Note that gethdr() works by <b>reference</b>: you can modify the header in-place once it has been retrieved:</p>

<pre>  $a  = rfits($filename);
  $ah = $a-&#62;gethdr();
  $ah-&#62;{FILENAME} = $filename;</pre>

<p>It is also important to realise that in most cases the header is not automatically copied when you copy the piddle. See <a href="#hdrcpy" class="podlinkpod"
>hdrcpy</a> to enable automatic header copying.</p>

<p>Here&#39;s another example: a wrapper around rcols that allows your piddle to remember the file it was read from and the columns could be easily written (here assuming that no regexp is needed, extensions are left as an exercise for the reader)</p>

<pre> sub ext_rcols {
    my ($file, @columns)=@_;
    my $header={};
    $$header{File}=$file;
    $$header{Columns}=\@columns;

    @piddles=rcols $file, @columns;
    foreach (@piddles) { $_-&#62;sethdr($header); }
    return @piddles;
 }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="hdr"
>hdr</a></h2>

<p>Retrieve or set header information from a piddle</p>

<pre> $pdl-&#62;hdr-&#62;{CDELT1} = 1;</pre>

<p>The <code>hdr</code> function allows convenient access to the header of a piddle. Unlike <code>gethdr</code> it is guaranteed to return a defined value, so you can use it in a hash dereference as in the example. If the header does not yet exist, it gets autogenerated as an empty hash.</p>

<p>Note that this is usually -- but not always -- What You Want. If you want to use a tied <a href="../Astro/FITS/Header.html" class="podlinkpod"
>Astro::FITS::Header</a> hash, for example, you should either construct it yourself and use <code>sethdr</code> to put it into the piddle, or use <a href="../fhdr.html" class="podlinkpod"
>fhdr</a> instead. (Note that you should be able to write out the FITS file successfully regardless of whether your PDL has a tied FITS header object or a vanilla hash).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="fhdr"
>fhdr</a></h2>

<p>Retrieve or set FITS header information from a piddle</p>

<pre> $pdl-&#62;fhdr-&#62;{CDELT1} = 1;</pre>

<p>The <code>fhdr</code> function allows convenient access to the header of a piddle. Unlike <code>gethdr</code> it is guaranteed to return a defined value, so you can use it in a hash dereference as in the example. If the header does not yet exist, it gets autogenerated as a tied <a href="../Astro/FITS/Header.html" class="podlinkpod"
>Astro::FITS::Header</a> hash.</p>

<p>Astro::FITS::Header tied hashes are better at matching the behavior of FITS headers than are regular hashes. In particular, the hash keys are CAsE INsEnSItiVE, unlike normal hash keys. See <a href="../Astro/FITS/Header.html" class="podlinkpod"
>Astro::FITS::Header</a> for details.</p>

<p>If you do not have Astro::FITS::Header installed, you get back a normal hash instead of a tied object.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="sethdr"
>sethdr</a></h2>

<p>Set header information of a piddle</p>

<pre> $pdl = zeroes(100,100);
 $h = {NAXIS=&#62;2, NAXIS1=&#62;100, NAXIS=&#62;100, COMMENT=&#62;&#34;Sample FITS-style header&#34;};
 # add a FILENAME field to the header
 $$h{FILENAME} = &#39;file.fits&#39;;
 $pdl-&#62;sethdr( $h );</pre>

<p>The <code>sethdr</code> function sets the header information for a piddle. You must feed in a hash ref or undef, and the header field of the PDL is set to be a new ref to the same hash (or undefined).</p>

<p>The hash ref requirement is a speed bump put in place since the normal use of headers is to store fits header information and the like. Of course, if you want you can hang whatever ugly old data structure you want off of the header, but that makes life more complex.</p>

<p>Remember that the hash is not copied -- the header is made into a ref that points to the same underlying data. To get a real copy without making any assumptions about the underlying data structure, you can use one of the following:</p>

<pre>  use PDL::IO::Dumper;
  $pdl-&#62;sethdr( deep_copy($h) );</pre>

<p>(which is slow but general), or</p>

<pre>  $pdl-&#62;sethdr( PDL::_hdr_copy($h) )</pre>

<p>(which uses the built-in sleazy deep copier), or (if you know that all the elements happen to be scalars):</p>

<pre>  { my %a = %$h;
    $pdl-&#62;sethdr(\%a);
  }</pre>

<p>which is considerably faster but just copies the top level.</p>

<p>The <code>sethdr</code> function must be given a hash reference or undef. For further information on the header, see <a href="#gethdr" class="podlinkpod"
>gethdr</a>, <a href="#hdr" class="podlinkpod"
>hdr</a>, <a href="#fhdr" class="podlinkpod"
>fhdr</a> and <a href="#hdrcpy" class="podlinkpod"
>hdrcpy</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="hdrcpy"
>hdrcpy</a></h2>

<p>switch on/off/examine automatic header copying</p>

<pre> print &#34;hdrs will be copied&#34; if $a-&#62;hdrcpy;
 $a-&#62;hdrcpy(1);       # switch on automatic header copying
 $b = $a-&#62;sumover;    # and $b will inherit $a&#39;s hdr
 $a-&#62;hdrcpy(0);       # and now make $a non-infectious again</pre>

<p><code>hdrcpy</code> without an argument just returns the current setting of the flag. See also &#34;hcpy&#34; which returns its PDL argument (and so is useful in method-call pipelines).</p>

<p>Normally, the optional header of a piddle is not copied automatically in pdl operations. Switching on the hdrcpy flag using the <code>hdrcpy</code> method will enable automatic hdr copying. Note that an actual deep copy gets made, which is rather processor-inefficient -- so avoid using header copying in tight loops!</p>

<p>Most PDLs have the <code>hdrcpy</code> flag cleared by default; however, some routines (notably <a href="../PDL/IO/FITS.html#rfits()" class="podlinkpod"
>rfits</a>) set it by default where that makes more sense.</p>

<p>The <code>hdrcpy</code> flag is viral: if you set it for a PDL, then derived PDLs will get copies of the header and will also have their <code>hdrcpy</code> flags set. For example:</p>

<pre>  $a = xvals(50,50);
  $a-&#62;hdrcpy(1);
  $a-&#62;hdr-&#62;{FOO} = &#34;bar&#34;;
  $b = $a++;
  $c = $b++;
  print $b-&#62;hdr-&#62;{FOO}, &#34; - &#34;, $c-&#62;hdr-&#62;{FOO}, &#34;\n&#34;;
  $b-&#62;hdr-&#62;{FOO} = &#34;baz&#34;;
  print $a-&#62;hdr-&#62;{FOO}, &#34; - &#34;, $b-&#62;hdr-&#62;{FOO}, &#34; - &#34;, $c-&#62;hdr-&#62;{FOO}, &#34;\n&#34;;</pre>

<p>will print:</p>

<pre>  bar - bar
  bar - baz - bar</pre>

<p>Performing an operation in which more than one PDL has its hdrcpy flag causes the resulting PDL to take the header of the first PDL:</p>

<pre>  ($a,$b) = sequence(5,2)-&#62;dog;
  $a-&#62;hdrcpy(1); $b-&#62;hdrcpy(1);
  $a-&#62;hdr-&#62;{foo} = &#39;a&#39;;
  $b-&#62;hdr-&#62;{foo} = &#39;b&#39;;
  print (($a+$b)-&#62;hdr-&#62;{foo} , ($b+$a)-&#62;hdr-&#62;{foo});</pre>

<p>will print:</p>

<pre>  a b</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="hcpy"
>hcpy</a></h2>

<p>Switch on/off automatic header copying, with PDL pass-through</p>

<pre>  $a = rfits(&#39;foo.fits&#39;)-&#62;hcpy(0);
  $a = rfits(&#39;foo.fits&#39;)-&#62;hcpy(1);</pre>

<p><code>hcpy</code> sets or clears the hdrcpy flag of a PDL, and returns the PDL itself. That makes it convenient for inline use in expressions.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="set_autopthread_targ"
>set_autopthread_targ</a></h2>

<p>Set the target number of processor threads (pthreads) for multi-threaded processing.</p>

<pre> set_autopthread_targ($num_pthreads);</pre>

<p><code>$num_pthreads</code> is the target number of pthreads the auto-pthread process will try to achieve.</p>

<p>See <a href="../PDL/ParallelCPU.html" class="podlinkpod"
>PDL::ParallelCPU</a> for an overview of the auto-pthread process.</p>

<pre>  # Example turning on auto-pthreading for a target of 2 pthreads and for functions involving
  #   PDLs with greater than 1M elements
  set_autopthread_targ(2);
  set_autopthread_size(1);

  # Execute a pdl function, processing will split into two pthreads as long as
  #  one of the pdl-threaded dimensions is divisible by 2.
  $a = minimum($b);

  # Get the actual number of pthreads that were run.
  $actual_pthread = get_autopthread_actual();</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_autopthread_targ"
>get_autopthread_targ</a></h2>

<p>Get the current target number of processor threads (pthreads) for multi-threaded processing.</p>

<pre> $num_pthreads = get_autopthread_targ();</pre>

<p><code>$num_pthreads</code> is the target number of pthreads the auto-pthread process will try to achieve.</p>

<p>See <a href="../PDL/ParallelCPU.html" class="podlinkpod"
>PDL::ParallelCPU</a> for an overview of the auto-pthread process.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_autopthread_actual"
>get_autopthread_actual</a></h2>

<p>Get the actual number of pthreads executed for the last pdl processing function.</p>

<pre> $autopthread_actual = get_autopthread_actual();</pre>

<p><code>$autopthread_actual</code> is the actual number of pthreads executed for the last pdl processing function.</p>

<p>See <a href="../PDL/ParallelCPU.html" class="podlinkpod"
>PDL::ParallelCPU</a> for an overview of the auto-pthread process.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="set_autopthread_size"
>set_autopthread_size</a></h2>

<p>Set the minimum size (in M-elements or 2^20 elements) of the largest PDL involved in a function where auto-pthreading will be performed. For small PDLs, it probably isn&#39;t worth starting multiple pthreads, so this function is used to define a minimum threshold where auto-pthreading won&#39;t be attempted.</p>

<pre> set_autopthread_size($size);</pre>

<p><code>$size</code> is the mimumum size, in M-elements or 2^20 elements (approx 1e6 elements) for the largest PDL involved in a function.</p>

<p>See <a href="../PDL/ParallelCPU.html" class="podlinkpod"
>PDL::ParallelCPU</a> for an overview of the auto-pthread process.</p>

<pre>  # Example turning on auto-pthreading for a target of 2 pthreads and for functions involving
  #   PDLs with greater than 1M elements
  set_autopthread_targ(2);
  set_autopthread_size(1);

  # Execute a pdl function, processing will split into two pthreads as long as
  #  one of the pdl-threaded dimensions is divisible by 2.
  $a = minimum($b);

  # Get the actual number of pthreads that were run.
  $actual_pthread = get_autopthread_actual();</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_autopthread_size"
>get_autopthread_size</a></h2>

<p>Get the current autopthread_size setting.</p>

<pre> $autopthread_size = get_autopthread_size();</pre>

<p><code>$autopthread_size</code> is the mimumum size limit for auto_pthreading to occur, in M-elements or 2^20 elements (approx 1e6 elements) for the largest PDL involved in a function</p>

<p>See <a href="../PDL/ParallelCPU.html" class="podlinkpod"
>PDL::ParallelCPU</a> for an overview of the auto-pthread process.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Copyright (C) Karl Glazebrook (kgb@aaoepp.aao.gov.au), Tuomas J. Lukka, (lukka@husc.harvard.edu) and Christian Soeller (c.soeller@auckland.ac.nz) 1997. Modified, Craig DeForest (deforest@boulder.swri.edu) 2002. All rights reserved. There is no warranty. You are allowed to redistribute this software / documentation under certain conditions. For details, see the file COPYING in the PDL distribution. If this file is separated from the PDL distribution, the copyright notice should be included in the file.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
