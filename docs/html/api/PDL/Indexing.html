<html><head><title>PDL::Indexing</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:24 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#OVERVIEW'>OVERVIEW</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Dimension_lists'>Dimension lists</a>
    <li class='indexItem indexItem2'><a href='#Indexing_and_Dataflow'>Indexing and Dataflow</a>
    <li class='indexItem indexItem2'><a href='#Threading_and_Dimension_Order'>Threading and Dimension Order</a>
    <li class='indexItem indexItem2'><a href='#Physical_and_Dummy_Dimensions'>Physical and Dummy Dimensions</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Indexing_and_threading_with_PDL'>Indexing and threading with PDL</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#pdls_can_have_children'>pdls can have children</a>
    <li class='indexItem indexItem2'><a href='#Slicing_pdls'>Slicing pdls</a>
    <li class='indexItem indexItem2'><a href='#There_are_different_kinds_of_assignments_in_PDL'>There are different kinds of assignments in PDL</a>
    <li class='indexItem indexItem2'><a href='#Other_functions_that_manipulate_dimensions'>Other functions that manipulate dimensions</a>
    <li class='indexItem indexItem2'><a href='#Calls_to_indexing_functions_can_be_chained'>Calls to indexing functions can be chained</a>
    <li class='indexItem indexItem2'><a href='#Propagated_assignments_(%27.%3D%27)_and_dummy_dimensions'>Propagated assignments (&#39;.=&#39;) and dummy dimensions</a>
    <li class='indexItem indexItem2'><a href='#Reasons_for_the_parent%2Fchild_(or_%22pointer%22)_concept'>Reasons for the parent/child (or &#34;pointer&#34;) concept</a>
    <li class='indexItem indexItem2'><a href='#How_to_make_things_physical_again'>How to make things physical again</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Threading'>Threading</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Implicit_threading_-_a_first_example'>Implicit threading - a first example</a>
    <li class='indexItem indexItem2'><a href='#How_does_the_example_work_%3F'>How does the example work ?</a>
    <li class='indexItem indexItem2'><a href='#A_call_for_coding_discipline'>A call for coding discipline</a>
    <li class='indexItem indexItem2'><a href='#How_to_figure_out_the_loop_dimensions'>How to figure out the loop dimensions</a>
    <li class='indexItem indexItem2'><a href='#Output_auto-creation_and_PP-function_calling_conventions'>Output auto-creation and PP-function calling conventions</a>
    <li class='indexItem indexItem2'><a href='#Explicit_threading'>Explicit threading</a>
    <li class='indexItem indexItem2'><a href='#Implicit_versus_explicit_threading'>Implicit versus explicit threading</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#PDL%3A%3APP'>PDL::PP</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#An_easy_way_to_define_functions_that_are_aware_of_indexing_and_threading_(and_the_universe_and_everything)'>An easy way to define functions that are aware of indexing and threading (and the universe and everything)</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Appendix_A'>Appendix A</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Affine_transformations_-_a_special_class_of_simple_and_powerful_transformations'>Affine transformations - a special class of simple and powerful transformations</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Appendix_B'>Appendix B</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#signatures_of_standard_PDL%3A%3APP_compiled_functions'>signatures of standard PDL::PP compiled functions</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#AUTHOR_%26_COPYRIGHT'>AUTHOR &#38; COPYRIGHT</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>PDL::Indexing - Introduction to indexing and slicing piddles.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="OVERVIEW"
>OVERVIEW</a></h1>

<p>This man page should serve as a first tutorial on the indexing and threading features of <i>PDL</i>.</p>

<p>Like all vectorized languages,
PDL automates looping over arrays using a variant of mathematical vector notation.
The automatic looping is called &#34;threading&#34;,
in part because ultimately PDL will implement parallel processing to speed up the loops.</p>

<p>A lot of the flexibility and power of PDL relies on the indexing and threading features of the Perl extension.
Indexing allows access to the data of a piddle in a very flexible way.
Threading provides efficient vectorization of simple operations.</p>

<p>The values of a piddle are stored compactly as typed values in a single block of memory,
not (as in a normal Perl list-of-lists) as individual Perl scalars.</p>

<p>In the sections that follow many &#34;methods&#34; are called out -- these are Perl operators that apply to PDLs.
From the <a href="../perldl.html" class="podlinkpod"
>perldl</a> (or <a href="../PDL/Perldl2.html" class="podlinkpod"
>pdl2</a>) shell,
you can find out more about each method by typing &#34;?&#34; followed by the method name.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Dimension_lists"
>Dimension lists</a></h2>

<p>A piddle (PDL variable),
in general,
is an N-dimensional array where N can be 0 (for a scalar),
1 (e.g.
for a sound sample),
or higher values for images and more complex structures.
Each dimension of the piddle has a positive integer size.
The <code>perl</code> interpreter treats each piddle as a special type of Perl scalar (a blessed Perl object,
actually -- but you don&#39;t have to know that to use them) that can be used anywhere you can put a normal scalar.</p>

<p>You can access the dimensions of a piddle as a Perl list and otherwise determine the size of a piddle with several methods.
The important ones are:</p>

<dl>
<dt><a name="nelem_-_the_total_number_of_elements_in_a_PDL"
>nelem - the total number of elements in a PDL</a></dt>

<dd>
<dt><a name="ndims_-_returns_the_number_of_dimensions_in_a_PDL"
>ndims - returns the number of dimensions in a PDL</a></dt>

<dd>
<dt><a name="dims_-_returns_the_dimension_list_of_a_PDL_as_a_Perl_list"
>dims - returns the dimension list of a PDL as a Perl list</a></dt>

<dd>
<dt><a name="dim_-_returns_the_size_of_a_particular_dimension_of_a_PDL"
>dim - returns the size of a particular dimension of a PDL</a></dt>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Indexing_and_Dataflow"
>Indexing and Dataflow</a></h2>

<p>PDL maintains a notion of &#34;dataflow&#34; between a piddle and indexed subfields of that piddle.
When you produce an indexed subfield or single element of a parent piddle,
the child and parent remain attached until you manually disconnect them.
This lets you represent the same data different ways within your code -- for example,
you can consider an RGB image simultaneously as a collection of (R,G,B) values in a 3 x 1000 x 1000 image,
and as three separate 1000 x 1000 color planes stored in different variables.
Modifying any of the variables changes the underlying memory,
and the changes are reflected in all representations of the data.</p>

<p>There are two important methods that let you control dataflow connections between a child and parent PDL:</p>

<dl>
<dt><a name="copy_-_forces_an_explicit_copy_of_a_PDL"
>copy - forces an explicit copy of a PDL</a></dt>

<dd>
<dt><a name="sever_-_breaks_the_dataflow_connection_between_a_PDL_and_its_parents_(if_any)"
>sever - breaks the dataflow connection between a PDL and its parents (if any)</a></dt>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Threading_and_Dimension_Order"
>Threading and Dimension Order</a></h2>

<p>Most PDL operations act on the first few dimensions of their piddle arguments.
For example,
<code>sumover</code> sums all elements along the first dimension in the list (dimension 0).
If you feed in a three-dimensional piddle,
then the first dimension is considered the &#34;active&#34; dimension and the later dimensions are &#34;thread&#34; dimensions because they are simply looped over.
There are several ways to transpose or re-order the dimension list of a PDL.
Those techniques are very fast since they don&#39;t touch the underlying data,
only change the way that PDL accesses the data.
The main dimension ordering functions are:</p>

<dl>
<dt><a name="mv_-_moves_a_particular_dimension_somewhere_else_in_the_dimension_list"
>mv - moves a particular dimension somewhere else in the dimension list</a></dt>

<dd>
<dt><a name="xchg_-_exchanges_two_dimensions_in_the_dimension_list,_leaving_the_rest_alone"
>xchg - exchanges two dimensions in the dimension list,
leaving the rest alone</a></dt>

<dd>
<dt><a name="reorder_-_allows_wholesale_mixing_of_the_dimensions"
>reorder - allows wholesale mixing of the dimensions</a></dt>

<dd>
<dt><a name="clump_-_clumps_together_two_or_more_small_dimensions_into_one_larger_one"
>clump - clumps together two or more small dimensions into one larger one</a></dt>

<dd>
<dt><a name="squeeze_-_eliminates_any_dimensions_of_size_1"
>squeeze - eliminates any dimensions of size 1</a></dt>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Physical_and_Dummy_Dimensions"
>Physical and Dummy Dimensions</a></h2>

<ul>
<li>document Perl level threading</li>

<li>threadids</li>

<li>update and correct description of slice</li>

<li>new functions in slice.pd (affine,
lag,
splitdim)</li>

<li>reworking of paragraph on explicit threading</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Indexing_and_threading_with_PDL"
>Indexing and threading with PDL</a></h1>

<p>A lot of the flexibility and power of PDL relies on the indexing and looping features of the Perl extension.
Indexing allows access to the data of a pdl object in a very flexible way.
Threading provides efficient implicit looping functionality (since the loops are implemented as optimized C code).</p>

<p>Pdl objects (later often called &#34;pdls&#34;) are Perl objects that represent multidimensional arrays and operations on those.
In contrast to simple Perl <code>@x</code> style lists the array data is compactly stored in a single block of memory thus taking up a lot less memory and enabling use of fast C code to implement operations (e.g.
addition,
etc) on pdls.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="pdls_can_have_children"
>pdls can have children</a></h2>

<p>Central to many of the indexing capabilities of PDL are the relation of &#34;parent&#34; and &#34;child&#34; between pdls.
Many of the indexing commands create a new pdl from an existing pdl.
The new pdl is the &#34;child&#34; and the old one is the &#34;parent&#34;.
The data of the new pdl is defined by a transformation that specifies how to generate (compute) its data from the parent&#39;s data.
The relation between the child pdl and its parent are often bidirectional,
meaning that changes in the child&#39;s data are propagated back to the parent.
(Note: You see,
we are aiming in our terminology already towards the new dataflow features.
The kind of dataflow that is used by the indexing commands (about which you will learn in a minute) is always in operation,
not only when you have explicitly switched on dataflow in your pdl by saying <code>$a-&#62;doflow</code>.
For further information about data flow check the dataflow man page.)</p>

<p>Another way to interpret the pdls created by our indexing commands is to view them as a kind of intelligent pointer that points back to some portion or all of its parent&#39;s data.
Therefore,
it is not surprising that the parent&#39;s data (or a portion of it) changes when manipulated through this &#34;pointer&#34;.
After these introductory remarks that hopefully prepared you for what is coming (rather than confuse you too much) we are going to dive right in and start with a description of the indexing commands and some typical examples how they might be used in PDL programs.
We will further illustrate the pointer/dataflow analogies in the context of some of the examples later on.</p>

<p>There are two different implementations of this ``smart pointer&#39;&#39; relationship: the first one,
which is a little slower but works for any transformation is simply to do the transformation forwards and backwards as necessary.
The other is to consider the child piddle a ``virtual&#39;&#39; piddle,
which only stores a pointer to the parent and access information so that routines which use the child piddle actually directly access the data in the parent.
If the virtual piddle is given to a routine which cannot use it,
PDL transparently physicalizes the virtual piddle before letting the routine use it.</p>

<p>Currently (1.94_01) all transformations which are ``affine&#39;&#39;,
i.e.
the indices of the data item in the parent piddle are determined by a linear transformation (+ constant) from the indices of the child piddle result in virtual piddles.
All other indexing routines (e.g.
<code>-&#62;index(...)</code>) result in physical piddles.
All routines compiled by PP can accept affine piddles (except those routines that pass pointers to external library functions).</p>

<p>Note that whether something is affine or not does not affect the semantics of what you do in any way: both</p>

<pre> $a-&#62;index(...) .= 5;
 $a-&#62;slice(...) .= 5;</pre>

<p>change the data in <code>$a</code>. The affinity does, however, have a significant impact on memory usage and performance.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Slicing_pdls"
>Slicing pdls</a></h2>

<p>Probably the most important application of the concept of parent/child pdls is the representation of rectangular slices of a physical pdl by a virtual pdl. Having talked long enough about concepts let&#39;s get more specific. Suppose we are working with a 2D pdl representing a 5x5 image (its unusually small so that we can print it without filling several screens full of digits ;).</p>

<pre> pdl&#62; $im = sequence(5,5)
 pdl&#62; p $im

 [
  [ 0  1  2  3  4]
  [ 5  6  7  8  9]
  [10 11 12 13 14]
  [15 16 17 18 19]
  [20 21 22 23 24]
 ]                                                                                

 pdl&#62; help vars
 PDL variables in package main::

 Name         Type   Dimension       Flow  State          Mem
 ----------------------------------------------------------------
 $im          Double D [5,5]                P            0.20Kb                  </pre>

<p>[ here it might be appropriate to quickly talk about the <code>help vars</code> command that provides information about pdls in the interactive <code>perldl</code> or <code>pdl2</code> shell that comes with PDL. ]</p>

<p>Now suppose we want to create a 1-D pdl that just references one line of the image, say line 2; or a pdl that represents all even lines of the image (imagine we have to deal with even and odd frames of an interlaced image due to some peculiar behaviour of our frame grabber). As another frequent application of slices we might want to create a pdl that represents a rectangular region of the image with top and bottom reversed. All these effects (and many more) can be easily achieved with the powerful slice function:</p>

<pre> pdl&#62; $line = $im-&#62;slice(&#39;:,(2)&#39;)
 pdl&#62; $even = $im-&#62;slice(&#39;:,1:-1:2&#39;)
 pdl&#62; $area = $im-&#62;slice(&#39;3:4,3:1&#39;)
 pdl&#62; help vars  # or just PDL-&#62;vars
 PDL variables in package main::

 Name         Type   Dimension       Flow  State          Mem
 ----------------------------------------------------------------
 $even        Double D [5,2]                -C           0.00Kb
 $im          Double D [5,5]                P            0.20Kb
 $line        Double D [5]                  -C           0.00Kb
 $area        Double D [2,3]                -C           0.00Kb                  </pre>

<p>All three &#34;child&#34; pdls are children of <code>$im</code> or in the other (largely equivalent) interpretation pointers to data of <code>$im</code>. Operations on those virtual pdls access only those portions of the data as specified by the argument to slice. So we can just print line 2:</p>

<pre> pdl&#62; p $line
 [10 11 12 13 14]</pre>

<p>Also note the difference in the &#34;Flow State&#34; of <code>$area</code> above and below:</p>

<pre> pdl&#62; p $area
 pdl&#62; help $area
 This variable is Double D [2,3]                VC           0.00Kb              </pre>

<p>The following demonstrates that <code>$im</code> and <code>$line</code> really behave as you would expect from a pointer-like object (or in the dataflow picture: the changes in <code>$line</code>&#39;s data are propagated back to <code>$im</code>):</p>

<pre> pdl&#62; $im++
 pdl&#62; p $line
 [11 12 13 14 15]
 pdl&#62; $line += 2
 pdl&#62; p $im

 [
  [ 1  2  3  4  5]
  [ 6  7  8  9 10]
  [13 14 15 16 17]
  [16 17 18 19 20]
  [21 22 23 24 25]
 ]</pre>

<p>Note how assignment operations on the child virtual pdls change the parent physical pdl and vice versa (however, the basic &#34;=&#34; assignment doesn&#39;t, use &#34;.=&#34; to obtain that effect. See below for the reasons). The virtual child pdls are something like &#34;live links&#34; to the &#34;original&#34; parent pdl. As previously said, they can be thought of to work similar to a C-pointer. But in contrast to a C-pointer they carry a lot more information. Firstly, they specify the structure of the data they represent (the dimensionality of the new pdl) and secondly, specify how to create this structure from its parents data (the way this works is buried in the internals of PDL and not important for you to know anyway (unless you want to hack the core in the future or would like to become a PDL guru in general (for a definition of this strange creature see <a href="../PDL/Internals.html" class="podlinkpod"
>PDL::Internals</a>)).</p>

<p>The previous examples have demonstrated typical usage of the slice function. Since the slicing functionality is so important here is an explanation of the syntax for the string argument to slice:</p>

<pre> $vpdl = $a-&#62;slice(&#39;ind0,ind1...&#39;)</pre>

<p>where <code>ind0</code> specifies what to do with index No 0 of the pdl <code>$a</code>, etc. Each element of the comma separated list can have one of the following forms:</p>

<dl>
<dt><a name="&#39;:&#39;"
>&#39;:&#39;</a></dt>

<dd>
<p>Use the whole dimension</p>

<dt><a name="&#39;n&#39;"
>&#39;n&#39;</a></dt>

<dd>
<p>Use only index <code>n</code>. The dimension of this index in the resulting virtual pdl is 1. An example involving those first two index formats:</p>

<pre> pdl&#62; $column = $im-&#62;slice(&#39;2,:&#39;)
 pdl&#62; $row = $im-&#62;slice(&#39;:,0&#39;)
 pdl&#62; p $column

 [
  [ 3]
  [ 8]
  [15]
  [18]
  [23]
 ]                                                                               

 pdl&#62; p $row

 [
  [1 2 3 4 5]
 ]                                                                               

 pdl&#62; help $column
 This variable is Double D [1,5]                VC           0.00Kb

 pdl&#62; help $row
 This variable is Double D [5,1]                VC           0.00Kb              </pre>

<dt><a name="&#39;(n)&#39;"
>&#39;(n)&#39;</a></dt>

<dd>
<p>Use only index <code>n</code>. This dimension is removed from the resulting pdl (relying on the fact that a dimension of size 1 can always be removed). The distinction between this case and the previous one becomes important in assignments where left and right hand side have to have appropriate dimensions.</p>

<pre> pdl&#62; $line = $im-&#62;slice(&#39;:,(0)&#39;)
 pdl&#62; help $line
 This variable is Double D [5]                  -C           0.00Kb

 pdl&#62; p $line
 [1 2 3 4 5]          </pre>

<p>Spot the difference to the previous example?</p>

<dt><a name="&#39;n1:n2&#39;_or_&#39;n1:n2:n3&#39;"
>&#39;n1:n2&#39; or &#39;n1:n2:n3&#39;</a></dt>

<dd>
<p>Take the range of indices from <code>n1</code> to <code>n2</code> or (second form) take the range of indices from <code>n1</code> to <code>n2</code> with step <code>n3</code>. An example for the use of this format is the previous definition of the sub-image composed of even lines.</p>

<pre> pdl&#62; $even = $im-&#62;slice(&#39;:,1:-1:2&#39;)</pre>

<p>This example also demonstrates that negative indices work like they do for normal Perl style arrays by counting backwards from the end of the dimension. If <code>n2</code> is smaller than <code>n1</code> (in the example -1 is equivalent to index 4) the elements in the virtual pdl are effectively reverted with respect to its parent.</p>

<dt><a name="&#39;*[n]&#39;"
>&#39;*[n]&#39;</a></dt>

<dd>
<p>Add a dummy dimension. The size of this dimension will be 1 by default or equal to <code>n</code> if the optional numerical argument is given.</p>

<p>Now, this is really something a bit strange on first sight. What is a dummy dimension? A dummy dimension inserts a dimension where there wasn&#39;t one before. How is that done ? Well, in the case of the new dimension having size 1 it can be easily explained by the way in which you can identify a vector (with <code>m</code> elements) with an <code>(1,m)</code> or <code>(m,1)</code> matrix. The same holds obviously for higher dimensional objects. More interesting is the case of a dummy dimensions of size greater than one (e.g. <code>slice(&#39;*5,:&#39;)</code>). This works in the same way as a call to the <a href="../PDL/Core.html#dummy" class="podlinkpod"
>dummy</a> function creates a new dummy dimension. So read on and check its explanation below.</p>

<dt><a name="&#39;([n1:n2[:n3]]=i)&#39;"
>&#39;([n1:n2[:n3]]=i)&#39;</a></dt>

<dd>
<p>[Not yet implemented ??????] With an argument like this you make <i>generalised diagonals</i>. The <i>diagonal</i> will be dimension no. <code>i</code> of the new output pdl and (if optional part in brackets specified) will extend along the range of indices specified of the respective parent pdl&#39;s dimension. In general an argument like this only makes sense if there are other arguments like this in the same call to slice. The part in brackets is optional for this type of argument. All arguments of this type that specify the same target dimension <code>i</code> have to relate to the same number of indices in their parent dimension. The best way to explain it is probably to give an example, here we make a pdl that refers to the elements along the space diagonal of its parent pdl (a cube):</p>

<pre> $cube = zeroes(5,5,5);
 $sdiag = $cube-&#62;slice(&#39;(=0),(=0),(=0)&#39;);</pre>

<p>The above command creates a virtual pdl that represents the diagonal along the parents&#39; dimension no. 0, 1 and 2 and makes its dimension 0 (the only dimension) of it. You use the extended syntax if the dimension sizes of the parent dimensions you want to build the diagonal from have different sizes or you want to reverse the sequence of elements in the diagonal, e.g.</p>

<pre> $rect = zeroes(12,3,5,6,2);
 $vpdl = $rect-&#62;slice(&#39;2:7,(0:1=1),(4),(5:4=1),(=1)&#39;);</pre>

<p>So the elements of $vpdl will then be related to those of its parent in way we can express as:</p>

<pre>  vpdl(i,j) = rect(i+2,j,4,5-j,j)       0&#60;=i&#60;5, 0&#60;=j&#60;2</pre>
</dd>
</dl>

<p>[ work in the new index function: <code>$b = $a-&#62;index($c);</code> ???? ]</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="There_are_different_kinds_of_assignments_in_PDL"
>There are different kinds of assignments in PDL</a></h2>

<p>The previous examples have already shown that virtual pdls can be used to operate on or access portions of data of a parent pdl. They can also be used as lvalues in assignments (as the use of <code>++</code> in some of the examples above has already demonstrated). For explicit assignments to the data represented by a virtual pdl you have to use the overloaded <code>.=</code> operator (which in this context we call <i>propagated assignment</i>). Why can&#39;t you use the normal assignment operator <code>=</code>?</p>

<p>Well, you definitely still can use the &#39;=&#39; operator but it wouldn&#39;t do what you want. This is due to the fact that the &#39;=&#39; operator cannot be overloaded in the same way as other assignment operators. If we tried to use &#39;=&#39; to try to assign data to a portion of a physical pdl through a virtual pdl we wouldn&#39;t achieve the desired effect (instead the variable representing the virtual pdl (a reference to a blessed thingy) would after the assignment just contain the reference to another blessed thingy which would behave to future assignments as a &#34;physical&#34; copy of the original rvalue [this is actually not yet clear and subject of discussions in the PDL developers mailing list]. In that sense it would break the connection of the pdl to the parent [ isn&#39;t this behaviour in a sense the opposite of what happens in dataflow, where <code>.=</code> breaks the connection to the parent? ].</p>

<p>E.g.</p>

<pre> pdl&#62; $line = $im-&#62;slice(&#39;:,(2)&#39;)
 pdl&#62; $line = zeroes(5);
 pdl&#62; $line++;
 pdl&#62; p $im

 [
  [ 1  2  3  4  5]
  [ 6  7  8  9 10]
  [13 14 15 16 17]
  [16 17 18 19 20]
  [21 22 23 24 25]
 ]

 pdl&#62; p $line
 [1 1 1 1 1]</pre>

<p>But using <code>.=</code></p>

<pre> pdl&#62; $line = $im-&#62;slice(&#39;:,(2)&#39;)
 pdl&#62; $line .= zeroes(5)
 pdl&#62; $line++
 pdl&#62; p $im

 [
  [ 1  2  3  4  5]
  [ 6  7  8  9 10]
  [ 1  1  1  1  1]
  [16 17 18 19 20]
  [21 22 23 24 25]
 ]                                                                               

 pdl&#62; print $line
 [1 1 1 1 1]</pre>

<p>Also, you can substitute</p>

<pre> pdl&#62; $line .= 0;</pre>

<p>for the assignment above (the zero is converted to a scalar piddle, with no dimensions so it can be assigned to any piddle).</p>

<p>A nice feature in recent perl versions is lvalue subroutines (i.e., versions 5.6.x and higher including all perls currently supported by PDL). That allows one to use the slicing syntax on both sides of the assignment:</p>

<pre> pdl&#62; $im-&#62;slice(&#39;:,(2)&#39;) .= zeroes(5)-&#62;xvals-&#62;float</pre>

<p>Related to the lvalue sub assignment feature is a little trap for the unwary: recent perls introduced a &#34;feature&#34; which breaks PDL&#39;s use of lvalue subs for slice assignments when running under the perl debugger, <code>perl -d</code>. Under the debugger, the above usage gives an error like: <code> Can&#39;t return a temporary from lvalue subroutine... </code> So you must use syntax like this:</p>

<pre> pdl&#62; ($pdl = $im-&#62;slice(&#39;:,(2)&#39;)) .= zeroes(5)-&#62;xvals-&#62;float</pre>

<p>which works both with and without the debugger but is arguably clumsy and awkward to read.</p>

<p>Note that there can be a problem with assignments like this when lvalue and rvalue pdls refer to overlapping portions of data in the parent pdl:</p>

<pre> # revert the elements of the first line of $a
 ($tmp = $a-&#62;slice(&#39;:,(1)&#39;)) .= $a-&#62;slice(&#39;-1:0,(1)&#39;);</pre>

<p>Currently, the parent data on the right side of the assignments is not copied before the (internal) assignment loop proceeds. Therefore, the outcome of this assignment will depend on the sequence in which elements are assigned and almost certainly <i>not</i> do what you wanted. So the semantics are currently <b>undefined</b> for now and liable to change anytime. To obtain the desired behaviour, use</p>

<pre> ($tmp = $a-&#62;slice(&#39;:,(1)&#39;)) .= $a-&#62;slice(&#39;-1:0,(1)&#39;)-&#62;copy;</pre>

<p>which makes a physical copy of the slice or</p>

<pre> ($tmp = $a-&#62;slice(&#39;:,(1)&#39;)) .= $a-&#62;slice(&#39;-1:0,(1)&#39;)-&#62;sever;</pre>

<p>which returns the same slice but severs the connection of the slice to its parent.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Other_functions_that_manipulate_dimensions"
>Other functions that manipulate dimensions</a></h2>

<p>Having talked extensively about the <a href="../PDL/Slices.html#slice" class="podlinkpod"
>slice</a> function it should be noted that this is not the only PDL indexing function. There are additional indexing functions which are also useful (especially in the context of threading which we will talk about later). Here are a list and some examples how to use them.</p>

<dl>
<dt><a name="dummy"
><code>dummy</code></a></dt>

<dd>
<p>inserts a dummy dimension of the size you specify (default 1) at the chosen location. You can&#39;t wait to hear how that is achieved? Well, all elements with index <code>(X,x,Y)</code> (<code>0&#60;=x&#60;size_of_dummy_dim</code>) just map to the element with index <code>(X,Y)</code> of the parent pdl (where <code>X</code> and <code>Y</code> refer to the group of indices before and after the location where the dummy dimension was inserted.)</p>

<p>This example calculates the x coordinate of the centroid of an image (later we will learn that we didn&#39;t actually need the dummy dimension thanks to the magic of implicit threading; but using dummy dimensions the code would also work in a thread-less world; though once you have worked with PDL threads you wouldn&#39;t want to live without them again).</p>

<pre> # centroid
 ($xd,$yd) = $im-&#62;dims;
 $xc = sum($im*xvals(zeroes($xd))-&#62;dummy(1,$yd))/sum($im);</pre>

<p>Let&#39;s explain how that works in a little more detail. First, the product:</p>

<pre> $xvs = xvals(zeroes($xd));
 print $xvs-&#62;dummy(1,$yd);      # repeat the line $yd times
 $prod = $im*xvs-&#62;dummy(1,$yd); # form the pixel-wise product with
                                # the repeated line of x-values</pre>

<p>The rest is then summing the results of the pixel-wise product together and normalizing with the sum of all pixel values in the original image thereby calculating the x-coordinate of the &#34;center of mass&#34; of the image (interpreting pixel values as local mass) which is known as the centroid of an image.</p>

<p>Next is a (from the point of view of memory consumption) very cheap conversion from grey-scale to RGB, i.e. every pixel holds now a triple of values instead of a scalar. The three values in the triple are, fortunately, all the same for a grey image, so that our trick works well in that it maps all the three members of the triple to the same source element:</p>

<pre> # a cheap grey-scale to RGB conversion
 $rgb = $grey-&#62;dummy(0,3)</pre>

<p>Unfortunately this trick cannot be used to convert your old B/W photos to color ones in the way you&#39;d like. :(</p>

<p>Note that the memory usage of piddles with dummy dimensions is especially sensitive to the internal representation. If the piddle can be represented as a virtual affine (``vaffine&#39;&#39;) piddle, only the control structures are stored. But if <code>$b</code> in</p>

<pre> $a = zeroes(10000);
 $b = $a-&#62;dummy(1,10000);</pre>

<p>is made physical by some routine, you will find that the memory usage of your program has suddenly grown by 100Mb.</p>

<dt><a name="diagonal"
><code>diagonal</code></a></dt>

<dd>
<p>replaces two dimensions (which have to be of equal size) by one dimension that references all the elements along the &#34;diagonal&#34; along those two dimensions. Here, we have two examples which should appear familiar to anyone who has ever done some linear algebra. Firstly, make a unity matrix:</p>

<pre> # unity matrix
 $e = zeroes(float, 3, 3); # make everything zero
 ($tmp = $e-&#62;diagonal(0,1)) .= 1; # set the elements along the diagonal to 1
 print $e;</pre>

<p>Or the other diagonal:</p>

<pre> ($tmp = $e-&#62;slice(&#39;:-1:0&#39;)-&#62;diagonal(0,1)) .= 2;
 print $e;</pre>

<p>(Did you notice how we used the slice function to revert the sequence of lines before setting the diagonal of the new child, thereby setting the cross diagonal of the parent ?) Or a mapping from the space of diagonal matrices to the field over which the matrices are defined, the trace of a matrix:</p>

<pre> # trace of a matrix
 $trace = sum($mat-&#62;diagonal(0,1));  # sum all the diagonal elements</pre>

<dt><a name="xchg_and_mv"
><code>xchg</code> and <code>mv</code></a></dt>

<dd>
<p><a href="../PDL/Slices.html#xchg" class="podlinkpod"
>xchg</a> exchanges or &#34;transposes&#34; the two specified dimensions. A straightforward example:</p>

<pre> # transpose a matrix (without explicitly reshuffling data and
 # making a copy)
 $prod = $a x $a-&#62;xchg(0,1);</pre>

<p><code>$prod</code> should now be pretty close to the unity matrix if <code>$a</code> is an orthogonal matrix. Often <code>xchg</code> will be used in the context of threading but more about that later.</p>

<p><a href="../PDL/Slices.html#mv" class="podlinkpod"
>mv</a> works in a similar fashion. It moves a dimension (specified by its number in the parent) to a new position in the new child pdl:</p>

<pre> $b = $a-&#62;mv(4,0);  # make the 5th dimension of $a the first in the
                    # new child $b</pre>

<p>The difference between <code>xchg</code> and <code>mv</code> is that <code>xchg</code> only changes the position of two dimensions with each other, whereas <code>mv</code> inserts the first dimension to the place of second, moving the other dimensions around accordingly.</p>

<dt><a name="clump"
><code>clump</code></a></dt>

<dd>
<p>collapses several dimensions into one. Its only argument specifies how many dimensions of the source pdl should be collapsed (starting from the first). An (admittedly unrealistic) example is a 3D pdl which holds data from a stack of image files that you have just read in. However, the data from each image really represents a 1D time series and has only been arranged that way because it was digitized with a frame grabber. So to have it again as an array of time sequences you say</p>

<pre> pdl&#62; $seqs = $stack-&#62;clump(2)
 pdl&#62; help vars
 PDL variables in package main::

 Name         Type   Dimension       Flow  State          Mem
 ----------------------------------------------------------------
 $seqs        Double D [8000,50]            -C           0.00Kb                  
 $stack       Double D [100,80,50]          P            3.05Mb      </pre>

<p>Unrealistic as it may seem, our confocal microscope software writes data (sometimes) this way. But more often you use clump to achieve a certain effect when using implicit or explicit threading.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Calls_to_indexing_functions_can_be_chained"
>Calls to indexing functions can be chained</a></h2>

<p>As you might have noticed in some of the examples above calls to the indexing functions can be nicely chained since all of these functions return a newly created child object. However, when doing extensive index manipulations in a chain be sure to keep track of what you are doing, e.g.</p>

<pre> $a-&#62;xchg(0,1)-&#62;mv(0,4)</pre>

<p>moves the dimension 1 of <code>$a</code> to position 4 since when the second command is executed the original dimension 1 has been moved to position 0 of the new child that calls the <code>mv</code> function. I think you get the idea (in spite of my convoluted explanations).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Propagated_assignments_(&#39;.=&#39;)_and_dummy_dimensions"
>Propagated assignments (&#39;.=&#39;) and dummy dimensions</a></h2>

<p>A sublety related to indexing is the assignment to pdls containing dummy dimensions of size greater than 1. These assignments (using <code>.=</code>) are forbidden since several elements of the lvalue pdl point to the same element of the parent. As a consequence the value of those parent elements are potentially ambiguous and would depend on the sequence in which the implementation makes the assignments to elements. Therefore, an assignment like this:</p>

<pre> $a = pdl [1,2,3];
 $b = $a-&#62;dummy(1,4);
 $b .= yvals(zeroes(3,4));</pre>

<p>can produce unexpected results and the results are explicitly <b>undefined</b> by PDL because when PDL gets parallel computing features, the current result may well change.</p>

<p>From the point of view of dataflow the introduction of greater-size-than-one dummy dimensions is regarded as an irreversible transformation (similar to the terminology in thermodynamics) which precludes backward propagation of assignment to a parent (which you had explicitly requested using the <code>.=</code> assignment). A similar problem to watch out for occurs in the context of threading where sometimes dummy dimensions are created implicitly during the thread loop (see below).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Reasons_for_the_parent/child_(or_&#34;pointer&#34;)_concept"
>Reasons for the parent/child (or &#34;pointer&#34;) concept</a></h2>

<p>[ this will have to wait a bit ]</p>

<pre> XXXXX being memory efficient
 XXXXX in the context of threading
 XXXXX very flexible and powerful way of accessing portions of pdl data
       (in much more general way than sec, etc allow)
 XXXXX efficient implementation
 XXXXX difference to section/at, etc.</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="How_to_make_things_physical_again"
>How to make things physical again</a></h2>

<p>[ XXXXX fill in later when everything has settled a bit more ]</p>

<pre> ** When needed (xsub routine interfacing C lib function)
 ** How achieved (-&#62;physical)
 ** How to test (isphysical (explain how it works currently))
 ** -&#62;copy and -&#62;sever</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Threading"
>Threading</a></h1>

<p>In the previous paragraph on indexing we have already mentioned the term occasionally but now its really time to talk explicitly about &#34;threading&#34; with pdls. The term threading has many different meanings in different fields of computing. Within the framework of PDL it could probably be loosely defined as an implicit looping facility. It is implicit because you don&#39;t specify anything like enclosing for-loops but rather the loops are automatically (or &#39;magically&#39;) generated by PDL based on the dimensions of the pdls involved. This should give you a first idea why the index/dimension manipulating functions you have met in the previous paragraphs are especially important and useful in the context of threading. The other ingredient for threading (apart from the pdls involved) is a function that is threading aware (generally, these are <a href="../PDL/PP.html" class="podlinkpod"
>PDL::PP</a> compiled functions) and that the pdls are &#34;threaded&#34; over. So much about the terminology and now let&#39;s try to shed some light on what it all means.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Implicit_threading_-_a_first_example"
>Implicit threading - a first example</a></h2>

<p>There are two slightly different variants of threading. We start with what we call &#34;implicit threading&#34;. Let&#39;s pick a practical example that involves looping of a function over many elements of a pdl. Suppose we have an RGB image that we want to convert to grey-scale. The RGB image is represented by a 3-dim pdl <code>im(3,x,y)</code> where the first dimension contains the three color components of each pixel and <code>x</code> and <code>y</code> are width and height of the image, respectively. Next we need to specify how to convert a color-triple at a given pixel into a grey-value (to be a realistic example it should represent the relative intensity with which our color insensitive eye cells would detect that color to achieve what we would call a natural conversion from color to grey-scale). An approximation that works quite well is to compute the grey intensity from each RGB triplet (r,g,b) as a weighted sum</p>

<pre> grey-value = 77/256*r + 150/256*g + 29/256*b =
     inner([77,150,29]/256, [r,g,b])</pre>

<p>where the last form indicates that we can write this as an inner product of the 3-vector comprising the weights for red, green and blue components with the 3-vector containing the color components. Traditionally, we might have written a function like the following to process the whole image:</p>

<pre> my @dims=$im-&#62;dims;
 # here normally check that first dim has correct size (3), etc
 $grey=zeroes(@dims[1,2]);   # make the pdl for the resulting grey image
 $w = pdl [77,150,29] / 256; # the vector of weights
 for ($j=0;$j&#60;dims[2];$j++) {
    for ($i=0;$i&#60;dims[1];$i++) {
        # compute the pixel value
        $tmp = inner($w,$im-&#62;slice(&#39;:,(i),(j)&#39;));
        set($grey,$i,$j,$tmp); # and set it in the grey-scale image
    }
 }</pre>

<p>Now we write the same using threading (noting that <code>inner</code> is a threading aware function defined in the <a href="../PDL/Primitive.html" class="podlinkpod"
>PDL::Primitive</a> package)</p>

<pre> $grey = inner($im,pdl([77,150,29]/256));</pre>

<p>We have ended up with a one-liner that automatically creates the pdl <code>$grey</code> with the right number and size of dimensions and performs the loops automatically (these loops are implemented as fast C code in the internals of PDL). Well, we still owe you an explanation how this &#39;magic&#39; is achieved.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="How_does_the_example_work_?"
>How does the example work ?</a></h2>

<p>The first thing to note is that every function that is threading aware (these are without exception functions compiled from concise descriptions by <a href="../PDL/PP.html" class="podlinkpod"
>PDL::PP</a>, later just called PP-functions) expects a defined (minimum) number of dimensions (we call them core dimensions) from each of its pdl arguments. The <a href="../PDL/Primitive.html#inner" class="podlinkpod"
>inner</a> function expects two one-dimensional (input) parameters from which it calculates a zero-dimensional (output) parameter. We write that symbolically as <code>inner((n),(n),[o]())</code> and call it <code>inner</code>&#39;s <i>signature</i>, where n represents the size of that dimension. n being equal in the first and second parameter means that those dimensions have to be of equal size in any call. As a different example take the outer product which takes two 1D vectors to generate a 2D matrix, symbolically written as <code>outer((n),(m),[o](n,m))</code>. The <code>[o]</code> in both examples indicates that this (here third) argument is an output argument. In the latter example the dimensions of first and second argument don&#39;t have to agree but you see how they determine the size of the two dimensions of the output pdl.</p>

<p>Here is the point when threading finally enters the game. If you call PP-functions with pdls that have <i>more</i> than the required core dimensions the first dimensions of the pdl arguments are used as the core dimensions and the additional extra dimensions are threaded over. Let us demonstrate this first with our example above</p>

<pre> $grey = inner($im,$w); # w is the weight vector from above</pre>

<p>In this case $w is 1D and so supplied just the core dimension, <code>$im</code> is 3D, more specifically <code>(3,x,y)</code>. The first dimension (of size 3) is the required core dimension that matches (as required by inner) the first (and only) dimension of <code>$w</code>. The second dimension is the first thread dimension (of size <code>x</code>) and the third is here the second thread dimension (of size <code>y</code>). The output pdl is automatically created (as requested by setting <code>$grey</code> to &#34;null&#34; prior to invocation). The output dimensions are obtained by appending the <i>loop dimensions</i> (here <code>(x,y)</code>) to the core output dimensions (here 0D) to yield the final dimensions of the auto-created pdl (here <code>0D+2D=2D</code> to yield a 2D output of size <code>(x,y)</code>).</p>

<p>So the above command calls the core functionality that computes the inner product of two 1D vectors <code>x*y</code> times with <code>$w</code> and all 1D slices of the form <code>(&#39;:,(i),(j)&#39;)</code> of <code>$im</code> and sets the respective elements of the output pdl <code>$grey(i,j)</code> to the result of each computation. We could write that symbolically as</p>

<pre> $grey(0,0) = f($w,$im(:,(0),(0)))
 $grey(1,0) = f($w,$im(:,(1),(0)))
     .
     .
     .
 $grey(x-2,y-1) = f($w,$im(:,(x-2),(y-1)))
 $grey(x-1,y-1) = f($w,$im(:,(x-1),(y-1)))</pre>

<p>But this is done automatically by PDL without writing any explicit Perl loops. We see that the command really creates an output pdl with the right dimensions and sets the elements indeed to the result of the computation for each pixel of the input image.</p>

<p>When even more pdls and extra dimensions are involved things get a bit more complicated. We will first give the general rules how the thread dimensions depend on the dimensions of input pdls enabling you to figure out the dimensionality of an auto-created output pdl (for any given set of input pdls and core dimensions of the PP-function in question). The general rules will most likely appear a bit confusing on first sight so that we&#39;ll set out to illustrate the usage with a set of further examples (which will hopefully also demonstrate that there are indeed many practical situations where threading comes in extremely handy).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="A_call_for_coding_discipline"
>A call for coding discipline</a></h2>

<p>Before we point out the other technical details of threading, please note this call for programming discipline when using threading:</p>

<p>In order to preserve human readability, <i>PLEASE</i> comment any nontrivial expression in your code involving threading. Most importantly, for any subroutine, include information at the beginning about what you expect the dimensions to represent (or ranges of dimensions).</p>

<p>As a warning, look at this undocumented function and try to guess what might be going on:</p>

<pre> sub lookup {
   my ($im,$palette) = @_;
   my $res;
   index($palette-&#62;xchg(0,1),
              $im-&#62;long-&#62;dummy(0,($palette-&#62;dim)[0]),
              ($res=null));
   return $res;
 }</pre>

<p>Would you agree that it might be difficult to figure out expected dimensions, purpose of the routine, etc ? (If you want to find out what this piece of code does, see below)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="How_to_figure_out_the_loop_dimensions"
>How to figure out the loop dimensions</a></h2>

<p>There are a couple of rules that allow you to figure out number and size of loop dimensions (and if the size of your input pdls comply with the threading rules). Dimensions of any pdl argument are broken down into two groups in the following: Core dimensions (as defined by the PP-function, see <b>Appendix B</b> for a list of PDL primitives) and extra dimensions which comprises all remaining dimensions of that pdl. For example calling a function <code>func</code> with the signature <code>func((n,m),[o](n))</code> with a pdl <code>a(2,4,7,1,3)</code> as <code>f($a,($o = null))</code> results in the semantic splitting of a&#39;s dimensions into: core dimensions <code>(2,4)</code> and extra dimensions <code>(7,1,3)</code>.</p>

<dl>
<dt><a name="R0"
>R0</a></dt>

<dd>
<p>Core dimensions are identified with the first N dimensions of the respective pdl argument (and are required). Any further dimensions are extra dimensions and used to determine the loop dimensions.</p>

<dt><a name="R1"
>R1</a></dt>

<dd>
<p>The number of (implicit) loop dimensions is equal to the maximal number of extra dimensions taken over the set of pdl arguments.</p>

<dt><a name="R2"
>R2</a></dt>

<dd>
<p>The size of each of the loop dimensions is derived from the size of the respective dimensions of the pdl arguments. The size of a loop dimension is given by the maximal size found in any of the pdls having this extra dimension.</p>

<dt><a name="R3"
>R3</a></dt>

<dd>
<p>For all pdls that have a given extra dimension the size must be equal to the size of the loop dimension (as determined by the previous rule) or 1; otherwise you raise a runtime exception. If the size of the extra dimension in a pdl is one it is implicitly treated as a dummy dimension of size equal to that loop dim size when performing the thread loop.</p>

<dt><a name="R4"
>R4</a></dt>

<dd>
<p>If a pdl doesn&#39;t have a loop dimension, in the thread loop this pdl is treated as if having a dummy dimension of size equal to the size of that loop dimension.</p>

<dt><a name="R5"
>R5</a></dt>

<dd>
<p>If output auto-creation is used (by setting the relevant pdl to <code>PDL-&#62;null</code> before invocation) the number of dimensions of the created pdl is equal to the sum of the number of core output dimensions + number of loop dimensions. The size of the core output dimensions is derived from the relevant dimension of input pdls (as specified in the function definition) and the sizes of the other dimensions are equal to the size of the loop dimension it is derived from. The automatically created pdl will be physical (unless dataflow is in operation).</p>
</dd>
</dl>

<p>In this context, note that you can run into the problem with assignment to pdls containing greater-than-one dummy dimensions (see above). Although your output pdl(s) didn&#39;t contain any dummy dimensions in the first place they may end up with implicitly created dummy dimensions according to <i>R4</i>.</p>

<p>As an example, suppose we have a (here unspecified) PP-function with the signature:</p>

<pre> func((m,n),(m,n,o),(m),[o](m,o))</pre>

<p>and you call it with 3 pdls <code>a(5,3,10,11)</code>, <code>b(5,3,2,10,1,12)</code>, and <code>c(5,1,11,12)</code> as</p>

<pre> func($a,$b,$c,($d=null))</pre>

<p>then the number of loop dimensions is 3 (by <code>R0+R1</code> from <code>$b</code> and <code>$c</code>) with sizes <code>(10,11,12)</code> (by R2); the two output core dimensions are <code>(5,2)</code> (from the signature of func) resulting in a 5-dimensional output pdl <code>$c</code> of size <code>(5,2,10,11,12)</code> (see R5) and (the automatically created) <code>$d</code> is derived from <code>($a,$b,$c)</code> in a way that can be expressed in pdl pseudo-code as</p>

<pre> $d(:,:,i,j,k) .= func($a(:,:,i,j),$b(:,:,:,i,0,k),$c(:,0,j,k))
    with 0&#60;=i&#60;10, 0&#60;=j&#60;=11, 0&#60;=k&#60;12</pre>

<p>If we analyze the color to grey-scale conversion again with these rules in mind we note another great advantage of implicit threading. We can call the conversion with a pdl representing a pixel (<code>im(3)</code>), a line of rgb pixels (<code>im(3,x)</code>), a proper color image (<code>im(3,x,y)</code>) or a whole stack of RGB images (<code>im(3,x,y,z)</code>). As long as <code>$im</code> is of the form <code>(3,...)</code> the automatically created output pdl will contain the right number of dimensions and contain the intensity data as we expect it since the loops have been implicitly performed thanks to <i>implicit threading</i>. You can easily convince yourself that calling with a color pixel <code>$grey</code> is 0D, with a line it turns out 1D <code>grey(x)</code>, with an image we get <code>grey(x,y)</code> and finally we get a converted image stack <code>grey(x,y,z)</code>.</p>

<p>Let&#39;s fill these general rules with some more life by going through a couple of further examples. The reader may try to figure out equivalent formulations with explicit for-looping and compare the flexibility of those routines using implicit threading to the explicit formulation. Furthermore, especially when using several thread dimensions it is a useful exercise to check the relative speed by doing some benchmark tests (which we still have to do).</p>

<p>First in the row is a slightly reworked centroid example, now coded with threading in mind.</p>

<pre> # threaded mult to calculate centroid coords, works for stacks as well
 $xc = sumover(($im*xvals(($im-&#62;dims)[0]))-&#62;clump(2)) /
       sumover($im-&#62;clump(2));</pre>

<p>Let&#39;s analyze what&#39;s going on step by step. First the product:</p>

<pre> $prod = $im*xvals(zeroes(($im-&#62;dims)[0]))</pre>

<p>This will actually work for <code>$im</code> being one, two, three, and higher dimensional. If <code>$im</code> is one-dimensional it&#39;s just an ordinary product (in the sense that every element of <code>$im</code> is multiplied with the respective element of <code>xvals(...)</code>), if <code>$im</code> has more dimensions further threading is done by adding appropriate dummy dimensions to <code>xvals(...)</code> according to R4. More importantly, the two <a href="../PDL/Ufunc.html#sumover" class="podlinkpod"
>sumover</a> operations show a first example of how to make use of the dimension manipulating commands. A quick look at sumover&#39;s signature will remind you that it will only &#34;gobble up&#34; the first dimension of a given input pdl. But what if we want to really compute the sum over all elements of the first two dimensions? Well, nothing keeps us from passing a virtual pdl into sumover which in this case is formed by clumping the first two dimensions of the &#34;parent pdl&#34; into one. From the point of view of the parent pdl the sum is now computed over the first two dimensions, just as we wanted, though sumover has just done the job as specified by its signature. Got it ?</p>

<p>Another little finesse of writing the code like that: we intentionally used <code>sumover($pdl-&#62;clump(2))</code> instead of <code>sum($pdl)</code> so that we can either pass just an image <code>(x,y)</code> or a stack of images <code>(x,y,t)</code> into this routine and get either just one x-coordiante or a vector of x-coordinates (of size t) in return.</p>

<p>Another set of common operations are what one could call &#34;projection operations&#34;. These operations take a N-D pdl as input and return a (N-1)-D &#34;projected&#34; pdl. These operations are often performed with functions like <a href="../PDL/Ufunc.html#sumover" class="podlinkpod"
>sumover</a>, <a href="../PDL/Ufunc.html#prodover" class="podlinkpod"
>prodover</a>, <a href="../PDL/Ufunc.html#minimum" class="podlinkpod"
>minimum</a> and <a href="../PDL/Ufunc.html#maximum" class="podlinkpod"
>maximum</a>. Using again images as examples we might want to calculate the maximum pixel value for each line of an image or image stack. We know how to do that</p>

<pre> # maxima of lines (as function of line number and time)
 maximum($stack,($ret=null));</pre>

<p>But what if you want to calculate maxima per column when implicit threading always applies the core functionality to the first dimension and threads over all others? How can we achieve that instead the core functionality is applied to the second dimension and threading is done over the others. Can you guess it? Yes, we make a virtual pdl that has the second dimension of the &#34;parent pdl&#34; as its first dimension using the <code>mv</code> command.</p>

<pre> # maxima of columns (as function of column number and time)
 maximum($stack-&#62;mv(1,0),($ret=null));</pre>

<p>and calculating all the sums of sub-slices over the third dimension is now almost too easy</p>

<pre> # sums of pixels in time (assuming time is the third dim)
 sumover($stack-&#62;mv(2,0),($ret=null));</pre>

<p>Finally, if you want to apply the operation to all elements (like max over all elements or sum over all elements) regardless of the dimensions of the pdl in question <code>clump</code> comes in handy. As an example look at the definition of <code>sum</code> (as defined in <code>Ufunc.pm</code>):</p>

<pre> sub sum {
   PDL::Ufunc::sumover($name-&#62;clump(-1),($tmp=null));
   return $tmp-&#62;at(); # return a Perl number, not a 0D pdl
 }</pre>

<p>We have already mentioned that all basic operations support threading and assignment is no exception. So here are a couple of threaded assignments</p>

<pre> pdl&#62; $im = zeroes(byte, 10,20)
 pdl&#62; $line = exp(-rvals(10)**2/9)
 # threaded assignment
 pdl&#62; $im .= $line      # set every line of $im to $line
 pdl&#62; $im2 .= 5         # set every element of $im2 to 5</pre>

<p>By now you probably see how it works and what it does, don&#39;t you?</p>

<p>To finish the examples in this paragraph here is a function to create an RGB image from what is called a palette image. The palette image consists of two parts: an image of indices into a color lookup table and the color lookup table itself. [ describe how it works ] We are going to use a PP-function we haven&#39;t encoutered yet in the previous examples. It is the aptly named <a href="../PDL/Slices.html#index" class="podlinkpod"
>index</a> function, signature <code>((n),(),[o]())</code> (see <b>Appendix B</b>) with the core functionality that <code>index(pdl (0,2,4,5),2,($ret=null))</code> will return the element with index 2 of the first input pdl. In this case, <code>$ret</code> will contain the value 4. So here is the example:</p>

<pre> # a threaded index lookup to generate an RGB, or RGBA or YMCK image
 # from a palette image (represented by a lookup table $palette and
 # an color-index image $im)
 # you can say just dummy(0) since the rules of threading make it fit
 pdl&#62; index($palette-&#62;xchg(0,1),
               $im-&#62;long-&#62;dummy(0,($palette-&#62;dim)[0]),
               ($res=null));</pre>

<p>Let&#39;s go through it and explain the steps involved. Assuming we are dealing with an RGB lookup-table $palette is of size <code>(3,x)</code>. First we exchange the dimensions of the palette so that looping is done over the first dimension of <code>$palette</code> (of size 3 that represent r, g, and b components). Now looking at <code>$im</code>, we add a dummy dimension of size equal to the length of the number of components (in the case we are discussing here we could have just used the number 3 since we have 3 color components). We can use a dummy dimension since for red, green and blue color components we use the same index from the original image, e.g. assuming a certain pixel of <code>$im</code> had the value 4 then the lookup should produce the triple</p>

<pre> [palette(0,4),palette(1,4),palette(2,4)] </pre>

<p>for the new red, green and blue components of the output image. Hopefully by now you have some sort of idea what the above piece of code is supposed to do (it is often actually quite complicated to describe in detail how a piece of threading code works; just go ahead and experiment a bit to get a better feeling for it).</p>

<p>If you have read the threading rules carefully, then you might have noticed that we didn&#39;t have to explicitly state the size of the dummy dimension that we created for <code>$im</code>; when we create it with size 1 (the default) the rules of threading make it automatically fit to the desired size (by rule R3, in our example the size would be 3 assuming a palette of size <code>(3,x)</code>). Since situations like this do occur often in practice this is actually why rule R3 has been introduced (the part that makes dimensions of size 1 fit to the thread loop dim size). So we can just say</p>

<pre> pdl&#62; index($palette-&#62;xchg(0,1),$im-&#62;long-&#62;dummy(0),($res=null));</pre>

<p>Again, you can convince yourself that this routine will create the right output if called with a pixel (<code>$im</code> is 0D), a line (<code>$im</code> is 1D), an image (<code>$im</code> is 2D), ..., an RGB lookup table (palette is <code>(3,x)</code>) and RGBA lookup table (palette is <code>(4,x)</code>, see e.g. OpenGL). This flexibility is achieved by the rules of threading which are made to do the right thing in most situations.</p>

<p>To wrap it all up once again, the general idea is as follows. If you want to achieve looping over certain dimensions and have the <i>core functionality</i> applied to another specified set of dimensions you use the dimension manipulating commands to create a (or several) <i>virtual</i> pdl(s) so that from the point of view of the <i>parent</i> pdl(s) you get what you want (always having the signature of the function in question and R1-R5 in mind!). Easy, isn&#39;t it ?</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Output_auto-creation_and_PP-function_calling_conventions"
>Output auto-creation and PP-function calling conventions</a></h2>

<p>At this point we have to divert to some technical detail that has to do with the general calling conventions of PP-functions and the automatic creation of output arguments. Basically, there are two ways of invoking pdl routines, namely</p>

<pre> $result = func($a,$b);</pre>

<p>and</p>

<pre> func($a,$b,$result);</pre>

<p>If you are only using implicit threading then the output variable can be automatically created by PDL. You flag that to the PP-function by setting the output argument to a special kind of pdl that is returned from a call to the function <code>PDL-&#62;null</code> that returns an essentially &#34;empty&#34; pdl (for those interested in details there is a flag in the C pdl structure for this). The dimensions of the created pdl are determined by the rules of implicit threading: the first dimensions are the core output dimensions to which the threading dimensions are appended (which are in turn determined by the dimensions of the input pdls as described above). So you can say</p>

<pre> func($a,$b,($result=PDL-&#62;null));</pre>

<p>or</p>

<pre> $result = func($a,$b)</pre>

<p>which are <b>exactly</b> equivalent.</p>

<p>Be warned that you can <i>not</i> use output auto-creation when using explicit threading (for reasons explained in the following section on <b>explicit threading</b>, the second variant of threading).</p>

<p>In &#34;tight&#34; loops you probably want to avoid the implicit creation of a temporary pdl in each step of the loop that comes along with the &#34;functional&#34; style but rather say</p>

<pre> # create output pdl of appropriate size only at first invocation
 $result = null;  
 for (0...$n) {
      func($a,$b,$result); # in all but the first invocation $result
      func2($b);           # is defined and has the right size to
                           # take the output provided $b&#39;s dims don&#39;t change
      twiddle($result,$a); # do something from $result to $a for iteration
 }</pre>

<p>The take-home message of this section once more: be aware of the limitation on output creation when using <b>explicit threading</b>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Explicit_threading"
>Explicit threading</a></h2>

<p>Having so far only talked about the first flavour of threading it is now about time to introduce the second variant. Instead of shuffling around dimensions all the time and relying on the rules of implicit threading to get it all right you sometimes might want to specify in a more explicit way how to perform the thread loop. It is probably not too surprising that this variant of the game is called <i>explicit threading</i>. Now, before we create the wrong impression: it is not either <i>implicit</i> or <i>explicit</i>; the two flavours do mix. But more about that later.</p>

<p>The two most used functions with explicit threading are <a href="../PDL/Core.html#PDL%3A%3Athread" class="podlinkpod"
>thread</a> and <a href="../PDL/Slices.html#unthread" class="podlinkpod"
>unthread</a>. We start with an example that illustrates typical usage of the former:</p>

<pre> [ # ** this is the worst possible example to start with ]
 #  but can be used to show that $mat += $line is different from
 #                               $mat-&#62;thread(0) += $line
 # explicit threading to add a vector to each column of a matrix
 pdl&#62; $mat  = zeroes(4,3)
 pdl&#62; $line = pdl (3.1416,2,-2)
 pdl&#62; ($tmp = $mat-&#62;thread(0)) += $line</pre>

<p>In this example, <code>$mat-&#62;thread(0)</code> tells PDL that you want the second dimension of this pdl to be threaded over first leading to a thread loop that can be expressed as</p>

<pre> for (j=0; j&#60;3; j++) {
    for (i=0; i&#60;4; i++) {
        mat(i,j) += src(j);
    }
 }</pre>

<p><code>thread</code> takes a list of numbers as arguments which explicitly specify which dimensions to thread over first. With the introduction of explicit threading the dimensions of a pdl are conceptually split into three different groups the latter two of which we have already encountered: thread dimensions, core dimensions and extra dimensions.</p>

<p>Conceptually, it is best to think of those dimensions of a pdl that have been specified in a call to <code>thread</code> as being taken away from the set of normal dimensions and put on a separate stack. So assuming we have a pdl <code>a(4,7,2,8)</code> saying</p>

<pre> $b = $a-&#62;thread(2,1)</pre>

<p>creates a new virtual pdl of dimension <code>b(4,8)</code> (which we call the remaining dims) that also has 2 thread dimensions of size <code>(2,7)</code>. For the purposes of this document we write that symbolically as <code>b(4,8){2,7}</code>. An important difference to the previous examples where only implicit threading was used is the fact that the core dimensions are matched against the <i>remaining dimensions</i> which are not necessarily the first dimensions of the pdl. We will now specify how the presence of thread dimensions changes the rules R1-R5 for thread loops (which apply to the special case where none of the pdl arguments has any thread dimensions).</p>

<dl>
<dt><a name="T0"
>T0</a></dt>

<dd>
<p>Core dimensions are matched against the first n <i>remaining dimensions</i> of the pdl argument (note the difference to R1). Any further <i>remaining dimensions</i> are <i>extra dimensions</i> and are used to determine the <i>implicit loop dimensions</i>.</p>

<dt><a name="T1a"
>T1a</a></dt>

<dd>
<p>The number of <i>implicit loop dimensions</i> is equal to the maximal number of extra dimensions taken over the set of pdl arguments.</p>

<dt><a name="T1b"
>T1b</a></dt>

<dd>
<p>The number of <i>explicit loop dimensions</i> is equal to the maximal number of thread dimensions taken over the set of pdl arguments.</p>

<dt><a name="T1c"
>T1c</a></dt>

<dd>
<p>The total number of <i>loop dimensions</i> is equal to the sum of <i>explicit loop dimensions</i> and <i>implicit loop dimensions</i>. In the thread loop, <i>explicit loop dimensions</i> are threaded over first followed by <i>implicit loop dimensions</i>.</p>

<dt><a name="T2"
>T2</a></dt>

<dd>
<p>The size of each of the <i>loop dimensions</i> is derived from the size of the respective dimensions of the pdl arguments. It is given by the maximal size found in any pdls having this thread dimension (for <i>explicit loop dimensions</i>) or extra dimension (for <i>implicit loop dimensions</i>).</p>

<dt><a name="T3"
>T3</a></dt>

<dd>
<p>This rule applies to any <i>explicit loop dimension</i> as well as any <i>implicit loop dimension</i>. For all pdls that have a given <i>thread/extra dimension</i> the size must be equal to the size of the respective <i>explicit/implicit loop dimension</i> or 1; otherwise you raise a runtime exception. If the size of a <i>thread/extra dimension</i> of a pdl is one it is implicitly treated as a dummy dimension of size equal to the <i>explicit/implicit loop dimension</i>.</p>

<dt><a name="T4"
>T4</a></dt>

<dd>
<p>If a pdl doesn&#39;t have a <i>thread/extra dimension</i> that corresponds to an <i>explicit/implicit loop dimension</i>, in the thread loop this pdl is treated as if having a dummy dimension of size equal to the size of that loop dimension.</p>

<dt><a name="T4a"
>T4a</a></dt>

<dd>
<p>All pdls that do have <i>thread dimensions</i> must have the same number of thread dimensions.</p>

<dt><a name="T5"
>T5</a></dt>

<dd>
<p>Output auto-creation cannot be used if any of the pdl arguments has any <i>thread dimensions</i>. Otherwise R5 applies.</p>
</dd>
</dl>

<p>The same restrictions apply with regard to implicit dummy dimensions (created by application of T4) as already mentioned in the section on implicit threading: if any of the output pdls has an (explicit or implicitly created) greater-than-one dummy dimension a runtime exception will be raised.</p>

<p>Let us demonstrate these rules at work in a generic case. Suppose we have a (here unspecified) PP-function with the signature:</p>

<pre> func((m,n),(m),(),[o](m))</pre>

<p>and you call it with 3 pdls <code>a(5,3,10,11)</code>, <code>b(3,5,10,1,12)</code>, <code>c(10)</code> and an output pdl <code>d(3,11,5,10,12)</code> (which can here <i>not</i> be automatically created) as</p>

<pre> func($a-&#62;thread(1,3),$b-&#62;thread(0,3),$c,$d-&#62;thread(0,1))</pre>

<p>From the signature of func and the above call the pdls split into the following groups of core, extra and thread dimensions (written in the form <code>pdl(core dims){thread dims}[extra dims]</code>):</p>

<pre> a(5,10){3,11}[] b(5){3,1}[10,12] c(){}[10] d(5){3,11}[10,12]</pre>

<p>With this to help us along (it is in general helpful to write the arguments down like this when you start playing with threading and want to keep track of what is going on) we further deduce that the number of explicit loop dimensions is 2 (by T1b from <code>$a</code> and <code>$b</code>) with sizes <code>(3,11)</code> (by T2); 2 implicit loop dimensions (by T1a from <code>$b</code> and <code>$d</code>) of size <code>(10,12)</code> (by T2) and the elements of are computed from the input pdls in a way that can be expressed in pdl pseudo-code as</p>

<pre> for (l=0;l&#60;12;l++)
  for (k=0;k&#60;10;k++)
   for (j=0;j&#60;11;j++)         effect of treating it as dummy dim (index j)
    for (i=0;i&#60;3;i++)                         |
       d(i,j,:,k,l) = func(a(:,i,:,j),b(i,:,k,0,l),c(k))</pre>

<p>Ugh, this example was really not easy in terms of bookkeeping. It serves mostly as an example how to figure out what&#39;s going on when you encounter a complicated looking expression. But now it is really time to show that threading is useful by giving some more of our so called &#34;practical&#34; examples.</p>

<p>[ The following examples will need some additional explanations in the future. For the moment please try to live with the comments in the code fragments. ]</p>

<p>Example 1:</p>

<pre> *** inverse of matrix represented by eigvecs and eigvals
 ** given a symmetrical matrix M = A^T x diag(lambda_i) x A
 **    =&#62;  inverse M^-1 = A^T x diag(1/lambda_i) x A
 ** first $tmp = diag(1/lambda_i)*A
 ** then  A^T * $tmp by threaded inner product
 # index handling so that matrices print correct under pdl
 $inv .= $evecs*0;  # just copy to get appropriately sized output
 $tmp .= $evecs;    # initialise, no back-propagation
 ($tmp2 = $tmp-&#62;thread(0)) /= $evals;    #  threaded division
 # and now a matrix multiplication in disguise
 PDL::Primitive::inner($evecs-&#62;xchg(0,1)-&#62;thread(-1,1),
                       $tmp-&#62;thread(0,-1),
                       $inv-&#62;thread(0,1));
 # alternative for matrix mult using implicit threading,
 # first xchg only for transpose
 PDL::Primitive::inner($evecs-&#62;xchg(0,1)-&#62;dummy(1),
                       $tmp-&#62;xchg(0,1)-&#62;dummy(2),
                       ($inv=null));</pre>

<p>Example 2:</p>

<pre> # outer product by threaded multiplication
 # stress that we need to do it with explicit call to my_biop1
 # when using explicit threading
 $res=zeroes(($a-&#62;dims)[0],($b-&#62;dims)[0]);
 my_biop1($a-&#62;thread(0,-1),$b-&#62;thread(-1,0),$res-&#62;(0,1),&#34;*&#34;);
 # similar thing by implicit threading with auto-created pdl
 $res = $a-&#62;dummy(1) * $b-&#62;dummy(0);</pre>

<p>Example 3:</p>

<pre> # different use of thread and unthread to shuffle a number of
 # dimensions in one go without lots of calls to -&#62;xchg and -&#62;mv


 # use thread/unthread to shuffle dimensions around
 # just try it out and compare the child pdl with its parent
 $trans = $a-&#62;thread(4,1,0,3,2)-&#62;unthread;</pre>

<p>Example 4:</p>

<pre> # calculate a couple of bounding boxes
 # $bb will hold BB as [xmin,xmax],[ymin,ymax],[zmin,zmax]
 # we use again thread and unthread to shuffle dimensions around
 pdl&#62; $bb = zeroes(double, 2,3 );
 pdl&#62; minimum($vertices-&#62;thread(0)-&#62;clump-&#62;unthread(1), $bb-&#62;slice(&#39;(0),:&#39;));
 pdl&#62; maximum($vertices-&#62;thread(0)-&#62;clump-&#62;unthread(1), $bb-&#62;slice(&#39;(1),:&#39;));</pre>

<p>Example 5:</p>

<pre> # calculate a self-rationed (i.e. self normalized) sequence of images
 # uses explicit threading and an implicitly threaded division
 $stack = read_image_stack();
 # calculate the average (per pixel average) of the first $n+1 images
 $aver = zeroes([stack-&#62;dims]-&#62;[0,1]);  # make the output pdl
 sumover($stack-&#62;slice(&#34;:,:,0:$n&#34;)-&#62;thread(0,1),$aver);
 $aver /= ($n+1);
 $stack /= $aver;  # normalize the stack by doing a threaded division
 # implicit versus explicit
 # alternatively calculate $aver with implicit threading and auto-creation
 sumover($stack-&#62;slice(&#34;:,:,0:$n&#34;)-&#62;mv(2,0),($aver=null));
 $aver /= ($n+1);
 #</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Implicit_versus_explicit_threading"
>Implicit versus explicit threading</a></h2>

<p>In this paragraph we are going to illustrate when explicit threading is preferable over implicit threading and vice versa. But then again, this is probably not the best way of putting the case since you already know: the two flavours do mix. So, it&#39;s more about how to get the best of both worlds and, anyway, in the best of Perl traditions: TIMTOWTDI !</p>

<p>[ Sorry, this still has to be filled in in a later release; either refer to above examples or choose some new ones ]</p>

<p>Finally, this may be a good place to justify all the technical detail we have been going on about for a couple of pages: why threading ?</p>

<p>Well, code that uses threading should be (considerably) faster than code that uses explicit for-loops (or similar Perl constructs) to achieve the same functionality. Especially on supercomputers (with vector computing facilities/parallel processing) PDL threading will be implemented in a way that takes advantage of the additional facilities of these machines. Furthermore, it is a conceptually simply construct (though technical details might get involved at times) and can <i>greatly</i> reduce the syntactical complexity of PDL code (but keep the admonition for documentation in mind). Once you are comfortable with the <i>threading</i> way of thinking (and coding) it shouldn&#39;t be too difficult to understand code that somebody else has written than (provided he gave you an idea what expected input dimensions are, etc.). As a general tip to increase the performance of your code: if you have to introduce a loop into your code try to reformulate the problem so that you can use threading to perform the loop (as with anything there are exceptions to this rule of thumb; but the authors of this document tend to think that these are rare cases ;).</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PDL::PP"
>PDL::PP</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="An_easy_way_to_define_functions_that_are_aware_of_indexing_and_threading_(and_the_universe_and_everything)"
>An easy way to define functions that are aware of indexing and threading (and the universe and everything)</a></h2>

<p>PDL:PP is part of the PDL distribution. It is used to generate functions that are aware of indexing and threading rules from very concise descriptions. It can be useful for you if you want to write your own functions or if you want to interface functions from an external library so that they support indexing and threading (and maybe dataflow as well, see <a href="../PDL/Dataflow.html" class="podlinkpod"
>PDL::Dataflow</a>). For further details check <a href="../PDL/PP.html" class="podlinkpod"
>PDL::PP</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Appendix_A"
>Appendix A</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Affine_transformations_-_a_special_class_of_simple_and_powerful_transformations"
>Affine transformations - a special class of simple and powerful transformations</a></h2>

<p>[ This is also something to be added in future releases. Do we already have the general make_affine routine in PDL ? It is possible that we will reference another appropriate man page from here ]</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Appendix_B"
>Appendix B</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="signatures_of_standard_PDL::PP_compiled_functions"
>signatures of standard PDL::PP compiled functions</a></h2>

<p>A selection of signatures of PDL primitives to show how many dimensions PP compiled functions gobble up (and therefore you can figure out what will be threaded over). Most of those functions are the basic ones defined in <code>primitive.pd</code></p>

<pre> # functions in primitive.pd
 #
 sumover        ((n),[o]())
 prodover       ((n),[o]())
 axisvalues     ((n))                                   inplace
 inner          ((n),(n),[o]())
 outer          ((n),(m),[o](n,m))
 innerwt        ((n),(n),(n),[o]())
 inner2         ((m),(m,n),(n),[o]())
 inner2t        ((j,n),(n,m),(m,k),[o]())
 index          (1D,0D,[o])
 minimum        (1D,[o])
 maximum        (1D,[o])
 wstat          ((n),(n),(),[o],())
 assgn          ((),())

 # basic operations
 binary operations ((),(),[o]())
 unary operations  ((),[o]())</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR_&#38;_COPYRIGHT"
>AUTHOR &#38; COPYRIGHT</a></h1>

<p>Copyright (C) 1997 Christian Soeller (c.soeller@auckland.ac.nz) &#38; Tuomas J. Lukka (lukka@fas.harvard.edu). All rights reserved. Although destined for release as a man page with the standard PDL distribution, it is not public domain. Permission is granted to freely distribute verbatim copies of this document provided that no modifications outside of formatting be made, and that this notice remain intact. You are permitted and encouraged to use its code and derivatives thereof in your own source code for fun or for profit as you see fit.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
