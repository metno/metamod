<html><head><title>PDL::Types</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:24 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#Support_functions'>Support functions</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#typesrtkeys'>typesrtkeys</a>
    <li class='indexItem indexItem2'><a href='#ppdefs'>ppdefs</a>
    <li class='indexItem indexItem2'><a href='#typefld'>typefld</a>
    <li class='indexItem indexItem2'><a href='#mapfld_(in_value%2C_in_key%2C_out_key)'>mapfld (in_value, in_key, out_key)</a>
    <li class='indexItem indexItem2'><a href='#typesynonyms'>typesynonyms</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#PDL%3A%3AType_OBJECTS'>PDL::Type OBJECTS</a>
  <li class='indexItem indexItem1'><a href='#Adding%2Fremoving_types'>Adding/removing types</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Format_of_a_type_entry'>Format of a type entry</a>
    <li class='indexItem indexItem2'><a href='#Fields_in_a_type_entry'>Fields in a type entry</a>
    <li class='indexItem indexItem2'><a href='#Other_things_you_need_to_do'>Other things you need to do</a>
  </ul>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>PDL::Types - define fundamental PDL Datatypes</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre> use PDL::Types;

 $pdl = ushort( 2.0, 3.0 );
 print &#34;The actual c type used to store ushort&#39;s is &#39;&#34; .
    $pdl-&#62;type-&#62;realctype() . &#34;&#39;\n&#34;;
 The actual c type used to store ushort&#39;s is &#39;unsigned short&#39;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Internal module - holds all the PDL Type info. The type info can be accessed easily using the <code>PDL::Type</code> object returned by the <a href="../PDL/Core.html#type" class="podlinkpod"
>type</a> method.</p>

<p>Skip to the end of this document to find out how to change the set of types supported by PDL.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Support_functions"
>Support functions</a></h1>

<p>A number of functions are available for module writers to get/process type information. These are used in various places (e.g. <code>PDL::PP</code>, <code>PDL::Core</code>) to generate the appropriate type loops, etc.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="typesrtkeys"
>typesrtkeys</a></h2>

<p>return array of keys of typehash sorted in order of type complexity</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ppdefs"
>ppdefs</a></h2>

<p>return array of pp symbols for all known types</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="typefld"
>typefld</a></h2>

<p>return specified field (<code>$fld</code>) for specified type (<code>$type</code>) by querying type hash</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="mapfld_(in_value,_in_key,_out_key)"
>mapfld (in_value, in_key, out_key)</a></h2>

<p>Map a given source field to the corresponding target field by querying the type hash. This gives you a way to say, &#34;Find the type whose <code>$in_key</code> is equal to <code>$value</code>, and return that type&#39;s value for <code>$out_key</code>. For example:</p>

<pre> # Does byte type use nan?
 $uses_nan = PDL::Types::mapfld(byte =&#62; &#39;ppforcetype&#39;, &#39;usenan&#39;);
 # Equivalent:
 $uses_nan = byte-&#62;usenan;
 
 # What is the actual C type for the value that we call &#39;long&#39;?
 $type_name = PDL::Types::mapfld(long =&#62; &#39;convertfunc&#39;, &#39;realctype&#39;);
 # Equivalent:
 $type_name = long-&#62;realctype;</pre>

<p>As you can see, the equivalent examples are much shorter and legible, so you should only use mapfld if you were given the type index (in which case the actual type is not immediately obvious):</p>

<pre> $type_index = 4;
 $type_name = PDL::Types::mapfld($type_index =&#62; numval, &#39;realctype&#39;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="typesynonyms"
>typesynonyms</a></h2>

<p>return type related synonym definitions to be included in pdl.h . This routine must be updated to include new types as required. Mostly the automatic updating should take care of the vital things.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PDL::Type_OBJECTS"
>PDL::Type OBJECTS</a></h1>

<p>This module declares one class - <code>PDL::Type</code> - objects of this class are returned by the <a href="../PDL/Core.html#type" class="podlinkpod"
>type</a> method of a piddle. It has several methods, listed below, which provide an easy way to access type information:</p>

<p>Additionally, comparison and stringification are overloaded so that you can compare and print type objects, e.g.</p>

<pre>  $nofloat = 1 if $pdl-&#62;type &#60; float;
  die &#34;must be double&#34; if $type != double;</pre>

<p>For further examples check again the <a href="../PDL/Core.html#type" class="podlinkpod"
>type</a> method.</p>

<dl>
<dt><a name="enum"
>enum</a></dt>

<dd>
<p>Returns the number representing this datatype (see <a href="../PDL/Core.html#PDL%3A%3Aget_datatype" class="podlinkpod"
>get_datatype</a>).</p>

<dt><a name="symbol"
>symbol</a></dt>

<dd>
<p>Returns one of &#39;PDL_B&#39;, &#39;PDL_S&#39;, &#39;PDL_US&#39;, &#39;PDL_L&#39;, &#39;PDL_LL&#39;, &#39;PDL_F&#39; or &#39;PDL_D&#39;.</p>

<dt><a name="ctype"
>ctype</a></dt>

<dd>
<p>Returns the macro used to represent this type in C code (eg &#39;PDL_Long&#39;).</p>

<dt><a name="ppsym"
>ppsym</a></dt>

<dd>
<p>The letter used to represent this type in PP code code (eg &#39;U&#39; for <a href="../PDL/Core.html#ushort" class="podlinkpod"
>ushort</a>).</p>

<dt><a name="realctype"
>realctype</a></dt>

<dd>
<p>The actual C type used to store this type.</p>

<dt><a name="shortctype"
>shortctype</a></dt>

<dd>
<p>The value returned by <code>ctype</code> without the &#39;PDL_&#39; prefix.</p>

<dt><a name="badvalue"
>badvalue</a></dt>

<dd>
<p>The special numerical value used to represent bad values for this type. See <a href="../PDL/Bad.html#badvalue" class="podlinkpod"
>badvalue routine in PDL::Bad</a> for more details.</p>

<dt><a name="orig_badvalue"
>orig_badvalue</a></dt>

<dd>
<p>The default special numerical value used to represent bad values for this type. (You can change the value that represents bad values for each type during runtime.) See the <a href="../PDL/Bad.html#orig_badvalue" class="podlinkpod"
>orig_badvalue routine in PDL::Bad</a> for more details.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Adding/removing_types"
>Adding/removing types</a></h1>

<p>You can change the types that PDL knows about by editing entries in the definition of the variable <code>@types</code> that appears close to the top of the file <em>Types.pm.PL</em> (i.e. the file from which this module was generated).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Format_of_a_type_entry"
>Format of a type entry</a></h2>

<p>Each entry in the <code>@types</code> array is a hash reference. Here is an example taken from the actual code that defines the <code>ushort</code> type:</p>

<pre>             {
              identifier =&#62; &#39;US&#39;,
              onecharident =&#62; &#39;U&#39;,   # only needed if different from identifier
              pdlctype =&#62; &#39;PDL_Ushort&#39;,
              realctype =&#62; &#39;unsigned short&#39;,
              ppforcetype =&#62; &#39;ushort&#39;,
              usenan =&#62; 0,
              packtype =&#62; &#39;S*&#39;,
             },</pre>

<p>Before we start to explain the fields please take this important message on board: <i>entries must be listed in order of increasing complexity</i>. This is critical to ensure that PDL&#39;s type conversion works correctly. Basically, a less complex type will be converted to a more complex type as required.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Fields_in_a_type_entry"
>Fields in a type entry</a></h2>

<p>Each type entry has a number of required and optional entry.</p>

<p>A list of all the entries:</p>

<ul>
<li>identifier
<p><i>Required</i>. A short sequence of upercase letters that identifies this type uniquely. More than three characters is probably overkill.</p>
</li>

<li>onecharident
<p><i>Optional</i>. Only required if the <code>identifier</code> has more than one character. This should be a unique uppercase character that will be used to reference this type in PP macro expressions of the <code>TBSULFD</code> type. If you don&#39;t know what I am talking about read the PP manpage or ask on the mailing list.</p>
</li>

<li>pdlctype
<p><i>Required</i>. The <code>typedefed</code> name that will be used to access this type from C code.</p>
</li>

<li>realctype
<p><i>Required</i>. The C compiler type that is used to implement this type. For portability reasons this one might be platform dependent.</p>
</li>

<li>ppforcetype
<p><i>Required</i>. The type name used in PP signatures to refer to this type.</p>
</li>

<li>usenan
<p><i>Required</i>. Flag that signals if this type has to deal with NaN issues. Generally only required for floating point types.</p>
</li>

<li>packtype
<p><i>Required</i>. The Perl pack type used to pack Perl values into the machine representation for this type. For details see <code>perldoc -f pack</code>.</p>
</li>
</ul>

<p>Also have a look at the entries at the top of <em>Types.pm.PL</em>.</p>

<p>The syntax is not written into stone yet and might change as the concept matures.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Other_things_you_need_to_do"
>Other things you need to do</a></h2>

<p>You need to check modules that do I/O (generally in the <em>IO</em> part of the directory tree). In the future we might add fields to type entries to automate this. This requires changes to those IO modules first though.</p>

<p>You should also make sure that any type macros in PP files (i.e. <code>$TBSULFD...</code>) are updated to reflect the new type. PDL::PP::Dump has a mode to check for type macros requiring updating. Do something like</p>

<pre>    find . -name \*.pd -exec perl -Mblib=. -M&#39;PDL::PP::Dump=typecheck&#39; {} \;</pre>

<p>from the PDL root directory <i>after</i> updating <em>Types.pm.PL</em> to check for such places.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
