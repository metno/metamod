<html><head><title>PDL::NiceSlice</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:24 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSYS'>SYNOPSYS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#Use_in_scripts_and_perldl_or_pdl2_shell'>Use in scripts and perldl or pdl2 shell</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#evals_and_PDL%3A%3ANiceSlice'>evals and PDL::NiceSlice</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#The_new_slicing_syntax'>The new slicing syntax</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Parentheses_following_a_scalar_variable_name'>Parentheses following a scalar variable name</a>
    <li class='indexItem indexItem2'><a href='#The_default_method_syntax'>The default method syntax</a>
    <li class='indexItem indexItem2'><a href='#When_to_use_which_syntax%3F'>When to use which syntax?</a>
    <li class='indexItem indexItem2'><a href='#The_argument_list'>The argument list</a>
    <li class='indexItem indexItem2'><a href='#Modifiers'>Modifiers</a>
    <li class='indexItem indexItem2'><a href='#Combining_modifiers'>Combining modifiers</a>
    <li class='indexItem indexItem2'><a href='#Argument_formats'>Argument formats</a>
    <li class='indexItem indexItem2'><a href='#piddles_as_indices_in_ranges'>piddles as indices in ranges</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#IMPLEMENTATION'>IMPLEMENTATION</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Conditional_operator'>Conditional operator</a>
    <li class='indexItem indexItem2'><a href='#The_DATA_file_handle'>The DATA file handle</a>
    <li class='indexItem indexItem2'><a href='#Possible_interaction_with_Inline%3A%3APdlpp'>Possible interaction with Inline::Pdlpp</a>
    <li class='indexItem indexItem2'><a href='#Bug_reports'>Bug reports</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>PDL::NiceSlice - toward a nicer slicing syntax for PDL</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSYS"
>SYNOPSYS</a></h1>

<pre>  use PDL::NiceSlice;

  $a(1:4) .= 2;             # concise syntax for ranges
  print $b((0),1:$end);     # use variables in the slice expression
  $a-&#62;xchg(0,1)-&#62;(($pos-1)) .= 0; # default method syntax

  $idx = long 1, 7, 3, 0;   # a piddle of indices
  $a(-3:2:2,$idx) += 3;     # mix explicit indexing and ranges
  $a-&#62;clump(1,2)-&#62;(0:30);   # &#39;default method&#39; syntax
  $a(myfunc(0,$var),1:4)++; # when using functions in slice expressions
                            # use parentheses around args!

  $b = $a(*3);              # Add dummy dimension of order 3

  # modifiers are specified in a ;-separated trailing block
  $a($a!=3;?)++;            # short for $a-&#62;where($a!=3)++
  $a(0:1114;_) .= 0;        # short for $a-&#62;flat-&#62;(0:1114)
  $b = $a(0:-1:3;|);        # short for $a(0:-1:3)-&#62;sever
  $n = sequence 3,1,4,1;
  $b = $n(;-);              # drop all dimensions of size 1 (AKA squeeze)
  $b = $n(0,0;-|);          # squeeze *and* sever
  $c = $a(0,3,0;-);         # more compact way of saying $a((0),(3),(0))</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Slicing is a basic, extremely common operation, and PDL&#39;s <a href="../PDL/Slices.html#slice" class="podlinkpod"
>slice</a> method would be cumbersome to use in many cases. <code>PDL::NiceSlice</code> rectifies that by incorporating new slicing syntax directly into the language via a perl <i>source filter</i> (see <a href="../perlfilter.html" class="podlinkpod"
>the perlfilter man page</a>). NiceSlice adds no new functionality, only convenient syntax.</p>

<p>NiceSlice is loaded automatically in the perldl or pdl2 shell, but (to avoid conflicts with other modules) must be loaded explicitly in standalone perl/PDL scripts (see below). If you prefer not to use a prefilter on your standalone scripts, you can use the <a href="../PDL/Slices.html#slice" class="podlinkpod"
>slice</a> method in those scripts, rather than the more compact NiceSlice constructs.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Use_in_scripts_and_perldl_or_pdl2_shell"
>Use in scripts and <code>perldl</code> or <code>pdl2</code> shell</a></h1>

<p>The new slicing syntax can be switched on and off in scripts and perl modules by using or unloading <code>PDL::NiceSlice</code>.</p>

<p>But now back to scripts and modules. Everything after <code>use PDL::NiceSlice</code> will be translated and you can use the new slicing syntax. Source filtering will continue until the end of the file is encountered. You can stop sourcefiltering before the end of the file by issuing a <code>no PDL::NiceSlice</code> statement.</p>

<p>Here is an example:</p>

<pre>  use PDL::NiceSlice;

  # this code will be translated
  # and you can use the new slicing syntax

  no PDL::NiceSlice;

  # this code won&#39;t
  # and the new slicing syntax will raise errors!</pre>

<p>See also <a href="../Filter/Simple.html" class="podlinkpod"
>Filter::Simple</a> and <em>example</em> in this distribution for further examples.</p>

<p>NOTE: Unlike &#34;normal&#34; modules you need to include a <code>use PDL::NiceSlice</code> call in each and every file that contains code that uses the new slicing syntax. Imagine the following situation: a file <em>test0.pl</em></p>

<pre>   # start test0.pl
   use PDL;
   use PDL::NiceSlice;

   $a = sequence 10;
   print $a(0:4),&#34;\n&#34;;

   require &#39;test1.pl&#39;;
   # end test0.pl</pre>

<p>that <code>require</code>s a second file <em>test1.pl</em></p>

<pre>   # begin test1.pl
   $aa = sequence 11;
   print $aa(0:7),&#34;\n&#34;;
   1;
   # end test1.pl</pre>

<p>Following conventional perl wisdom everything should be alright since we <code>use</code>d <code>PDL</code> and <code>PDL::NiceSlice</code> already from within <em>test0.pl</em> and by the time <em>test1.pl</em> is <code>require</code>d things should be defined and imported, etc. A quick test run will, however, produce something like the following:</p>

<pre>  perl test0.pl
 [0 1 2 3 4]
 syntax error at test1.pl line 3, near &#34;0:&#34;
 Compilation failed in require at test0.pl line 7.</pre>

<p>This can be fixed by adding the line</p>

<pre>  use PDL::NiceSlice;</pre>

<p><code>before</code> the code in <em>test1.pl</em> that uses the new slicing syntax (to play safe just include the line near the top of the file), e.g.</p>

<pre>   # begin corrected test1.pl
   use PDL::NiceSlice;
   $aa = sequence 11;
   print $aa(0:7),&#34;\n&#34;;
   1;
   # end test1.pl</pre>

<p>Now things proceed more smoothly</p>

<pre>  perl test0.pl
 [0 1 2 3 4]
 [0 1 2 3 4 5 6 7]</pre>

<p>Note that we don&#39;t need to issue <code>use PDL</code> again. <code>PDL::NiceSlice</code> is a somewhat <i>funny</i> module in that respect. It is a consequence of the way source filtering works in Perl (see also the IMPLEMENTATION section below).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="evals_and_PDL::NiceSlice"
>evals and <code>PDL::NiceSlice</code></a></h2>

<p>Due to <code>PDL::NiceSlice</code> being a source filter it won&#39;t work in the usual way within evals. The following will <i>not</i> do what you want:</p>

<pre>  $a = sequence 10;
  eval &#60;&#60; &#39;EOE&#39;;

  use PDL::NiceSlice;
  $b = $a(0:5);

  EOE
  print $b;</pre>

<p>Instead say:</p>

<pre>  use PDL::NiceSlice;
  $a = sequence 10;
  eval &#60;&#60; &#39;EOE&#39;;

  $b = $a(0:5);

  EOE
  print $b;</pre>

<p>Source filters <i>must</i> be executed at compile time to be effective. And <code>PDL::NiceFilter</code> is just a source filter (although it is not necessarily obvious for the casual user).</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="The_new_slicing_syntax"
>The new slicing syntax</a></h1>

<p>Using <code>PDL::NiceSlice</code> slicing piddles becomes so much easier since, first of all, you don&#39;t need to make explicit method calls. No</p>

<pre>  $pdl-&#62;slice(....);</pre>

<p>calls, etc. Instead, <code>PDL::NiceSlice</code> introduces two ways in which to slice piddles without too much typing:</p>

<ul>
<li>using parentheses directly following a scalar variable name, for example
<pre>   $c = $b(0:-3:4,(0));</pre>
</li>

<li>using the so called <i>default method</i> invocation in which the piddle object is treated as if it were a reference to a subroutine (see also <a href="../perlref.html" class="podlinkpod"
>perlref</a>). Take this example that slices a piddle that is part of a perl list <code>@b</code>:
<pre>  $c = $b[0]-&#62;(0:-3:4,(0));</pre>
</li>
</ul>

<p>The format of the argument list is the same for both types of invocation and will be explained in more detail below.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Parentheses_following_a_scalar_variable_name"
>Parentheses following a scalar variable name</a></h2>

<p>An arglist in parentheses following directly after a scalar variable name that is <i>not</i> preceded by <code>&#38;</code> will be resolved as a slicing command, e.g.</p>

<pre>  $a(1:4) .= 2;         # only use this syntax on piddles
  $sum += $a(,(1));</pre>

<p>However, if the variable name is immediately preceded by a <code>&#38;</code>, for example</p>

<pre>  &#38;$a(4,5);</pre>

<p>it will not be interpreted as a slicing expression. Rather, to avoid interfering with the current subref syntax, it will be treated as an invocation of the code reference <code>$a</code> with argumentlist <code>(4,5)</code>.</p>

<p>The $a(ARGS) syntax collides in a minor way with the perl syntax. In particular, ``foreach $var(LIST)&#39;&#39; appears like a PDL slicing call. NiceSlice avoids translating the ``for $var(LIST)&#39;&#39; and ``foreach $var(LIST)&#39;&#39; constructs for this reason. Since you can&#39;t use just any old lvalue expression in the &#39;foreach&#39; &#39;for&#39; constructs -- only a real perl scalar will do -- there&#39;s no functionality lost. If later versions of perl accept ``foreach &#60;lvalue-expr&#62; (LIST)&#39;&#39;, then you can use the code ref syntax, below, to get what you want.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_default_method_syntax"
>The <i>default method</i> syntax</a></h2>

<p>The second syntax that will be recognized is what I called the <i>default method</i> syntax. It is the method arrow <code>-&#62;</code> directly followed by an open parenthesis, e.g.</p>

<pre>  $a-&#62;xchg(0,1)-&#62;(($pos)) .= 0;</pre>

<p>Note that this conflicts with the use of normal code references, since you can write in plain Perl</p>

<pre>  $sub = sub { print join &#39;,&#39;, @_ };
  $sub-&#62;(1,&#39;a&#39;);</pre>

<p>NOTE: Once <code>use PDL::NiceSlice</code> is in effect (you can always switch it off with a line <code>no PDL::NiceSlice;</code> anywhere in the script) the source filter will incorrectly replace the above call to <code>$sub</code> with an invocation of the slicing method. This is one of the pitfalls of using a source filter that doesn&#39;t know anything about the runtime type of a variable (cf. the Implementation section).</p>

<p>This shouldn&#39;t be a major problem in practice; a simple workaround is to use the <code>&#38;</code>-way of calling subrefs, e.g.:</p>

<pre>  $sub = sub { print join &#39;,&#39;, @_ };
  &#38;$sub(1,&#39;a&#39;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="When_to_use_which_syntax?"
>When to use which syntax?</a></h2>

<p>Why are there two different ways to invoke slicing? The first syntax <code>$a(args)</code> doesn&#39;t work with chained method calls. E.g.</p>

<pre>  $a-&#62;xchg(0,1)(0);</pre>

<p>won&#39;t work. It can <i>only</i> be used directly following a valid perl variable name. Instead, use the <i>default method</i> syntax in such cases:</p>

<pre>  $a-&#62;xchg(0,1)-&#62;(0);</pre>

<p>Similarly, if you have a list of piddles <code>@pdls</code>:</p>

<pre>  $b = $pdls[5]-&#62;(0:-1);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_argument_list"
>The argument list</a></h2>

<p>The argument list is a comma separated list. Each argument specifies how the corresponding dimension in the piddle is sliced. In contrast to usage of the <a href="../PDL/Slices.html#slice" class="podlinkpod"
>slice</a> method the arguments should <i>not</i> be quoted. Rather freely mix literals (1,3,etc), perl variables and function invocations, e.g.</p>

<pre>  $a($pos-1:$end,myfunc(1,3)) .= 5;</pre>

<p>There can even be other slicing commands in the arglist:</p>

<pre>  $a(0:-1:$pdl($step)) *= 2;</pre>

<p>NOTE: If you use function calls in the arglist make sure that you use parentheses around their argument lists. Otherwise the source filter will get confused since it splits the argument list on commas that are not protected by parentheses. Take the following example:</p>

<pre>  sub myfunc { return 5*$_[0]+$_[1] }
  $a = sequence 10;
  $sl = $a(0:myfunc 1, 2);
  print $sl;
 PDL barfed: Error in slice:Too many dims in slice
 Caught at file /usr/local/bin/perldl, line 232, pkg main</pre>

<p>The simple fix is</p>

<pre>  $sl = $a(0:myfunc(1, 2));
  print $sl;
 [0 1 2 3 4 5 6 7]</pre>

<p>Note that using prototypes in the definition of myfunc does not help. At this stage the source filter is simply not intelligent enough to make use of this information. So beware of this subtlety.</p>

<p>Another pitfall to be aware of: currently, you can&#39;t use the conditional operator in slice expressions (i.e., <code>?:</code>, since the parser confuses them with ranges). For example, the following will cause an error:</p>

<pre>  $a = sequence 10;
  $b = rand &#62; 0.5 ? 0 : 1; # this one is ok
  print $a($b ? 1 : 2);    # error !
 syntax error at (eval 59) line 3, near &#34;1,</pre>

<p>For the moment, just try to stay clear of the conditional operator in slice expressions (or provide us with a patch to the parser to resolve this issue ;).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Modifiers"
>Modifiers</a></h2>

<p>Following a suggestion originally put forward by Karl Glazebrook the latest versions of <code>PDL::NiceSlice</code> implement <i>modifiers</i> in slice expressions. Modifiers are convenient shorthands for common variations on PDL slicing. The general syntax is</p>

<pre>    $pdl(&#60;slice&#62;;&#60;modifier&#62;)</pre>

<p>Four modifiers are currently implemented:</p>

<ul>
<li><code>_</code> : <i>flatten</i> the piddle before applying the slice expression. Here is an example
<pre>   $b = sequence 3, 3;
   print $b(0:-2;_); # same as $b-&#62;flat-&#62;(0:-2)
 [0 1 2 3 4 5 6 7]</pre>

<p>which is quite different from the same slice expression without the modifier</p>

<pre>   print $b(0:-2);
 [
  [0 1]
  [3 4]
  [6 7]
 ]</pre>
</li>

<li><code>|</code> : <a href="../PDL/Core.html#sever" class="podlinkpod"
>sever</a> the link to the piddle, e.g.
<pre>   $a = sequence 10;
   $b = $a(0:2;|)++;  # same as $a(0:2)-&#62;sever++
   print $b;
 [1 2 3]
   print $a; # check if $a has been modified
 [0 1 2 3 4 5 6 7 8 9]</pre>
</li>

<li><code>?</code> : short hand to indicate that this is really a <a href="../PDL/Primitive.html#where" class="podlinkpod"
>where</a> expression
<p>As expressions like</p>

<pre>  $a-&#62;where($a&#62;5)</pre>

<p>are used very often you can write that shorter as</p>

<pre>  $a($a&#62;5;?)</pre>

<p>With the <code>?</code>-modifier the expression preceding the modifier is <i>not</i> really a slice expression (e.g. ranges are not allowed) but rather an expression as required by the <a href="../PDL/Primitive.html#where" class="podlinkpod"
>where</a> method. For example, the following code will raise an error:</p>

<pre>  $a = sequence 10;
  print $a(0:3;?);
 syntax error at (eval 70) line 3, near &#34;0:&#34;</pre>

<p>That&#39;s about all there is to know about this one.</p>
</li>

<li><code>-</code> : <i>squeeze</i> out any singleton dimensions. In less technical terms: reduce the number of dimensions (potentially) by deleting all dims of size 1. It is equivalent to doing a <a href="../PDL/Core.html#reshape" class="podlinkpod"
>reshape</a>(-1). That can be very handy if you want to simplify the results of slicing operations:
<pre>  $a = ones 3, 4, 5;
  $b = $a(1,0;-); # easier to type than $a((1),(0))
  print $b-&#62;info;
 PDL: Double D [5]</pre>

<p>It also provides a unique opportunity to have smileys in your code! Yes, PDL gives new meaning to smileys.</p>
</li>
</ul>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Combining_modifiers"
>Combining modifiers</a></h2>

<p>Several modifiers can be used in the same expression, e.g.</p>

<pre>  $c = $a(0;-|); # squeeze and sever</pre>

<p>Other combinations are just as useful, e.g. <code>;_|</code> to flatten and sever. The sequence in which modifiers are specified is not important.</p>

<p>A notable exception is the <code>where</code> modifier (<code>?</code>) which must not be combined with other flags (let me know if you see a good reason to relax this rule).</p>

<p>Repeating any modifier will raise an error:</p>

<pre>  $c = $a(-1:1;|-|); # will cause error
 NiceSlice error: modifier | used twice or more</pre>

<p>Modifiers are still a new and experimental feature of <code>PDL::NiceSlice</code>. I am not sure how many of you are actively using them. <i>Please do so and experiment with the syntax</i>. I think modifiers are very useful and make life a lot easier. Feedback is welcome as usual. The modifier syntax will likely be further tuned in the future but we will attempt to ensure backwards compatibility whenever possible.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Argument_formats"
>Argument formats</a></h2>

<p>In slice expressions you can use ranges and secondly, piddles as 1D index lists (although compare the description of the <code>?</code>-modifier above for an exception).</p>

<ul>
<li>ranges
<p>You can access ranges using the usual <code>:</code> separated format:</p>

<pre>  $a($start:$stop:$step) *= 4;</pre>

<p>Note that you can omit the trailing step which then defaults to 1. Double colons (<code>::</code>) are not allowed to avoid clashes with Perl&#39;s namespace syntax. So if you want to use steps different from the default you have to also at least specify the stop position. Examples:</p>

<pre>  $a(::2);   # this won&#39;t work (in the way you probably intended)
  $a(:-1:2); # this will select every 2nd element in the 1st dim</pre>

<p>Just as with <a href="../PDL/Slices.html#slice" class="podlinkpod"
>slice</a> negative indices count from the end of the dimension backwards with <code>-1</code> being the last element. If the start index is larger than the stop index the resulting piddle will have the elements in reverse order between these limits:</p>

<pre>  print $a(-2:0:2);
 [8 6 4 2 0]</pre>

<p>A single index just selects the given index in the slice</p>

<pre>  print $a(5);
 [5]</pre>

<p>Note, however, that the corresponding dimension is not removed from the resulting piddle but rather reduced to size 1:</p>

<pre>  print $a(5)-&#62;info
 PDL: Double D [1]</pre>

<p>If you want to get completely rid of that dimension enclose the index in parentheses (again similar to the <a href="../PDL/Slices.html#slice" class="podlinkpod"
>slice</a> syntax):</p>

<pre>  print $a((5));
 5</pre>

<p>In this particular example a 0D piddle results. Note that this syntax is only allowed with a single index. All these will be errors:</p>

<pre>  print $a((0,4));  # will work but not in the intended way
  print $a((0:4));  # compile time error</pre>

<p>An empty argument selects the whole dimension, in this example all of the first dimension:</p>

<pre>  print $a(,(0));</pre>

<p>Alternative ways to select a whole dimension are</p>

<pre>  $a = sequence 5, 5; 
  print $a(:,(0));
  print $a(0:-1,(0));
  print $a(:-1,(0));
  print $a(0:,(0));</pre>

<p>Arguments for trailing dimensions can be omitted. In that case these dimensions will be fully kept in the sliced piddle:</p>

<pre>  $a = random 3,4,5;
  print $a-&#62;info;
 PDL: Double D [3,4,5]
  print $a((0))-&#62;info;
 PDL: Double D [4,5]
  print $a((0),:,:)-&#62;info;  # a more explicit way
 PDL: Double D [4,5]
  print $a((0),,)-&#62;info;    # similar
 PDL: Double D [4,5]</pre>
</li>

<li>dummy dimensions
<p>As in <a href="../slice.html" class="podlinkpod"
>slice</a>, you can insert a dummy dimension by preceding a single index argument with &#39;*&#39;. A lone &#39;*&#39; inserts a dummy dimension of order 1; a &#39;*&#39; followed by a number inserts a dummy dimension of that order.</p>
</li>

<li>piddle index lists
<p>The second way to select indices from a dimension is via 1D piddles of indices. A simple example:</p>

<pre>  $a = random 10;
  $idx = long 3,4,7,0;
  $b = $a($idx);</pre>

<p>This way of selecting indices was previously only possible using <a href="../PDL/Slices.html#dice" class="podlinkpod"
>dice</a> (<code>PDL::NiceSlice</code> attempts to unify the <code>slice</code> and <code>dice</code> interfaces). Note that the indexing piddles must be 1D or 0D. Higher dimensional piddles as indices will raise an error:</p>

<pre>  $a = sequence 5, 5;
  $idx2 = ones 2,2;
  $sum = $a($idx2)-&#62;sum;
 piddle must be &#60;= 1D at /home/XXXX/.perldlrc line 93</pre>

<p>Note that using index piddles is not as efficient as using ranges. If you can represent the indices you want to select using a range use that rather than an equivalent index piddle. In particular, memory requirements are increased with index piddles (and execution time <i>may</i> be longer). That said, if an index piddle is the way to go use it!</p>
</li>
</ul>

<p>As you might have expected ranges and index piddles can be freely mixed in slicing expressions:</p>

<pre>  $a = random 5, 5;
  $b = $a(-1:2,pdl(3,0,1));</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="piddles_as_indices_in_ranges"
>piddles as indices in ranges</a></h2>

<p>You can use piddles to specify indices in ranges. No need to turn them into proper perl scalars with the new slicing syntax. However, make sure they contain not more than one element! Otherwise a runtime error will be triggered. First a couple of examples that illustrate proper usage:</p>

<pre>  $a = sequence 5, 5;
  $rg = pdl(1,-1,3);
  print $a($rg(0):$rg(1):$rg(2),2);
 [
  [11 14]
 ]
  print $a($rg+1,:$rg(0));
 [
  [2 0 4]
  [7 5 9]
 ]</pre>

<p>The next one raises an error</p>

<pre>  print $a($rg+1,:$rg(0:1));
 multielement piddle where only one allowed at XXX/Core.pm line 1170.</pre>

<p>The problem is caused by using the 2-element piddle <code>$rg(0:1)</code> as the stop index in the second argument <code>:$rg(0:1)</code> that is interpreted as a range by <code>PDL::NiceSlice</code>. You <i>can</i> use multielement piddles as index piddles as described above but not in ranges. And <code>PDL::NiceSlice</code> treats any expression with unprotected <code>:</code>&#39;s as a range. <i>Unprotected</i> means as usual <i>&#34;not occurring between matched parentheses&#34;</i>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="IMPLEMENTATION"
>IMPLEMENTATION</a></h1>

<p><code>PDL::NiceSlice</code> exploits the ability of Perl to use source filtering (see also <a href="../perlfilter.html" class="podlinkpod"
>perlfilter</a>). A source filter basically filters (or rewrites) your perl code before it is seen by the compiler. <code>PDL::NiceSlice</code> searches through your Perl source code and when it finds the new slicing syntax it rewrites the argument list appropriately and splices a call to the <code>nslice</code> method using the modified arg list into your perl code. You can see how this works in the <a href="../perldl.html" class="podlinkpod"
>perldl</a> or <a href="../PDL/Perldl2.html" class="podlinkpod"
>pdl2</a> shells by switching on reporting (see above how to do that).</p>

<p>The <code>nslice</code> method is an extended version of <a href="../PDL/Core.html#mslice" class="podlinkpod"
>mslice</a> that knows how to deal with index piddles (and therefore combines slicing and dicing). Full documentation of <code>nslice</code> will be in the next PDL release.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Conditional_operator"
>Conditional operator</a></h2>

<p>The conditional operator can&#39;t be used in slice expressions (see above).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_DATA_file_handle"
>The <code>DATA</code> file handle</a></h2>

<p><i>Note</i>: To avoid clobbering the <code>DATA</code> filehandle <code>PDL::NiceSlice</code> switches itself off when encountering the <code>__END__</code> or <code>__DATA__</code> tokens. This should not be a problem for you unless you use <code>SelfLoader</code> to load PDL code including the new slicing from that section. It is even desirable when working with <a href="../Inline/Pdlpp.html" class="podlinkpod"
>Inline::Pdlpp</a>, see below.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Possible_interaction_with_Inline::Pdlpp"
>Possible interaction with <a href="../Inline/Pdlpp.html" class="podlinkpod"
>Inline::Pdlpp</a></a></h2>

<p>There is currently an undesired interaction between <code>PDL::NiceSlice</code> and the new <a href="../Inline/Pdlpp.html" class="podlinkpod"
>Inline::Pdlpp</a> module (currently only in PDL CVS). Since PP code generally contains expressions of the type <code>$var()</code> (to access piddles, etc) <code>PDL::NiceSlice</code> recognizes those <i>incorrectly</i> as slice expressions and does its substitutions. This is not a problem if you use the <code>DATA</code> section for your Pdlpp code -- the recommended place for Inline code anyway. In that case <code>PDL::NiceSlice</code> will have switched itself off before encountering any Pdlpp code (see above):</p>

<pre>    # use with Inline modules
  use PDL;
  use PDL::NiceSlice;
  use Inline Pdlpp;

  $a = sequence(10);
  print $a(0:5);

  __END__

  __Pdlpp__

  ... inline stuff</pre>

<p>Otherwise switch <code>PDL::NiceSlice</code> explicitly off around the Inline::Pdlpp code:</p>

<pre>  use PDL::NiceSlice;

  $a = sequence 10;
  $a(0:3)++;
  $a-&#62;inc;

  no PDL::NiceSlice; # switch off before Pdlpp code
  use Inline Pdlpp =&#62; &#34;Pdlpp source code&#34;;</pre>

<p>The cleaner solution is to always stick with the <code>DATA</code> way of including your <code>Inline</code> code as in the first example. That way you keep your nice Perl code at the top and all the ugly Pdlpp stuff etc at the bottom.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Bug_reports"
>Bug reports</a></h2>

<p>Feedback and bug reports are welcome. Please include an example that demonstrates the problem. Log bug reports in the PDL bug database at</p>

<pre>  http://sourceforge.net/bugs/?group_id=612</pre>

<p>or send them to the pdl-porters mailing list &#60;pdl-porters@jach.hawaii.edu&#62;.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright (c) 2001, 2002 Christian Soeller. All Rights Reserved. This module is free software. It may be used, redistributed and/or modified under the same terms as PDL itself (see <a href="http://pdl.perl.org" class="podlinkurl"
>http://pdl.perl.org</a>).</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
