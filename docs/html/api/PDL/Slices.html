<html><head><title>PDL::Slices</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:24 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#FUNCTIONS'>FUNCTIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#s_identity'>s_identity</a>
    <li class='indexItem indexItem2'><a href='#index'>index</a>
    <li class='indexItem indexItem2'><a href='#index2d'>index2d</a>
    <li class='indexItem indexItem2'><a href='#indexNDb'>indexNDb</a>
    <li class='indexItem indexItem2'><a href='#indexND'>indexND</a>
    <li class='indexItem indexItem2'><a href='#rangeb'>rangeb</a>
    <li class='indexItem indexItem2'><a href='#range'>range</a>
    <li class='indexItem indexItem2'><a href='#rld'>rld</a>
    <li class='indexItem indexItem2'><a href='#rle'>rle</a>
    <li class='indexItem indexItem2'><a href='#xchg'>xchg</a>
    <li class='indexItem indexItem2'><a href='#reorder'>reorder</a>
    <li class='indexItem indexItem2'><a href='#mv'>mv</a>
    <li class='indexItem indexItem2'><a href='#oneslice'>oneslice</a>
    <li class='indexItem indexItem2'><a href='#slice'>slice</a>
    <li class='indexItem indexItem2'><a href='#using'>using</a>
    <li class='indexItem indexItem2'><a href='#diagonalI'>diagonalI</a>
    <li class='indexItem indexItem2'><a href='#lags'>lags</a>
    <li class='indexItem indexItem2'><a href='#splitdim'>splitdim</a>
    <li class='indexItem indexItem2'><a href='#rotate'>rotate</a>
    <li class='indexItem indexItem2'><a href='#threadI'>threadI</a>
    <li class='indexItem indexItem2'><a href='#identvaff'>identvaff</a>
    <li class='indexItem indexItem2'><a href='#unthread'>unthread</a>
    <li class='indexItem indexItem2'><a href='#dice'>dice</a>
    <li class='indexItem indexItem2'><a href='#dice_axis'>dice_axis</a>
  </ul>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>PDL::Slices -- Indexing,
slicing,
and dicing</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use PDL;
  $a = ones(3,3);
  $b = $a-&#62;slice(&#39;-1:0,(1)&#39;);
  $c = $a-&#62;dummy(2);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This package provides many of the powerful PerlDL core index manipulation routines. These routines mostly allow two-way data flow, so you can modify your data in the most convenient representation. For example, you can make a 1000x1000 unit matrix with</p>

<pre> $a = zeroes(1000,1000);
 $a-&#62;diagonal(0,1) ++;</pre>

<p>which is quite efficient. See <a href="../PDL/Indexing.html" class="podlinkpod"
>PDL::Indexing</a> and <a href="../PDL/Tips.html" class="podlinkpod"
>PDL::Tips</a> for more examples.</p>

<p>Slicing is so central to the PDL language that a special compile-time syntax has been introduced to handle it compactly; see <a href="../PDL/NiceSlice.html" class="podlinkpod"
>PDL::NiceSlice</a> for details.</p>

<p>PDL indexing and slicing functions usually include two-way data flow, so that you can separate the actions of reshaping your data structures and modifying the data themselves. Two special methods, <a href="../copy.html" class="podlinkpod"
>copy</a> and <a href="../sever.html" class="podlinkpod"
>sever</a>, help you control the data flow connection between related variables.</p>

<pre> $b = $a-&#62;slice(&#34;1:3&#34;); # Slice maintains a link between $a and $b.
 $b += 5;               # $a is changed!</pre>

<p>If you want to force a physical copy and no data flow, you can copy or sever the slice expression:</p>

<pre> $b = $a-&#62;slice(&#34;1:3&#34;)-&#62;copy;
 $b += 5;               # $a is not changed.

 $b = $a-&#62;slice(&#34;1:3&#34;)-&#62;sever;
 $b += 5;               # $a is not changed.</pre>

<p>The difference between <code>sever</code> and <code>copy</code> is that sever acts on (and returns) its argument, while copy produces a disconnected copy. If you say</p>

<pre> $b = $a-&#62;slice(&#34;1:3&#34;);
 $c = $b-&#62;sever;</pre>

<p>then the variables <code>$b</code> and <code>$c</code> point to the same object but with <code>-&#62;copy</code> they would not.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FUNCTIONS"
>FUNCTIONS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="s_identity"
>s_identity</a></h2>

<pre>  Signature: (P(); C())</pre>

<p>Internal vaffine identity function.</p>

<p>s_identity processes bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="index"
>index</a></h2>

<pre>  Signature: (a(n); int ind(); [oca] c())</pre>

<p><code>index</code> and <code>index2d</code> provide rudimentary index indirection.</p>

<pre> $c = index($source,$ind);
 $c = index2d($source2,$ind1,$ind2);</pre>

<p>use the <code>$ind</code> variables as indices to look up values in <code>$source</code>. <code>index2d</code> uses separate piddles for X and Y coordinates. For more general N-dimensional indexing, see <a href="../PDL/Slices.html" class="podlinkpod"
>PDL::Slices</a> or the <a href="../PDL/NiceSlice.html" class="podlinkpod"
>PDL::NiceSlice</a> syntax.</p>

<p>These functions are two-way, i.e. after</p>

<pre> $c = $a-&#62;index(pdl[0,5,8]);
 $c .= pdl [0,2,4];</pre>

<p>the changes in <code>$c</code> will flow back to <code>$a</code>.</p>

<p><code>index</code> provids simple threading: multiple-dimensioned arrays are treated as collections of 1-D arrays, so that</p>

<pre> $a = xvals(10,10)+10*yvals(10,10);
 $b = $a-&#62;index(3);
 $c = $a-&#62;index(9-xvals(10));</pre>

<p>puts a single column from <code>$a</code> into <code>$b</code>, and puts a single element from each column of <code>$a</code> into <code>$c</code>. If you want to extract multiple columns from an array in one operation, see <a href="#dice" class="podlinkpod"
>dice</a> or <a href="#indexND" class="podlinkpod"
>indexND</a>.</p>

<p>index barfs if any of the index values are bad.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="index2d"
>index2d</a></h2>

<pre>  Signature: (a(na,nb); int inda(); int indb(); [oca] c())</pre>

<p><code>index</code> and <code>index2d</code> provide rudimentary index indirection.</p>

<pre> $c = index($source,$ind);
 $c = index2d($source2,$ind1,$ind2);</pre>

<p>use the <code>$ind</code> variables as indices to look up values in <code>$source</code>. <code>index2d</code> uses separate piddles for X and Y coordinates. For more general N-dimensional indexing, see <a href="../PDL/Slices.html" class="podlinkpod"
>PDL::Slices</a> or the <a href="../PDL/NiceSlice.html" class="podlinkpod"
>PDL::NiceSlice</a> syntax.</p>

<p>These functions are two-way, i.e. after</p>

<pre> $c = $a-&#62;index(pdl[0,5,8]);
 $c .= pdl [0,2,4];</pre>

<p>the changes in <code>$c</code> will flow back to <code>$a</code>.</p>

<p><code>index</code> provids simple threading: multiple-dimensioned arrays are treated as collections of 1-D arrays, so that</p>

<pre> $a = xvals(10,10)+10*yvals(10,10);
 $b = $a-&#62;index(3);
 $c = $a-&#62;index(9-xvals(10));</pre>

<p>puts a single column from <code>$a</code> into <code>$b</code>, and puts a single element from each column of <code>$a</code> into <code>$c</code>. If you want to extract multiple columns from an array in one operation, see <a href="#dice" class="podlinkpod"
>dice</a> or <a href="#indexND" class="podlinkpod"
>indexND</a>.</p>

<p>index2d barfs if either of the index values are bad.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="indexNDb"
>indexNDb</a></h2>

<pre>  Backwards-compatibility alias for indexND</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="indexND"
>indexND</a></h2>

<pre>  Find selected elements in an N-D piddle, with optional boundary handling</pre>

<pre>  $out = $source-&#62;indexND( $index, [$method] )

  $source = 10*xvals(10,10) + yvals(10,10);
  $index  = pdl([[2,3],[4,5]],[[6,7],[8,9]]);
  print $source-&#62;indexND( $index );

  [
   [23 45]
   [67 89]
  ]</pre>

<p>IndexND collapses <code>$index</code> by lookup into <code>$source</code>. The 0th dimension of <code>$index</code> is treated as coordinates in <code>$source</code>, and the return value has the same dimensions as the rest of <code>$index</code>. The returned elements are looked up from <code>$source</code>. Dataflow works -- propagated assignment flows back into <code>$source</code>.</p>

<p>IndexND and IndexNDb were originally separate routines but they are both now implemented as a call to <a href="#range" class="podlinkpod"
>range</a>, and have identical syntax to one another.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="rangeb"
>rangeb</a></h2>

<pre>  Signature: (P(); C(); SV *index; SV *size; SV *boundary)</pre>

<p>Engine for <a href="#range" class="podlinkpod"
>range</a></p>

<p>Same calling convention as <a href="#range" class="podlinkpod"
>range</a>, but you must supply all parameters. <code>rangeb</code> is marginally faster as it makes a direct PP call, avoiding the perl argument-parsing step.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="range"
>range</a></h2>

<p>Extract selected chunks from a source piddle, with boundary conditions</p>

<pre>        $out = $source-&#62;range($index,[$size,[$boundary]])</pre>

<p>Returns elements or rectangular slices of the original piddle, indexed by the <code>$index</code> piddle. <code>$source</code> is an N-dimensional piddle, and <code>$index</code> is a piddle whose first dimension has size up to N. Each row of <code>$index</code> is treated as coordinates of a single value or chunk from <code>$source</code>, specifying the location(s) to extract.</p>

<p>If you specify a single index location, then range is essentially an expensive slice, with controllable boundary conditions.</p>

<p><b>INPUTS</b></p>

<p><code>$index</code> and <code>$size</code> can be piddles or array refs such as you would feed to <a href="../PDL/Core.html#zeroes" class="podlinkpod"
>zeroes</a> and its ilk. If <code>$index</code>&#39;s 0th dimension has size higher than the number of dimensions in <code>$source</code>, then <code>$source</code> is treated as though it had trivial dummy dimensions of size 1, up to the required size to be indexed by <code>$index</code> -- so if your source array is 1-D and your index array is a list of 3-vectors, you get two dummy dimensions of size 1 on the end of your source array.</p>

<p>You can extract single elements or N-D rectangular ranges from <code>$source</code>, by setting <code>$size</code>. If <code>$size</code> is undef or zero, then you get a single sample for each row of <code>$index</code>. This behavior is similar to <a href="#indexNDb" class="podlinkpod"
>indexNDb</a>, which is in fact implemented as a call to <a href="#range" class="podlinkpod"
>range</a>.</p>

<p>If <code>$size</code> is positive then you get a range of values from <code>$source</code> at each location, and the output has extra dimensions allocated for them. <code>$size</code> can be a scalar, in which case it applies to all dimensions, or an N-vector, in which case each element is applied independently to the corresponding dimension in <code>$source</code>. See below for details.</p>

<p><code>$boundary</code> is a number, string, or list ref indicating the type of boundary conditions to use when ranges reach the edge of <code>$source</code>. If you specify no boundary conditions the default is to forbid boundary violations on all axes. If you specify exactly one boundary condition, it applies to all axes. If you specify more (as elements of a list ref, or as a packed string, see below), then they apply to dimensions in the order in which they appear, and the last one applies to all subsequent dimensions. (This is less difficult than it sounds; see the examples below).</p>

<dl>
<dt><a name="0_(synonyms:_&#39;f&#39;,&#39;forbid&#39;)_(default)"
>0 (synonyms: &#39;f&#39;,&#39;forbid&#39;) <b>(default)</b></a></dt>

<dd>
<p>Ranges are not allowed to cross the boundary of the original PDL. Disallowed ranges throw an error. The errors are thrown at evaluation time, not at the time of the range call (this is the same behavior as <a href="#slice" class="podlinkpod"
>slice</a>).</p>

<dt><a name="1_(synonyms:_&#39;t&#39;,&#39;truncate&#39;)"
>1 (synonyms: &#39;t&#39;,&#39;truncate&#39;)</a></dt>

<dd>
<p>Values outside the original piddle get BAD if you&#39;ve got bad value support compiled into your PDL and set the badflag for the source PDL; or 0 if you haven&#39;t (you must set the badflag if you want BADs for out of bound values, otherwise you get 0). Reverse dataflow works OK for the portion of the child that is in-bounds. The out-of-bounds part of the child is reset to (BAD|0) during each dataflow operation, but execution continues.</p>

<dt><a name="2_(synonyms:_&#39;e&#39;,&#39;x&#39;,&#39;extend&#39;)"
>2 (synonyms: &#39;e&#39;,&#39;x&#39;,&#39;extend&#39;)</a></dt>

<dd>
<p>Values that would be outside the original piddle point instead to the nearest allowed value within the piddle. See the CAVEAT below on mappings that are not single valued.</p>

<dt><a name="3_(synonyms:_&#39;p&#39;,&#39;periodic&#39;)"
>3 (synonyms: &#39;p&#39;,&#39;periodic&#39;)</a></dt>

<dd>
<p>Periodic boundary conditions apply: the numbers in $index are applied, strict-modulo the corresponding dimensions of $source. This is equivalent to duplicating the $source piddle throughout N-D space. See the CAVEAT below about mappings that are not single valued.</p>

<dt><a name="4_(synonyms:_&#39;m&#39;,&#39;mirror&#39;)"
>4 (synonyms: &#39;m&#39;,&#39;mirror&#39;)</a></dt>

<dd>
<p>Mirror-reflection periodic boundary conditions apply. See the CAVEAT below about mappings that are not single valued.</p>
</dd>
</dl>

<p>The boundary condition identifiers all begin with unique characters, so you can feed in multiple boundary conditions as either a list ref or a packed string. (The packed string is marginally faster to run). For example, the four expressions [0,1], [&#39;forbid&#39;,&#39;truncate&#39;], [&#39;f&#39;,&#39;t&#39;], and &#39;ft&#39; all specify that violating the boundary in the 0th dimension throws an error, and all other dimensions get truncated.</p>

<p>If you feed in a single string, it is interpreted as a packed boundary array if all of its characters are valid boundary specifiers (e.g. &#39;pet&#39;), but as a single word-style specifier if they are not (e.g. &#39;forbid&#39;).</p>

<p><b>OUTPUT</b></p>

<p>The output threads over both <code>$index</code> and <code>$source</code>. Because implicit threading can happen in a couple of ways, a little thought is needed. The returned dimension list is stacked up like this:</p>

<pre>   (index thread dims), (index dims (size)), (source thread dims)</pre>

<p>The first few dims of the output correspond to the extra dims of <code>$index</code> (beyond the 0 dim). They allow you to pick out individual ranges from a large, threaded collection.</p>

<p>The middle few dims of the output correspond to the size dims specified in <code>$size</code>, and contain the range of values that is extracted at each location in <code>$source</code>. Every nonzero element of <code>$size</code> is copied to the dimension list here, so that if you feed in (for example) <code>$size = [2,0,1]</code> you get an index dim list of <code>(2,1)</code>.</p>

<p>The last few dims of the output correspond to extra dims of <code>$source</code> beyond the number of dims indexed by <code>$index</code>. These dims act like ordinary thread dims, because adding more dims to <code>$source</code> just tacks extra dims on the end of the output. Each source thread dim ranges over the entire corresponding dim of <code>$source</code>.</p>

<p><b>Dataflow</b>: Dataflow is bidirectional.</p>

<p><b>Examples</b>: Here are basic examples of <code>range</code> operation, showing how to get ranges out of a small matrix. The first few examples show extraction and selection of individual chunks. The last example shows how to mark loci in the original matrix (using dataflow).</p>

<pre> pdl&#62; $src = 10*xvals(10,5)+yvals(10,5)
 pdl&#62; print $src-&#62;range([2,3])    # Cut out a single element
 23
 pdl&#62; print $src-&#62;range([2,3],1)  # Cut out a single 1x1 block
 [
  [23]
 ]
 pdl&#62; print $src-&#62;range([2,3], [2,1]) # Cut a 2x1 chunk
 [
  [23 33]
 ]
 pdl&#62; print $src-&#62;range([[2,3]],[2,1]) # Trivial list of 1 chunk
 [
  [
   [23]
   [33]
  ]
 ]
 pdl&#62; print $src-&#62;range([[2,3],[0,1]], [2,1])   # two 2x1 chunks
 [
  [
   [23  1]
   [33 11]
  ]
 ]
 pdl&#62; # A 2x2 collection of 2x1 chunks
 pdl&#62; print $src-&#62;range([[[1,1],[2,2]],[[2,3],[0,1]]],[2,1])
 [
  [
   [
    [11 22]
    [23  1]
   ]
   [
    [21 32]
    [33 11]
   ]
  ]
 ]
 pdl&#62; $src = xvals(5,3)*10+yvals(5,3)
 pdl&#62; print $src-&#62;range(3,1)  # Thread over y dimension in $src 
 [
  [30]
  [31]
  [32]
 ]

 pdl&#62; $src = zeroes(5,4);
 pdl&#62; $src-&#62;range(pdl([2,3],[0,1]),pdl(2,1)) .= xvals(2,2,1) + 1
 pdl&#62; print $src
 [
  [0 0 0 0 0]
  [2 2 0 0 0]
  [0 0 0 0 0]
  [0 0 1 1 0]
 ]</pre>

<p><b>CAVEAT</b>: It&#39;s quite possible to select multiple ranges that intersect. In that case, modifying the ranges doesn&#39;t have a guaranteed result in the original PDL -- the result is an arbitrary choice among the valid values. For some things that&#39;s OK; but for others it&#39;s not. In particular, this doesn&#39;t work:</p>

<pre>    pdl&#62; $photon_list = new PDL::RandVar-&#62;sample(500)-&#62;reshape(2,250)*10
    pdl&#62; histogram = zeroes(10,10)
    pdl&#62; histogram-&#62;range($photon_list,1)++;  #not what you wanted</pre>

<p>The reason is that if two photons land in the same bin, then that bin doesn&#39;t get incremented twice. (That may get fixed in a later version...)</p>

<p><b>PERMISSIVE RANGING</b>: If <code>$index</code> has too many dimensions compared to <code>$source</code>, then $source is treated as though it had dummy dimensions of size 1, up to the required number of dimensions. These virtual dummy dimensions have the usual boundary conditions applied to them.</p>

<p>If the 0 dimension of <code>$index</code> is ludicrously large (if its size is more than 5 greater than the number of dims in the source PDL) then range will insist that you specify a size in every dimension, to make sure that you know what you&#39;re doing. That catches a common error with range usage: confusing the initial dim (which is usually small) with another index dim (perhaps of size 1000).</p>

<p>If the index variable is Empty, then range() always returns the Empty PDL. If the index variable is not Empty, indexing it always yields a boundary violation. All non-barfing conditions are treated as truncation, since there are no actual data to return.</p>

<p><b>EFFICIENCY</b>: Because <code>range</code> isn&#39;t an affine transformation (it involves lookup into a list of N-D indices), it is somewhat memory-inefficient for long lists of ranges, and keeping dataflow open is much slower than for affine transformations (which don&#39;t have to copy data around).</p>

<p>Doing operations on small subfields of a large range is inefficient because the engine must flow the entire range back into the original PDL with every atomic perl operation, even if you only touch a single element. One way to speed up such code is to sever your range, so that PDL doesn&#39;t have to copy the data with each operation, then copy the elements explicitly at the end of your loop. Here&#39;s an example that labels each region in a range sequentially, using many small operations rather than a single xvals assignment:</p>

<pre>  ### How to make a collection of small ops run fast with range...
  $a =  $data-&#62;range($index, $sizes, $bound)-&#62;sever; 
  $aa = $data-&#62;range($index, $sizes, $bound);        
  map { $a($_ - 1) .= $_; } (1..$a-&#62;nelem);    # Lots of little ops
  $aa .= $a;</pre>

<p><code>range</code> is a perl front-end to a PP function, <code>rangeb</code>. Calling <code>rangeb</code> is marginally faster but requires that you include all arguments.</p>

<p>DEVEL NOTES</p>

<p>* index thread dimensions are effectively clumped internally. This makes it easier to loop over the index array but a little more brain-bending to tease out the algorithm.</p>

<p>* Currently the index threads really do run fastest in memory; this is probably the wrong direction to thread, for fastest behavior -- modifying the appropriate dimincs in RedoDims ought to take care of it.</p>

<p>rangeb processes bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="rld"
>rld</a></h2>

<pre>  Signature: (int a(n); b(n); [o]c(m))</pre>

<p>Run-length decode a vector</p>

<p>Given a vector <code>$a</code> of the numbers of instances of values <code>$b</code>, run-length decode to <code>$c</code>.</p>

<pre> rld($a,$b,$c=null);</pre>

<p>rld does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="rle"
>rle</a></h2>

<pre>  Signature: (c(n); int [o]a(n); [o]b(n))</pre>

<p>Run-length encode a vector</p>

<p>Given vector <code>$c</code>, generate a vector <code>$a</code> with the number of each element, and a vector <code>$b</code> of the unique values. Only the elements up to the first instance of <code>0</code> in <code>$a</code> should be considered.</p>

<pre> rle($c,$a=null,$b=null);</pre>

<p>rle does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="xchg"
>xchg</a></h2>

<pre>  Signature: (P(); C(); int n1; int n2)</pre>

<p>exchange two dimensions</p>

<p>Negative dimension indices count from the end.</p>

<p>The command</p>

<pre> $b = $a-&#62;xchg(2,3);</pre>

<p>creates <code>$b</code> to be like <code>$a</code> except that the dimensions 2 and 3 are exchanged with each other i.e.</p>

<pre> $b-&#62;at(5,3,2,8) == $a-&#62;at(5,3,8,2)</pre>

<p>xchg does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="reorder"
>reorder</a></h2>

<p>Re-orders the dimensions of a PDL based on the supplied list.</p>

<p>Similar to the <a href="#xchg" class="podlinkpod"
>xchg</a> method, this method re-orders the dimensions of a PDL. While the <a href="#xchg" class="podlinkpod"
>xchg</a> method swaps the position of two dimensions, the reorder method can change the positions of many dimensions at once.</p>

<pre> # Completely reverse the dimension order of a 6-Dim array.
 $reOrderedPDL = $pdl-&#62;reorder(5,4,3,2,1,0); </pre>

<p>The argument to reorder is an array representing where the current dimensions should go in the new array. In the above usage, the argument to reorder <code>(5,4,3,2,1,0)</code> indicates that the old dimensions (<code>$pdl</code>&#39;s dims) should be re-arranged to make the new pdl (<code>$reOrderPDL</code>) according to the following:</p>

<pre>   Old Position   New Position
   ------------   ------------
   5              0
   4              1
   3              2
   2              3
   1              4
   0              5</pre>

<p>You do not need to specify all dimensions, only a complete set starting at position 0. (Extra dimensions are left where they are). This means, for example, that you can reorder() the X and Y dimensions of an image, and not care whether it is an RGB image with a third dimension running across color plane.</p>

<p>Example:</p>

<pre> pdl&#62; $a = sequence(5,3,2);       # Create a 3-d Array
 pdl&#62; p $a
 [
  [
   [ 0  1  2  3  4]
   [ 5  6  7  8  9]
   [10 11 12 13 14]
  ]
  [
   [15 16 17 18 19]
   [20 21 22 23 24]
   [25 26 27 28 29]
  ]
 ]
 pdl&#62; p $a-&#62;reorder(2,1,0); # Reverse the order of the 3-D PDL
 [
  [
   [ 0 15]
   [ 5 20]
   [10 25]
  ]
  [
   [ 1 16]
   [ 6 21]
   [11 26]
  ]
  [
   [ 2 17]
   [ 7 22]
   [12 27]
  ]
  [
   [ 3 18]
   [ 8 23]
   [13 28]
  ]
  [
   [ 4 19]
   [ 9 24]
   [14 29]
  ]
 ]</pre>

<p>The above is a simple example that could be duplicated by calling <code>$a-&#62;xchg(0,2)</code>, but it demonstrates the basic functionality of reorder.</p>

<p>As this is an index function, any modifications to the result PDL will change the parent.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="mv"
>mv</a></h2>

<pre>  Signature: (P(); C(); int n1; int n2)</pre>

<p>move a dimension to another position</p>

<p>The command</p>

<pre> $b = $a-&#62;mv(4,1);</pre>

<p>creates <code>$b</code> to be like <code>$a</code> except that the dimension 4 is moved to the place 1, so:</p>

<pre> $b-&#62;at(1,2,3,4,5,6) == $a-&#62;at(1,5,2,3,4,6);</pre>

<p>The other dimensions are moved accordingly. Negative dimension indices count from the end.</p>

<p>mv does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="oneslice"
>oneslice</a></h2>

<pre>  Signature: (P(); C(); int nth; int from; int step; int nsteps)</pre>

<p>experimental function - not for public use</p>

<pre> $a = oneslice();</pre>

<p>This is not for public use currently. See the source if you have to. This function can be used to accomplish run-time changing of transformations i.e. changing the size of some piddle at run-time.</p>

<p>However, the mechanism is not yet finalized and this is just a demonstration.</p>

<p>oneslice does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="slice"
>slice</a></h2>

<pre>  Signature: (P(); C(); char* str)</pre>

<p>Extract a rectangular slice of a piddle, from a string specifier.</p>

<p><code>slice</code> was the original Swiss-army-knife PDL indexing routine, but is largely superseded by the <a href="../PDL/NiceSlice.html" class="podlinkpod"
>NiceSlice</a> source prefilter and its associated <a href="../PDL/Core.html#nslice" class="podlinkpod"
>nslice</a> method. It is still used as the basic underlying slicing engine for <a href="../PDL/Core.html#nslice" class="podlinkpod"
>nslice</a>, and is especially useful in particular niche applications.</p>

<pre> $a-&#62;slice(&#39;1:3&#39;);  #  return the second to fourth elements of $a
 $a-&#62;slice(&#39;3:1&#39;);  #  reverse the above
 $a-&#62;slice(&#39;-2:1&#39;); #  return last-but-one to second elements of $a</pre>

<p>The argument string is a comma-separated list of what to do for each dimension. The current formats include the following, where <i>a</i>, <i>b</i> and <i>c</i> are integers and can take legal array index values (including -1 etc):</p>

<dl>
<dt><a name=":"
>:</a></dt>

<dd>
<p>takes the whole dimension intact.</p>

<dt><a name="&#39;&#39;"
>&#39;&#39;</a></dt>

<dd>
<p>(nothing) is a synonym for &#34;:&#34; (This means that <code>$a-&#62;slice(&#39;:,3&#39;)</code> is equal to <code>$a-&#62;slice(&#39;,3&#39;)</code>).</p>

<dt><a name="a"
>a</a></dt>

<dd>
<p>slices only this value out of the corresponding dimension.</p>

<dt><a name="(a)"
>(a)</a></dt>

<dd>
<p>means the same as &#34;a&#34; by itself except that the resulting dimension of length one is deleted (so if <code>$a</code> has dims <code>(3,4,5)</code> then <code>$a-&#62;slice(&#39;:,(2),:&#39;)</code> has dimensions <code>(3,5)</code> whereas <code>$a-&#62;slice(&#39;:,2,:&#39;)</code> has dimensions <code>(3,1,5))</code>.</p>

<dt><a name="a:b"
>a:b</a></dt>

<dd>
<p>slices the range <i>a</i> to <i>b</i> inclusive out of the dimension.</p>

<dt><a name="a:b:c"
>a:b:c</a></dt>

<dd>
<p>slices the range <i>a</i> to <i>b</i>, with step <i>c</i> (i.e. <code>3:7:2</code> gives the indices <code>(3,5,7)</code>). This may be confusing to Matlab users but several other packages already use this syntax.</p>

<dt><a name="&#39;*&#39;"
>&#39;*&#39;</a></dt>

<dd>
<p>inserts an extra dimension of width 1 and</p>

<dt><a name="&#39;*a&#39;"
>&#39;*a&#39;</a></dt>

<dd>
<p>inserts an extra (dummy) dimension of width <i>a</i>.</p>
</dd>
</dl>

<p>An extension is planned for a later stage allowing <code>$a-&#62;slice(&#39;(=1),(=1|5:8),3:6(=1),4:6&#39;)</code> to express a multidimensional diagonal of <code>$a</code>.</p>

<p>Trivial out-of-bounds slicing is allowed: if you slice a source dimension that doesn&#39;t exist, but only index the 0th element, then <code>slice</code> treats the source as if there were a dummy dimension there. The following are all equivalent:</p>

<pre>        xvals(5)-&#62;dummy(1,1)-&#62;slice(&#39;(2),0&#39;)  # Add dummy dim, then slice
        xvals(5)-&#62;slice(&#39;(2),0&#39;)              # Out-of-bounds slice adds dim.
        xvals(5)-&#62;slice((2),0)                # NiceSlice syntax
        xvals(5)-&#62;((2))-&#62;dummy(0,1)           # NiceSlice syntax</pre>

<p>This is an error:</p>

<pre>        xvals(5)-&#62;slice(&#39;(2),1&#39;)        # nontrivial out-of-bounds slice dies</pre>

<p>Because slicing doesn&#39;t directly manipulate the source and destination pdl -- it just sets up a transformation between them -- indexing errors often aren&#39;t reported until later. This is either a bug or a feature, depending on whether you prefer error-reporting clarity or speed of execution.</p>

<p>slice does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="using"
>using</a></h2>

<p>Returns array of column numbers requested</p>

<pre> line $pdl-&#62;using(1,2);</pre>

<p>Plot, as a line, column 1 of <code>$pdl</code> vs. column 2</p>

<pre> pdl&#62; $pdl = rcols(&#34;file&#34;);
 pdl&#62; line $pdl-&#62;using(1,2);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="diagonalI"
>diagonalI</a></h2>

<pre>  Signature: (P(); C(); SV *list)</pre>

<p>Returns the multidimensional diagonal over the specified dimensions.</p>

<p>The diagonal is placed at the first (by number) dimension that is diagonalized. The other diagonalized dimensions are removed. So if <code>$a</code> has dimensions <code>(5,3,5,4,6,5)</code> then after</p>

<pre> $b = $a-&#62;diagonal(0,2,5);</pre>

<p>the piddle <code>$b</code> has dimensions <code>(5,3,4,6)</code> and <code>$b-&#62;at(2,1,0,1)</code> refers to <code>$a-&#62;at(2,1,2,0,1,2)</code>.</p>

<p>NOTE: diagonal doesn&#39;t handle threadids correctly. XXX FIX</p>

<p>diagonalI does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="lags"
>lags</a></h2>

<pre>  Signature: (P(); C(); int nthdim; int step; int n)</pre>

<p>Returns a piddle of lags to parent.</p>

<p>Usage:</p>

<pre>  $lags = $a-&#62;lags($nthdim,$step,$nlags);</pre>

<p>I.e. if <code>$a</code> contains</p>

<pre> [0,1,2,3,4,5,6,7]</pre>

<p>then</p>

<pre> $b = $a-&#62;lags(0,2,2);</pre>

<p>is a (5,2) matrix</p>

<pre> [2,3,4,5,6,7]
 [0,1,2,3,4,5]</pre>

<p>This order of returned indices is kept because the function is called &#34;lags&#34; i.e. the nth lag is n steps behind the original.</p>

<p><code>$step</code> and <code>$nlags</code> must be positive. <code>$nthdim</code> can be negative and will then be counted from the last dim backwards in the usual way (-1 = last dim).</p>

<p>lags does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="splitdim"
>splitdim</a></h2>

<pre>  Signature: (P(); C(); int nthdim; int nsp)</pre>

<p>Splits a dimension in the parent piddle (opposite of <a href="../PDL/Core.html#clump" class="podlinkpod"
>clump</a>)</p>

<p>After</p>

<pre> $b = $a-&#62;splitdim(2,3);</pre>

<p>the expression</p>

<pre> $b-&#62;at(6,4,x,y,3,6) == $a-&#62;at(6,4,x+3*y)</pre>

<p>is always true (<code>x</code> has to be less than 3).</p>

<p>splitdim does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="rotate"
>rotate</a></h2>

<pre>  Signature: (x(n); int shift(); [oca]y(n))</pre>

<p>Shift vector elements along with wrap. Flows data back&#38;forth.</p>

<p>rotate does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="threadI"
>threadI</a></h2>

<pre>  Signature: (P(); C(); int id; SV *list)</pre>

<p>internal</p>

<p>Put some dimensions to a threadid.</p>

<pre> $b = $a-&#62;threadI(0,1,5); # thread over dims 1,5 in id 1</pre>

<p>threadI does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="identvaff"
>identvaff</a></h2>

<pre>  Signature: (P(); C())</pre>

<p>A vaffine identity transformation (includes thread_id copying).</p>

<p>Mainly for internal use.</p>

<p>identvaff does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="unthread"
>unthread</a></h2>

<pre>  Signature: (P(); C(); int atind)</pre>

<p>All threaded dimensions are made real again.</p>

<p>See [TBD Doc] for details and examples.</p>

<p>unthread does not process bad values. It will set the bad-value flag of all output piddles if the flag is set for any of the input piddles.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="dice"
>dice</a></h2>

<p>Dice rows/columns/planes out of a PDL using indexes for each dimension.</p>

<p>This function can be used to extract irregular subsets along many dimension of a PDL, e.g. only certain rows in an image, or planes in a cube. This can of course be done with the usual dimension tricks but this saves having to figure it out each time!</p>

<p>This method is similar in functionality to the <a href="#slice" class="podlinkpod"
>slice</a> method, but <a href="#slice" class="podlinkpod"
>slice</a> requires that contiguous ranges or ranges with constant offset be extracted. ( i.e. <a href="#slice" class="podlinkpod"
>slice</a> requires ranges of the form <code>1,2,3,4,5</code> or <code>2,4,6,8,10</code>). Because of this restriction, <a href="#slice" class="podlinkpod"
>slice</a> is more memory efficient and slightly faster than dice</p>

<pre> $slice = $data-&#62;dice([0,2,6],[2,1,6]); # Dicing a 2-D array</pre>

<p>The arguments to dice are arrays (or 1D PDLs) for each dimension in the PDL. These arrays are used as indexes to which rows/columns/cubes,etc to dice-out (or extract) from the <code>$data</code> PDL.</p>

<p>Use <code>X</code> to select all indices along a given dimension (compare also <a href="../PDL/Core.html#mslice" class="podlinkpod"
>mslice</a>). As usual (in slicing methods) trailing dimensions can be omitted implying <code>X</code>&#39;es for those.</p>

<pre> pdl&#62; $a = sequence(10,4)
 pdl&#62; p $a
 [
  [ 0  1  2  3  4  5  6  7  8  9]
  [10 11 12 13 14 15 16 17 18 19]
  [20 21 22 23 24 25 26 27 28 29]
  [30 31 32 33 34 35 36 37 38 39]
 ]
 pdl&#62; p $a-&#62;dice([1,2],[0,3]) # Select columns 1,2 and rows 0,3
 [
  [ 1  2]
  [31 32]
 ]
 pdl&#62; p $a-&#62;dice(X,[0,3])
 [
  [ 0  1  2  3  4  5  6  7  8  9]
  [30 31 32 33 34 35 36 37 38 39]
 ]
 pdl&#62; p $a-&#62;dice([0,2,5])
 [
  [ 0  2  5]
  [10 12 15]
  [20 22 25]
  [30 32 35]
 ]</pre>

<p>As this is an index function, any modifications to the slice change the parent (use the <code>.=</code> operator).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="dice_axis"
>dice_axis</a></h2>

<p>Dice rows/columns/planes from a single PDL axis (dimension) using index along a specified axis</p>

<p>This function can be used to extract irregular subsets along any dimension, e.g. only certain rows in an image, or planes in a cube. This can of course be done with the usual dimension tricks but this saves having to figure it out each time!</p>

<pre> $slice = $data-&#62;dice_axis($axis,$index);</pre>

<pre> pdl&#62; $a = sequence(10,4)
 pdl&#62; $idx = pdl(1,2)
 pdl&#62; p $a-&#62;dice_axis(0,$idx) # Select columns
 [
  [ 1  2]
  [11 12]
  [21 22]
  [31 32]
 ]
 pdl&#62; $t = $a-&#62;dice_axis(1,$idx) # Select rows
 pdl&#62; $t.=0
 pdl&#62; p $a
 [
  [ 0  1  2  3  4  5  6  7  8  9]
  [ 0  0  0  0  0  0  0  0  0  0]
  [ 0  0  0  0  0  0  0  0  0  0]
  [30 31 32 33 34 35 36 37 38 39]
 ]</pre>

<p>The trick to using this is that the index selects elements along the dimensions specified, so if you have a 2D image <code>axis=0</code> will select certain <code>X</code> values - i.e. extract columns</p>

<p>As this is an index function, any modifications to the slice change the parent.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
