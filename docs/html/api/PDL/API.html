<html><head><title>PDL::API</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:23 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#Creating_a_piddle_manually_from_Perl'>Creating a piddle manually from Perl</a>
  <li class='indexItem indexItem1'><a href='#Creating_a_piddle_in_C'>Creating a piddle in C</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Wrapping_your_own_data_into_a_piddle'>Wrapping your own data into a piddle</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#The_gory_details'>The gory details</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#The_Core_struct_--_getting_at_PDL_core_routines_at_runtime'>The Core struct -- getting at PDL core routines at runtime</a>
    <li class='indexItem indexItem2'><a href='#Some_selected_core_routines_explained'>Some selected core routines explained</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>PDL::API - making piddles from Perl and C/XS code</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>A simple cookbook how to create piddles manually.
It covers both the Perl and the C/XS level.
Additionally,
it describes the PDL core routines that can be accessed from other modules.
These routines basically define the PDL API.
If you need to access piddles from C/XS you probably need to know about these functions.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use PDL;
  sub mkmypiddle {
   ...
  }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Creating_a_piddle_manually_from_Perl"
>Creating a piddle manually from Perl</a></h1>

<p>Sometimes you want to create a piddle <i>manually</i> from binary data. You can do that at the Perl level. Examples in the distribution include some of the IO routines. The code snippet below illustrates the required steps.</p>

<pre>   use Carp;
   sub mkmypiddle {
     my $class = shift;
     my $pdl  = $class-&#62;new;
     $pdl-&#62;set_datatype($PDL_B);
     my @dims = (1,3,4);
     my $size = 1;
     for (@dims) { $size *= $_ }
     $pdl-&#62;setdims([@dims]);
     my $dref = $pdl-&#62;get_dataref();

     # read data directly from file
     open my $file, &#39;&#60;data.dat&#39; or die &#34;couldn&#39;t open data.dat&#34;;
     my $len = $size*PDL::Core::howbig($pdl-&#62;get_datatype);
     croak &#34;couldn&#39;t read enough data&#34; if
       read( $file, $$dref, $len) != $len;
     close $file;
     $pdl-&#62;upd_data();

     return $pdl;
   }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Creating_a_piddle_in_C"
>Creating a piddle in C</a></h1>

<p>The following example creates a piddle at the C level. We use the <code>Inline</code> module which is really the way to interface Perl and C these days. Note the use of the <code>PDL_INCLUDE</code>, <code>PDL_TYPEMAP</code>, <code>PDL_AUTO_INCLUDE</code> and <code>PDL_BOOT</code> functions that were imported from <code>PDL::Core::Dev</code>. They are used in conjunction with an Inline Config call to ensure that the PDL typemap, the PDL include files and the PDL Core routines are found during compilation and later runtime execution.</p>

<pre>   use PDL::LiteF;
   use PDL::Core::Dev;

   $a = myfloatseq(); # exercise our C piddle constructor

   print $a-&#62;info,&#34;\n&#34;;

   # the reason for this config call is explained below
   use Inline C =&#62; Config =&#62;
     INC           =&#62; &#38;PDL_INCLUDE,  # make sure we find pdlcore.h etc
     TYPEMAPS      =&#62; &#38;PDL_TYPEMAP,  # use the PDL typemap
     AUTO_INCLUDE  =&#62; &#38;PDL_AUTO_INCLUDE,  # global declarations and includes
     BOOT          =&#62; &#38;PDL_BOOT;     # boot code to load the Core struct

   use Inline C;
   Inline-&#62;init; # useful if you want to be able to &#39;do&#39;-load this script

   __DATA__

   __C__

   static pdl* new_pdl(int datatype, PDL_Long dims[], int ndims)
   {
     pdl *p = PDL-&#62;pdlnew();
     PDL-&#62;setdims (p, dims, ndims);  /* set dims */
     p-&#62;datatype = datatype;         /* and data type */
     PDL-&#62;allocdata (p);             /* allocate the data chunk */

     return p;
   }

   pdl* myfloatseq()
   {
     PDL_Long dims[] = {5,5,5};
     pdl *p = new_pdl(PDL_F,dims,3);
     PDL_Float *dataf = (PDL_Float *) p-&#62;data;
     int i;

     for (i=0;i&#60;5*5*5;i++)
       dataf[i] = i; /* the data must be initialized ! */
     return p;
   }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Wrapping_your_own_data_into_a_piddle"
>Wrapping your own data into a piddle</a></h2>

<p>Sometimes you obtain a chunk of data from another source, for example an image processing library, etc. All you want to do in that case is wrap your data into a piddle struct at the C level. Examples using this approach can be found in the IO modules (where FastRaw and FlexRaw use it for mmapped access) and the Gimp Perl module (that uses it to wrap Gimp pixel regions into piddles). The following script demonstrates a simple example:</p>

<pre>   use PDL::LiteF;
   use PDL::Core::Dev;
   use PDL::Graphics::PGPLOT;

   $b = mkpiddle();

   print $b-&#62;info,&#34;\n&#34;;

   imag1 $b;

   use Inline C =&#62; Config =&#62;
     INC           =&#62; &#38;PDL_INCLUDE,
     TYPEMAPS      =&#62; &#38;PDL_TYPEMAP,
     AUTO_INCLUDE  =&#62; &#38;PDL_AUTO_INCLUDE,
     BOOT          =&#62; &#38;PDL_BOOT;

   use Inline C;
   Inline-&#62;init;

   __DATA__

   __C__

   /* wrap a user supplied chunk of data into a piddle
    * You must specify the dimensions (dims,ndims) and 
    * the datatype (constants for the datatypes are declared
    * in pdl.h; e.g. PDL_B for byte type, etc)
    *
    * when the created piddle &#39;npdl&#39; is destroyed on the
    * Perl side the function passed as the &#39;delete_magic&#39;
    * parameter will be called with the pointer to the pdl structure
    * and the &#39;delparam&#39; argument.
    * This gives you an opportunity to perform any clean up
    * that is necessary. For example, you might have to
    * explicitly call a function to free the resources
    * associated with your data pointer.
    * At the very least &#39;delete_magic&#39; should zero the piddle&#39;s data pointer:
    * 
    *     void delete_mydata(pdl* pdl, int param)
    *     {
    *       pdl-&#62;data = 0;
    *     }
    *     pdl *p = pdl_wrap(mydata, PDL_B, dims, ndims, delete_mydata,0);
    *
    * pdl_wrap returns the pointer to the pdl
    * that was created.
    */
   typedef void (*DelMagic)(pdl *, int param);
   static void default_magic(pdl *p, int pa) { p-&#62;data = 0; }
   static pdl* pdl_wrap(void *data, int datatype, PDL_Long dims[],
                        int ndims, DelMagic delete_magic, int delparam)
   {
     pdl* npdl = PDL-&#62;pdlnew(); /* get the empty container */

     PDL-&#62;setdims(npdl,dims,ndims); /* set dims      */
     npdl-&#62;datatype = datatype;     /* and data type */
     npdl-&#62;data = data;             /* point it to your data */
     /* make sure the core doesn&#39;t meddle with your data */
     npdl-&#62;state |= PDL_DONTTOUCHDATA | PDL_ALLOCATED;
     if (delete_magic != NULL)
       PDL-&#62;add_deletedata_magic(npdl, delete_magic, delparam);
     else
       PDL-&#62;add_deletedata_magic(npdl, default_magic, 0);
     return npdl;
   }

   #define SZ 256
   /* a really silly function that makes a ramp image
    * in reality this could be an opaque function
    * in some library that you are using
    */
   static PDL_Byte* mkramp(void)
   {
     PDL_Byte *data;
     int i;

     if ((data = malloc(SZ*SZ*sizeof(PDL_Byte))) == NULL)
       croak(&#34;mkramp: Couldn&#39;t allocate memory&#34;);
     for (i=0;i&#60;SZ*SZ;i++)
       data[i] = i % SZ;

     return data;
   }

   /* this function takes care of the required clean-up */
   static void delete_myramp(pdl* p, int param)
   {
     if (p-&#62;data)
       free(p-&#62;data);
     p-&#62;data = 0;
   }

   pdl* mkpiddle()
   {
     PDL_Long dims[] = {SZ,SZ};
     pdl *p;

     p = pdl_wrap((void *) mkramp(), PDL_B, dims, 2, 
                  delete_myramp,0); /* the delparam is abitrarily set to 0 */
     return p;
   }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="The_gory_details"
>The gory details</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_Core_struct_--_getting_at_PDL_core_routines_at_runtime"
>The Core struct -- getting at PDL core routines at runtime</a></h2>

<p>PDL uses a technique similar to that employed by the Tk modules to let other modules use its core routines. A pointer to all shared core PDL routines is stored in the <code>$PDL::SHARE</code> variable. XS code should get hold of this pointer at boot time so that the rest of the C/XS code can then use that pointer for access at run time. This initial loading of the pointer is most easily achieved using the functions <code>PDL_AUTO_INCLUDE</code> and <code>PDL_BOOT</code> that are defined and exported by <code>PDL::Core::Dev</code>. Typical usage with the Inline module has already been demonstrated:</p>

<pre>   use Inline C =&#62; Config =&#62;
     INC           =&#62; &#38;PDL_INCLUDE,
     TYPEMAPS      =&#62; &#38;PDL_TYPEMAP,
     AUTO_INCLUDE  =&#62; &#38;PDL_AUTO_INCLUDE, # declarations
     BOOT          =&#62; &#38;PDL_BOOT;         # code for the XS boot section</pre>

<p>The code returned by <code>PDL_AUTO_INCLUDE</code> makes sure that <em>pdlcore.h</em> is included and declares the static variables to hold the pointer to the <code>Core</code> struct. It looks something like this:</p>

<pre>   print PDL_AUTO_INCLUDE;

 #include &#60;pdlcore.h&#62;
 static Core* PDL; /* Structure holds core C functions */
 static SV* CoreSV;       /* Gets pointer to Perl var holding core structure */</pre>

<p>The code returned by <code>PDL_BOOT</code> retrieves the <code>$PDL::SHARE</code> variable and initializes the pointer to the <code>Core</code> struct. For those who know their way around the Perl API here is the code:</p>

<pre>   print PDL_BOOT;

   perl_require_pv (&#34;PDL::Core&#34;); /* make sure PDL::Core is loaded */
   CoreSV = perl_get_sv(&#34;PDL::SHARE&#34;,FALSE);  /* SV* value */
 #ifndef aTHX_
 #define aTHX_
 #endif
   if (CoreSV==NULL)
     Perl_croak(aTHX_ &#34;We require the PDL::Core module, which was not found&#34;);
   PDL = INT2PTR(Core*,SvIV( CoreSV ));  /* Core* value */
   if (PDL-&#62;Version != PDL_CORE_VERSION)
     Perl_croak(aTHX_ &#34;The code needs to be recompiled against the newly installed PDL&#34;);</pre>

<p>The <code>Core</code> struct contains version info to ensure that the structure defined in <em>pdlcore.h</em> really corresponds to the one obtained at runtime. The code above tests for this</p>

<pre>   if (PDL-&#62;Version != PDL_CORE_VERSION)
     ....</pre>

<p>For more information on the Core struct see <a href="../PDL/Internals.html" class="podlinkpod"
>PDL::Internals</a>.</p>

<p>With these preparations your code can now access the core routines as already shown in some of the examples above, e.g.</p>

<pre>  pdl *p = PDL-&#62;pdlnew();</pre>

<p>By default the C variable named <code>PDL</code> is used to hold the pointer to the <code>Core</code> struct. If that is (for whichever reason) a problem you can explicitly specify a name for the variable with the <code>PDL_AUTO_INCLUDE</code> and the <code>PDL_BOOT</code> routines:</p>

<pre>   use Inline C =&#62; Config =&#62;
     INC           =&#62; &#38;PDL_INCLUDE,
     TYPEMAPS      =&#62; &#38;PDL_TYPEMAP,
     AUTO_INCLUDE  =&#62; &#38;PDL_AUTO_INCLUDE &#39;PDL_Corep&#39;,
     BOOT          =&#62; &#38;PDL_BOOT &#39;PDL_Corep&#39;;</pre>

<p>Make sure you use the same identifier with <code>PDL_AUTO_INCLUDE</code> and <code>PDL_BOOT</code> and use that same identifier in your own code. E.g., continuing from the example above:</p>

<pre>  pdl *p = PDL_Corep-&#62;pdlnew();</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Some_selected_core_routines_explained"
>Some selected core routines explained</a></h2>

<p>The full definition of the <code>Core</code> struct can be found in the file <em>pdlcore.h</em>. In the following the most frequently used member functions of this struct are briefly explained.</p>

<ul>
<li><code>pdl *SvPDLV(SV *sv)</code></li>

<li><code>pdl *SetSV_PDL(SV *sv, pdl *it)</code></li>

<li><code>pdl *pdlnew()</code>
<p><code>pdlnew</code> returns an empty pdl object that needs further initialization to turn it into a proper piddle. Example:</p>

<pre>  pdl *p = PDL-&#62;pdlnew();
  PDL-&#62;setdims(p,dims,ndims);
  p-&#62;datatype = PDL_B;</pre>
</li>

<li><code>pdl *null()</code></li>

<li><code>SV *copy(pdl* p, char* )</code></li>

<li><code>void *smalloc(int nbytes)</code></li>

<li><code>int howbig(int pdl_datatype)</code></li>

<li><code>void add_deletedata_magic(pdl *p, void (*func)(pdl*, int), int param)</code></li>

<li><code>void allocdata(pdl *p)</code></li>

<li><code>void make_physical(pdl *p)</code></li>

<li><code>void make_physdims(pdl *p)</code></li>

<li><code>void make_physvaffine(pdl *p)</code></li>

<li><code>void qsort_X(PDL_Xtype *data, int a, int b)</code> and <code>void qsort_ind_X(PDL_Xtype *data, int *ix, int a, int b)</code>
<p>where X is one of B,S,U,L,F,D and Xtype is one of Byte, Short, Ushort, Long, Float or Double.</p>
</li>

<li><code>float NaN_float</code> and <code>double NaN_double</code>
<p>These are constants to produce the required NaN values.</p>
</li>

<li><code>void pdl_barf(const char* pat,...)</code> and <code>void pdl_warn(const char* pat,...)</code>
<p>These are C-code equivalents of <code>barf</code> and <code>warn</code>. They include special handling of error or warning messages during pthreading (i.e. processor multi-threading) that defer the messages until after pthreading is completed. When pthreading is complete, perl&#39;s <code>barf</code> or <code>warn</code> is called with the deferred messages. This is needed to keep from calling perl&#39;s <code>barf</code> or <code>warn</code> during pthreading, which can cause segfaults.</p>

<p>Note that <code>barf</code> and <code>warn</code> have been redefined (using c-preprocessor macros) in pdlcore.h to <code>PDL-&#62;barf</code> and <code>PDL-&#62;warn</code>. This is to keep any XS or PP code from calling perl&#39;s <code>barf</code> or <code>warn</code> directly, which can cause segfaults during pthreading.</p>

<p>See <a href="../PDL/ParallelCPU.html" class="podlinkpod"
>PDL::ParallelCPU</a> for more information on pthreading.</p>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../PDL.html" class="podlinkpod"
>PDL</a></p>

<p><a href="../Inline.html" class="podlinkpod"
>Inline</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>This manpage is still under development. Feedback and corrections are welcome.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright 2010 Christian Soeller (c.soeller@auckland.ac.nz). You can distribute and/or modify this document under the same terms as the current Perl license.</p>

<p>See: http://dev.perl.org/licenses/</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
