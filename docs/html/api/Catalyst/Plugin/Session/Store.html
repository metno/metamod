<html><head><title>Catalyst::Plugin::Session::Store</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:03 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#WRITING_STORE_PLUGINS'>WRITING STORE PLUGINS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Required_Methods'>Required Methods</a>
    <li class='indexItem indexItem2'><a href='#Error_handling'>Error handling</a>
    <li class='indexItem indexItem2'><a href='#Auto-Expiry_on_the_Backend'>Auto-Expiry on the Backend</a>
  </ul>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Catalyst::Plugin::Session::Store - Base class for session storage drivers.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    package Catalyst::Plugin::Session::Store::MyBackend;
    use base qw/Catalyst::Plugin::Session::Store/;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This class doesn&#39;t actually provide any functionality, but when the <code>Catalyst::Plugin::Session</code> module sets up it will check to see that <code>YourApp-&#62;isa(&#34;Catalyst::Plugin::Session::Store&#34;)</code>. When you write a session storage plugin you should subclass this module for this reason. This documentation is intended for authors of session storage plugins, not for end users.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="WRITING_STORE_PLUGINS"
>WRITING STORE PLUGINS</a></h1>

<p>All session storage plugins need to adhere to the following interface specification to work correctly:</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Required_Methods"
>Required Methods</a></h2>

<dl>
<dt><a name="get_session_data_$key"
>get_session_data $key</a></dt>

<dd>
<dt><a name="store_session_data_$key,_$data"
>store_session_data $key, $data</a></dt>

<dd>
<p>Retrieve or store session data by key.</p>

<p><code>$data</code> is currently either a hash reference (for most keys) or an integer value (for expires), but all value types should be supported.</p>

<p>Keys are in the format <code>prefix:id</code>, where <code>prefix</code> is <code>session</code>, <code>expires</code>, or <code>flash</code>, and <code>id</code> is always the session ID. Plugins such as <a href="../../../Catalyst/Plugin/Session/PerUser.html" class="podlinkpod"
>Catalyst::Plugin::Session::PerUser</a> store extensions to this format, such as <code>user:username</code>.</p>

<p>It is suggested that the store should split on the colon and store the data more efficiently - the API should remain stable, with the possible addition of new prefixes in the future.</p>

<p>For example, <code>Store::DBI</code> maps <code>expires:id</code> a column of <code>session:id</code> by special-casing <code>get_session_data</code> and <code>store_session_data</code> for that key format, in order to ease the implementation of <code>delete_expired_sessions</code>.</p>

<p>The only assurance stores are required to make is that given</p>

<pre>    $c-&#62;store_session_data( $x, $y );</pre>

<p>for any $x,</p>

<pre>    $y == $c-&#62;get_session_data( $x )</pre>

<p>will hold.</p>

<dt><a name="store_session_data_(_$key,_$data_)"
>store_session_data ( $key, $data )</a></dt>

<dd>
<p>Store a session whose KEY is the first parameter and data is the second parameter in storage.</p>

<p>The second parameter is a hash reference, which should normally be serialized (and later deserialized by <code>get_session_data</code>).</p>

<dt><a name="delete_session_data_(_$key_)"
>delete_session_data ( $key )</a></dt>

<dd>
<p>Delete the session whose KEY is the parameter.</p>

<dt><a name="delete_expired_sessions"
>delete_expired_sessions</a></dt>

<dd>
<p>This method is not called by any code at present, but may be called in the future, as part of a Catalyst-specific maintenance script.</p>

<p>If you are wrapping around a backend which manages its own auto expiry you can just give this method an empty body.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Error_handling"
>Error handling</a></h2>

<p>All errors should be thrown using <a href="../../../Catalyst/Exception.html" class="podlinkpod"
>Catalyst::Exception</a>. Return values are not checked, and are assumed to be OK. Missing values are not errors.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Auto-Expiry_on_the_Backend"
>Auto-Expiry on the Backend</a></h2>

<p>Storage plugins are encouraged to use <code>$c-&#62;session_expires</code>, <code>$c-&#62;config(&#39;Plugin::Session&#39; =&#62; { expires =&#62; $val })</code>, or the storage of the <code>expires:$sessionid</code> key to perform more efficient expiration, but only for the key prefixes <code>session</code>, <code>flash</code> and <code>expires</code>.</p>

<p>If the backend chooses not to do so, <a href="../../../Catalyst/Plugin/Session.html" class="podlinkpod"
>Catalyst::Plugin::Session</a> will detect expired sessions as they are retrieved and delete them if necessary.</p>

<p>Note that session store that use this approach may leak disk space, since nothing will actively delete an expired session. The <code>delete_expired_sessions</code> method is there so that regularly scheduled maintenance scripts can give your backend the opportunity to clean up.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
