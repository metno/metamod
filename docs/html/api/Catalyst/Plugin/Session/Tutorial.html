<html><head><title>Catalyst::Plugin::Session::Tutorial</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:03 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#ASSUMPTIONS'>ASSUMPTIONS</a>
  <li class='indexItem indexItem1'><a href='#WHAT_ARE_SESSIONS'>WHAT ARE SESSIONS</a>
  <li class='indexItem indexItem1'><a href='#HOW_SESSIONS_WORK'>HOW SESSIONS WORK</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Cookies'>Cookies</a>
    <li class='indexItem indexItem2'><a href='#Cookie_Alternatives'>Cookie Alternatives</a>
    <li class='indexItem indexItem2'><a href='#Server-Side_Behavior'>Server-Side Behavior</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#USING_SESSIONS'>USING SESSIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#State_Plugins'>State Plugins</a>
    <li class='indexItem indexItem2'><a href='#Store_Plugins'>Store Plugins</a>
    <li class='indexItem indexItem2'><a href='#Configuration'>Configuration</a>
    <li class='indexItem indexItem2'><a href='#Usage'>Usage</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SECURITY_ISSUES'>SECURITY ISSUES</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#(Not)_Trusting_the_Client'>(Not) Trusting the Client</a>
    <li class='indexItem indexItem2'><a href='#Session_Hijacking'>Session Hijacking</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Cross_Site_Scripting'>Cross Site Scripting</a>
      <li class='indexItem indexItem3'><a href='#Social_Engineering'>Social Engineering</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Catalyst::Plugin::Session::Tutorial - Understanding and using sessions.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ASSUMPTIONS"
>ASSUMPTIONS</a></h1>

<p>This tutorial assumes that you are familiar with web applications in general and Catalyst specifically (up to models and configuration),
and that you know what HTTP is.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="WHAT_ARE_SESSIONS"
>WHAT ARE SESSIONS</a></h1>

<p>When users use a site,
especially one that knows who they are (sites you log in to,
sites which let you keep a shopping cart,
etc.),
the server preparing the content has to know that request X comes from client A while request Y comes from client B,
so that each user gets the content meant for them.</p>

<p>The problem is that HTTP is a stateless protocol.
This means that every request is distinct,
and even if it comes from the same client,
it&#39;s difficult to know that.</p>

<p>The way sessions are maintained between distinct requests is that the client says,
for every request,
&#34;I&#39;m client A&#34; or &#34;I&#39;m client B&#34;.</p>

<p>This piece of data that tells the server &#34;I&#39;m X&#34; is called the session ID,
and the threading of several requests together is called a session.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="HOW_SESSIONS_WORK"
>HOW SESSIONS WORK</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Cookies"
>Cookies</a></h2>

<p>HTTP has a feature that lets this become easier,
called cookies.
A cookie is something the server asks the client to save somewhere,
and resend every time a request is made.</p>

<p>The way they work is that the server sends the <code>Set-Cookie</code> header,
with a cookie name,
a value,
and some metadata (like when it expires,
what paths it applies to,
etc.).
The client saves this.</p>

<p>Then,
on every subsequent request the client will send a <code>Cookie</code> header,
with the cookie name and value.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Cookie_Alternatives"
>Cookie Alternatives</a></h2>

<p>Another way is to make sure that the session ID is repeated is to include it in every URI.</p>

<p>This can be as either a part of the path,
or as a query parameter.</p>

<p>This technique has several issues which are discussed in <a href="../../../Catalyst/Plugin/Session/State/URI.html#CAVEATS" class="podlinkpod"
>&#34;CAVEATS&#34; in Catalyst::Plugin::Session::State::URI</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Server-Side_Behavior"
>Server-Side Behavior</a></h2>

<p>When the server receives the session ID it can then look this key up in a database of some sort.
For example the database can contain a shopping cart&#39;s contents,
user preferences,
etc.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="USING_SESSIONS"
>USING SESSIONS</a></h1>

<p>In <a href="../../../Catalyst.html" class="podlinkpod"
>Catalyst</a>,
the <a href="../../../Catalyst/Plugin/Session.html" class="podlinkpod"
>Catalyst::Plugin::Session</a> plugin provides an API for convenient handling of session data.
This API is based on the older,
less flexible and less reliable <a href="../../../Catalyst/Plugin/Session/FastMmap.html" class="podlinkpod"
>Catalyst::Plugin::Session::FastMmap</a>.</p>

<p>The plugin is modular,
and requires backend plugins to be used.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="State_Plugins"
>State Plugins</a></h2>

<p>State plugins handle session ID persistence.
For example <a href="../../../Catalyst/Plugin/Session/State/Cookie.html" class="podlinkpod"
>Catalyst::Plugin::Session::State::Cookie</a> creates a cookie with the session ID in it.</p>

<p>These plugins will automatically set <code>$c-&#62;sessionid</code> at the beginning of the request,
and automatically cause <code>$c-&#62;sessionid</code> to be saved by the client at the end of the request.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Store_Plugins"
>Store Plugins</a></h2>

<p>The backend into which session data is stored is provided by these plugins.
For example,
<a href="../../../Catalyst/Plugin/Session/Store/DBI.html" class="podlinkpod"
>Catalyst::Plugin::Session::Store::DBI</a> uses a database table to store session data,
while <a href="../../../Catalyst/Plugin/Session/Store/FastMmap.html" class="podlinkpod"
>Catalyst::Plugin::Session::Store::FastMmap</a> uses <a href="../../../Cache/FastMmap.html" class="podlinkpod"
>Cache::FastMmap</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Configuration"
>Configuration</a></h2>

<p>First you need to load the appropriate plugins into your <a href="../../../Catalyst.html" class="podlinkpod"
>Catalyst</a> application:</p>

<pre>    package MyApp;

    use Catalyst qw/
        Session
        Session::State::Cookie
        Session::Store::File
    /;</pre>

<p>This loads the session API, as well as the required backends of your choice.</p>

<p>After the plugins are loaded they need to be configured. This is done according to <a href="../../../Catalyst/Manual/Cookbook.html#Configure_your_application" class="podlinkpod"
>&#34;Configure_your_application&#34; in Catalyst::Manual::Cookbook</a>.</p>

<p>Each backend plugin requires its own configuration options (with most plugins providing sensible defaults). The session API itself also has configurable options listed in <a href="../../../Catalyst/Plugin/Session.html#CONFIGURATION" class="podlinkpod"
>&#34;CONFIGURATION&#34; in Catalyst::Plugin::Session</a>.</p>

<p>For the plugins above we don&#39;t need any configuration at all - they should work out of the box, but suppose we did want to change some things around, it&#39;ll look like this:</p>

<pre>    MyApp-&#62;config( &#39;Plugin::Session&#39; =&#62; {
        cookie_name =&#62; &#34;my_fabulous_cookie&#34;,
        storage     =&#62; &#34;/path/to/store_data_file&#34;,
    });</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Usage"
>Usage</a></h2>

<p>Now, let&#39;s say we have an online shop, and the user is adding an item to the shopping cart.</p>

<p>Typically the item the user was viewing would have a form or link that adds the item to the cart.</p>

<p>Suppose this link goes to <code>/cart/add/foo_baz/2</code>, meaning that we want two units of the item <code>foo_baz</code> to be added to the cart.</p>

<p>Our <code>add</code> action should look something like this:</p>

<pre>    package MyApp::Controller::Cart;

    sub add : Local {
        my ( $self, $c, $item_id, $quantity ) = @_;
        $quantity ||= 1;

        if ( $c-&#62;model(&#34;Items&#34;)-&#62;item_exists($item_id) ) {
            $c-&#62;session-&#62;{cart}{$item_id} += $quantity;
        } else {
            die &#34;No such item&#34;;
        }
    }</pre>

<p>The way this works is that <code>$c-&#62;session</code> always returns a hash reference to some data which is stored by the storage backend plugin. The hash reference returned always contains the same items that were in there at the end of the last request.</p>

<p>All the mishmash described above is done automatically. First, the method looks to see if a session ID is set. This session ID will be set by the State plugin if appropriate, at the start of the request (e.g. by looking at the cookies sent by the client).</p>

<p>If a session ID is set, the store will be asked to retrieve the session data for that specific session ID, and this is returned from <code>$c-&#62;session</code>. This retrieval is cached, and will only happen once per request, if at all.</p>

<p>If a session ID is not set, a new one is generated, a new anonymous hash is created and saved in the store with the session ID as the key, and the reference to the hash is returned.</p>

<p>The action above takes this hash reference, and updates a nested hash within it, that counts quantity of each item as stored in the cart.</p>

<p>Any cart-listing code can then look into the session data and use it to display the correct items, which will, of course, be remembered across requests.</p>

<p>Here is an action some Template Toolkit example code that could be used to generate a cart listing:</p>

<pre>    sub list_cart : Local {
        my ( $self, $c ) = @_;

        # get the cart data, that maps from item_id to quantity
        my $cart = $c-&#62;session-&#62;{cart} || {};

        # this is our abstract model in which items are stored
        my $storage = $c-&#62;model(&#34;Items&#34;);

        # map from item_id to item (an object or hash reference)
        my %items = map { $_ =&#62; $storage-&#62;get_item($_) } keys %$cart;

        # put the relevant info on the stash
        $c-&#62;stash-&#62;{cart}{items} = \%items;
        $c-&#62;stash-&#62;{cart}{quantity} = $cart;
    }</pre>

<p>And [a part of] the template it forwards to:</p>

<pre>    &#60;table&#62;

        &#60;thead&#62;
            &#60;tr&#62;
                &#60;th&#62;Item&#60;/th&#62;
                &#60;th&#62;Quantity&#60;/th&#62;
                &#60;th&#62;Price&#60;/th&#62;
                &#60;th&#62;remove&#60;/th&#62;
            &#60;/tr&#62;
        &#60;/thead&#62;

        &#60;tbody&#62;
        [%# the table body lists all the items in the cart %]
        [% FOREACH item_id = cart.items.keys %]

            [%# each item has its own row in the table %]

            [% item = cart.items.$item_id %]
            [% quantity = cart.quantity.$item_id %]

            &#60;tr&#62;
                &#60;td&#62;
                    [%# item.name is an attribute in the item
                      # object, as loaded from the store %]
                    [% item.name %]
                &#60;/td&#62;

                &#60;td&#62;
                    [%# supposedly this is part of a form where you
                      # can update the quantity %]
                    &#60;input type=&#34;text&#34; name=&#34;[% item_id %]_quantity&#34;
                        value=&#34;[% quantity %]&#34; /&#62;
                &#60;/td&#62;

                &#60;td&#62; $ [% item.price * quantity %] &#60;/td&#62;

                &#60;td&#62;
                    &#60;a href=&#34;[% c.uri_for(&#39;/cart/remove&#39;) %]/[% item_id %]&#34;&#62;
                        &#60;img src=&#34;/static/trash_can.png&#34; /&#62;
                    &#60;/a&#62;
                &#60;/td&#62;
        [% END %]
        &#60;tbody&#62;

        &#60;tfoot&#62;
            &#60;tr&#62;
                &#60;td colspan=&#34;2&#34;&#62; Total: &#60;/td&#62;
                &#60;td&#62;
                    [%# calculate sum in this cell - too
                      # much headache for a tutorial ;-) %]
                &#60;/td&#62;
                &#60;td&#62;
                    &#60;a href=&#34;[% c.uri_for(&#39;/cart/empty&#39;) %]&#34;&#62;Empty cart&#60;/a&#62;
                &#60;/td&#62;
            &#60;/tr&#62;
        &#60;/tfoot&#62;

    &#60;/table&#62;</pre>

<p>As you can see the way that items are added into <code>$c-&#62;session-&#62;{cart}</code> is pretty simple. Since <code>$c-&#62;session</code> is restored as necessary, and contains data from previous requests by the same client, the cart can be updated as the user navigates the site pretty transparently.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SECURITY_ISSUES"
>SECURITY ISSUES</a></h1>

<p>These issues all relate to how session data is managed, as described above. These are not issues you should be concerned about in your application code, but are here for their educational value.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="(Not)_Trusting_the_Client"
>(Not) Trusting the Client</a></h2>

<p>In order to avoid the overhead of server-side data storage, the session data can be included in the cookie itself.</p>

<p>There are two problems with this:</p>

<ol>
<li>The user can change the data.</li>

<li>Cookies have a 4 kilobyte size limit.
<p>The size limit is of no concern in this section, but data changing is. In the database scheme the data can be trusted, since the user can neither read nor write it. However, if the data is delegated to the user, then special measures have to be added for ensuring data integrity, and perhaps secrecy too.</p>

<p>This can be implemented by encrypting and signing the cookie data, but this is a big headache.</p>
</li>
</ol>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Session_Hijacking"
>Session Hijacking</a></h2>

<p>What happens when client B says &#34;I&#39;m client A&#34;? Well, basically, the server buys it. There&#39;s no real way around it.</p>

<p>The solution is to make &#34;I&#39;m client A&#34; a difficult thing to say. This is why session IDs are randomized. If they are properly randomized, session IDs are so hard to guess that they must be stolen instead.</p>

<p>This is called session hijacking. There are several ways one might hijack another user&#39;s session.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Cross_Site_Scripting"
>Cross Site Scripting</a></h3>

<p>One is by using cross site scripting attacks to steal the cookie data. In community sites, where users can cause the server to display arbitrary HTML, they can use this to put JavaScript code on the server.</p>

<p>If the server does not enforce a strict subset of tags that may be used, the malicious user could use this code to steal the cookies (there is a JavaScript API that lets cookies be accessed, but this code has to be run on the same website that the cookie came from).</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Social_Engineering"
>Social Engineering</a></h3>

<p>By tricking a user into revealing a URI with session data embedded in it (when cookies are not used), the session ID can also be stolen.</p>

<p>Also, a naive user could be tricked into showing the cookie data from the browser to a malicious user.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Yuval Kogman &#60;nothingmuch@woobling.org&#62;</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
