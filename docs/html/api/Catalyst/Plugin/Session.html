<html><head><title>Catalyst::Plugin::Session</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:03 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#RECOMENDED_BACKENDS'>RECOMENDED BACKENDS</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <li class='indexItem indexItem1'><a href='#INTERNAL_METHODS'>INTERNAL METHODS</a>
  <li class='indexItem indexItem1'><a href='#USING_SESSIONS_DURING_PREPARE'>USING SESSIONS DURING PREPARE</a>
  <li class='indexItem indexItem1'><a href='#CONFIGURATION'>CONFIGURATION</a>
  <li class='indexItem indexItem1'><a href='#SPECIAL_KEYS'>SPECIAL KEYS</a>
  <li class='indexItem indexItem1'><a href='#CAVEATS'>CAVEATS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Round_the_Robin_Proxies'>Round the Robin Proxies</a>
    <li class='indexItem indexItem2'><a href='#Race_Conditions'>Race Conditions</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#Contributors'>Contributors</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_%26_LICENSE'>COPYRIGHT &#38; LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Catalyst::Plugin::Session - Generic Session plugin - ties together server side storage and client side state required to maintain session data.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    # To get sessions to &#34;just work&#34;, all you need to do is use these plugins:

    use Catalyst qw/
      Session
      Session::Store::FastMmap
      Session::State::Cookie
      /;

    # you can replace Store::FastMmap with Store::File - both have sensible
    # default configurations (see their docs for details)

    # more complicated backends are available for other scenarios (DBI storage,
    # etc)


    # after you&#39;ve loaded the plugins you can save session data
    # For example, if you are writing a shopping cart, it could be implemented
    # like this:

    sub add_item : Local {
        my ( $self, $c ) = @_;

        my $item_id = $c-&#62;req-&#62;param(&#34;item&#34;);

        # $c-&#62;session is a hash ref, a bit like $c-&#62;stash
        # the difference is that it&#39; preserved across requests

        push @{ $c-&#62;session-&#62;{items} }, $item_id;

        $c-&#62;forward(&#34;MyView&#34;);
    }

    sub display_items : Local {
        my ( $self, $c ) = @_;

        # values in $c-&#62;session are restored
        $c-&#62;stash-&#62;{items_to_display} =
          [ map { MyModel-&#62;retrieve($_) } @{ $c-&#62;session-&#62;{items} } ];

        $c-&#62;forward(&#34;MyView&#34;);
    }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>The Session plugin is the base of two related parts of functionality required for session management in web applications.</p>

<p>The first part, the State, is getting the browser to repeat back a session key, so that the web application can identify the client and logically string several requests together into a session.</p>

<p>The second part, the Store, deals with the actual storage of information about the client. This data is stored so that the it may be revived for every request made by the same client.</p>

<p>This plugin links the two pieces together.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="RECOMENDED_BACKENDS"
>RECOMENDED BACKENDS</a></h1>

<dl>
<dt><a name="Session::State::Cookie"
>Session::State::Cookie</a></dt>

<dd>
<p>The only really sane way to do state is using cookies.</p>

<dt><a name="Session::Store::File"
>Session::Store::File</a></dt>

<dd>
<p>A portable backend, based on Cache::File.</p>

<dt><a name="Session::Store::FastMmap"
>Session::Store::FastMmap</a></dt>

<dd>
<p>A fast and flexible backend, based on Cache::FastMmap.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<dl>
<dt><a name="sessionid"
>sessionid</a></dt>

<dd>
<p>An accessor for the session ID value.</p>

<dt><a name="session"
>session</a></dt>

<dd>
<p>Returns a hash reference that might contain unserialized values from previous requests in the same session, and whose modified value will be saved for future requests.</p>

<p>This method will automatically create a new session and session ID if none exists.</p>

<p>You can also set session keys by passing a list of key/value pairs or a hashref.</p>

<pre>    $c-&#62;session-&#62;{foo} = &#34;bar&#34;;      # This works.
    $c-&#62;session(one =&#62; 1, two =&#62; 2); # And this.
    $c-&#62;session({ answer =&#62; 42 });   # And this.</pre>

<dt><a name="session_expires"
>session_expires</a></dt>

<dd>
<p>This method returns the time when the current session will expire, or 0 if there is no current session. If there is a session and it already expired, it will delete the session and return 0 as well.</p>

<dt><a name="flash"
>flash</a></dt>

<dd>
<p>This is like Ruby on Rails&#39; flash data structure. Think of it as a stash that lasts for longer than one request, letting you redirect instead of forward.</p>

<p>The flash data will be cleaned up only on requests on which actually use $c-&#62;flash (thus allowing multiple redirections), and the policy is to delete all the keys which haven&#39;t changed since the flash data was loaded at the end of every request.</p>

<p>Note that use of the flash is an easy way to get data across requests, but it&#39;s also strongly disrecommended, due it it being inherently plagued with race conditions. This means that it&#39;s unlikely to work well if your users have multiple tabs open at once, or if your site does a lot of AJAX requests.</p>

<p><a href="../../Catalyst/Plugin/StatusMessage.html" class="podlinkpod"
>Catalyst::Plugin::StatusMessage</a> is the recommended alternative solution, as this doesn&#39;t suffer from these issues.</p>

<pre>    sub moose : Local {
        my ( $self, $c ) = @_;

        $c-&#62;flash-&#62;{beans} = 10;
        $c-&#62;response-&#62;redirect( $c-&#62;uri_for(&#34;foo&#34;) );
    }

    sub foo : Local {
        my ( $self, $c ) = @_;

        my $value = $c-&#62;flash-&#62;{beans};

        # ...

        $c-&#62;response-&#62;redirect( $c-&#62;uri_for(&#34;bar&#34;) );
    }

    sub bar : Local {
        my ( $self, $c ) = @_;

        if ( exists $c-&#62;flash-&#62;{beans} ) { # false

        }
    }</pre>

<dt><a name="clear_flash"
>clear_flash</a></dt>

<dd>
<p>Zap all the keys in the flash regardless of their current state.</p>

<dt><a name="keep_flash_@keys"
>keep_flash @keys</a></dt>

<dd>
<p>If you want to keep a flash key for the next request too, even if it hasn&#39;t changed, call <code>keep_flash</code> and pass in the keys as arguments.</p>

<dt><a name="delete_session_REASON"
>delete_session REASON</a></dt>

<dd>
<p>This method is used to invalidate a session. It takes an optional parameter which will be saved in <code>session_delete_reason</code> if provided.</p>

<p>NOTE: This method will <b>also</b> delete your flash data.</p>

<dt><a name="session_delete_reason"
>session_delete_reason</a></dt>

<dd>
<p>This accessor contains a string with the reason a session was deleted. Possible values include:</p>

<ul>
<li><code>address mismatch</code></li>

<li><code>session expired</code></li>
</ul>

<dt><a name="session_expire_key_$key,_$ttl"
>session_expire_key $key, $ttl</a></dt>

<dd>
<p>Mark a key to expire at a certain time (only useful when shorter than the expiry time for the whole session).</p>

<p>For example:</p>

<pre>    __PACKAGE__-&#62;config(&#39;Plugin::Session&#39; =&#62; { expires =&#62; 10000000000 }); # &#34;forever&#34;
    (NB If this number is too large, Y2K38 breakage could result.)

    # later

    $c-&#62;session_expire_key( __user =&#62; 3600 );</pre>

<p>Will make the session data survive, but the user will still be logged out after an hour.</p>

<p>Note that these values are not auto extended.</p>

<dt><a name="change_session_id"
>change_session_id</a></dt>

<dd>
<p>By calling this method you can force a session id change while keeping all session data. This method might come handy when you are paranoid about some advanced variations of session fixation attack.</p>

<p>If you want to prevent this session fixation scenario:</p>

<pre>    0) let us have WebApp with anonymous and authenticated parts
    1) a hacker goes to vulnerable WebApp and gets a real sessionid,
       just by browsing anonymous part of WebApp
    2) the hacker inserts (somehow) this values into a cookie in victim&#39;s browser
    3) after the victim logs into WebApp the hacker can enter his/her session</pre>

<p>you should call change_session_id in your login controller like this:</p>

<pre>      if ($c-&#62;authenticate( { username =&#62; $user, password =&#62; $pass } )) {
        # login OK
        $c-&#62;change_session_id;
        ...
      } else {
        # login FAILED
        ...
      }</pre>

<dt><a name="change_session_expires_$expires"
>change_session_expires $expires</a></dt>

<dd>
<p>You can change the session expiration time for this session;</p>

<pre>    $c-&#62;change_session_expires( 4000 );</pre>

<p>Note that this only works to set the session longer than the config setting.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="INTERNAL_METHODS"
>INTERNAL METHODS</a></h1>

<dl>
<dt><a name="setup"
>setup</a></dt>

<dd>
<p>This method is extended to also make calls to <code>check_session_plugin_requirements</code> and <code>setup_session</code>.</p>

<dt><a name="check_session_plugin_requirements"
>check_session_plugin_requirements</a></dt>

<dd>
<p>This method ensures that a State and a Store plugin are also in use by the application.</p>

<dt><a name="setup_session"
>setup_session</a></dt>

<dd>
<p>This method populates <code>$c-&#62;config(&#39;Plugin::Session&#39;)</code> with the default values listed in <a href="#CONFIGURATION" class="podlinkpod"
>&#34;CONFIGURATION&#34;</a>.</p>

<dt><a name="prepare_action"
>prepare_action</a></dt>

<dd>
<p>This method is extended.</p>

<p>Its only effect is if the (off by default) <code>flash_to_stash</code> configuration parameter is on - then it will copy the contents of the flash to the stash at prepare time.</p>

<dt><a name="finalize_headers"
>finalize_headers</a></dt>

<dd>
<p>This method is extended and will extend the expiry time before sending the response.</p>

<dt><a name="finalize_body"
>finalize_body</a></dt>

<dd>
<p>This method is extended and will call finalize_session before the other finalize_body methods run. Here we persist the session data if a session exists.</p>

<dt><a name="initialize_session_data"
>initialize_session_data</a></dt>

<dd>
<p>This method will initialize the internal structure of the session, and is called by the <code>session</code> method if appropriate.</p>

<dt><a name="create_session_id"
>create_session_id</a></dt>

<dd>
<p>Creates a new session ID using <code>generate_session_id</code> if there is no session ID yet.</p>

<dt><a name="validate_session_id_SID"
>validate_session_id SID</a></dt>

<dd>
<p>Make sure a session ID is of the right format.</p>

<p>This currently ensures that the session ID string is any amount of case insensitive hexadecimal characters.</p>

<dt><a name="generate_session_id"
>generate_session_id</a></dt>

<dd>
<p>This method will return a string that can be used as a session ID. It is supposed to be a reasonably random string with enough bits to prevent collision. It basically takes <code>session_hash_seed</code> and hashes it using SHA-1, MD5 or SHA-256, depending on the availability of these modules.</p>

<dt><a name="session_hash_seed"
>session_hash_seed</a></dt>

<dd>
<p>This method is actually rather internal to generate_session_id, but should be overridable in case you want to provide more random data.</p>

<p>Currently it returns a concatenated string which contains:</p>

<ul>
<li>A counter</li>

<li>The current time</li>

<li>One value from <code>rand</code>.</li>

<li>The stringified value of a newly allocated hash reference</li>

<li>The stringified value of the Catalyst context object</li>
</ul>

<p>in the hopes that those combined values are entropic enough for most uses. If this is not the case you can replace <code>session_hash_seed</code> with e.g.</p>

<pre>    sub session_hash_seed {
        open my $fh, &#34;&#60;&#34;, &#34;/dev/random&#34;;
        read $fh, my $bytes, 20;
        close $fh;
        return $bytes;
    }</pre>

<p>Or even more directly, replace <code>generate_session_id</code>:</p>

<pre>    sub generate_session_id {
        open my $fh, &#34;&#60;&#34;, &#34;/dev/random&#34;;
        read $fh, my $bytes, 20;
        close $fh;
        return unpack(&#34;H*&#34;, $bytes);
    }</pre>

<p>Also have a look at <a href="../../Crypt/Random.html" class="podlinkpod"
>Crypt::Random</a> and the various openssl bindings - these modules provide APIs for cryptographically secure random data.</p>

<dt><a name="finalize_session"
>finalize_session</a></dt>

<dd>
<p>Clean up the session during <code>finalize</code>.</p>

<p>This clears the various accessors after saving to the store.</p>

<dt><a name="dump_these"
>dump_these</a></dt>

<dd>
<p>See <a href="../../Catalyst.html#dump_these" class="podlinkpod"
>&#34;dump_these&#34; in Catalyst</a> - ammends the session data structure to the list of dumped objects if session ID is defined.</p>

<dt><a name="calculate_extended_session_expires"
>calculate_extended_session_expires</a></dt>

<dd>
<dt><a name="calculate_initial_session_expires"
>calculate_initial_session_expires</a></dt>

<dd>
<dt><a name="create_session_id_if_needed"
>create_session_id_if_needed</a></dt>

<dd>
<dt><a name="delete_session_id"
>delete_session_id</a></dt>

<dd>
<dt><a name="extend_session_expires"
>extend_session_expires</a></dt>

<dd>
<p>Note: this is *not* used to give an individual user a longer session. See &#39;change_session_expires&#39;.</p>

<dt><a name="extend_session_id"
>extend_session_id</a></dt>

<dd>
<dt><a name="get_session_id"
>get_session_id</a></dt>

<dd>
<dt><a name="reset_session_expires"
>reset_session_expires</a></dt>

<dd>
<dt><a name="session_is_valid"
>session_is_valid</a></dt>

<dd>
<dt><a name="set_session_id"
>set_session_id</a></dt>

<dd>
<dt><a name="initial_session_expires"
>initial_session_expires</a></dt>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="USING_SESSIONS_DURING_PREPARE"
>USING SESSIONS DURING PREPARE</a></h1>

<p>The earliest point in time at which you may use the session data is after <a href="../../Catalyst/Plugin/Session.html" class="podlinkpod"
>Catalyst::Plugin::Session</a>&#39;s <code>prepare_action</code> has finished.</p>

<p>State plugins must set $c-&#62;session ID before <code>prepare_action</code>, and during <code>prepare_action</code> <a href="../../Catalyst/Plugin/Session.html" class="podlinkpod"
>Catalyst::Plugin::Session</a> will actually load the data from the store.</p>

<pre>    sub prepare_action {
        my $c = shift;

        # don&#39;t touch $c-&#62;session yet!

        $c-&#62;NEXT::prepare_action( @_ );

        $c-&#62;session;  # this is OK
        $c-&#62;sessionid; # this is also OK
    }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CONFIGURATION"
>CONFIGURATION</a></h1>

<pre>    $c-&#62;config(&#39;Plugin::Session&#39; =&#62; {
        expires =&#62; 1234,
    });</pre>

<p>All configuation parameters are provided in a hash reference under the <code>Plugin::Session</code> key in the configuration hash.</p>

<dl>
<dt><a name="expires"
>expires</a></dt>

<dd>
<p>The time-to-live of each session, expressed in seconds. Defaults to 7200 (two hours).</p>

<dt><a name="expiry_threshold"
>expiry_threshold</a></dt>

<dd>
<p>Only update the session expiry time if it would otherwise expire within this many seconds from now.</p>

<p>The purpose of this is to keep the session store from being updated when nothing else in the session is updated.</p>

<p>Defaults to 0 (in which case, the expiration will always be updated).</p>

<dt><a name="verify_address"
>verify_address</a></dt>

<dd>
<p>When true, <code>$c-&#62;request-&#62;address</code> will be checked at prepare time. If it is not the same as the address that initiated the session, the session is deleted.</p>

<p>Defaults to false.</p>

<dt><a name="verify_user_agent"
>verify_user_agent</a></dt>

<dd>
<p>When true, <code>$c-&#62;request-&#62;user_agent</code> will be checked at prepare time. If it is not the same as the user agent that initiated the session, the session is deleted.</p>

<p>Defaults to false.</p>

<dt><a name="flash_to_stash"
>flash_to_stash</a></dt>

<dd>
<p>This option makes it easier to have actions behave the same whether they were forwarded to or redirected to. On prepare time it copies the contents of <code>flash</code> (if any) to the stash.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SPECIAL_KEYS"
>SPECIAL KEYS</a></h1>

<p>The hash reference returned by <code>$c-&#62;session</code> contains several keys which are automatically set:</p>

<dl>
<dt><a name="__expires"
>__expires</a></dt>

<dd>
<p>This key no longer exists. Use <code>session_expires</code> instead.</p>

<dt><a name="__updated"
>__updated</a></dt>

<dd>
<p>The last time a session was saved to the store.</p>

<dt><a name="__created"
>__created</a></dt>

<dd>
<p>The time when the session was first created.</p>

<dt><a name="__address"
>__address</a></dt>

<dd>
<p>The value of <code>$c-&#62;request-&#62;address</code> at the time the session was created. This value is only populated if <code>verify_address</code> is true in the configuration.</p>

<dt><a name="__user_agent"
>__user_agent</a></dt>

<dd>
<p>The value of <code>$c-&#62;request-&#62;user_agent</code> at the time the session was created. This value is only populated if <code>verify_user_agent</code> is true in the configuration.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CAVEATS"
>CAVEATS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Round_the_Robin_Proxies"
>Round the Robin Proxies</a></h2>

<p><code>verify_address</code> could make your site inaccessible to users who are behind load balanced proxies. Some ISPs may give a different IP to each request by the same client due to this type of proxying. If addresses are verified these users&#39; sessions cannot persist.</p>

<p>To let these users access your site you can either disable address verification as a whole, or provide a checkbox in the login dialog that tells the server that it&#39;s OK for the address of the client to change. When the server sees that this box is checked it should delete the <code>__address</code> special key from the session hash when the hash is first created.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Race_Conditions"
>Race Conditions</a></h2>

<p>In this day and age where cleaning detergents and Dutch football (not the American kind) teams roam the plains in great numbers, requests may happen simultaneously. This means that there is some risk of session data being overwritten, like this:</p>

<ol>
<li>request a starts, request b starts, with the same session ID</li>

<li>session data is loaded in request a</li>

<li>session data is loaded in request b</li>

<li>session data is changed in request a</li>

<li>request a finishes, session data is updated and written to store</li>

<li>request b finishes, session data is updated and written to store, overwriting changes by request a</li>
</ol>

<p>For applications where any given user&#39;s session is only making one request at a time this plugin should be safe enough.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<p>Andy Grundman</p>

<p>Christian Hansen</p>

<p>Yuval Kogman, <code>nothingmuch@woobling.org</code></p>

<p>Sebastian Riedel</p>

<p>Tomas Doran (t0m) <code>bobtfish@bobtfish.net</code> (current maintainer)</p>

<p>Sergio Salvi</p>

<p>kmx <code>kmx@volny.cz</code></p>

<p>Florian Ragwitz (rafl) <code>rafl@debian.org</code></p>

<p>Kent Fredric (kentnl)</p>

<p>And countless other contributers from #catalyst. Thanks guys!</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Contributors"
>Contributors</a></h1>

<p>Devin Austin (dhoss) &#60;dhoss@cpan.org&#62;</p>

<p>Robert Rothenberg &#60;rrwo@cpan.org&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_&#38;_LICENSE"
>COPYRIGHT &#38; LICENSE</a></h1>

<pre>    Copyright (c) 2005 the aforementioned authors. All rights
    reserved. This program is free software; you can redistribute
    it and/or modify it under the same terms as Perl itself.</pre>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
