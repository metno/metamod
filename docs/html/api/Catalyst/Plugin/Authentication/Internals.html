<html><head><title>Catalyst::Plugin::Authentication::Internals</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:02 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#INTRODUCTION'>INTRODUCTION</a>
  <li class='indexItem indexItem1'><a href='#OVERVIEW'>OVERVIEW</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#INITIALIZATION'>INITIALIZATION</a>
    <li class='indexItem indexItem2'><a href='#AUTHENTICATION'>AUTHENTICATION</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#WRITING_A_STORE'>WRITING A STORE</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#STORAGE_BACKEND'>STORAGE BACKEND</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#STORE_METHODS'>STORE METHODS</a>
      <li class='indexItem indexItem3'><a href='#OPTIONAL_STORE_METHODS'>OPTIONAL STORE METHODS</a>
      <ul   class='indexList indexList4'>
        <li class='indexItem indexItem4'><a href='#auto_update_user(_%24authinfo%2C_%24c%2C_%24res_)'>auto_update_user( $authinfo, $c, $res )</a>
        <li class='indexItem indexItem4'><a href='#auto_create_user(_%24authinfo%2C_%24c_)'>auto_create_user( $authinfo, $c )</a>
      </ul>
    </ul>
    <li class='indexItem indexItem2'><a href='#USER_OBJECT'>USER OBJECT</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#USER_METHODS'>USER METHODS</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#WRITING_A_CREDENTIAL'>WRITING A CREDENTIAL</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#CREDENTIAL_METHODS'>CREDENTIAL METHODS</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_%26_LICENSE'>COPYRIGHT &#38; LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Catalyst::Plugin::Authentication::Internals - All about authentication Stores and Credentials</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="INTRODUCTION"
>INTRODUCTION</a></h1>

<p><a href="../../../Catalyst/Plugin/Authentication.html" class="podlinkpod"
>Catalyst::Plugin::Authentication</a> provides a standard authentication interface to application developers using the Catalyst framework.
It is designed to allow application developers to use various methods of user storage and credential verification.
It is also designed to provide for minimal change to the application when switching between different storage and credential verification methods.</p>

<p>While <a href="../../../Catalyst/Plugin/Authentication.html" class="podlinkpod"
>Catalyst::Plugin::Authentication</a> provides the interface to the application developer,
the actual work of verifying the credentials and retrieving users is delegated to separate modules.
These modules are called <b>Credentials</b> and storage backends,
or <b>Stores</b>,
respectively.
For authentication to function there must be at least one credential and one store.
A pairing of a store and a credential is referred to as a <b>Realm</b>.
There may be any number of realms defined for an application,
though most applications will not require more than one or two.</p>

<p>The details of using this module can be found in the <a href="../../../Catalyst/Plugin/Authentication.html" class="podlinkpod"
>Catalyst::Plugin::Authentication</a> documentation.</p>

<p>What follows is an explanation of how the module functions internally and what is required to implement a credential or a store.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="OVERVIEW"
>OVERVIEW</a></h1>

<p>There are two main entry points you need to be aware of when writing a store or credential module.
The first is initialization and the second is during the actual call to the Catalyst application&#39;s authenticate method.</p>

<p>A simplified description of the authentication process follows:</p>

<p><b>Initialization</b></p>

<blockquote>
<p><b>Realm Setup</b> - for each realm:</p>

<blockquote>
<p>1) The Realm is instantiated using new() method</p>

<p>2) The Store is instantiated using new() method</p>

<p>3) The Credential Instantiated using new() method</p>

<p>4) Credential and Store objects tied to realm for use during requests</p>
</blockquote>
</blockquote>

<p><b>Authentication</b></p>

<blockquote>
<p><code>$c-&#62;authenticate( $userinfo,
$realm )</code> called</p>

<blockquote>
<p>1) Credential object retrieved for realm provided</p>

<p>2) Credential&#39;s authenticate() method called with authinfo and realm object for current realm</p>

<blockquote>
<p>The realm object and the authinfo hash are provided to the credential object&#39;s authenticate call.
In most cases the credential object will attempt to retrieve a user using the realm&#39;s find_user() method,
which by default relays the call directly to the Store&#39;s find_user() method.
It will then usually compare the retrieved user&#39;s information with the information provided in the $authinfo hash.
This is how the default &#39;Password&#39; credential functions.
If the credentials match,
the authenticate() method should return a user object.</p>
</blockquote>

<p>3) User object stored in session</p>

<blockquote>
<p>If the user object supports session storage,
the successfully authenticated user will be placed in session storage.
This is done by calling the realm object&#39;s persist_user() method.
The persist_user() routine by default calls the Store&#39;s for_session() method,
which should return serialized data (IE a scalar).
This serialized data is passed back to the store via the from_session() method,
so the data should contain enough information for the store to recreate / reload the user.</p>
</blockquote>
</blockquote>
</blockquote>

<p><b>Sessions</b> - Per-Request operations</p>

<blockquote>
<p>When any user-related activity occurs,
and $c-&#62;authenticate has not yet been called,
the Catalyst::Plugin::Authentication module will attempt to restore the persisted user (normally from the session if one is available).
There is only one step in this process:</p>

<blockquote>
<p>1) Store object&#39;s from_session() is called</p>
</blockquote>

<p>The serialized data previously returned by the store&#39;s for_session() method is provided to the from_session() method.
The from_session() method should return a valid user object.</p>

<p>Note that the for_session() is only called during the original $c-&#62;authenticate() call,
so if changes are made to the user that need to be reflected in your session data,
you will want to call the $c-&#62;persist_user() method - which will perform the session storage process again (complete with call to for_session()).</p>
</blockquote>

<p>More detailed information about these processes is below.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="INITIALIZATION"
>INITIALIZATION</a></h2>

<p>When the authentication module is loaded,
it reads it&#39;s configuration to determine the realms to set up for the application and which realm is to be the default.
For each realm defined in the application&#39;s config,
<a href="../../../Catalyst/Plugin/Authentication.html" class="podlinkpod"
>Catalyst::Plugin::Authentication</a> instantiates both a new credential object and a new store object.
See below for the details of how credentials and stores are instantiated.</p>

<p><b>NOTE</b>: The instances created will remain active throughout the entire lifetime of the application,
and so should be relatively lightweight.
Care should be taken to ensure that they do not grow,
or retain information per request,
because they will be involved in each authentication request and could therefore substantially hurt memory consumption over time.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="AUTHENTICATION"
>AUTHENTICATION</a></h2>

<p>When <code>$c-&#62;authenticate()</code> is called from within an application,
the objects created in the initialization process come into play.
<code>$c-&#62;authenticate()</code> takes two arguments.
The first is a hash reference containing all the information available about the user.
This will be used to locate the user in the store and verify the user&#39;s credentials.
The second argument is the realm to authenticate against.
If the second argument is omitted,
the default realm is assumed.</p>

<p>The main authentication module then locates the credential and store objects for the realm specified and calls the credential object&#39;s <code>authenticate()</code> method.
It provides three arguments,
first the application object,
or <code>$c</code>,
then a reference to the store object,
and finally the hashref provided in the <code>$c-&#62;authenticate</code> call.
The main authentication module expects the return value to be a reference to a user object upon successful authentication.
If it receives anything aside from a reference,
it is considered to be an authentication failure.
Upon success,
the returned user is marked as authenticated and the application can act accordingly,
using <code>$c-&#62;user</code> to access the authenticated user,
etc.</p>

<p>Astute readers will note that the main <a href="../../../Catalyst/Plugin/Authentication.html" class="podlinkpod"
>Catalyst::Plugin::Authentication</a> module does not interact with the store in any way,
save for passing a reference to it to the credential.
This is correct.
The credential object is responsible for obtaining the user from the provided store using information from the userinfo hashref and/or data obtained during the credential verification process.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="WRITING_A_STORE"
>WRITING A STORE</a></h1>

<p>There are two parts to an authentication store,
the store object and the user object.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="STORAGE_BACKEND"
>STORAGE BACKEND</a></h2>

<p>Writing a store is actually quite simple.
There are only five methods that must be implemented.
They are:</p>

<pre>    new()           - instantiates the store object
    find_user()     - locates a user using data contained in the hashref
    for_session()   - prepares a user to be stored in the session
    from_session()  - does any restoration required when obtaining a user from the session
    user_supports() - provides information about what the user object supports</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="STORE_METHODS"
>STORE METHODS</a></h3>

<dl>
<dt><a name="new(_$config,_$app,_$realm_)"
>new( $config, $app, $realm )</a></dt>

<dd>
<p>The <code>new()</code> method is called only once, during the setup process of <a href="../../../Catalyst/Plugin/Authentication.html" class="podlinkpod"
>Catalyst::Plugin::Authentication</a>. The first argument, <code>$config</code>, is a hash reference containing the configuration information for the store module. The second argument is a reference to the Catalyst application.</p>

<p>Note that when new() is called, Catalyst has not yet loaded the various controller and model classes, nor is it definite that other plugins have been loaded, so your new() method must not rely on any of those being present. If any of this is required for your store to function, you should defer that part of initialization until the first method call.</p>

<p>The <code>new()</code> method should return a blessed reference to your store object.</p>

<dt><a name="find_user(_$authinfo,_$c_)"
>find_user( $authinfo, $c )</a></dt>

<dd>
<p>This is the workhorse of any authentication store. It&#39;s job is to take the information provided to it via the <code>$authinfo</code> hashref and locate the user that matches it. It should return a reference to a user object. A return value of anything else is considered to mean no user was found that matched the information provided.</p>

<p>How <code>find_user()</code> accomplishes it&#39;s job is entirely up to you, the author, as is what $authinfo is required to contain. Many stores will simply use a username element in $authinfo to locate the user, but more advanced functionality is possible and you may bend the $authinfo to your needs. Be aware, however, that both Credentials and Stores usually work with the same $authinfo hash, so take care to avoid overlapping element names.</p>

<p>Please note that this routine may be called numerous times in various circumstances, and that a successful match for a user here does <b>NOT</b> necessarily constitute successful authentication. Your store class should never assume this and in most cases <code>$c</code> <b>should not be modified</b> by your store object.</p>

<dt><a name="for_session(_$c,_$user_)"
>for_session( $c, $user )</a></dt>

<dd>
<p>This method is responsible for preparing a user object for storage in the session. It should return information that can be placed in the session and later used to restore a user object (using the <code>from_session()</code> method). It should therefore ensure that whatever information provided can be used by the <code>from_session()</code> method to locate the unique user being saved. Note that there is no guarantee that the same Catalyst instance will receive both the <code>for_session()</code> and <code>from_session()</code> calls. You should take care to provide information that can be used to restore a user, regardless of the current state of the application. A good rule of thumb is that if <code>from_session()</code> can revive the user with the given information even if the Catalyst application has just started up, you are in good shape.</p>

<dt><a name="from_session(_$c,_$frozenuser_)"
>from_session( $c, $frozenuser )</a></dt>

<dd>
<p>This method is called whenever a user is being restored from the session. <code>$frozenuser</code> contains the information that was stored in the session for the user. This will under normal circumstances be the exact data your store returned from the previous call to <code>for_session()</code>. <code>from_session()</code> should return a valid user object.</p>

<dt><a name="user_supports(_$feature,_..._)"
>user_supports( $feature, ... )</a></dt>

<dd>
<p>This method allows credentials and other objects to inquire as to what the underlying user object is capable of. This is pretty-well free-form and the main purpose is to allow graceful integration with credentials and applications that may provide advanced functionality based on whether the underlying user object can do certain things. In most cases you will want to pass this directly to the underlying user class&#39; <code>supports</code> method. Note that this is used as a <b>class</b> method against the user class and therefore must be able to function without an instantiated user object.</p>
</dd>
</dl>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="OPTIONAL_STORE_METHODS"
>OPTIONAL STORE METHODS</a></h3>

<p>If you want your store to be able to auto- create users, then you can implement these methods:</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="auto_update_user(_$authinfo,_$c,_$res_)"
>auto_update_user( $authinfo, $c, $res )</a></h4>

<p>This method is called if the realm&#39;s auto_update_user setting is true.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="auto_create_user(_$authinfo,_$c_)"
>auto_create_user( $authinfo, $c )</a></h4>

<p>This method is called if the realm&#39;s auto_create_user setting is true.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="USER_OBJECT"
>USER OBJECT</a></h2>

<p>The user object is an important piece of your store module. It will be the part of the system that the application developer will interact with most. As such, the API for the user object is very rigid. All user objects <b>MUST</b> inherit from <a href="../../../Catalyst/Authentication/User.html" class="podlinkpod"
>Catalyst::Authentication::User</a>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="USER_METHODS"
>USER METHODS</a></h3>

<p>The routines required by the <a href="../../../Catalyst/Plugin/Authentication.html" class="podlinkpod"
>Catalyst::Plugin::Authentication</a> plugin are below. Note that of these, only get_object is strictly required, as the <a href="../../../Catalyst/Authentication/User.html" class="podlinkpod"
>Catalyst::Authentication::User</a> base class contains reasonable implementations of the rest. If you do choose to implement only the <code>get_object()</code> routine, please read the base class code and documentation so that you fully understand how the other routines will be implemented for you.</p>

<p>Also, your user object can implement whatever additional methods you require to provide the functionality you need. So long as the below are implemented, and you don&#39;t overlap the base class&#39; methods with incompatible routines, you should experience no problems.</p>

<dl>
<dt><a name="id(_)"
>id( )</a></dt>

<dd>
<p>The <code>id()</code> method should return a unique id (scalar) that can be used to retreive this user from the store. Often this will be provided to the store&#39;s <code>find_user()</code> routine as <code>id =&#62; $user-&#62;id</code> so you should ensure that your store&#39;s <code>find_user()</code> can cope with that.</p>

<dt><a name="supports(_$feature,_$subfeature_..._)"
>supports( $feature, $subfeature ... )</a></dt>

<dd>
<p>This method checks to see if the user class supports a particular feature. It is implemented such that each argument provides a subfeature of the previous argument. In other words, passing &#39;foo&#39;, &#39;bar&#39; would return true if the user supported the &#39;foo&#39; feature, and the &#39;bar&#39; feature of &#39;foo&#39;. This is implemented in Catalyst::Authentication::User, so if your class inherits from that, you do not need to implement this and can instead implement supported_features().</p>

<p><b>Note:</b> If you want the authentication module to be able to save your user in the session you must return true when presented with the feature &#39;session&#39;.</p>

<dt><a name="supported_features(_)"
>supported_features( )</a></dt>

<dd>
<p>This method should return a hashref of features supported by the user class. This is for more flexible integration with some Credentials / applications. It is not required that you support anything, and returning <code>undef</code> is perfectly acceptable and in most cases what you will do.</p>

<dt><a name="get(_$fieldname_)"
>get( $fieldname )</a></dt>

<dd>
<p>This method should return the value of the field matching fieldname provided, or undef if there is no field matching that fieldname. In most cases this will access the underlying storage mechanism for the user data and return the information. This is used as a standard method of accessing an authenticated user&#39;s data, and MUST be implemented by all user objects.</p>

<p><b>Note</b>: There is no equivalent &#39;set&#39; method. Each user class is likely to vary greatly in how data must be saved and it is therefore impractical to try to provide a standard way of accomplishing it. When an application developer needs to save data, they should obtain the underlying object / data by calling get_object, and work with it directly.</p>

<dt><a name="get_object(_)"
>get_object( )</a></dt>

<dd>
<p>This method returns the underlying user object. If your user object is backed by another object class, this method should return that underlying object. This allows the application developer to obtain an editable object. Generally speaking this will only be done by developers who know what they are doing and require advanced functionality which is either unforeseen or inconsistent across user classes. If your object is not backed by another class, or you need to provide additional intermediate functionality, it is perfectly reasonable to return <code>$self</code>.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="WRITING_A_CREDENTIAL"
>WRITING A CREDENTIAL</a></h1>

<p>Compared to writing a store, writing a credential is very simple. There is only one class to implement, and it consists of only two required routines. They are:</p>

<pre>    new()           - instantiates the credential object
    authenticate()  - performs the authentication and returns a user object</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="CREDENTIAL_METHODS"
>CREDENTIAL METHODS</a></h2>

<dl>
<dt><a name="new(_$config,_$app,_$realm_)"
>new( $config, $app, $realm )</a></dt>

<dd>
<p>Like the Store method of the same name, the <code>new()</code> method is called only once, during the setup process of <a href="../../../Catalyst/Plugin/Authentication.html" class="podlinkpod"
>Catalyst::Plugin::Authentication</a>. The first argument, <code>$config</code>, is a hash reference containing the configuration information for the credential module. The second argument is a reference to the Catalyst application. $realm is the instantiated Realm object, which you may use to access realm routines - such as find_user.</p>

<p>Again, when the credential&#39;s new() method is called, Catalyst has not yet loaded the various controller and model classes.</p>

<p>The new method should perform any necessary setup required and instantiate your credential object. It should return your instantiated credential.</p>

<dt><a name="authenticate(_$c,_$realm,_$authinfo_)"
>authenticate( $c, $realm, $authinfo )</a></dt>

<dd>
<p>This is the workhorse of your credential. When $c-&#62;authenticate() is called the <a href="../../../Catalyst/Plugin/Authentication.html" class="podlinkpod"
>Catalyst::Plugin::Authentication</a> module retrieves the realm object and passes it, along with the $authinfo hash to your credential&#39;s authenticate method. Your module should use the $authinfo hash to obtain the user from the realm passed, and then perform any credential verification steps necessary to authenticate the user. This method should return the user object returned by the authentication store if credential verification succeeded. It should return undef on failure.</p>

<p>How your credential module performs the credential verification is entirely up to you. In most cases, the credential will retrieve a user from the store first (using the stores find_user() method), and then validate the user&#39;s information. However, this does not have to be the case.</p>

<p>It is perfectly acceptable for your credential to perform other tasks prior to attempting to retrieve the user from the store. It may also make sense for your credential to perform activities which help to locate the user in question, for example, finding a user id based on an encrypted token. In these scenarios, the $authinfo hash passed to find_user() can be different than that which is passed in to $c-&#62;authenticate(). Once again this is perfectly acceptable if it makes sense for your credential, though you are strongly advised to note this behavior clearly in your credential&#39;s documentation - as application authors are almost certainly expecting the user to be found using the information provided to $c-&#62;authenticate().</p>

<p>Look at the <a href="../../../Catalyst/Authentication/Credential/Password.html" class="podlinkpod"
>Catalyst::Authentication::Credential::Password</a> module source to see this in action. In order to avoid possible mismatches between the encrypted and unencrypted passwords, the password credential actually removes the provided password from the authinfo array. It does this because, in many cases, the store&#39;s password field will be encrypted in some way, and the password passed to $c-&#62;authenticate is almost certainly in plaintext.</p>

<p>NOTE: You should always assume that a store is going to use all the information passed to it to locate the user in question. If there are fields in the $authinfo hash that you are sure are specific to your credential, you may want to consider removing them before user retrieval. A better solution is to place those arguments that are specific to your credential within their own subhash named after your module.</p>

<p>The <a href="../../../Catalyst/Authentication/Store/DBIx/Class.html" class="podlinkpod"
>Catalyst::Authentication::Store::DBIx::Class</a> module does this in order to encapsulate arguments intended specifically for that module. See the <a href="../../../Catalyst/Authentication/Store/DBIx/Class/User.html" class="podlinkpod"
>Catalyst::Authentication::Store::DBIx::Class::User</a> source for details.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<p>Jay Kuri, <code>jayk@cpan.org</code></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_&#38;_LICENSE"
>COPYRIGHT &#38; LICENSE</a></h1>

<p>Copyright (c) 2005 the aforementioned authors. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
