<html><head><title>Catalyst::DispatchType::Chained</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:02 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#%24self-%3Elist(%24c)'>$self-&#62;list($c)</a>
    <li class='indexItem indexItem2'><a href='#%24self-%3Ematch(_%24c%2C_%24path_)'>$self-&#62;match( $c, $path )</a>
    <li class='indexItem indexItem2'><a href='#%24self-%3Erecurse_match(_%24c%2C_%24parent%2C_%5C%40path_parts_)'>$self-&#62;recurse_match( $c, $parent, \@path_parts )</a>
    <li class='indexItem indexItem2'><a href='#%24self-%3Eregister(_%24c%2C_%24action_)'>$self-&#62;register( $c, $action )</a>
    <li class='indexItem indexItem2'><a href='#%24self-%3Euri_for_action(%24action%2C_%24captures)'>$self-&#62;uri_for_action($action, $captures)</a>
    <li class='indexItem indexItem2'><a href='#%24c-%3Eexpand_action(%24action)'>$c-&#62;expand_action($action)</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#USAGE'>USAGE</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Introduction'>Introduction</a>
    <li class='indexItem indexItem2'><a href='#Attributes'>Attributes</a>
    <li class='indexItem indexItem2'><a href='#Auto_actions%2C_dispatching_and_forwarding'>Auto actions, dispatching and forwarding</a>
    <li class='indexItem indexItem2'><a href='#match_captures'>match_captures</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Catalyst::DispatchType::Chained - Path Part DispatchType</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<p>Path part matching,
allowing several actions to sequentially take care of processing a request:</p>

<pre>  #   root action - captures one argument after it
  sub foo_setup : Chained(&#39;/&#39;) PathPart(&#39;foo&#39;) CaptureArgs(1) {
      my ( $self, $c, $foo_arg ) = @_;
      ...
  }

  #   child action endpoint - takes one argument
  sub bar : Chained(&#39;foo_setup&#39;) Args(1) {
      my ( $self, $c, $bar_arg ) = @_;
      ...
  }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Dispatch type managing default behaviour. For more information on dispatch types, see:</p>

<ul>
<li><a href="../../Catalyst/Manual/Intro.html" class="podlinkpod"
>Catalyst::Manual::Intro</a> for how they affect application authors</li>

<li><a href="../../Catalyst/DispatchType.html" class="podlinkpod"
>Catalyst::DispatchType</a> for implementation information.</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$self-&#62;list($c)"
>$self-&#62;list($c)</a></h2>

<p>Debug output for Path Part dispatch points</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$self-&#62;match(_$c,_$path_)"
>$self-&#62;match( $c, $path )</a></h2>

<p>Calls <code>recurse_match</code> to see if a chain matches the <code>$path</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$self-&#62;recurse_match(_$c,_$parent,_\@path_parts_)"
>$self-&#62;recurse_match( $c, $parent, \@path_parts )</a></h2>

<p>Recursive search for a matching chain.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$self-&#62;register(_$c,_$action_)"
>$self-&#62;register( $c, $action )</a></h2>

<p>Calls register_path for every Path attribute for the given $action.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$self-&#62;uri_for_action($action,_$captures)"
>$self-&#62;uri_for_action($action, $captures)</a></h2>

<p>Get the URI part for the action, using <code>$captures</code> to fill the capturing parts.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$c-&#62;expand_action($action)"
>$c-&#62;expand_action($action)</a></h2>

<p>Return a list of actions that represents a chained action. See <a href="../../Catalyst/Dispatcher.html" class="podlinkpod"
>Catalyst::Dispatcher</a> for more info. You probably want to use the expand_action it provides rather than this directly.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="USAGE"
>USAGE</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Introduction"
>Introduction</a></h2>

<p>The <code>Chained</code> attribute allows you to chain public path parts together by their private names. A chain part&#39;s path can be specified with <code>PathPart</code> and can be declared to expect an arbitrary number of arguments. The endpoint of the chain specifies how many arguments it gets through the <code>Args</code> attribute. <code>:Args(0)</code> would be none at all, <code>:Args</code> without an integer would be unlimited. The path parts that aren&#39;t endpoints are using <code>CaptureArgs</code> to specify how many parameters they expect to receive. As an example setup:</p>

<pre>  package MyApp::Controller::Greeting;
  use base qw/ Catalyst::Controller /;

  #   this is the beginning of our chain
  sub hello : PathPart(&#39;hello&#39;) Chained(&#39;/&#39;) CaptureArgs(1) {
      my ( $self, $c, $integer ) = @_;
      $c-&#62;stash-&#62;{ message } = &#34;Hello &#34;;
      $c-&#62;stash-&#62;{ arg_sum } = $integer;
  }

  #   this is our endpoint, because it has no :CaptureArgs
  sub world : PathPart(&#39;world&#39;) Chained(&#39;hello&#39;) Args(1) {
      my ( $self, $c, $integer ) = @_;
      $c-&#62;stash-&#62;{ message } .= &#34;World!&#34;;
      $c-&#62;stash-&#62;{ arg_sum } += $integer;

      $c-&#62;response-&#62;body( join &#34;&#60;br/&#62;\n&#34; =&#62;
          $c-&#62;stash-&#62;{ message }, $c-&#62;stash-&#62;{ arg_sum } );
  }</pre>

<p>The debug output provides a separate table for chained actions, showing the whole chain as it would match and the actions it contains. Here&#39;s an example of the startup output with our actions above:</p>

<pre>  ...
  [debug] Loaded Path Part actions:
  .-----------------------+------------------------------.
  | Path Spec             | Private                      |
  +-----------------------+------------------------------+
  | /hello/*/world/*      | /greeting/hello (1)          |
  |                       | =&#62; /greeting/world           |
  &#39;-----------------------+------------------------------&#39;
  ...</pre>

<p>As you can see, Catalyst only deals with chains as whole paths and builds one for each endpoint, which are the actions with <code>:Chained</code> but without <code>:CaptureArgs</code>.</p>

<p>Let&#39;s assume this application gets a request at the path <code>/hello/23/world/12</code>. What happens then? First, Catalyst will dispatch to the <code>hello</code> action and pass the value <code>23</code> as an argument to it after the context. It does so because we have previously used <code>:CaptureArgs(1)</code> to declare that it has one path part after itself as its argument. We told Catalyst that this is the beginning of the chain by specifying <code>:Chained(&#39;/&#39;)</code>. Also note that instead of saying <code>:PathPart(&#39;hello&#39;)</code> we could also just have said <code>:PathPart</code>, as it defaults to the name of the action.</p>

<p>After <code>hello</code> has run, Catalyst goes on to dispatch to the <code>world</code> action. This is the last action to be called: Catalyst knows this is an endpoint because we did not specify a <code>:CaptureArgs</code> attribute. Nevertheless we specify that this action expects an argument, but at this point we&#39;re using <code>:Args(1)</code> to do that. We could also have said <code>:Args</code> or left it out altogether, which would mean this action would get all arguments that are there. This action&#39;s <code>:Chained</code> attribute says <code>hello</code> and tells Catalyst that the <code>hello</code> action in the current controller is its parent.</p>

<p>With this we have built a chain consisting of two public path parts. <code>hello</code> captures one part of the path as its argument, and also specifies the path root as its parent. So this part is <code>/hello/$arg</code>. The next part is the endpoint <code>world</code>, expecting one argument. It sums up to the path part <code>world/$arg</code>. This leads to a complete chain of <code>/hello/$arg/world/$arg</code> which is matched against the requested paths.</p>

<p>This example application would, if run and called by e.g. <code>/hello/23/world/12</code>, set the stash value <code>message</code> to &#34;Hello&#34; and the value <code>arg_sum</code> to &#34;23&#34;. The <code>world</code> action would then append &#34;World!&#34; to <code>message</code> and add <code>12</code> to the stash&#39;s <code>arg_sum</code> value. For the sake of simplicity no view is shown. Instead we just put the values of the stash into our body. So the output would look like:</p>

<pre>  Hello World!
  35</pre>

<p>And our test server would have given us this debugging output for the request:</p>

<pre>  ...
  [debug] &#34;GET&#34; request for &#34;hello/23/world/12&#34; from &#34;127.0.0.1&#34;
  [debug] Path is &#34;/greeting/world&#34;
  [debug] Arguments are &#34;12&#34;
  [info] Request took 0.164113s (6.093/s)
  .------------------------------------------+-----------.
  | Action                                   | Time      |
  +------------------------------------------+-----------+
  | /greeting/hello                          | 0.000029s |
  | /greeting/world                          | 0.000024s |
  &#39;------------------------------------------+-----------&#39;
  ...</pre>

<p>What would be common uses of this dispatch technique? It gives the possibility to split up logic that contains steps that each depend on each other. An example would be, for example, a wiki path like <code>/wiki/FooBarPage/rev/23/view</code>. This chain can be easily built with these actions:</p>

<pre>  sub wiki : PathPart(&#39;wiki&#39;) Chained(&#39;/&#39;) CaptureArgs(1) {
      my ( $self, $c, $page_name ) = @_;
      #  load the page named $page_name and put the object
      #  into the stash
  }

  sub rev : PathPart(&#39;rev&#39;) Chained(&#39;wiki&#39;) CaptureArgs(1) {
      my ( $self, $c, $revision_id ) = @_;
      #  use the page object in the stash to get at its
      #  revision with number $revision_id
  }

  sub view : PathPart Chained(&#39;rev&#39;) Args(0) {
      my ( $self, $c ) = @_;
      #  display the revision in our stash. Another option
      #  would be to forward a compatible object to the action
      #  that displays the default wiki pages, unless we want
      #  a different interface here, for example restore
      #  functionality.
  }</pre>

<p>It would now be possible to add other endpoints, for example <code>restore</code> to restore this specific revision as the current state.</p>

<p>You don&#39;t have to put all the chained actions in one controller. The specification of the parent through <code>:Chained</code> also takes an absolute action path as its argument. Just specify it with a leading <code>/</code>.</p>

<p>If you want, for example, to have actions for the public paths <code>/foo/12/edit</code> and <code>/foo/12</code>, just specify two actions with <code>:PathPart(&#39;foo&#39;)</code> and <code>:Chained(&#39;/&#39;)</code>. The handler for the former path needs a <code>:CaptureArgs(1)</code> attribute and a endpoint with <code>:PathPart(&#39;edit&#39;)</code> and <code>:Chained(&#39;foo&#39;)</code>. For the latter path give the action just a <code>:Args(1)</code> to mark it as endpoint. This sums up to this debugging output:</p>

<pre>  ...
  [debug] Loaded Path Part actions:
  .-----------------------+------------------------------.
  | Path Spec             | Private                      |
  +-----------------------+------------------------------+
  | /foo/*                | /controller/foo_view         |
  | /foo/*/edit           | /controller/foo_load (1)     |
  |                       | =&#62; /controller/edit          |
  &#39;-----------------------+------------------------------&#39;
  ...</pre>

<p>Here&#39;s a more detailed specification of the attributes belonging to <code>:Chained</code>:</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Attributes"
>Attributes</a></h2>

<dl>
<dt><a name="PathPart"
>PathPart</a></dt>

<dd>
<p>Sets the name of this part of the chain. If it is specified without arguments, it takes the name of the action as default. So basically <code>sub foo :PathPart</code> and <code>sub foo :PathPart(&#39;foo&#39;)</code> are identical. This can also contain slashes to bind to a deeper level. An action with <code>sub bar :PathPart(&#39;foo/bar&#39;) :Chained(&#39;/&#39;)</code> would bind to <code>/foo/bar/...</code>. If you don&#39;t specify <code>:PathPart</code> it has the same effect as using <code>:PathPart</code>, it would default to the action name.</p>

<dt><a name="PathPrefix"
>PathPrefix</a></dt>

<dd>
<p>Sets PathPart to the path_prefix of the current controller.</p>

<dt><a name="Chained"
>Chained</a></dt>

<dd>
<p>Has to be specified for every child in the chain. Possible values are absolute and relative private action paths or a single slash <code>/</code> to tell Catalyst that this is the root of a chain. The attribute <code>:Chained</code> without arguments also defaults to the <code>/</code> behavior. Relative action paths may use <code>../</code> to refer to actions in parent controllers.</p>

<p>Because you can specify an absolute path to the parent action, it doesn&#39;t matter to Catalyst where that parent is located. So, if your design requests it, you can redispatch a chain through any controller or namespace you want.</p>

<p>Another interesting possibility gives <code>:Chained(&#39;.&#39;)</code>, which chains itself to an action with the path of the current controller&#39;s namespace. For example:</p>

<pre>  #   in MyApp::Controller::Foo
  sub bar : Chained CaptureArgs(1) { ... }

  #   in MyApp::Controller::Foo::Bar
  sub baz : Chained(&#39;.&#39;) Args(1) { ... }</pre>

<p>This builds up a chain like <code>/bar/*/baz/*</code>. The specification of <code>.</code> as the argument to Chained here chains the <code>baz</code> action to an action with the path of the current controller namespace, namely <code>/foo/bar</code>. That action chains directly to <code>/</code>, so the <code>/bar/*/baz/*</code> chain comes out as the end product.</p>

<dt><a name="ChainedParent"
>ChainedParent</a></dt>

<dd>
<p>Chains an action to another action with the same name in the parent controller. For Example:</p>

<pre>  # in MyApp::Controller::Foo
  sub bar : Chained CaptureArgs(1) { ... }

  # in MyApp::Controller::Foo::Moo
  sub bar : ChainedParent Args(1) { ... }</pre>

<p>This builds a chain like <code>/bar/*/bar/*</code>.</p>

<dt><a name="CaptureArgs"
>CaptureArgs</a></dt>

<dd>
<p>Must be specified for every part of the chain that is not an endpoint. With this attribute Catalyst knows how many of the following parts of the path (separated by <code>/</code>) this action wants to capture as its arguments. If it doesn&#39;t expect any, just specify <code>:CaptureArgs(0)</code>. The captures get passed to the action&#39;s <code>@_</code> right after the context, but you can also find them as array references in <code>$c-&#62;request-&#62;captures-&#62;[$level]</code>. The <code>$level</code> is the level of the action in the chain that captured the parts of the path.</p>

<p>An action that is part of a chain (that is, one that has a <code>:Chained</code> attribute) but has no <code>:CaptureArgs</code> attribute is treated by Catalyst as a chain end.</p>

<dt><a name="Args"
>Args</a></dt>

<dd>
<p>By default, endpoints receive the rest of the arguments in the path. You can tell Catalyst through <code>:Args</code> explicitly how many arguments your endpoint expects, just like you can with <code>:CaptureArgs</code>. Note that this also affects whether this chain is invoked on a request. A chain with an endpoint specifying one argument will only match if exactly one argument exists in the path.</p>

<p>You can specify an exact number of arguments like <code>:Args(3)</code>, including <code>0</code>. If you just say <code>:Args</code> without any arguments, it is the same as leaving it out altogether: The chain is matched regardless of the number of path parts after the endpoint.</p>

<p>Just as with <code>:CaptureArgs</code>, the arguments get passed to the action in <code>@_</code> after the context object. They can also be reached through <code>$c-&#62;request-&#62;arguments</code>.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Auto_actions,_dispatching_and_forwarding"
>Auto actions, dispatching and forwarding</a></h2>

<p>Note that the list of <code>auto</code> actions called depends on the private path of the endpoint of the chain, not on the chained actions way. The <code>auto</code> actions will be run before the chain dispatching begins. In every other aspect, <code>auto</code> actions behave as documented.</p>

<p>The <code>forward</code>ing to other actions does just what you would expect. i.e. only the target action is run. The actions that that action is chained to are not run. If you <code>detach</code> out of a chain, the rest of the chain will not get called after the <code>detach</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="match_captures"
>match_captures</a></h2>

<p>A method which can optionally be implemented by actions to stop chain matching.</p>

<p>See <a href="../../Catalyst/Action.html" class="podlinkpod"
>Catalyst::Action</a> for further details.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<p>Catalyst Contributors, see Catalyst.pm</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>This library is free software. You can redistribute it and/or modify it under the same terms as Perl itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
