<html><head><title>Catalyst::Controller::REST</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:02 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#CONFIGURATION'>CONFIGURATION</a>
  <li class='indexItem indexItem1'><a href='#SERIALIZATION'>SERIALIZATION</a>
  <li class='indexItem indexItem1'><a href='#AVAILABLE_SERIALIZERS'>AVAILABLE SERIALIZERS</a>
  <li class='indexItem indexItem1'><a href='#CUSTOM_SERIALIZERS'>CUSTOM SERIALIZERS</a>
  <li class='indexItem indexItem1'><a href='#STATUS_HELPERS'>STATUS HELPERS</a>
  <li class='indexItem indexItem1'><a href='#MANUAL_RESPONSES'>MANUAL RESPONSES</a>
  <li class='indexItem indexItem1'><a href='#IMPLEMENTATION_DETAILS'>IMPLEMENTATION DETAILS</a>
  <li class='indexItem indexItem1'><a href='#A_MILD_WARNING'>A MILD WARNING</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#LICENSE'>LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Catalyst::Controller::REST - A RESTful controller</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    package Foo::Controller::Bar;
    use Moose;
    use namespace::autoclean;

    BEGIN { extends &#39;Catalyst::Controller::REST&#39; }

    sub thing : Local : ActionClass(&#39;REST&#39;) { }

    # Answer GET requests to &#34;thing&#34;
    sub thing_GET {
       my ( $self, $c ) = @_;

       # Return a 200 OK, with the data in entity
       # serialized in the body
       $self-&#62;status_ok(
            $c,
            entity =&#62; {
                some =&#62; &#39;data&#39;,
                foo  =&#62; &#39;is real bar-y&#39;,
            },
       );
    }

    # Answer PUT requests to &#34;thing&#34;
    sub thing_PUT {
        my ( $self, $c ) = @_;

        $radiohead = $c-&#62;req-&#62;data-&#62;{radiohead};

        $self-&#62;status_created(
            $c,
            location =&#62; $c-&#62;req-&#62;uri,
            entity =&#62; {
                radiohead =&#62; $radiohead,
            }
        );
    }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Catalyst::Controller::REST implements a mechanism for building RESTful services in Catalyst. It does this by extending the normal Catalyst dispatch mechanism to allow for different subroutines to be called based on the HTTP Method requested, while also transparently handling all the serialization/deserialization for you.</p>

<p>This is probably best served by an example. In the above controller, we have declared a Local Catalyst action on &#34;sub thing&#34;, and have used the ActionClass(&#39;REST&#39;).</p>

<p>Below, we have declared &#34;thing_GET&#34; and &#34;thing_PUT&#34;. Any GET requests to thing will be dispatched to &#34;thing_GET&#34;, while any PUT requests will be dispatched to &#34;thing_PUT&#34;.</p>

<p>Any unimplemented HTTP methods will be met with a &#34;405 Method Not Allowed&#34; response, automatically containing the proper list of available methods. You can override this behavior through implementing a custom <code>thing_not_implemented</code> method.</p>

<p>If you do not provide an OPTIONS handler, we will respond to any OPTIONS requests with a &#34;200 OK&#34;, populating the Allowed header automatically.</p>

<p>Any data included in <code>$c-&#62;stash-&#62;{&#39;rest&#39;}</code> will be serialized for you. The serialization format will be selected based on the content-type of the incoming request. It is probably easier to use the <a href="#STATUS_HELPERS" class="podlinkpod"
>&#34;STATUS HELPERS&#34;</a>, which are described below.</p>

<p>&#34;The HTTP POST, PUT, and OPTIONS methods will all automatically <a href="../../Catalyst/Action/Deserialize.html" class="podlinkpod"
>deserialize</a> the contents of <code>$c-&#62;request-&#62;body</code> into the <code>$c-&#62;request-&#62;data</code> hashref&#34;, based on the request&#39;s <code>Content-type</code> header. A list of understood serialization formats is <a href="#AVAILABLE_SERIALIZERS" class="podlinkpod"
>below</a>.</p>

<p>If we do not have (or cannot run) a serializer for a given content-type, a 415 &#34;Unsupported Media Type&#34; error is generated.</p>

<p>To make your Controller RESTful, simply have it</p>

<pre>  BEGIN { extends &#39;Catalyst::Controller::REST&#39; }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CONFIGURATION"
>CONFIGURATION</a></h1>

<p>See <a href="../../Catalyst/Action/Serialize.html#CONFIGURATION" class="podlinkpod"
>&#34;CONFIGURATION&#34; in Catalyst::Action::Serialize</a>. Note that the <code>serialize</code> key has been deprecated.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SERIALIZATION"
>SERIALIZATION</a></h1>

<p>Catalyst::Controller::REST will automatically serialize your responses, and deserialize any POST, PUT or OPTIONS requests. It evaluates which serializer to use by mapping a content-type to a Serialization module. We select the content-type based on:</p>

<dl>
<dt><a name="The_Content-Type_Header"
><b>The Content-Type Header</b></a></dt>

<dd>
<p>If the incoming HTTP Request had a Content-Type header set, we will use it.</p>

<dt><a name="The_content-type_Query_Parameter"
><b>The content-type Query Parameter</b></a></dt>

<dd>
<p>If this is a GET request, you can supply a content-type query parameter.</p>

<dt><a name="Evaluating_the_Accept_Header"
><b>Evaluating the Accept Header</b></a></dt>

<dd>
<p>Finally, if the client provided an Accept header, we will evaluate it and use the best-ranked choice.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AVAILABLE_SERIALIZERS"
>AVAILABLE SERIALIZERS</a></h1>

<p>A given serialization mechanism is only available if you have the underlying modules installed. For example, you can&#39;t use XML::Simple if it&#39;s not already installed.</p>

<p>In addition, each serializer has its quirks in terms of what sorts of data structures it will properly handle. <a href="../../Catalyst/Controller/REST.html" class="podlinkpod"
>Catalyst::Controller::REST</a> makes no attempt to save you from yourself in this regard. :)</p>

<ul>
<li><code>text/x-yaml</code> =&#62; <code>YAML::Syck</code>
<p>Returns YAML generated by <a href="../../YAML/Syck.html" class="podlinkpod"
>YAML::Syck</a>.</p>
</li>

<li><code>text/html</code> =&#62; <code>YAML::HTML</code>
<p>This uses <a href="../../YAML/Syck.html" class="podlinkpod"
>YAML::Syck</a> and <a href="../../URI/Find.html" class="podlinkpod"
>URI::Find</a> to generate YAML with all URLs turned to hyperlinks. Only usable for Serialization.</p>
</li>

<li><code>application/json</code> =&#62; <code>JSON</code>
<p>Uses <a href="../../JSON.html" class="podlinkpod"
>JSON</a> to generate JSON output. It is strongly advised to also have <a href="../../JSON/XS.html" class="podlinkpod"
>JSON::XS</a> installed. The <code>text/x-json</code> content type is supported but is deprecated and you will receive warnings in your log.</p>

<p>You can also add a hash in your controller config to pass options to the json object. For instance, to relax permissions when deserializing input, add: __PACKAGE__-&#62;config( json_options =&#62; { relaxed =&#62; 1 } )</p>
</li>

<li><code>text/javascript</code> =&#62; <code>JSONP</code>
<p>If a callback=? parameter is passed, this returns javascript in the form of: $callback($serializedJSON);</p>

<p>Note - this is disabled by default as it can be a security risk if you are unaware.</p>

<p>The usual MIME types for this serialization format are: &#39;text/javascript&#39;, &#39;application/x-javascript&#39;, &#39;application/javascript&#39;.</p>
</li>

<li><code>text/x-data-dumper</code> =&#62; <code>Data::Serializer</code>
<p>Uses the <a href="../../Data/Serializer.html" class="podlinkpod"
>Data::Serializer</a> module to generate <a href="../../Data/Dumper.html" class="podlinkpod"
>Data::Dumper</a> output.</p>
</li>

<li><code>text/x-data-denter</code> =&#62; <code>Data::Serializer</code>
<p>Uses the <a href="../../Data/Serializer.html" class="podlinkpod"
>Data::Serializer</a> module to generate <a href="../../Data/Denter.html" class="podlinkpod"
>Data::Denter</a> output.</p>
</li>

<li><code>text/x-data-taxi</code> =&#62; <code>Data::Serializer</code>
<p>Uses the <a href="../../Data/Serializer.html" class="podlinkpod"
>Data::Serializer</a> module to generate <a href="../../Data/Taxi.html" class="podlinkpod"
>Data::Taxi</a> output.</p>
</li>

<li><code>text/x-config-general</code> =&#62; <code>Data::Serializer</code>
<p>Uses the <a href="../../Data/Serializer.html" class="podlinkpod"
>Data::Serializer</a> module to generate <a href="../../Config/General.html" class="podlinkpod"
>Config::General</a> output.</p>
</li>

<li><code>text/x-php-serialization</code> =&#62; <code>Data::Serializer</code>
<p>Uses the <a href="../../Data/Serializer.html" class="podlinkpod"
>Data::Serializer</a> module to generate <a href="../../PHP/Serialization.html" class="podlinkpod"
>PHP::Serialization</a> output.</p>
</li>

<li><code>text/xml</code> =&#62; <code>XML::Simple</code>
<p>Uses <a href="../../XML/Simple.html" class="podlinkpod"
>XML::Simple</a> to generate XML output. This is probably not suitable for any real heavy XML work. Due to <a href="../../XML/Simple.html" class="podlinkpod"
>XML::Simple</a>s requirement that the data you serialize be a HASHREF, we transform outgoing data to be in the form of:</p>

<pre>  { data =&#62; $yourdata }</pre>
</li>

<li><a href="../../View.html" class="podlinkpod"
>View</a>
<p>Uses a regular Catalyst view. For example, if you wanted to have your <code>text/html</code> and <code>text/xml</code> views rendered by TT, set:</p>

<pre>  __PACKAGE__-&#62;config(
      map =&#62; {
          &#39;text/html&#39; =&#62; [ &#39;View&#39;, &#39;TT&#39; ],
          &#39;text/xml&#39;  =&#62; [ &#39;View&#39;, &#39;XML&#39; ],
      }
  );</pre>

<p>Your views should have a <code>process</code> method like this:</p>

<pre>  sub process {
      my ( $self, $c, $stash_key ) = @_;

      my $output;
      eval {
          $output = $self-&#62;serialize( $c-&#62;stash-&#62;{$stash_key} );
      };
      return $@ if $@;

      $c-&#62;response-&#62;body( $output );
      return 1;  # important
  }

  sub serialize {
      my ( $self, $data ) = @_;

      my $serialized = ... process $data here ...

      return $serialized;
  }</pre>
</li>

<li>Callback
<p>For infinite flexibility, you can provide a callback for the deserialization/serialization steps.</p>

<pre>  __PACKAGE__-&#62;config(
      map =&#62; {
          &#39;text/xml&#39;  =&#62; [ &#39;Callback&#39;, { deserialize =&#62; \&#38;parse_xml, serialize =&#62; \&#38;render_xml } ],
      }
  );</pre>

<p>The <code>deserialize</code> callback is passed a string that is the body of the request and is expected to return a scalar value that results from the deserialization. The <code>serialize</code> callback is passed the data structure that needs to be serialized and must return a string suitable for returning in the HTTP response. In addition to receiving the scalar to act on, both callbacks are passed the controller object and the context (i.e. <code>$c</code>) as the second and third arguments.</p>
</li>
</ul>

<p>By default, <a href="../../Catalyst/Controller/REST.html" class="podlinkpod"
>Catalyst::Controller::REST</a> will return a <code>415 Unsupported Media Type</code> response if an attempt to use an unsupported content-type is made. You can ensure that something is always returned by setting the <code>default</code> config option:</p>

<pre>  __PACKAGE__-&#62;config(default =&#62; &#39;text/x-yaml&#39;);</pre>

<p>would make it always fall back to the serializer plugin defined for <code>text/x-yaml</code>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CUSTOM_SERIALIZERS"
>CUSTOM SERIALIZERS</a></h1>

<p>Implementing new Serialization formats is easy! Contributions are most welcome! If you would like to implement a custom serializer, you should create two new modules in the <a href="../../Catalyst/Action/Serialize.html" class="podlinkpod"
>Catalyst::Action::Serialize</a> and <a href="../../Catalyst/Action/Deserialize.html" class="podlinkpod"
>Catalyst::Action::Deserialize</a> namespace. Then assign your new class to the content-type&#39;s you want, and you&#39;re done.</p>

<p>See <a href="../../Catalyst/Action/Serialize.html" class="podlinkpod"
>Catalyst::Action::Serialize</a> and <a href="../../Catalyst/Action/Deserialize.html" class="podlinkpod"
>Catalyst::Action::Deserialize</a> for more information.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="STATUS_HELPERS"
>STATUS HELPERS</a></h1>

<p>Since so much of REST is in using HTTP, we provide these Status Helpers. Using them will ensure that you are responding with the proper codes, headers, and entities.</p>

<p>These helpers try and conform to the HTTP 1.1 Specification. You can refer to it at: <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.txt" class="podlinkurl"
>http://www.w3.org/Protocols/rfc2616/rfc2616.txt</a>. These routines are all implemented as regular subroutines, and as such require you pass the current context ($c) as the first argument.</p>

<dl>
<dt><a name="status_ok"
>status_ok</a></dt>

<dd>
<p>Returns a &#34;200 OK&#34; response. Takes an &#34;entity&#34; to serialize.</p>

<p>Example:</p>

<pre>  $self-&#62;status_ok(
    $c,
    entity =&#62; {
        radiohead =&#62; &#34;Is a good band!&#34;,
    }
  );</pre>

<dt><a name="status_created"
>status_created</a></dt>

<dd>
<p>Returns a &#34;201 CREATED&#34; response. Takes an &#34;entity&#34; to serialize, and a &#34;location&#34; where the created object can be found.</p>

<p>Example:</p>

<pre>  $self-&#62;status_created(
    $c,
    location =&#62; $c-&#62;req-&#62;uri,
    entity =&#62; {
        radiohead =&#62; &#34;Is a good band!&#34;,
    }
  );</pre>

<p>In the above example, we use the requested URI as our location. This is probably what you want for most PUT requests.</p>

<dt><a name="status_accepted"
>status_accepted</a></dt>

<dd>
<p>Returns a &#34;202 ACCEPTED&#34; response. Takes an &#34;entity&#34; to serialize. Also takes optional &#34;location&#34; for queue type scenarios.</p>

<p>Example:</p>

<pre>  $self-&#62;status_accepted(
    $c,
    location =&#62; $c-&#62;req-&#62;uri,
    entity =&#62; {
        status =&#62; &#34;queued&#34;,
    }
  );</pre>

<dt><a name="status_no_content"
>status_no_content</a></dt>

<dd>
<p>Returns a &#34;204 NO CONTENT&#34; response.</p>

<dt><a name="status_multiple_choices"
>status_multiple_choices</a></dt>

<dd>
<p>Returns a &#34;300 MULTIPLE CHOICES&#34; response. Takes an &#34;entity&#34; to serialize, which should provide list of possible locations. Also takes optional &#34;location&#34; for preferred choice.</p>

<dt><a name="status_found"
>status_found</a></dt>

<dd>
<p>Returns a &#34;302 FOUND&#34; response. Takes an &#34;entity&#34; to serialize. Also takes optional &#34;location&#34;.</p>

<dt><a name="status_bad_request"
>status_bad_request</a></dt>

<dd>
<p>Returns a &#34;400 BAD REQUEST&#34; response. Takes a &#34;message&#34; argument as a scalar, which will become the value of &#34;error&#34; in the serialized response.</p>

<p>Example:</p>

<pre>  $self-&#62;status_bad_request(
    $c,
    message =&#62; &#34;Cannot do what you have asked!&#34;,
  );</pre>

<dt><a name="status_forbidden"
>status_forbidden</a></dt>

<dd>
<p>Returns a &#34;403 FORBIDDEN&#34; response. Takes a &#34;message&#34; argument as a scalar, which will become the value of &#34;error&#34; in the serialized response.</p>

<p>Example:</p>

<pre>  $self-&#62;status_forbidden(
    $c,
    message =&#62; &#34;access denied&#34;,
  );</pre>

<dt><a name="status_not_found"
>status_not_found</a></dt>

<dd>
<p>Returns a &#34;404 NOT FOUND&#34; response. Takes a &#34;message&#34; argument as a scalar, which will become the value of &#34;error&#34; in the serialized response.</p>

<p>Example:</p>

<pre>  $self-&#62;status_not_found(
    $c,
    message =&#62; &#34;Cannot find what you were looking for!&#34;,
  );</pre>

<dt><a name="gone"
>gone</a></dt>

<dd>
<p>Returns a &#34;41O GONE&#34; response. Takes a &#34;message&#34; argument as a scalar, which will become the value of &#34;error&#34; in the serialized response.</p>

<p>Example:</p>

<pre>  $self-&#62;status_gone(
    $c,
    message =&#62; &#34;The document have been deleted by foo&#34;,
  );</pre>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="MANUAL_RESPONSES"
>MANUAL RESPONSES</a></h1>

<p>If you want to construct your responses yourself, all you need to do is put the object you want serialized in $c-&#62;stash-&#62;{&#39;rest&#39;}.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="IMPLEMENTATION_DETAILS"
>IMPLEMENTATION DETAILS</a></h1>

<p>This Controller ties together <a href="../../Catalyst/Action/REST.html" class="podlinkpod"
>Catalyst::Action::REST</a>, <a href="../../Catalyst/Action/Serialize.html" class="podlinkpod"
>Catalyst::Action::Serialize</a> and <a href="../../Catalyst/Action/Deserialize.html" class="podlinkpod"
>Catalyst::Action::Deserialize</a>. It should be suitable for most applications. You should be aware that it:</p>

<dl>
<dt><a name="Configures_the_Serialization_Actions"
>Configures the Serialization Actions</a></dt>

<dd>
<p>This class provides a default configuration for Serialization. It is currently:</p>

<pre>  __PACKAGE__-&#62;config(
      &#39;stash_key&#39; =&#62; &#39;rest&#39;,
      &#39;map&#39;       =&#62; {
         &#39;text/html&#39;          =&#62; &#39;YAML::HTML&#39;,
         &#39;text/xml&#39;           =&#62; &#39;XML::Simple&#39;,
         &#39;text/x-yaml&#39;        =&#62; &#39;YAML&#39;,
         &#39;application/json&#39;   =&#62; &#39;JSON&#39;,
         &#39;text/x-json&#39;        =&#62; &#39;JSON&#39;,
         &#39;text/x-data-dumper&#39; =&#62; [ &#39;Data::Serializer&#39;, &#39;Data::Dumper&#39; ],
         &#39;text/x-data-denter&#39; =&#62; [ &#39;Data::Serializer&#39;, &#39;Data::Denter&#39; ],
         &#39;text/x-data-taxi&#39;   =&#62; [ &#39;Data::Serializer&#39;, &#39;Data::Taxi&#39;   ],
         &#39;application/x-storable&#39;   =&#62; [ &#39;Data::Serializer&#39;, &#39;Storable&#39; ],
         &#39;application/x-freezethaw&#39; =&#62; [ &#39;Data::Serializer&#39;, &#39;FreezeThaw&#39; ],
         &#39;text/x-config-general&#39;    =&#62; [ &#39;Data::Serializer&#39;, &#39;Config::General&#39; ],
         &#39;text/x-php-serialization&#39; =&#62; [ &#39;Data::Serializer&#39;, &#39;PHP::Serialization&#39; ],
      },
  );</pre>

<p>You can read the full set of options for this configuration block in <a href="../../Catalyst/Action/Serialize.html" class="podlinkpod"
>Catalyst::Action::Serialize</a>.</p>

<dt><a name="Sets_a_begin_and_end_method_for_you"
>Sets a <code>begin</code> and <code>end</code> method for you</a></dt>

<dd>
<p>The <code>begin</code> method uses <a href="../../Catalyst/Action/Deserialize.html" class="podlinkpod"
>Catalyst::Action::Deserialize</a>. The <code>end</code> method uses <a href="../../Catalyst/Action/Serialize.html" class="podlinkpod"
>Catalyst::Action::Serialize</a>. If you want to override either behavior, simply implement your own <code>begin</code> and <code>end</code> actions and forward to another action with the Serialize and/or Deserialize action classes:</p>

<pre>  package Foo::Controller::Monkey;
  use Moose;
  use namespace::autoclean;

  BEGIN { extends &#39;Catalyst::Controller::REST&#39; }

  sub begin : Private {
    my ($self, $c) = @_;
    ... do things before Deserializing ...
    $c-&#62;forward(&#39;deserialize&#39;);
    ... do things after Deserializing ...
  }

  sub deserialize : ActionClass(&#39;Deserialize&#39;) {}

  sub end :Private {
    my ($self, $c) = @_;
    ... do things before Serializing ...
    $c-&#62;forward(&#39;serialize&#39;);
    ... do things after Serializing ...
  }

  sub serialize : ActionClass(&#39;Serialize&#39;) {}</pre>

<p>If you need to deserialize multipart requests (i.e. REST data in one part and file uploads in others) you can do so by using the <a href="../../Catalyst/Action/DeserializeMultiPart.html" class="podlinkpod"
>Catalyst::Action::DeserializeMultiPart</a> action class.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="A_MILD_WARNING"
>A MILD WARNING</a></h1>

<p>I have code in production using <a href="../../Catalyst/Controller/REST.html" class="podlinkpod"
>Catalyst::Controller::REST</a>. That said, it is still under development, and it&#39;s possible that things may change between releases. I promise to not break things unnecessarily. :)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../../Catalyst/Action/REST.html" class="podlinkpod"
>Catalyst::Action::REST</a>, <a href="../../Catalyst/Action/Serialize.html" class="podlinkpod"
>Catalyst::Action::Serialize</a>, <a href="../../Catalyst/Action/Deserialize.html" class="podlinkpod"
>Catalyst::Action::Deserialize</a></p>

<p>For help with REST in general:</p>

<p>The HTTP 1.1 Spec is required reading. http://www.w3.org/Protocols/rfc2616/rfc2616.txt</p>

<p>Wikipedia! http://en.wikipedia.org/wiki/Representational_State_Transfer</p>

<p>The REST Wiki: http://rest.blueoxen.net/cgi-bin/wiki.pl?FrontPage</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<p>See <a href="../../Catalyst/Action/REST.html" class="podlinkpod"
>Catalyst::Action::REST</a> for authors.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENSE"
>LICENSE</a></h1>

<p>You may distribute this code under the same terms as Perl itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
