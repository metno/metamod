<html><head><title>Catalyst::View::TT</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:03 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#CONFIGURATION'>CONFIGURATION</a>
    <li class='indexItem indexItem2'><a href='#DYNAMIC_INCLUDE_PATH'>DYNAMIC INCLUDE_PATH</a>
    <li class='indexItem indexItem2'><a href='#Unicode'>Unicode</a>
    <li class='indexItem indexItem2'><a href='#RENDERING_VIEWS'>RENDERING VIEWS</a>
    <li class='indexItem indexItem2'><a href='#CAPTURING_TEMPLATE_OUTPUT'>CAPTURING TEMPLATE OUTPUT</a>
    <li class='indexItem indexItem2'><a href='#TEMPLATE_PROFILING'>TEMPLATE PROFILING</a>
    <li class='indexItem indexItem2'><a href='#METHODS'>METHODS</a>
    <li class='indexItem indexItem2'><a href='#new'>new</a>
    <li class='indexItem indexItem2'><a href='#process(%24c)'>process($c)</a>
    <li class='indexItem indexItem2'><a href='#render(%24c%2C_%24template%2C_%5C%25args)'>render($c, $template, \%args)</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Backwards_compatibility_note'>Backwards compatibility note</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#template_vars'>template_vars</a>
    <li class='indexItem indexItem2'><a href='#config'>config</a>
    <li class='indexItem indexItem2'><a href='#paths'>paths</a>
    <li class='indexItem indexItem2'><a href='#expose_methods'>expose_methods</a>
    <li class='indexItem indexItem2'><a href='#content_type'>content_type</a>
    <li class='indexItem indexItem2'><a href='#CATALYST_VAR'>CATALYST_VAR</a>
    <li class='indexItem indexItem2'><a href='#TIMER'>TIMER</a>
    <li class='indexItem indexItem2'><a href='#TEMPLATE_EXTENSION'>TEMPLATE_EXTENSION</a>
    <li class='indexItem indexItem2'><a href='#PROVIDERS'>PROVIDERS</a>
    <li class='indexItem indexItem2'><a href='#CLASS'>CLASS</a>
    <li class='indexItem indexItem2'><a href='#HELPERS'>HELPERS</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#NOTES'>NOTES</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Catalyst::View::TT - Template View Class</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<p># use the helper to create your View</p>

<pre>    myapp_create.pl view Web TT</pre>

<p># add custom configration in View/Web.pm</p>

<pre>    __PACKAGE__-&#62;config(
        # any TT configuration items go here
        TEMPLATE_EXTENSION =&#62; &#39;.tt&#39;,
        CATALYST_VAR =&#62; &#39;c&#39;,
        TIMER        =&#62; 0,
        ENCODING     =&#62; &#39;utf-8&#39;
        # Not set by default
        PRE_PROCESS        =&#62; &#39;config/main&#39;,
        WRAPPER            =&#62; &#39;site/wrapper&#39;,
        render_die =&#62; 1, # Default for new apps, see render method docs
        expose_methods =&#62; [qw/method_in_view_class/],
    );</pre>

<p># add include path configuration in MyApp.pm</p>

<pre>    __PACKAGE__-&#62;config(
        &#39;View::Web&#39; =&#62; {
            INCLUDE_PATH =&#62; [
                __PACKAGE__-&#62;path_to( &#39;root&#39;, &#39;src&#39; ),
                __PACKAGE__-&#62;path_to( &#39;root&#39;, &#39;lib&#39; ),
            ],
        },
    );</pre>

<p># render view from lib/MyApp.pm or lib/MyApp::Controller::SomeController.pm</p>

<pre>    sub message : Global {
        my ( $self, $c ) = @_;
        $c-&#62;stash-&#62;{template} = &#39;message.tt2&#39;;
        $c-&#62;stash-&#62;{message}  = &#39;Hello World!&#39;;
        $c-&#62;forward( $c-&#62;view(&#39;Web&#39;) );
    }</pre>

<p># access variables from template</p>

<pre>    The message is: [% message %].

    # example when CATALYST_VAR is set to &#39;Catalyst&#39;
    Context is [% Catalyst %]
    The base is [% Catalyst.req.base %]
    The name is [% Catalyst.config.name %]

    # example when CATALYST_VAR isn&#39;t set
    Context is [% c %]
    The base is [% base %]
    The name is [% name %]</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This is the Catalyst view class for the <a href="../../Template.html" class="podlinkpod"
>Template Toolkit</a>. Your application should defined a view class which is a subclass of this module. Throughout this manual it will be assumed that your application is named <em>MyApp</em> and you are creating a TT view named <em>Web</em>; these names are placeholders and should always be replaced with whatever name you&#39;ve chosen for your application and your view. The easiest way to create a TT view class is through the <em>myapp_create.pl</em> script that is created along with the application:</p>

<pre>    $ script/myapp_create.pl view Web TT</pre>

<p>This creates a <em>MyApp::View::Web.pm</em> module in the <em>lib</em> directory (again, replacing <code>MyApp</code> with the name of your application) which looks something like this:</p>

<pre>    package FooBar::View::Web;
    use Moose;

    extends &#39;Catalyst::View::TT&#39;;

    __PACKAGE__-&#62;config(DEBUG =&#62; &#39;all&#39;);</pre>

<p>Now you can modify your action handlers in the main application and/or controllers to forward to your view class. You might choose to do this in the end() method, for example, to automatically forward all actions to the TT view class.</p>

<pre>    # In MyApp or MyApp::Controller::SomeController

    sub end : Private {
        my( $self, $c ) = @_;
        $c-&#62;forward( $c-&#62;view(&#39;Web&#39;) );
    }</pre>

<p>But if you are using the standard auto-generated end action, you don&#39;t even need to do this!</p>

<pre>    # in MyApp::Controller::Root
    sub end : ActionClass(&#39;RenderView&#39;) {} # no need to change this line

    # in MyApp.pm
    __PACKAGE__-&#62;config(
        ...
        default_view =&#62; &#39;Web&#39;,
    );</pre>

<p>This will Just Work. And it has the advantages that:</p>

<ul>
<li>If you want to use a different view for a given request, just set &#60;&#60; $c-&#62;stash-&#62;{current_view} &#62;&#62;. (See <a href="../../Catalyst.html" class="podlinkpod"
>Catalyst</a>&#39;s <code>$c-&#62;view</code> method for details.</li>

<li>&#60;&#60; $c-&#62;res-&#62;redirect &#62;&#62; is handled by default. If you just forward to <code>View::Web</code> in your <code>end</code> routine, you could break this by sending additional content.</li>
</ul>

<p>See <a href="../../Catalyst/Action/RenderView.html" class="podlinkpod"
>Catalyst::Action::RenderView</a> for more details.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="CONFIGURATION"
>CONFIGURATION</a></h2>

<p>There are a three different ways to configure your view class. The first way is to call the <code>config()</code> method in the view subclass. This happens when the module is first loaded.</p>

<pre>    package MyApp::View::Web;
    use Moose;
    extends &#39;Catalyst::View::TT&#39;;

    __PACKAGE__-&#62;config({
        PRE_PROCESS  =&#62; &#39;config/main&#39;,
        WRAPPER      =&#62; &#39;site/wrapper&#39;,
    });</pre>

<p>You may also override the configuration provided in the view class by adding a &#39;View::Web&#39; section to your application config.</p>

<p>This should generally be used to inject the include paths into the view to avoid the view trying to load the application to resolve paths.</p>

<pre>    .. inside MyApp.pm ..
    __PACKAGE__-&#62;config(
        &#39;View::Web&#39; =&#62; {
            INCLUDE_PATH =&#62; [
                __PACKAGE__-&#62;path_to( &#39;root&#39;, &#39;templates&#39;, &#39;lib&#39; ),
                __PACKAGE__-&#62;path_to( &#39;root&#39;, &#39;templates&#39;, &#39;src&#39; ),
            ],
        },
    );</pre>

<p>You can also configure your view from within your config file if you&#39;re using <a href="../../Catalyst/Plugin/ConfigLoader.html" class="podlinkpod"
>Catalyst::Plugin::ConfigLoader</a>. This should be reserved for deployment-specific concerns. For example:</p>

<pre>    # MyApp_local.conf (Config::General format)

    &#60;View Web&#62;
      WRAPPER &#34;custom_wrapper&#34;
      INCLUDE_PATH __path_to(&#39;root/templates/custom_site&#39;)__
      INCLUDE_PATH __path_to(&#39;root/templates&#39;)__
    &#60;/View&#62;</pre>

<p>might be used as part of a simple way to deploy different instances of the same application with different themes.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="DYNAMIC_INCLUDE_PATH"
>DYNAMIC INCLUDE_PATH</a></h2>

<p>Sometimes it is desirable to modify INCLUDE_PATH for your templates at run time.</p>

<p>Additional paths can be added to the start of INCLUDE_PATH via the stash as follows:</p>

<pre>    $c-&#62;stash-&#62;{additional_template_paths} =
        [$c-&#62;config-&#62;{root} . &#39;/test_include_path&#39;];</pre>

<p>If you need to add paths to the end of INCLUDE_PATH, there is also an include_path() accessor available:</p>

<pre>    push( @{ $c-&#62;view(&#39;Web&#39;)-&#62;include_path }, qw/path/ );</pre>

<p>Note that if you use include_path() to add extra paths to INCLUDE_PATH, you MUST check for duplicate paths. Without such checking, the above code will add &#34;path&#34; to INCLUDE_PATH at every request, causing a memory leak.</p>

<p>A safer approach is to use include_path() to overwrite the array of paths rather than adding to it. This eliminates both the need to perform duplicate checking and the chance of a memory leak:</p>

<pre>    @{ $c-&#62;view(&#39;Web&#39;)-&#62;include_path } = qw/path another_path/;</pre>

<p>If you are calling <code>render</code> directly then you can specify dynamic paths by having a <code>additional_template_paths</code> key with a value of additonal directories to search. See <a href="#CAPTURING_TEMPLATE_OUTPUT" class="podlinkpod"
>&#34;CAPTURING TEMPLATE OUTPUT&#34;</a> for an example showing this.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Unicode"
>Unicode</a></h2>

<p>Be sure to set <code>ENCODING =&#62; &#39;utf-8&#39;</code> and use <a href="../../Catalyst/Plugin/Unicode/Encoding.html" class="podlinkpod"
>Catalyst::Plugin::Unicode::Encoding</a> if you want to use non-ascii characters (encoded as utf-8) in your templates.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="RENDERING_VIEWS"
>RENDERING VIEWS</a></h2>

<p>The view plugin renders the template specified in the <code>template</code> item in the stash.</p>

<pre>    sub message : Global {
        my ( $self, $c ) = @_;
        $c-&#62;stash-&#62;{template} = &#39;message.tt2&#39;;
        $c-&#62;forward( $c-&#62;view(&#39;Web&#39;) );
    }</pre>

<p>If a stash item isn&#39;t defined, then it instead uses the stringification of the action dispatched to (as defined by $c-&#62;action) in the above example, this would be <code>message</code>, but because the default is to append &#39;.tt&#39;, it would load <code>root/message.tt</code>.</p>

<p>The items defined in the stash are passed to the Template Toolkit for use as template variables.</p>

<pre>    sub default : Private {
        my ( $self, $c ) = @_;
        $c-&#62;stash-&#62;{template} = &#39;message.tt2&#39;;
        $c-&#62;stash-&#62;{message}  = &#39;Hello World!&#39;;
        $c-&#62;forward( $c-&#62;view(&#39;Web&#39;) );
    }</pre>

<p>A number of other template variables are also added:</p>

<pre>    c      A reference to the context object, $c
    base   The URL base, from $c-&#62;req-&#62;base()
    name   The application name, from $c-&#62;config-&#62;{ name }</pre>

<p>These can be accessed from the template in the usual way:</p>

<p>&#60;message.tt2&#62;:</p>

<pre>    The message is: [% message %]
    The base is [% base %]
    The name is [% name %]</pre>

<p>The output generated by the template is stored in <code>$c-&#62;response-&#62;body</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="CAPTURING_TEMPLATE_OUTPUT"
>CAPTURING TEMPLATE OUTPUT</a></h2>

<p>If you wish to use the output of a template for some other purpose than displaying in the response, e.g. for sending an email, this is possible using <a href="../../Catalyst/Plugin/Email.html" class="podlinkpod"
>Catalyst::Plugin::Email</a> and the <a href="../../render.html" class="podlinkpod"
>render</a> method:</p>

<pre>  sub send_email : Local {
    my ($self, $c) = @_;

    $c-&#62;email(
      header =&#62; [
        To      =&#62; &#39;me@localhost&#39;,
        Subject =&#62; &#39;A TT Email&#39;,
      ],
      body =&#62; $c-&#62;view(&#39;Web&#39;)-&#62;render($c, &#39;email.tt&#39;, {
        additional_template_paths =&#62; [ $c-&#62;config-&#62;{root} . &#39;/email_templates&#39;],
        email_tmpl_param1 =&#62; &#39;foo&#39;
        }
      ),
    );
  # Redirect or display a message
  }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="TEMPLATE_PROFILING"
>TEMPLATE PROFILING</a></h2>

<p>See <a href="../../TIMER.html" class="podlinkpod"
><code>TIMER</code></a> property of the <a href="../../config.html" class="podlinkpod"
>config</a> method.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="new"
>new</a></h2>

<p>The constructor for the TT view. Sets up the template provider, and reads the application config.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="process($c)"
>process($c)</a></h2>

<p>Renders the template specified in <code>$c-&#62;stash-&#62;{template}</code> or <code>$c-&#62;action</code> (the private name of the matched action). Calls <a href="../../render.html" class="podlinkpod"
>render</a> to perform actual rendering. Output is stored in <code>$c-&#62;response-&#62;body</code>.</p>

<p>It is possible to forward to the process method of a TT view from inside Catalyst like this:</p>

<pre>    $c-&#62;forward(&#39;View::Web&#39;);</pre>

<p>N.B. This is usually done automatically by <a href="../../Catalyst/Action/RenderView.html" class="podlinkpod"
>Catalyst::Action::RenderView</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="render($c,_$template,_\%args)"
>render($c, $template, \%args)</a></h2>

<p>Renders the given template and returns output. Throws a <a href="../../Template/Exception.html" class="podlinkpod"
>Template::Exception</a> object upon error.</p>

<p>The template variables are set to <code>%$args</code> if <code>$args</code> is a hashref, or <code>$c-&#62;stash</code> otherwise. In either case the variables are augmented with <code>base</code> set to <code>$c-&#62;req-&#62;base</code>, <code>c</code> to <code>$c</code>, and <code>name</code> to <code>$c-&#62;config-&#62;{name}</code>. Alternately, the <code>CATALYST_VAR</code> configuration item can be defined to specify the name of a template variable through which the context reference (<code>$c</code>) can be accessed. In this case, the <code>c</code>, <code>base</code>, and <code>name</code> variables are omitted.</p>

<p><code>$template</code> can be anything that Template::process understands how to process, including the name of a template file or a reference to a test string. See <a href="../../Template.html#process" class="podlinkpod"
>Template::process</a> for a full list of supported formats.</p>

<p>To use the render method outside of your Catalyst app, just pass a undef context. This can be useful for tests, for instance.</p>

<p>It is possible to forward to the render method of a TT view from inside Catalyst to render page fragments like this:</p>

<pre>    my $fragment = $c-&#62;forward(&#34;View::Web&#34;, &#34;render&#34;, $template_name, $c-&#62;stash-&#62;{fragment_data});</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Backwards_compatibility_note"
>Backwards compatibility note</a></h3>

<p>The render method used to just return the Template::Exception object, rather than just throwing it. This is now deprecated and instead the render method will throw an exception for new applications.</p>

<p>This behaviour can be activated (and is activated in the default skeleton configuration) by using <code>render_die =&#62; 1</code>. If you rely on the legacy behaviour then a warning will be issued.</p>

<p>To silence this warning, set <code>render_die =&#62; 0</code>, but it is recommended you adjust your code so that it works with <code>render_die =&#62; 1</code>.</p>

<p>In a future release, <code>render_die =&#62; 1</code> will become the default if unspecified.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="template_vars"
>template_vars</a></h2>

<p>Returns a list of keys/values to be used as the catalyst variables in the template.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="config"
>config</a></h2>

<p>This method allows your view subclass to pass additional settings to the TT configuration hash, or to set the options as below:</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="paths"
>paths</a></h2>

<p>The list of paths TT will look for templates in.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="expose_methods"
>expose_methods</a></h2>

<p>The list of methods in your View class which should be made available to the templates.</p>

<p>For example:</p>

<pre>  expose_methods =&#62; [qw/uri_for_css/],

  ...

  sub uri_for_css {
    my ($self, $c, $filename) = @_;

    # additional complexity like checking file exists here

    return $c-&#62;uri_for(&#39;/static/css/&#39; . $filename);
  }</pre>

<p>Then in the template:</p>

<pre>  [% uri_for_css(&#39;home.css&#39;) %]</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="content_type"
>content_type</a></h2>

<p>This lets you override the default content type for the response. If you do not set this and if you do not set the content type in your controllers, the default is <code>text/html; charset=utf-8</code>.</p>

<p>Use this if you are creating alternative view responses, such as text or JSON and want a global setting.</p>

<p>Any content type set in your controllers before calling this view are respected and have priority.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="CATALYST_VAR"
><code>CATALYST_VAR</code></a></h2>

<p>Allows you to change the name of the Catalyst context object. If set, it will also remove the base and name aliases, so you will have access them through &#60;context&#62;.</p>

<p>For example, if CATALYST_VAR has been set to &#34;Catalyst&#34;, a template might contain:</p>

<pre>    The base is [% Catalyst.req.base %]
    The name is [% Catalyst.config.name %]</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="TIMER"
><code>TIMER</code></a></h2>

<p>If you have configured Catalyst for debug output, and turned on the TIMER setting, <code>Catalyst::View::TT</code> will enable profiling of template processing (using <a href="../../Template/Timer.html" class="podlinkpod"
>Template::Timer</a>). This will embed HTML comments in the output from your templates, such as:</p>

<pre>    &#60;!-- TIMER START: process mainmenu/mainmenu.ttml --&#62;
    &#60;!-- TIMER START: include mainmenu/cssindex.tt --&#62;
    &#60;!-- TIMER START: process mainmenu/cssindex.tt --&#62;
    &#60;!-- TIMER END: process mainmenu/cssindex.tt (0.017279 seconds) --&#62;
    &#60;!-- TIMER END: include mainmenu/cssindex.tt (0.017401 seconds) --&#62;

    ....

    &#60;!-- TIMER END: process mainmenu/footer.tt (0.003016 seconds) --&#62;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="TEMPLATE_EXTENSION"
><code>TEMPLATE_EXTENSION</code></a></h2>

<p>a sufix to add when looking for templates bases on the <code>match</code> method in <a href="../../Catalyst/Request.html" class="podlinkpod"
>Catalyst::Request</a>.</p>

<p>For example:</p>

<pre>  package MyApp::Controller::Test;
  sub test : Local { .. }</pre>

<p>Would by default look for a template in &#60;root&#62;/test/test. If you set TEMPLATE_EXTENSION to &#39;.tt&#39;, it will look for &#60;root&#62;/test/test.tt.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="PROVIDERS"
><code>PROVIDERS</code></a></h2>

<p>Allows you to specify the template providers that TT will use.</p>

<pre>    MyApp-&#62;config(
        name     =&#62; &#39;MyApp&#39;,
        root     =&#62; MyApp-&#62;path_to(&#39;root&#39;),
        &#39;View::Web&#39; =&#62; {
            PROVIDERS =&#62; [
                {
                    name    =&#62; &#39;DBI&#39;,
                    args    =&#62; {
                        DBI_DSN =&#62; &#39;dbi:DB2:books&#39;,
                        DBI_USER=&#62; &#39;foo&#39;
                    }
                }, {
                    name    =&#62; &#39;_file_&#39;,
                    args    =&#62; {}
                }
            ]
        },
    );</pre>

<p>The &#39;name&#39; key should correspond to the class name of the provider you want to use. The _file_ name is a special case that represents the default TT file-based provider. By default the name is will be prefixed with &#39;Template::Provider::&#39;. You can fully qualify the name by using a unary plus:</p>

<pre>    name =&#62; &#39;+MyApp::Provider::Foo&#39;</pre>

<p>You can also specify the &#39;copy_config&#39; key as an arrayref, to copy those keys from the general config, into the config for the provider:</p>

<pre>    DEFAULT_ENCODING    =&#62; &#39;utf-8&#39;,
    PROVIDERS =&#62; [
        {
            name    =&#62; &#39;Encoding&#39;,
            copy_config =&#62; [qw(DEFAULT_ENCODING INCLUDE_PATH)]
        }
    ]</pre>

<p>This can prove useful when you want to use the additional_template_paths hack in your own provider, or if you need to use Template::Provider::Encoding</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="CLASS"
><code>CLASS</code></a></h2>

<p>Allows you to specify a custom class to use as the template class instead of <a href="../../Template.html" class="podlinkpod"
>Template</a>.</p>

<pre>    package MyApp::View::Web;
    use Moose;
    extends &#39;Catalyst::View::TT&#39;;

    use Template::AutoFilter;

    __PACKAGE__-&#62;config({
        CLASS =&#62; &#39;Template::AutoFilter&#39;,
    });</pre>

<p>This is useful if you want to use your own subclasses of <a href="../../Template.html" class="podlinkpod"
>Template</a>, so you can, for example, prevent XSS by automatically filtering all output through <code>| html</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="HELPERS"
>HELPERS</a></h2>

<p>The <a href="../../Catalyst/Helper/View/TT.html" class="podlinkpod"
>Catalyst::Helper::View::TT</a> and <a href="../../Catalyst/Helper/View/TTSite.html" class="podlinkpod"
>Catalyst::Helper::View::TTSite</a> helper modules are provided to create your view module. There are invoked by the <em>myapp_create.pl</em> script:</p>

<pre>    $ script/myapp_create.pl view Web TT

    $ script/myapp_create.pl view Web TTSite</pre>

<p>The <a href="../../Catalyst/Helper/View/TT.html" class="podlinkpod"
>Catalyst::Helper::View::TT</a> module creates a basic TT view module. The <a href="../../Catalyst/Helper/View/TTSite.html" class="podlinkpod"
>Catalyst::Helper::View::TTSite</a> module goes a little further. It also creates a default set of templates to get you started. It also configures the view module to locate the templates automatically.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NOTES"
>NOTES</a></h1>

<p>If you are using the <a href="../../CGI.html" class="podlinkpod"
>CGI</a> module inside your templates, you will experience that the Catalyst server appears to hang while rendering the web page. This is due to the debug mode of <a href="../../CGI.html" class="podlinkpod"
>CGI</a> (which is waiting for input in the terminal window). Turning off the debug mode using the &#34;-no_debug&#34; option solves the problem, eg.:</p>

<pre>    [% USE CGI(&#39;-no_debug&#39;) %]</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../../Catalyst.html" class="podlinkpod"
>Catalyst</a>, <a href="../../Catalyst/Helper/View/TT.html" class="podlinkpod"
>Catalyst::Helper::View::TT</a>, <a href="../../Catalyst/Helper/View/TTSite.html" class="podlinkpod"
>Catalyst::Helper::View::TTSite</a>, <a href="../../Template/Manual.html" class="podlinkpod"
>Template::Manual</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<p>Sebastian Riedel, <code>sri@cpan.org</code></p>

<p>Marcus Ramberg, <code>mramberg@cpan.org</code></p>

<p>Jesse Sheidlower, <code>jester@panix.com</code></p>

<p>Andy Wardley, <code>abw@cpan.org</code></p>

<p>Luke Saunders, <code>luke.saunders@gmail.com</code></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>This program is free software. You can redistribute it and/or modify it under the same terms as Perl itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
