<html><head><title>Catalyst::Authentication::Credential::Remote</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:02 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#CONFIG'>CONFIG</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#class'>class</a>
    <li class='indexItem indexItem2'><a href='#source'>source</a>
    <li class='indexItem indexItem2'><a href='#deny_regexp'>deny_regexp</a>
    <li class='indexItem indexItem2'><a href='#allow_regexp'>allow_regexp</a>
    <li class='indexItem indexItem2'><a href='#cutname_regexp'>cutname_regexp</a>
    <li class='indexItem indexItem2'><a href='#username_field'>username_field</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#new_(_%24config%2C_%24app%2C_%24realm_)'>new ( $config, $app, $realm )</a>
    <li class='indexItem indexItem2'><a href='#authenticate_(_%24realm%2C_%24authinfo_)'>authenticate ( $realm, $authinfo )</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#COMPATIBILITY'>COMPATIBILITY</a>
  <li class='indexItem indexItem1'><a href='#USING_WITH_A_REVERSE_PROXY'>USING WITH A REVERSE PROXY</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Catalyst::Authentication::Credential::Remote - Let the webserver (e.g.
Apache) authenticate Catalyst application users</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    # in your MyApp.pm
    __PACKAGE__-&#62;config(

        &#39;Plugin::Authentication&#39; =&#62; {
            default_realm =&#62; &#39;remoterealm&#39;,
            realms =&#62; {
                remoterealm =&#62; {
                    credential =&#62; {
                        class        =&#62; &#39;Remote&#39;,
                        allow_regexp =&#62; &#39;^(user.*|admin|guest)$&#39;,
                        deny_regexp  =&#62; &#39;test&#39;,
                    },
                    store =&#62; {
                        class =&#62; &#39;Null&#39;,
                        # if you want to have some additional user attributes
                        # like user roles, user full name etc. you can specify
                        # here the store where you keep this data
                    }
                },
            },
        },
        
    );
    
    # in your Controller/Root.pm you can implement &#34;auto-login&#34; in this way
    sub begin : Private {
        my ( $self, $c ) = @_;        
        unless ($c-&#62;user_exists) {
            # authenticate() for this module does not need any user info
            # as the username is taken from $c-&#62;req-&#62;remote_user and
            # password is not needed     
            unless ($c-&#62;authenticate( {} )) {
              # return 403 forbidden or kick out the user in other way
            };
        }   
    }

    # or you can implement in any controller an ordinary login action like this
    sub login : Global {
        my ( $self, $c ) = @_;
        $c-&#62;authenticate( {} );
    }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This module allows you to authenticate the users of your Catalyst application on underlaying webserver. The complete list of authentication method available via this module depends just on what your webserver (e.g. Apache, IIS, Lighttpd) is able to handle.</p>

<p>Besides the common methods like HTTP Basic and Digest authentication you can also use sophisticated ones like so called &#34;integrated authentication&#34; via NTLM or Kerberos (popular in corporate intranet applications running in Windows Active Directory environment) or even the SSL authentication when users authenticate themself using their client SSL certificates.</p>

<p>The main idea of this module is based on a fact that webserver passes the name of authenticated user into Catalyst application as REMOTE_USER variable (or in case of SSL client authentication in other variables like SSL_CLIENT_S_DN on Apache + mod_ssl) - from this point referenced as WEBUSER. This module simply takes this value - perfoms some optional checks (see below) - and if everything is OK the WEBUSER is declared as authenticated on Catalyst level. In fact this module does not perform any check for password or other credential; it simply believes the webserver that user was properly authenticated.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CONFIG"
>CONFIG</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="class"
>class</a></h2>

<p>This config item is <b>REQUIRED</b>.</p>

<p><b>class</b> is part of the core <a href="../../../Catalyst/Plugin/Authentication.html" class="podlinkpod"
>Catalyst::Plugin::Authentication</a> module, it contains the class name of the store to be used.</p>

<p>The classname used for Credential. This is part of <a href="../../../Catalyst/Plugin/Authentication.html" class="podlinkpod"
>Catalyst::Plugin::Authentication</a> and is the method by which Catalyst::Authentication::Credential::Remote is loaded as the credential validator. For this module to be used, this must be set to &#39;Remote&#39;.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="source"
>source</a></h2>

<p>This config item is <b>OPTIONAL</b> - default is REMOTE_USER.</p>

<p><b>source</b> contains a name of a variable passed from webserver that contains the user identification.</p>

<p>Supported values: REMOTE_USER, SSL_CLIENT_*, CERT_*, AUTH_USER</p>

<p><b>BEWARE:</b> Support for using different variables than REMOTE_USER does not work properly with Catalyst 5.8004 and before (if you want details see source code).</p>

<p>Note1: Apache + mod_ssl uses SSL_CLIENT_S_DN, SSL_CLIENT_S_DN_* etc. (has to be enabled by &#39;SSLOption +StdEnvVars&#39;) or you can also let Apache make a copy of this value into REMOTE_USER (Apache option &#39;SSLUserName SSL_CLIENT_S_DN&#39;).</p>

<p>Note2: Microsoft IIS uses CERT_SUBJECT, CERT_SERIALNUMBER etc. for storing info about client authenticated via SSL certificate. AUTH_USER on IIS seems to have the same value as REMOTE_USER (but there might be some differences I am not aware of).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="deny_regexp"
>deny_regexp</a></h2>

<p>This config item is <b>OPTIONAL</b> - no default value.</p>

<p><b>deny_regexp</b> contains a regular expression used for check against WEBUSER (see details below)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="allow_regexp"
>allow_regexp</a></h2>

<p>This config item is <b>OPTIONAL</b> - no default value.</p>

<p><b>deny_regexp</b> contains a regular expression used for check against WEBUSER.</p>

<p>Allow/deny checking of WEBUSER values goes in this way:</p>

<p>1) If <b>deny_regexp</b> is defined and WEBUSER matches deny_regexp then authentication FAILS otherwise continues with next step. If deny_regexp is not defined or is an empty string we skip this step.</p>

<p>2) If <b>allow_regexp</b> is defined and WEBUSER matches allow_regexp then authentication PASSES otherwise FAILS. If allow_regexp is not defined or is an empty string we skip this step.</p>

<p>The order deny-allow is fixed.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="cutname_regexp"
>cutname_regexp</a></h2>

<p>This config item is <b>OPTIONAL</b> - no default value.</p>

<p>If param <b>cutname_regexp</b> is specified we try to cut the final usename passed to Catalyst application as a substring from WEBUSER. This is useful for example in case of SSL authentication when WEBUSER looks like this &#39;CN=john, OU=Unit Name, O=Company, C=CZ&#39; - from this format we can simply cut pure usename by cutname_regexp set to &#39;CN=(.*), OU=Unit Name, O=Company, C=CZ&#39;.</p>

<p>Substring is always taken as &#39;$1&#39; regexp substring. If WEBUSER does not match cutname_regexp at all or if &#39;$1&#39; regexp substring is empty we pass the original WEBUSER value (without cutting) to Catalyst application.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="username_field"
>username_field</a></h2>

<p>This config item is <b>OPTIONAL</b> - default is <i>username</i></p>

<p>The key name in the authinfo hash that the user&#39;s username is mapped into. This is useful for using a store which requires a specific unusual field name for the username. The username is additionally mapped onto the <i>id</i> key.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="new_(_$config,_$app,_$realm_)"
>new ( $config, $app, $realm )</a></h2>

<p>Instantiate a new Catalyst::Authentication::Credential::Remote object using the configuration hash provided in $config. In case of invalid value of any configuration parameter (e.g. invalid regular expression) throws an exception.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="authenticate_(_$realm,_$authinfo_)"
>authenticate ( $realm, $authinfo )</a></h2>

<p>Takes the username form WEBUSER set by webserver, performs additional checks using optional allow_regexp/deny_regexp configuration params, optionaly takes substring from WEBUSER and the sets the resulting value as a Catalyst username.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COMPATIBILITY"
>COMPATIBILITY</a></h1>

<p>It is <b>strongly recommended</b> to use this module with Catalyst 5.80005 and above as previous versions have some bugs related to $c-&#62;engine-&#62;env and do not support $c-&#62;req-&#62;remote_user.</p>

<p>This module tries some workarounds when it detects an older version and should work as well.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="USING_WITH_A_REVERSE_PROXY"
>USING WITH A REVERSE PROXY</a></h1>

<p>If you are using a reverse proxy, then the WEBUSER will not be directly accessible by the Catalyst server. To use remote authentication, you will have to modify the web server to set a header containing the WEBUSER. You would then need to modify the PSGI configuration to map the header back to the WEBUSER variable.</p>

<p>For example, in Apache you would add the configuration</p>

<pre>  RequestHeader unset X-Forwarded-User
  RewriteEngine On
  RewriteCond %{LA-U:REMOTE_USER} (.+)
  RewriteRule . - [E=RU:%1]
  RequestHeader set X-Forwarded-User %{RU}e</pre>

<p>You then need to create a Plack::Middleware module to map the header back to the WEBUSER:</p>

<pre>  package Plack::Middleware::MyRemote;

  use parent qw( Plack::Middleware );

  use Plack::Util;

  sub call {
      my ($self, $env) = @_;

      my $user = $env-&#62;{HTTP_X_FORWARDED_USER} // &#34;&#34;;

      $env-&#62;{REMOTE_USER} = $user
        if ($user &#38;&#38; ($user ne &#39;(null)&#39;));

      my $res = $self-&#62;app-&#62;($env);

      return $res;
  }

  1;</pre>

<p>Finally, you need to modify <em>myapp.psgi</em> to use the custom middleware:</p>

<pre>  use strict;
  use warnings;

  use MyApp;

  use Plack::Builder;

  my $app = Drain-&#62;apply_default_middlewares(Drain-&#62;psgi_app);

  builder {
     enable &#34;Plack::Middleware::MyRemote&#34;;
     $app;
  };</pre>
<p class="backlinkbottom"><b><a name="___bottom" href="../../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
