<html><head><title>XML::LibXML::Text</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:29 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>XML::LibXML::Text - XML::LibXML Class for Text Nodes</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use XML::LibXML;
  # Only methods specific to Text nodes are listed here,
  # see XML::LibXML::Node manpage for other methods

  $text = XML::LibXML::Text-&#62;new( $content );
  $nodedata = $text-&#62;data;
  $text-&#62;setData( $text_content );
  $text-&#62;substringData($offset, $length);
  $text-&#62;appendData( $somedata );
  $text-&#62;insertData($offset, $string);
  $text-&#62;deleteData($offset, $length);
  $text-&#62;deleteDataString($remstring, $all);
  $text-&#62;replaceData($offset, $length, $string);
  $text-&#62;replaceDataString($old, $new, $flag);
  $text-&#62;replaceDataRegEx( $search_cond, $replace_cond, $reflags );</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Unlike the DOM specification, XML::LibXML implements the text node as the base class of all character data node. Therefore there exists no CharacterData class. This allows one to apply methods of text nodes also to Comments and CDATA-sections.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<p>The class inherits from <a href="../../XML/LibXML/Node.html" class="podlinkpod"
>XML::LibXML::Node</a>. The documentation for Inherited methods is not listed here.</p>

<p>Many functions listed here are extensively documented in the DOM Level 3 specification (<a href="http://www.w3.org/TR/DOM-Level-3-Core/" class="podlinkurl"
>http://www.w3.org/TR/DOM-Level-3-Core/</a>). Please refer to the specification for extensive documentation.</p>

<dl>
<dt><a name="new"
>new</a></dt>

<dd>
<pre>  $text = XML::LibXML::Text-&#62;new( $content );</pre>

<p>The constructor of the class. It creates an unbound text node.</p>

<dt><a name="data"
>data</a></dt>

<dd>
<pre>  $nodedata = $text-&#62;data;</pre>

<p>Although there exists the <code>nodeValue</code> attribute in the Node class, the DOM specification defines data as a separate attribute. <code>XML::LibXML</code> implements these two attributes not as different attributes, but as aliases, such as <code>libxml2</code> does. Therefore</p>

<pre>  $text-&#62;data;</pre>

<p>and</p>

<pre>  $text-&#62;nodeValue;</pre>

<p>will have the same result and are not different entities.</p>

<dt><a name="setData($string)"
>setData($string)</a></dt>

<dd>
<pre>  $text-&#62;setData( $text_content );</pre>

<p>This function sets or replaces text content to a node. The node has to be of the type &#34;text&#34;, &#34;cdata&#34; or &#34;comment&#34;.</p>

<dt><a name="substringData($offset,$length)"
>substringData($offset,$length)</a></dt>

<dd>
<pre>  $text-&#62;substringData($offset, $length);</pre>

<p>Extracts a range of data from the node. (DOM Spec) This function takes the two parameters $offset and $length and returns the sub-string, if available.</p>

<p>If the node contains no data or $offset refers to an non-existing string index, this function will return <i>undef</i>. If $length is out of range <code>substringData</code> will return the data starting at $offset instead of causing an error.</p>

<dt><a name="appendData($string)"
>appendData($string)</a></dt>

<dd>
<pre>  $text-&#62;appendData( $somedata );</pre>

<p>Appends a string to the end of the existing data. If the current text node contains no data, this function has the same effect as <code>setData</code>.</p>

<dt><a name="insertData($offset,$string)"
>insertData($offset,$string)</a></dt>

<dd>
<pre>  $text-&#62;insertData($offset, $string);</pre>

<p>Inserts the parameter $string at the given $offset of the existing data of the node. This operation will not remove existing data, but change the order of the existing data.</p>

<p>The $offset has to be a positive value. If $offset is out of range, <code>insertData</code> will have the same behaviour as <code>appendData</code>.</p>

<dt><a name="deleteData($offset,_$length)"
>deleteData($offset, $length)</a></dt>

<dd>
<pre>  $text-&#62;deleteData($offset, $length);</pre>

<p>This method removes a chunk from the existing node data at the given offset. The $length parameter tells, how many characters should be removed from the string.</p>

<dt><a name="deleteDataString($string,_[$all])"
>deleteDataString($string, [$all])</a></dt>

<dd>
<pre>  $text-&#62;deleteDataString($remstring, $all);</pre>

<p>This method removes a chunk from the existing node data. Since the DOM spec is quite unhandy if you already know <code>which</code> string to remove from a text node, this method allows more perlish code :)</p>

<p>The functions takes two parameters: <i>$string</i> and optional the <i>$all</i> flag. If $all is not set, <i>undef</i> or <i>0</i>, <code>deleteDataString</code> will remove only the first occurrence of $string. If $all is <i>TRUE</i><code>deleteDataString</code> will remove all occurrences of <i>$string</i> from the node data.</p>

<dt><a name="replaceData($offset,_$length,_$string)"
>replaceData($offset, $length, $string)</a></dt>

<dd>
<pre>  $text-&#62;replaceData($offset, $length, $string);</pre>

<p>The DOM style version to replace node data.</p>

<dt><a name="replaceDataString($oldstring,_$newstring,_[$all])"
>replaceDataString($oldstring, $newstring, [$all])</a></dt>

<dd>
<pre>  $text-&#62;replaceDataString($old, $new, $flag);</pre>

<p>The more programmer friendly version of replaceData() :)</p>

<p>Instead of giving offsets and length one can specify the exact string (<i>$oldstring</i>) to be replaced. Additionally the <i>$all</i> flag allows to replace all occurrences of <i>$oldstring</i>.</p>

<dt><a name="replaceDataRegEx(_$search_cond,_$replace_cond,_$reflags_)"
>replaceDataRegEx( $search_cond, $replace_cond, $reflags )</a></dt>

<dd>
<pre>  $text-&#62;replaceDataRegEx( $search_cond, $replace_cond, $reflags );</pre>

<p>This method replaces the node&#39;s data by a <code>simple</code> regular expression. Optional, this function allows to pass some flags that will be added as flag to the replace statement.</p>

<p><i>NOTE:</i> This is a shortcut for</p>

<pre>  my $datastr = $node-&#62;getData();
   $datastr =~ s/somecond/replacement/g; # &#39;g&#39; is just an example for any flag
   $node-&#62;setData( $datastr );</pre>

<p>This function can make things easier to read for simple replacements. For more complex variants it is recommended to use the code snippet above.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<p>Matt Sergeant, Christian Glahn, Petr Pajas</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>2.0014</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>2001-2007, AxKit.com Ltd.</p>

<p>2002-2006, Christian Glahn.</p>

<p>2006-2009, Petr Pajas.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
