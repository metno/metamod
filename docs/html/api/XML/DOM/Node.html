<html><head><title>XML::DOM::Node</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:28 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#GLOBAL_VARIABLES'>GLOBAL VARIABLES</a>
    <li class='indexItem indexItem2'><a href='#METHODS'>METHODS</a>
    <li class='indexItem indexItem2'><a href='#Additional_methods_not_in_the_DOM_Spec'>Additional methods not in the DOM Spec</a>
  </ul>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>XML::DOM::Node - Super class of all nodes in XML::DOM</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>XML::DOM::Node is the super class of all nodes in an XML::DOM document.
This means that all nodes that subclass XML::DOM::Node also inherit all the methods that XML::DOM::Node implements.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="GLOBAL_VARIABLES"
>GLOBAL VARIABLES</a></h2>

<dl>
<dt><a name="@NodeNames"
>@NodeNames</a></dt>

<dd>
<p>The variable @XML::DOM::Node::NodeNames maps the node type constants to strings.
It is used by XML::DOM::Node::getNodeTypeName.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h2>

<dl>
<dt><a name="getNodeType"
>getNodeType</a></dt>

<dd>
<p>Return an integer indicating the node type.
See XML::DOM constants.</p>

<dt><a name="getNodeName"
>getNodeName</a></dt>

<dd>
<p>Return a property or a hardcoded string,
depending on the node type.
Here are the corresponding functions or values:</p>

<pre> Attr                   getName
 AttDef                 getName
 AttlistDecl            getName
 CDATASection           &#34;#cdata-section&#34;
 Comment                &#34;#comment&#34;
 Document               &#34;#document&#34;
 DocumentType           getNodeName
 DocumentFragment       &#34;#document-fragment&#34;
 Element                getTagName
 ElementDecl            getName
 EntityReference        getEntityName
 Entity                 getNotationName
 Notation               getName
 ProcessingInstruction  getTarget
 Text                   &#34;#text&#34;
 XMLDecl                &#34;#xml-declaration&#34;</pre>

<p><b>Not In DOM Spec</b>: AttDef, AttlistDecl, ElementDecl and XMLDecl were added for completeness.</p>

<dt><a name="getNodeValue_and_setNodeValue_(value)"
>getNodeValue and setNodeValue (value)</a></dt>

<dd>
<p>Returns a string or undef, depending on the node type. This method is provided for completeness. In other languages it saves the programmer an upcast. The value is either available thru some other method defined in the subclass, or else undef is returned. Here are the corresponding methods: Attr::getValue, Text::getData, CDATASection::getData, Comment::getData, ProcessingInstruction::getData.</p>

<dt><a name="getParentNode_and_setParentNode_(parentNode)"
>getParentNode and setParentNode (parentNode)</a></dt>

<dd>
<p>The parent of this node. All nodes, except Document, DocumentFragment, and Attr may have a parent. However, if a node has just been created and not yet added to the tree, or if it has been removed from the tree, this is undef.</p>

<dt><a name="getChildNodes"
>getChildNodes</a></dt>

<dd>
<p>A NodeList that contains all children of this node. If there are no children, this is a NodeList containing no nodes. The content of the returned NodeList is &#34;live&#34; in the sense that, for instance, changes to the children of the node object that it was created from are immediately reflected in the nodes returned by the NodeList accessors; it is not a static snapshot of the content of the node. This is true for every NodeList, including the ones returned by the getElementsByTagName method.</p>

<p>NOTE: this implementation does not return a &#34;live&#34; NodeList for getElementsByTagName. See <a href="../../CAVEATS.html" class="podlinkpod"
>CAVEATS</a>.</p>

<p>When this method is called in a list context, it returns a regular perl list containing the child nodes. Note that this list is not &#34;live&#34;. E.g.</p>

<pre> @list = $node-&#62;getChildNodes;        # returns a perl list
 $nodelist = $node-&#62;getChildNodes;    # returns a NodeList (object reference)
 for my $kid ($node-&#62;getChildNodes)   # iterate over the children of $node</pre>

<dt><a name="getFirstChild"
>getFirstChild</a></dt>

<dd>
<p>The first child of this node. If there is no such node, this returns undef.</p>

<dt><a name="getLastChild"
>getLastChild</a></dt>

<dd>
<p>The last child of this node. If there is no such node, this returns undef.</p>

<dt><a name="getPreviousSibling"
>getPreviousSibling</a></dt>

<dd>
<p>The node immediately preceding this node. If there is no such node, this returns undef.</p>

<dt><a name="getNextSibling"
>getNextSibling</a></dt>

<dd>
<p>The node immediately following this node. If there is no such node, this returns undef.</p>

<dt><a name="getAttributes"
>getAttributes</a></dt>

<dd>
<p>A NamedNodeMap containing the attributes (Attr nodes) of this node (if it is an Element) or undef otherwise. Note that adding/removing attributes from the returned object, also adds/removes attributes from the Element node that the NamedNodeMap came from.</p>

<dt><a name="getOwnerDocument"
>getOwnerDocument</a></dt>

<dd>
<p>The Document object associated with this node. This is also the Document object used to create new nodes. When this node is a Document this is undef.</p>

<dt><a name="insertBefore_(newChild,_refChild)"
>insertBefore (newChild, refChild)</a></dt>

<dd>
<p>Inserts the node newChild before the existing child node refChild. If refChild is undef, insert newChild at the end of the list of children.</p>

<p>If newChild is a DocumentFragment object, all of its children are inserted, in the same order, before refChild. If the newChild is already in the tree, it is first removed.</p>

<p>Return Value: The node being inserted.</p>

<p>DOMExceptions:</p>

<ul>
<li>HIERARCHY_REQUEST_ERR
<p>Raised if this node is of a type that does not allow children of the type of the newChild node, or if the node to insert is one of this node&#39;s ancestors.</p>
</li>

<li>WRONG_DOCUMENT_ERR
<p>Raised if newChild was created from a different document than the one that created this node.</p>
</li>

<li>NO_MODIFICATION_ALLOWED_ERR
<p>Raised if this node is readonly.</p>
</li>

<li>NOT_FOUND_ERR
<p>Raised if refChild is not a child of this node.</p>
</li>
</ul>

<dt><a name="replaceChild_(newChild,_oldChild)"
>replaceChild (newChild, oldChild)</a></dt>

<dd>
<p>Replaces the child node oldChild with newChild in the list of children, and returns the oldChild node. If the newChild is already in the tree, it is first removed.</p>

<p>Return Value: The node replaced.</p>

<p>DOMExceptions:</p>

<ul>
<li>HIERARCHY_REQUEST_ERR
<p>Raised if this node is of a type that does not allow children of the type of the newChild node, or it the node to put in is one of this node&#39;s ancestors.</p>
</li>

<li>WRONG_DOCUMENT_ERR
<p>Raised if newChild was created from a different document than the one that created this node.</p>
</li>

<li>NO_MODIFICATION_ALLOWED_ERR
<p>Raised if this node is readonly.</p>
</li>

<li>NOT_FOUND_ERR
<p>Raised if oldChild is not a child of this node.</p>
</li>
</ul>

<dt><a name="removeChild_(oldChild)"
>removeChild (oldChild)</a></dt>

<dd>
<p>Removes the child node indicated by oldChild from the list of children, and returns it.</p>

<p>Return Value: The node removed.</p>

<p>DOMExceptions:</p>

<ul>
<li>NO_MODIFICATION_ALLOWED_ERR
<p>Raised if this node is readonly.</p>
</li>

<li>NOT_FOUND_ERR
<p>Raised if oldChild is not a child of this node.</p>
</li>
</ul>

<dt><a name="appendChild_(newChild)"
>appendChild (newChild)</a></dt>

<dd>
<p>Adds the node newChild to the end of the list of children of this node. If the newChild is already in the tree, it is first removed. If it is a DocumentFragment object, the entire contents of the document fragment are moved into the child list of this node</p>

<p>Return Value: The node added.</p>

<p>DOMExceptions:</p>

<ul>
<li>HIERARCHY_REQUEST_ERR
<p>Raised if this node is of a type that does not allow children of the type of the newChild node, or if the node to append is one of this node&#39;s ancestors.</p>
</li>

<li>WRONG_DOCUMENT_ERR
<p>Raised if newChild was created from a different document than the one that created this node.</p>
</li>

<li>NO_MODIFICATION_ALLOWED_ERR
<p>Raised if this node is readonly.</p>
</li>
</ul>

<dt><a name="hasChildNodes"
>hasChildNodes</a></dt>

<dd>
<p>This is a convenience method to allow easy determination of whether a node has any children.</p>

<p>Return Value: 1 if the node has any children, 0 otherwise.</p>

<dt><a name="cloneNode_(deep)"
>cloneNode (deep)</a></dt>

<dd>
<p>Returns a duplicate of this node, i.e., serves as a generic copy constructor for nodes. The duplicate node has no parent (parentNode returns undef.).</p>

<p>Cloning an Element copies all attributes and their values, including those generated by the XML processor to represent defaulted attributes, but this method does not copy any text it contains unless it is a deep clone, since the text is contained in a child Text node. Cloning any other type of node simply returns a copy of this node.</p>

<p>Parameters: <i>deep</i> If true, recursively clone the subtree under the specified node. If false, clone only the node itself (and its attributes, if it is an Element).</p>

<p>Return Value: The duplicate node.</p>

<dt><a name="normalize"
>normalize</a></dt>

<dd>
<p>Puts all Text nodes in the full depth of the sub-tree underneath this Element into a &#34;normal&#34; form where only markup (e.g., tags, comments, processing instructions, CDATA sections, and entity references) separates Text nodes, i.e., there are no adjacent Text nodes. This can be used to ensure that the DOM view of a document is the same as if it were saved and re-loaded, and is useful when operations (such as XPointer lookups) that depend on a particular document tree structure are to be used.</p>

<p><b>Not In DOM Spec</b>: In the DOM Spec this method is defined in the Element and Document class interfaces only, but it doesn&#39;t hurt to have it here...</p>

<dt><a name="getElementsByTagName_(name_[,_recurse])"
>getElementsByTagName (name [, recurse])</a></dt>

<dd>
<p>Returns a NodeList of all descendant elements with a given tag name, in the order in which they would be encountered in a preorder traversal of the Element tree.</p>

<p>Parameters: <i>name</i> The name of the tag to match on. The special value &#34;*&#34; matches all tags. <i>recurse</i> Whether it should return only direct child nodes (0) or any descendant that matches the tag name (1). This argument is optional and defaults to 1. It is not part of the DOM spec.</p>

<p>Return Value: A list of matching Element nodes.</p>

<p>NOTE: this implementation does not return a &#34;live&#34; NodeList for getElementsByTagName. See <a href="../../CAVEATS.html" class="podlinkpod"
>CAVEATS</a>.</p>

<p>When this method is called in a list context, it returns a regular perl list containing the result nodes. E.g.</p>

<pre> @list = $node-&#62;getElementsByTagName(&#34;tag&#34;);       # returns a perl list
 $nodelist = $node-&#62;getElementsByTagName(&#34;tag&#34;);   # returns a NodeList (object ref.)
 for my $elem ($node-&#62;getElementsByTagName(&#34;tag&#34;)) # iterate over the result nodes</pre>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Additional_methods_not_in_the_DOM_Spec"
>Additional methods not in the DOM Spec</a></h2>

<dl>
<dt><a name="getNodeTypeName"
>getNodeTypeName</a></dt>

<dd>
<p>Return the string describing the node type. E.g. returns &#34;ELEMENT_NODE&#34; if getNodeType returns ELEMENT_NODE. It uses @XML::DOM::Node::NodeNames.</p>

<dt><a name="toString"
>toString</a></dt>

<dd>
<p>Returns the entire subtree as a string.</p>

<dt><a name="printToFile_(filename)"
>printToFile (filename)</a></dt>

<dd>
<p>Prints the entire subtree to the file with the specified filename.</p>

<p>Croaks: if the file could not be opened for writing.</p>

<dt><a name="printToFileHandle_(handle)"
>printToFileHandle (handle)</a></dt>

<dd>
<p>Prints the entire subtree to the file handle. E.g. to print to STDOUT:</p>

<pre> $node-&#62;printToFileHandle (\*STDOUT);</pre>

<dt><a name="print_(obj)"
>print (obj)</a></dt>

<dd>
<p>Prints the entire subtree using the object&#39;s print method. E.g to print to a FileHandle object:</p>

<pre> $f = new FileHandle (&#34;file.out&#34;, &#34;w&#34;);
 $node-&#62;print ($f);</pre>

<dt><a name="getChildIndex_(child)"
>getChildIndex (child)</a></dt>

<dd>
<p>Returns the index of the child node in the list returned by getChildNodes.</p>

<p>Return Value: the index or -1 if the node is not found.</p>

<dt><a name="getChildAtIndex_(index)"
>getChildAtIndex (index)</a></dt>

<dd>
<p>Returns the child node at the specifed index or undef.</p>

<dt><a name="addText_(text)"
>addText (text)</a></dt>

<dd>
<p>Appends the specified string to the last child if it is a Text node, or else appends a new Text node (with the specified text.)</p>

<p>Return Value: the last child if it was a Text node or else the new Text node.</p>

<dt><a name="dispose"
>dispose</a></dt>

<dd>
<p>Removes all circular references in this node and its descendants so the objects can be claimed for garbage collection. The objects should not be used afterwards.</p>

<dt><a name="setOwnerDocument_(doc)"
>setOwnerDocument (doc)</a></dt>

<dd>
<p>Sets the ownerDocument property of this node and all its children (and attributes etc.) to the specified document. This allows the user to cut and paste document subtrees between different XML::DOM::Documents. The node should be removed from the original document first, before calling setOwnerDocument.</p>

<p>This method does nothing when called on a Document node.</p>

<dt><a name="isAncestor_(parent)"
>isAncestor (parent)</a></dt>

<dd>
<p>Returns 1 if parent is an ancestor of this node or if it is this node itself.</p>

<dt><a name="expandEntityRefs_(str)"
>expandEntityRefs (str)</a></dt>

<dd>
<p>Expands all the entity references in the string and returns the result. The entity references can be character references (e.g. &#34;&#38;#123;&#34; or &#34;&#38;#x1fc2&#34;), default entity references (&#34;&#38;quot;&#34;, &#34;&#38;gt;&#34;, &#34;&#38;lt;&#34;, &#34;&#38;apos;&#34; and &#34;&#38;amp;&#34;) or entity references defined in Entity objects as part of the DocumentType of the owning Document. Character references are expanded into UTF-8. Parameter entity references (e.g. %ent;) are not expanded.</p>

<dt><a name="to_sax_(_%HANDLERS_)"
>to_sax ( %HANDLERS )</a></dt>

<dd>
<p>E.g.</p>

<pre> $node-&#62;to_sax (DocumentHandler =&#62; $my_handler, 
                Handler =&#62; $handler2 );</pre>

<p>%HANDLERS may contain the following handlers:</p>

<ul>
<li>DocumentHandler</li>

<li>DTDHandler</li>

<li>EntityResolver</li>

<li>Handler
<p>Default handler when one of the above is not specified</p>
</li>
</ul>

<p>Each XML::DOM::Node generates the appropriate SAX callbacks (for the appropriate SAX handler.) Different SAX handlers can be plugged in to accomplish different things, e.g. <a href="../../XML/Checker.html" class="podlinkpod"
>XML::Checker</a> would check the node (currently only Document and Element nodes are supported), <a href="../../XML/Handler/BuildDOM.html" class="podlinkpod"
>XML::Handler::BuildDOM</a> would create a new DOM subtree (thereby, in essence, copying the Node) and in the near future, XML::Writer could print the node. All Perl SAX related work is still in flux, so this interface may change a little.</p>

<p>See PerlSAX for the description of the SAX interface.</p>

<dt><a name="check_(_[$checker]_)"
>check ( [$checker] )</a></dt>

<dd>
<p>See descriptions for check() in <a href="../../XML/DOM/Document.html" class="podlinkpod"
>XML::DOM::Document</a> and <a href="../../XML/DOM/Element.html" class="podlinkpod"
>XML::DOM::Element</a>.</p>

<dt><a name="xql_(_@XQL_OPTIONS_)"
>xql ( @XQL_OPTIONS )</a></dt>

<dd>
<p>To use the xql method, you must first <i>use</i> <a href="../../XML/XQL.html" class="podlinkpod"
>XML::XQL</a> and <a href="../../XML/XQL/DOM.html" class="podlinkpod"
>XML::XQL::DOM</a>. This method is basically a shortcut for:</p>

<pre> $query = new XML::XQL::Query ( @XQL_OPTIONS );
 return $query-&#62;solve ($node);</pre>

<p>If the first parameter in @XQL_OPTIONS is the XQL expression, you can leave off the &#39;Expr&#39; keyword, so:</p>

<pre> $node-&#62;xql (&#34;doc//elem1[@attr]&#34;, @other_options);</pre>

<p>is identical to:</p>

<pre> $node-&#62;xql (Expr =&#62; &#34;doc//elem1[@attr]&#34;, @other_options);</pre>

<p>See <a href="../../XML/XQL/Query.html" class="podlinkpod"
>XML::XQL::Query</a> for other available XQL_OPTIONS. See <a href="../../XML/XQL.html" class="podlinkpod"
>XML::XQL</a> and <a href="../../XML/XQL/Tutorial.html" class="podlinkpod"
>XML::XQL::Tutorial</a> for more info.</p>

<dt><a name="isHidden_()"
>isHidden ()</a></dt>

<dd>
<p>Whether the node is hidden. See <a href="../../XML/DOM.html#_Hidden_Nodes_" class="podlinkpod"
>Hidden Nodes</a> for details.</p>
</dd>
</dl>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
