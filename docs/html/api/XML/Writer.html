<html><head><title>XML::Writer</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:29 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Writing_XML'>Writing XML</a>
    <li class='indexItem indexItem2'><a href='#Querying_XML'>Querying XML</a>
    <li class='indexItem indexItem2'><a href='#Additional_Namespace_Support'>Additional Namespace Support</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#ERROR_REPORTING'>ERROR REPORTING</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>XML::Writer - Perl extension for writing XML documents.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use XML::Writer;
  use IO::File;

  my $output = IO::File-&#62;new(&#34;&#62;output.xml&#34;);

  my $writer = XML::Writer-&#62;new(OUTPUT =&#62; $output);
  $writer-&#62;startTag(&#34;greeting&#34;,
                    &#34;class&#34; =&#62; &#34;simple&#34;);
  $writer-&#62;characters(&#34;Hello, world!&#34;);
  $writer-&#62;endTag(&#34;greeting&#34;);
  $writer-&#62;end();
  $output-&#62;close();</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>XML::Writer is a helper module for Perl programs that write an XML document. The module handles all escaping for attribute values and character data and constructs different types of markup, such as tags, comments, and processing instructions.</p>

<p>By default, the module performs several well-formedness checks to catch errors during output. This behaviour can be extremely useful during development and debugging, but it can be turned off for production-grade code.</p>

<p>The module can operate either in regular mode in or Namespace processing mode. In Namespace mode, the module will generate Namespace Declarations itself, and will perform additional checks on the output.</p>

<p>Additional support is available for a simplified data mode with no mixed content: newlines are automatically inserted around elements and elements can optionally be indented based as their nesting level.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Writing_XML"
>Writing XML</a></h2>

<dl>
<dt><a name="new([$params])"
>new([$params])</a></dt>

<dd>
<p>Create a new XML::Writer object:</p>

<pre>  my $writer = XML::Writer-&#62;new(OUTPUT =&#62; $output, NEWLINES =&#62; 1);</pre>

<p>Arguments are an anonymous hash array of parameters:</p>

<dl>
<dt><a name="OUTPUT"
>OUTPUT</a></dt>

<dd>
<p>An object blessed into IO::Handle or one of its subclasses (such as IO::File), or a reference to a string, or any blessed object that has a print() method; if this parameter is not present, the module will write to standard output. If a string reference is passed, it will capture the generated XML (as a string; to get bytes use the <code>Encode</code> module).</p>

<dt><a name="NAMESPACES"
>NAMESPACES</a></dt>

<dd>
<p>A true (1) or false (0, undef) value; if this parameter is present and its value is true, then the module will accept two-member array reference in the place of element and attribute names, as in the following example:</p>

<pre>  my $rdfns = &#34;http://www.w3.org/1999/02/22-rdf-syntax-ns#&#34;;
  my $writer = XML::Writer-&#62;new(NAMESPACES =&#62; 1);
  $writer-&#62;startTag([$rdfns, &#34;Description&#34;]);</pre>

<p>The first member of the array is a namespace URI, and the second part is the local part of a qualified name. The module will automatically generate appropriate namespace declarations and will replace the URI part with a prefix.</p>

<dt><a name="PREFIX_MAP"
>PREFIX_MAP</a></dt>

<dd>
<p>A hash reference; if this parameter is present and the module is performing namespace processing (see the NAMESPACES parameter), then the module will use this hash to look up preferred prefixes for namespace URIs:</p>

<pre>  my $rdfns = &#34;http://www.w3.org/1999/02/22-rdf-syntax-ns#&#34;;
  my $writer = XML::Writer-&#62;new(NAMESPACES =&#62; 1,
                               PREFIX_MAP =&#62; {$rdfns =&#62; &#39;rdf&#39;});</pre>

<p>The keys in the hash table are namespace URIs, and the values are the associated prefixes. If there is not a preferred prefix for the namespace URI in this hash, then the module will automatically generate prefixes of the form &#34;__NS1&#34;, &#34;__NS2&#34;, etc.</p>

<p>To set the default namespace, use &#39;&#39; for the prefix.</p>

<dt><a name="FORCED_NS_DECLS"
>FORCED_NS_DECLS</a></dt>

<dd>
<p>An array reference; if this parameter is present, the document element will contain declarations for all the given namespace URIs. Declaring namespaces in advance is particularly useful when a large number of elements from a namespace are siblings, but don&#39;t share a direct ancestor from the same namespace.</p>

<dt><a name="NEWLINES"
>NEWLINES</a></dt>

<dd>
<p>A true or false value; if this parameter is present and its value is true, then the module will insert an extra newline before the closing delimiter of start, end, and empty tags to guarantee that the document does not end up as a single, long line. If the parameter is not present, the module will not insert the newlines.</p>

<dt><a name="UNSAFE"
>UNSAFE</a></dt>

<dd>
<p>A true or false value; if this parameter is present and its value is true, then the module will skip most well-formedness error checking. If the parameter is not present, the module will perform the well-formedness error checking by default. Turn off error checking at your own risk!</p>

<dt><a name="DATA_MODE"
>DATA_MODE</a></dt>

<dd>
<p>A true or false value; if this parameter is present and its value is true, then the module will enter a special data mode, inserting newlines automatically around elements and (unless UNSAFE is also specified) reporting an error if any element has both characters and elements as content.</p>

<dt><a name="DATA_INDENT"
>DATA_INDENT</a></dt>

<dd>
<p>A numeric value or white space; if this parameter is present, it represents the indent step for elements in data mode (it will be ignored when not in data mode). If it is white space it will be repeated for each level of indentation.</p>

<dt><a name="ENCODING"
>ENCODING</a></dt>

<dd>
<p>A character encoding; currently this must be one of &#39;utf-8&#39; or &#39;us-ascii&#39;. If present, it will be used for the underlying character encoding and as the default in the XML declaration.</p>

<dt><a name="CHECK_PRINT"
>CHECK_PRINT</a></dt>

<dd>
<p>A true or false value; if this parameter is present and its value is true, all prints to the underlying output will be checked for success. Failures will cause a croak rather than being ignored.</p>
</dd>
</dl>

<dt><a name="end()"
>end()</a></dt>

<dd>
<p>Finish creating an XML document. This method will check that the document has exactly one document element, and that all start tags are closed:</p>

<pre>  $writer-&#62;end();</pre>

<dt><a name="xmlDecl([$encoding,_$standalone])"
>xmlDecl([$encoding, $standalone])</a></dt>

<dd>
<p>Add an XML declaration to the beginning of an XML document. The version will always be &#34;1.0&#34;. If you provide a non-null encoding or standalone argument, its value will appear in the declaration (any non-null value for standalone except &#39;no&#39; will automatically be converted to &#39;yes&#39;). If not given here, the encoding will be taken from the ENCODING argument. Pass the empty string to suppress this behaviour.</p>

<pre>  $writer-&#62;xmlDecl(&#34;UTF-8&#34;);</pre>

<dt><a name="doctype($name,_[$publicId,_$systemId])"
>doctype($name, [$publicId, $systemId])</a></dt>

<dd>
<p>Add a DOCTYPE declaration to an XML document. The declaration must appear before the beginning of the root element. If you provide a publicId, you must provide a systemId as well, but you may provide just a system ID by passing &#39;undef&#39; for the publicId.</p>

<pre>  $writer-&#62;doctype(&#34;html&#34;);</pre>

<dt><a name="comment($text)"
>comment($text)</a></dt>

<dd>
<p>Add a comment to an XML document. If the comment appears outside the document element (either before the first start tag or after the last end tag), the module will add a carriage return after it to improve readability. In data mode, comments will be treated as empty tags:</p>

<pre>  $writer-&#62;comment(&#34;This is a comment&#34;);</pre>

<dt><a name="pi($target_[,_$data])"
>pi($target [, $data])</a></dt>

<dd>
<p>Add a processing instruction to an XML document:</p>

<pre>  $writer-&#62;pi(&#39;xml-stylesheet&#39;, &#39;href=&#34;style.css&#34; type=&#34;text/css&#34;&#39;);</pre>

<p>If the processing instruction appears outside the document element (either before the first start tag or after the last end tag), the module will add a carriage return after it to improve readability.</p>

<p>The $target argument must be a single XML name. If you provide the $data argument, the module will insert its contents following the $target argument, separated by a single space.</p>

<dt><a name="startTag($name_[,_$aname1_=&#62;_$value1,_...])"
>startTag($name [, $aname1 =&#62; $value1, ...])</a></dt>

<dd>
<p>Add a start tag to an XML document. Any arguments after the element name are assumed to be name/value pairs for attributes: the module will escape all &#39;&#38;&#39;, &#39;&#60;&#39;, &#39;&#62;&#39;, and &#39;&#34;&#39; characters in the attribute values using the predefined XML entities:</p>

<pre>  $writer-&#62;startTag(&#39;doc&#39;, &#39;version&#39; =&#62; &#39;1.0&#39;,
                           &#39;status&#39; =&#62; &#39;draft&#39;,
                           &#39;topic&#39; =&#62; &#39;AT&#38;T&#39;);</pre>

<p>All start tags must eventually have matching end tags.</p>

<dt><a name="emptyTag($name_[,_$aname1_=&#62;_$value1,_...])"
>emptyTag($name [, $aname1 =&#62; $value1, ...])</a></dt>

<dd>
<p>Add an empty tag to an XML document. Any arguments after the element name are assumed to be name/value pairs for attributes (see startTag() for details):</p>

<pre>  $writer-&#62;emptyTag(&#39;img&#39;, &#39;src&#39; =&#62; &#39;portrait.jpg&#39;,
                           &#39;alt&#39; =&#62; &#39;Portrait of Emma.&#39;);</pre>

<dt><a name="endTag([$name])"
>endTag([$name])</a></dt>

<dd>
<p>Add an end tag to an XML document. The end tag must match the closest open start tag, and there must be a matching and properly-nested end tag for every start tag:</p>

<pre>  $writer-&#62;endTag(&#39;doc&#39;);</pre>

<p>If the $name argument is omitted, then the module will automatically supply the name of the currently open element:</p>

<pre>  $writer-&#62;startTag(&#39;p&#39;);
  $writer-&#62;endTag();</pre>

<dt><a name="dataElement($name,_$data_[,_$aname1_=&#62;_$value1,_...])"
>dataElement($name, $data [, $aname1 =&#62; $value1, ...])</a></dt>

<dd>
<p>Print an entire element containing only character data. This is equivalent to</p>

<pre>  $writer-&#62;startTag($name [, $aname1 =&#62; $value1, ...]);
  $writer-&#62;characters($data);
  $writer-&#62;endTag($name);</pre>

<dt><a name="characters($data)"
>characters($data)</a></dt>

<dd>
<p>Add character data to an XML document. All &#39;&#60;&#39;, &#39;&#62;&#39;, and &#39;&#38;&#39; characters in the $data argument will automatically be escaped using the predefined XML entities:</p>

<pre>  $writer-&#62;characters(&#34;Here is the formula: &#34;);
  $writer-&#62;characters(&#34;a &#60; 100 &#38;&#38; a &#62; 5&#34;);</pre>

<p>You may invoke this method only within the document element (i.e. after the first start tag and before the last end tag).</p>

<p>In data mode, you must not use this method to add whitespace between elements.</p>

<dt><a name="raw($data)"
>raw($data)</a></dt>

<dd>
<p>Print data completely unquoted and unchecked to the XML document. For example <code>raw(&#39;&#60;&#39;)</code> will print a literal &#60; character. This necessarily bypasses all well-formedness checking, and is therefore only available in unsafe mode.</p>

<p>This can sometimes be useful for printing entities which are defined for your XML format but the module doesn&#39;t know about, for example &#38;nbsp; for XHTML.</p>

<dt><a name="cdata($data)"
>cdata($data)</a></dt>

<dd>
<p>As <code>characters()</code> but writes the data quoted in a CDATA section, that is, between &#60;![CDATA[ and ]]&#62;. If the data to be written itself contains ]]&#62;, it will be written as several consecutive CDATA sections.</p>

<dt><a name="cdataElement($name,_$data_[,_$aname1_=&#62;_$value1,_...])"
>cdataElement($name, $data [, $aname1 =&#62; $value1, ...])</a></dt>

<dd>
<p>As <code>dataElement()</code> but the element content is written as one or more CDATA sections (see <code>cdata()</code>).</p>

<dt><a name="setOutput($output)"
>setOutput($output)</a></dt>

<dd>
<p>Set the current output destination, as in the OUTPUT parameter for the constructor.</p>

<dt><a name="getOutput()"
>getOutput()</a></dt>

<dd>
<p>Return the current output destination, as in the OUTPUT parameter for the constructor.</p>

<dt><a name="setDataMode($mode)"
>setDataMode($mode)</a></dt>

<dd>
<p>Enable or disable data mode, as in the DATA_MODE parameter for the constructor.</p>

<dt><a name="getDataMode()"
>getDataMode()</a></dt>

<dd>
<p>Return the current data mode, as in the DATA_MODE parameter for the constructor.</p>

<dt><a name="setDataIndent($step)"
>setDataIndent($step)</a></dt>

<dd>
<p>Set the indent step for data mode, as in the DATA_INDENT parameter for the constructor.</p>

<dt><a name="getDataIndent()"
>getDataIndent()</a></dt>

<dd>
<p>Return the indent step for data mode, as in the DATA_INDENT parameter for the constructor.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Querying_XML"
>Querying XML</a></h2>

<dl>
<dt><a name="in_element($name)"
>in_element($name)</a></dt>

<dd>
<p>Return a true value if the most recent open element matches $name:</p>

<pre>  if ($writer-&#62;in_element(&#39;dl&#39;)) {
    $writer-&#62;startTag(&#39;dt&#39;);
  } else {
    $writer-&#62;startTag(&#39;li&#39;);
  }</pre>

<dt><a name="within_element($name)"
>within_element($name)</a></dt>

<dd>
<p>Return a true value if any open element matches $name:</p>

<pre>  if ($writer-&#62;within_element(&#39;body&#39;)) {
    $writer-&#62;startTag(&#39;h1&#39;);
  } else {
    $writer-&#62;startTag(&#39;title&#39;);
  }</pre>

<dt><a name="current_element()"
>current_element()</a></dt>

<dd>
<p>Return the name of the currently open element:</p>

<pre>  my $name = $writer-&#62;current_element();</pre>

<p>This is the equivalent of</p>

<pre>  my $name = $writer-&#62;ancestor(0);</pre>

<dt><a name="ancestor($n)"
>ancestor($n)</a></dt>

<dd>
<p>Return the name of the nth ancestor, where $n=0 for the current open element.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Additional_Namespace_Support"
>Additional Namespace Support</a></h2>

<p>As of 0.510, these methods may be used while writing a document.</p>

<dl>
<dt><a name="addPrefix($uri,_$prefix)"
>addPrefix($uri, $prefix)</a></dt>

<dd>
<p>Add a preferred mapping between a Namespace URI and a prefix. See also the PREFIX_MAP constructor parameter.</p>

<p>To set the default namespace, omit the $prefix parameter or set it to &#39;&#39;.</p>

<dt><a name="removePrefix($uri)"
>removePrefix($uri)</a></dt>

<dd>
<p>Remove a preferred mapping between a Namespace URI and a prefix.</p>

<dt><a name="forceNSDecl($uri)"
>forceNSDecl($uri)</a></dt>

<dd>
<p>Indicate that a namespace declaration for this URI should be included with the next element to be started.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ERROR_REPORTING"
>ERROR REPORTING</a></h1>

<p>With the default settings, the XML::Writer module can detect several basic XML well-formedness errors:</p>

<ul>
<li>Lack of a (top-level) document element, or multiple document elements.</li>

<li>Unclosed start tags.</li>

<li>Misplaced delimiters in the contents of processing instructions or comments.</li>

<li>Misplaced or duplicate XML declaration(s).</li>

<li>Misplaced or duplicate DOCTYPE declaration(s).</li>

<li>Mismatch between the document type name in the DOCTYPE declaration and the name of the document element.</li>

<li>Mismatched start and end tags.</li>

<li>Attempts to insert character data outside the document element.</li>

<li>Duplicate attributes with the same name.</li>
</ul>

<p>During Namespace processing, the module can detect the following additional errors:</p>

<ul>
<li>Attempts to use PI targets or element or attribute names containing a colon.</li>

<li>Attempts to use attributes with names beginning &#34;xmlns&#34;.</li>
</ul>

<p>To ensure full error detection, a program must also invoke the end method when it has finished writing a document:</p>

<pre>  $writer-&#62;startTag(&#39;greeting&#39;);
  $writer-&#62;characters(&#34;Hello, world!&#34;);
  $writer-&#62;endTag(&#39;greeting&#39;);
  $writer-&#62;end();</pre>

<p>This error reporting can catch many hidden bugs in Perl programs that create XML documents; however, if necessary, it can be turned off by providing an UNSAFE parameter:</p>

<pre>  my $writer = XML::Writer-&#62;new(OUTPUT =&#62; $output, UNSAFE =&#62; 1);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>David Megginson &#60;david@megginson.com&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>Copyright (c) 1999 by Megginson Technologies.</p>

<p>Copyright (c) 2003 Ed Avis &#60;ed@membled.com&#62;</p>

<p>Copyright (c) 2004-2010 Joseph Walton &#60;joe@kafsemo.org&#62;</p>

<p>Redistribution and use in source and compiled forms, with or without modification, are permitted under any circumstances. No warranty.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>XML::Parser</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
