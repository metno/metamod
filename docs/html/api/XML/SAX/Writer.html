<html><head><title>XML::SAX::Writer</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:29 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Why_yet_another_XML_Writer_%3F'>Why yet another XML Writer ?</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <li class='indexItem indexItem1'><a href='#THE_CONSUMER_INTERFACE'>THE CONSUMER INTERFACE</a>
  <li class='indexItem indexItem1'><a href='#THE_ENCODER_INTERFACE'>THE ENCODER INTERFACE</a>
  <li class='indexItem indexItem1'><a href='#CUSTOM_OUTPUT'>CUSTOM OUTPUT</a>
  <li class='indexItem indexItem1'><a href='#TODO'>TODO</a>
  <li class='indexItem indexItem1'><a href='#CREDITS'>CREDITS</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#POD_ERRORS'>POD ERRORS</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>XML::SAX::Writer - SAX2 Writer</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use XML::SAX::Writer;
  use XML::SAX::SomeDriver;

  my $w = XML::SAX::Writer-&#62;new;
  my $d = XML::SAX::SomeDriver-&#62;new(Handler =&#62; $w);

  $d-&#62;parse(&#39;some options...&#39;);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Why_yet_another_XML_Writer_?"
>Why yet another XML Writer ?</a></h2>

<p>A new XML Writer was needed to match the SAX2 effort because quite naturally no existing writer understood SAX2. My first intention had been to start patching XML::Handler::YAWriter as it had previously been my favourite writer in the SAX1 world.</p>

<p>However the more I patched it the more I realised that what I thought was going to be a simple patch (mostly adding a few event handlers and changing the attribute syntax) was turning out to be a rewrite due to various ideas I&#39;d been collecting along the way. Besides, I couldn&#39;t find a way to elegantly make it work with SAX2 without breaking the SAX1 compatibility which people are probably still using. There are of course ways to do that, but most require user interaction which is something I wanted to avoid.</p>

<p>So in the end there was a new writer. I think it&#39;s in fact better this way as it helps keep SAX1 and SAX2 separated.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<ul>
<li>new(%hash)
<p>This is the constructor for this object. &#194;&#160;It takes a number of parameters, all of which are optional.</p>
</li>

<li>-- Output
<p>This parameter can be one of several things. &#194;&#160;If it is a simple scalar, it is interpreted as a filename which will be opened for writing. &#194;&#160;If it is a scalar reference, output will be appended to this scalar. &#194;&#160;If it is an array reference, output will be pushed onto this array as it is generated. &#194;&#160;If it is a filehandle, then output will be sent to this filehandle.</p>

<p>Finally, it is possible to pass an object for this parameter, in which case it is assumed to be an object that implements the consumer interface <a href="#THE_CONSUMER_INTERFACE" class="podlinkpod"
>described later in the documentation</a>.</p>

<p>If this parameter is not provided, then output is sent to STDOUT.</p>
</li>

<li>-- Escape
<p>This should be a hash reference where the keys are characters sequences that should be escaped and the values are the escaped form of the sequence. &#194;&#160;By default, this module will escape the ampersand (&#38;), less than (&#60;), greater than (&#62;), double quote (&#34;), and apostrophe (&#39;). Note that some browsers don&#39;t support the &#38;apos; escape used for apostrophes so that you should be careful when outputting XHTML.</p>

<p>If you only want to add entries to the Escape hash, you can first copy the contents of %XML::SAX::Writer::DEFAULT_ESCAPE.</p>
</li>

<li>-- CommentEscape
<p>Comment content often needs to be escaped differently from other content. This option works exactly as the previous one except that by default it only escapes the double dash (--) and that the contents can be copied from %XML::SAX::Writer::COMMENT_ESCAPE.</p>
</li>

<li>-- EncodeFrom
<p>The character set encoding in which incoming data will be provided. This defaults to UTF-8, which works for US-ASCII as well.</p>
</li>

<li>-- EncodeTo
<p>The character set encoding in which output should be encoded. &#194;&#160;Again, this defaults to UTF-8.</p>
</li>

<li>-- QuoteCharacter
<p>Set the character used to quote attributes. This defaults to single quotes (&#39;) for backwards compatiblity.</p>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="THE_CONSUMER_INTERFACE"
>THE CONSUMER INTERFACE</a></h1>

<p>XML::SAX::Writer can receive pluggable consumer objects that will be in charge of writing out what is formatted by this module. Setting a Consumer is done by setting the Output option to the object of your choice instead of to an array, scalar, or file handle as is more commonly done (internally those in fact map to Consumer classes and and simply available as options for your convienience).</p>

<p>If you don&#39;t understand this, don&#39;t worry. You don&#39;t need it most of the time.</p>

<p>That object can be from any class, but must have two methods in its API. It is also strongly recommended that it inherits from XML::SAX::Writer::ConsumerInterface so that it will not break if that interface evolves over time. There are examples at the end of XML::SAX::Writer&#39;s code.</p>

<p>The two methods that it needs to implement are:</p>

<ul>
<li>output STRING
<p>(Required)</p>

<p>This is called whenever the Writer wants to output a string formatted in XML. Encoding conversion, character escaping, and formatting have already taken place. It&#39;s up to the consumer to do whatever it wants with the string.</p>
</li>

<li>finalize()
<p>(Optional)</p>

<p>This is called once the document has been output in its entirety, during the end_document event. end_document will in fact return whatever finalize() returns, and that in turn should be returned by parse() for whatever parser was invoked. It might be useful if you need to provide feedback of some sort.</p>
</li>
</ul>

<p>Here&#39;s an example of a custom consumer. Note the extra <code>$</code> signs in front of $self; the base class is optimized for the overwhelmingly common case where only one data member is required and $self is a reference to that data member.</p>

<pre>    package MyConsumer;

    @ISA = qw( XML::SAX::Writer::ConsumerInterface );

    use strict;

    sub new {
        my $self = shift-&#62;SUPER::new( my $output );

        $$self = &#39;&#39;;      # Note the extra &#39;$&#39;

        return $self;
    }

    sub output {
        my $self = shift;
        $$self .= uc shift;
    }

    sub get_output {
        my $self = shift;
        return $$self;
    }</pre>

<p>And here&#39;s one way to use it:</p>

<pre>    my $c = MyConsumer-&#62;new;
    my $w = XML::SAX::Writer-&#62;new( Output =&#62; $c );

    ## ... send events to $w ...

    print $c-&#62;get_output;</pre>

<p>If you need to store more that one data member, pass in an array or hash reference:</p>

<pre>        my $self = shift-&#62;SUPER::new( {} );</pre>

<p>and access it like:</p>

<pre>    sub output {
        my $self = shift;
        $$self-&#62;{Output} .= uc shift;
    }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="THE_ENCODER_INTERFACE"
>THE ENCODER INTERFACE</a></h1>

<p>Encoders can be plugged in to allow one to use one&#39;s favourite encoder object. Presently there are two encoders: Iconv and NullEncoder, and one based on <code>Encode</code> ought to be out soon. They need to implement two methods, and may inherit from XML::SAX::Writer::NullConverter if they wish to</p>

<dl>
<dt><a name="new_FROM_ENCODING,_TO_ENCODING"
>new FROM_ENCODING, TO_ENCODING</a></dt>

<dd>
<p>Creates a new Encoder. The arguments are the chosen encodings.</p>

<dt><a name="convert_STRING"
>convert STRING</a></dt>

<dd>
<p>Converts that string and returns it.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CUSTOM_OUTPUT"
>CUSTOM OUTPUT</a></h1>

<p>This module is generally used to write XML -- which it does most of the time -- but just like the rest of SAX it can be used as a generic framework to output data, the opposite of a non-XML SAX parser.</p>

<p>Of course there&#39;s only so much that one can abstract, so depending on your format this may or may not be useful. If it is, you&#39;ll need to know the followin API (and probably to have a look inside <code>XML::SAX::Writer::XML</code>, the default Writer).</p>

<dl>
<dt><a name="init"
>init</a></dt>

<dd>
<p>Called before the writing starts, it&#39;s a chance for the subclass to do some initialisation if it needs it.</p>

<dt><a name="setConverter"
>setConverter</a></dt>

<dd>
<p>This is used to set the proper converter for character encodings. The default implementation should suffice but you can override it. It must set <code>$self-</code>{Encoder}&#62; to an Encoder object. Subclasses *should* call it.</p>

<dt><a name="setConsumer"
>setConsumer</a></dt>

<dd>
<p>Same as above, except that it is for the Consumer object, and that it must set <code>$self-</code>{Consumer}&#62;.</p>

<dt><a name="setEscaperRegex"
>setEscaperRegex</a></dt>

<dd>
<p>Will initialise the escaping regex <code>$self-</code>{EscaperRegex}&#62; based on what is needed.</p>

<dt><a name="escape_STRING"
>escape STRING</a></dt>

<dd>
<p>Takes a string and escapes it properly.</p>

<dt><a name="setCommentEscaperRegex_and_escapeComment_STRING"
>setCommentEscaperRegex and escapeComment STRING</a></dt>

<dd>
<p>These work exactly the same as the two above, except that they are meant to operate on comment contents, which often have different escaping rules than those that apply to regular content.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TODO"
>TODO</a></h1>

<pre>    - proper UTF-16 handling

    - the formatting options need to be developed.

    - test, test, test (and then some tests)

    - doc, doc, doc (actually this part is in better shape)

    - remove the xml_decl and replace it with intelligent logic, as
    discussed on perl-xml

    - make a the Consumer selecting code available in the API, to avoid
    duplicating

    - add an Apache output Consumer, triggered by passing $r as Output</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CREDITS"
>CREDITS</a></h1>

<p>Michael Koehne (XML::Handler::YAWriter) for much inspiration and Barrie Slaymaker for the Consumer pattern idea, the coderef output option and miscellaneous bugfixes and performance tweaks. Of course the usual suspects (Kip Hampton and Matt Sergeant) helped in the usual ways.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Robin Berjon, robin@knowscape.com</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright (c) 2001-2006 Robin Berjon and Perl XML project. Some rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>XML::SAX::*</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="POD_ERRORS"
>POD ERRORS</a></h1>

<p>Hey! <b>The above document had some coding errors, which are explained below:</b></p>

<dl>
<dt><a name="Around_line_443:"
>Around line 443:</a></dt>

<dd>
<p>Expected &#39;=item *&#39;</p>

<dt><a name="Around_line_459:"
>Around line 459:</a></dt>

<dd>
<p>Expected &#39;=item *&#39;</p>

<dt><a name="Around_line_471:"
>Around line 471:</a></dt>

<dd>
<p>Expected &#39;=item *&#39;</p>

<dt><a name="Around_line_478:"
>Around line 478:</a></dt>

<dd>
<p>Expected &#39;=item *&#39;</p>

<dt><a name="Around_line_483:"
>Around line 483:</a></dt>

<dd>
<p>Expected &#39;=item *&#39;</p>

<dt><a name="Around_line_488:"
>Around line 488:</a></dt>

<dd>
<p>Expected &#39;=item *&#39;</p>
</dd>
</dl>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
