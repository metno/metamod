<html><head><title>XML::SAX::ParserFactory</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:29 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#LICENSE'>LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>XML::SAX::ParserFactory - Obtain a SAX parser</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use XML::SAX::ParserFactory;
  use XML::SAX::XYZHandler;
  my $handler = XML::SAX::XYZHandler-&#62;new();
  my $p = XML::SAX::ParserFactory-&#62;parser(Handler =&#62; $handler);
  $p-&#62;parse_uri(&#34;foo.xml&#34;);
  # or $p-&#62;parse_string(&#34;&#60;foo/&#62;&#34;) or $p-&#62;parse_file($fh);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>XML::SAX::ParserFactory is a factory class for providing an application with a Perl SAX2 XML parser. It is akin to DBI - a front end for other parser classes. Each new SAX2 parser installed will register itself with XML::SAX, and then it will become available to all applications that use XML::SAX::ParserFactory to obtain a SAX parser.</p>

<p>Unlike DBI however, XML/SAX parsers almost all work alike (especially if they subclass XML::SAX::Base, as they should), so rather than specifying the parser you want in the call to <code>parser()</code>, XML::SAX has several ways to automatically choose which parser to use:</p>

<ul>
<li>$XML::SAX::ParserPackage
<p>If this package variable is set, then this package is <code>require()</code>d and an instance of this package is returned by calling the <code>new()</code> class method in that package. If it cannot be loaded or there is an error, an exception will be thrown. The variable can also contain a version number:</p>

<pre>  $XML::SAX::ParserPackage = &#34;XML::SAX::Expat (0.72)&#34;;</pre>

<p>And the number will be treated as a minimum version number.</p>
</li>

<li>Required features
<p>It is possible to require features from the parsers. For example, you may wish for a parser that supports validation via a DTD. To do that, use the following code:</p>

<pre>  use XML::SAX::ParserFactory;
  my $factory = XML::SAX::ParserFactory-&#62;new();
  $factory-&#62;require_feature(&#39;http://xml.org/sax/features/validation&#39;);
  my $parser = $factory-&#62;parser(...);</pre>

<p>Alternatively, specify the required features in the call to the ParserFactory constructor:</p>

<pre>  my $factory = XML::SAX::ParserFactory-&#62;new(
          RequiredFeatures =&#62; {
               &#39;http://xml.org/sax/features/validation&#39; =&#62; 1,
               }
          );</pre>

<p>If the features you have asked for are unavailable (for example the user might not have a validating parser installed), then an exception will be thrown.</p>

<p>The list of known parsers is searched in reverse order, so it will always return the last installed parser that supports all of your requested features (Note: this is subject to change if someone comes up with a better way of making this work).</p>
</li>

<li>SAX.ini
<p>ParserFactory will search @INC for a file called SAX.ini, which is in a simple format:</p>

<pre>  # a comment looks like this,
  ; or like this, and are stripped anywhere in the file
  key = value # SAX.in contains key/value pairs.</pre>

<p>All whitespace is non-significant.</p>

<p>This file can contain either a line:</p>

<pre>  ParserPackage = MyParserModule (1.02)</pre>

<p>Where MyParserModule is the module to load and use for the parser, and the number in brackets is a minimum version to load.</p>

<p>Or you can list required features:</p>

<pre>  http://xml.org/sax/features/validation = 1</pre>

<p>And each feature with a true value will be required.</p>
</li>

<li>Fallback
<p>If none of the above works, the last parser installed on the user&#39;s system will be used. The XML::SAX package ships with a pure perl XML parser, XML::SAX::PurePerl, so that there will always be a fallback parser.</p>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Matt Sergeant, matt@sergeant.org</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENSE"
>LICENSE</a></h1>

<p>This is free software, you may use it and distribute it under the same terms as Perl itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
