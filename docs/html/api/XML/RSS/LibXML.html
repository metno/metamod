<html><head><title>XML::RSS::LibXML</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:29 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#VERSION_0.30'>VERSION 0.30</a>
  <li class='indexItem indexItem1'><a href='#COMPATIBILITY'>COMPATIBILITY</a>
  <li class='indexItem indexItem1'><a href='#PARSED_STRUCTURE'>PARSED STRUCTURE</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#new(%25args)'>new(%args)</a>
    <li class='indexItem indexItem2'><a href='#parse(%24string)'>parse($string)</a>
    <li class='indexItem indexItem2'><a href='#parsefile(%24filename)'>parsefile($filename)</a>
    <li class='indexItem indexItem2'><a href='#channel(%25args)'>channel(%args)</a>
    <li class='indexItem indexItem2'><a href='#add_item(%25args)'>add_item(%args)</a>
    <li class='indexItem indexItem2'><a href='#image(%25args)'>image(%args)</a>
    <li class='indexItem indexItem2'><a href='#textinput(%25args)'>textinput(%args)</a>
    <li class='indexItem indexItem2'><a href='#as_string(%24format)'>as_string($format)</a>
    <li class='indexItem indexItem2'><a href='#add_module(uri_%3D%3E_%24uri%2C_prefix_%3D%3E_%24prefix)'>add_module(uri =&#62; $uri, prefix =&#62; $prefix)</a>
    <li class='indexItem indexItem2'><a href='#save(%24file)'>save($file)</a>
    <li class='indexItem indexItem2'><a href='#items()'>items()</a>
    <li class='indexItem indexItem2'><a href='#create_libxml()'>create_libxml()</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#PERFORMANCE'>PERFORMANCE</a>
  <li class='indexItem indexItem1'><a href='#CAVEATS'>CAVEATS</a>
  <li class='indexItem indexItem1'><a href='#TODO'>TODO</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>XML::RSS::LibXML - XML::RSS with XML::LibXML</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use XML::RSS::LibXML;
  my $rss = XML::RSS::LibXML-&#62;new;
  $rss-&#62;parsefile($file);

  print &#34;channel: $rss-&#62;{channel}-&#62;{title}\n&#34;;
  foreach my $item (@{ $rss-&#62;{items} }) {
     print &#34;  item: $item-&#62;{title} ($item-&#62;{link})\n&#34;;
  }

  # Add custom modules
  $rss-&#62;add_module(uri =&#62; $uri, prefix =&#62; $prefix);

  # See docs for XML::RSS for these
  $rss-&#62;channel(...);
  $rss-&#62;add_item(...);
  $rss-&#62;image(...);
  $rss-&#62;textinput(...);
  $rss-&#62;save(...);

  $rss-&#62;as_string($format);

  # XML::RSS::LibXML only methods

  my $version     = $rss-&#62;version;
  my $base        = $rss-&#62;base;
  my $hash        = $rss-&#62;namespaces;
  my $list        = $rss-&#62;items;
  my $encoding    = $rss-&#62;encoding;
  my $modules     = $rss-&#62;modules;
  my $output      = $rss-&#62;output;
  my $stylesheets = $rss-&#62;stylesheets;
  my $num_items   = $rss-&#62;num_items;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>XML::RSS::LibXML uses XML::LibXML (libxml2) for parsing RSS instead of XML::RSS&#39; XML::Parser (expat), while trying to keep interface compatibility with XML::RSS.</p>

<p>XML::RSS is an extremely handy tool, but it is unfortunately not exactly the most lean or efficient RSS parser, especially in a long-running process. So for a long time I had been using my own version of RSS parser to get the maximum speed and efficiency - this is the re-packaged version of that module, such that it adheres to the XML::RSS interface.</p>

<p>Use this module when you have severe performance requirements working with RSS files.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION_0.30"
>VERSION 0.30</a></h1>

<p>The original XML::RSS has been evolving in fairly rapid manner lately, and that meant that there were a lot of features to keep up with. To keep compatibility, I&#39;ve had to pretty much rewrite the module from ground up.</p>

<p>Now XML::RSS::LibXML is *almost* compatible with XML::RSS. If there are problems, please send in bug reports (or more preferrably, patches ;)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COMPATIBILITY"
>COMPATIBILITY</a></h1>

<p>There seems to be a bit of confusion as to how compatible XML::RSS::LibXML is with XML::RSS: XML::RSS::LibXML is <b>NOT</b> 100% compatible with XML::RSS. For instance XML::RS::LibXML does not do a complete parsing of the XML document because of the way we deal with XPath and libxml&#39;s DOM (see CAVEATS below)</p>

<p>On top of that, I originally wrote XML::RSS::LibXML as sort of a fast replacement for XML::RAI, which looked cool in terms of abstracting the various modules. And therefore versions prior to 0.02 worked more like XML::RAI rather than XML::RSS. That was a mistake in hind sight, so it has been addressed (Since XML::RSS::LibXML version 0.08, it even supports writing RSS :)</p>

<p>From now on XML::RSS::LibXML will try to match XML::RSS&#39;s functionality as much as possible in terms of parsing RSS feeds. Please send in patches and any tests that may be useful!</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PARSED_STRUCTURE"
>PARSED STRUCTURE</a></h1>

<p>Once parsed the resulting data structure resembles that of XML::RSS. However, as one addition/improvement, XML::RSS::LibXML uses a technique to allow users to access complex data structures that XML::RSS doesn&#39;t support as of this writing.</p>

<p>For example, suppose you have a tag like the following:</p>

<pre>  &#60;rss version=&#34;2.0&#34; xml:base=&#34;http://example.com/&#34;&#62;
  ...
    &#60;channel&#62;
      &#60;tag attr1=&#34;val1&#34; attr2=&#34;val3&#34;&#62;foo bar baz&#60;/tag&#62;
    &#60;/channel&#62;
  &#60;/rss&#62;</pre>

<p>All of the fields in this construct can be accessed like so:</p>

<pre>  $rss-&#62;channel-&#62;{tag}        # &#34;foo bar baz&#34;
  $rss-&#62;channel-&#62;{tag}{attr1} # &#34;val1&#34;
  $rss-&#62;channel-&#62;{tag}{attr2} # &#34;val2&#34;</pre>

<p>See <a href="../../XML/RSS/LibXML/MagicElement.html" class="podlinkpod"
>XML::RSS::LibXML::MagicElement</a> for details.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="new(%args)"
>new(%args)</a></h2>

<p>Creates a new instance of XML::RSS::LibXML. You may specify a version or an XML base in the constructor args to control which output format as_string() will use.</p>

<pre>  XML::RSS::LibXML-&#62;new(version =&#62; &#39;1.0&#39;, base =&#62; &#39;http://example.com/&#39;);</pre>

<p>The XML base will be included only in RSS 2.0 output. You can also specify the encoding that you expect this RSS object to use when creating an RSS string</p>

<pre>  XML::RSS::LiBXML-&#62;new(encoding =&#62; &#39;euc-jp&#39;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="parse($string)"
>parse($string)</a></h2>

<p>Parse a string containing RSS.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="parsefile($filename)"
>parsefile($filename)</a></h2>

<p>Parse an RSS file specified by $filename</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="channel(%args)"
>channel(%args)</a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="add_item(%args)"
>add_item(%args)</a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="image(%args)"
>image(%args)</a></h2>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="textinput(%args)"
>textinput(%args)</a></h2>

<p>These methods are used to generate RSS. See the documentation for XML::RSS for details. Currently RSS version 0.9, 1.0, and 2.0 are supported.</p>

<p>Additionally, add_item takes an extra parameter, &#34;mode&#34;, which allows you to add items either in front of the list or at the end of the list:</p>

<pre>   $rss-&#62;add_item(
      mode =&#62; &#34;append&#34;,
      title =&#62; &#34;...&#34;,
      link  =&#62; &#34;...&#34;,
   );

   $rss-&#62;add_item(
      mode =&#62; &#34;insert&#34;,
      title =&#62; &#34;...&#34;,
      link  =&#62; &#34;...&#34;,
   );</pre>

<p>By default, items are appended to the end of the list</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="as_string($format)"
>as_string($format)</a></h2>

<p>Return the string representation of the parsed RSS. If $format is true, this flag is passed to the underlying XML::LibXML object&#39;s toString() method.</p>

<p>By default, $format is true.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="add_module(uri_=&#62;_$uri,_prefix_=&#62;_$prefix)"
>add_module(uri =&#62; $uri, prefix =&#62; $prefix)</a></h2>

<p>Adds a new module. You should do this before parsing the RSS. XML::RSS::LibXML understands a few modules by default:</p>

<pre>    rdf     =&#62; &#34;http://www.w3.org/1999/02/22-rdf-syntax-ns#&#34;,
    dc      =&#62; &#34;http://purl.org/dc/elements/1.1/&#34;,
    syn     =&#62; &#34;http://purl.org/rss/1.0/modules/syndication/&#34;,
    admin   =&#62; &#34;http://webns.net/mvcb/&#34;,
    content =&#62; &#34;http://purl.org/rss/1.0/modules/content/&#34;,
    cc      =&#62; &#34;http://web.resource.org/cc/&#34;,
    taxo    =&#62; &#34;http://purl.org/rss/1.0/modules/taxonomy/&#34;,</pre>

<p>So you do not need to add these explicitly.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="save($file)"
>save($file)</a></h2>

<p>Saves the RSS to a file</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="items()"
>items()</a></h2>

<p>Syntactic sugar to allow statement like this:</p>

<pre>  foreach my $item ($rss-&#62;items) {
    ...
  }</pre>

<p>Instead of</p>

<pre>  foreach my $item (@{$rss-&#62;{items}}) {
    ...
  }</pre>

<p>In scalar context, returns the reference to the list of items.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="create_libxml()"
>create_libxml()</a></h2>

<p>Creates, configures, and returns an XML::LibXML object. Used by <code>parse()</code> to instantiate the parser used to parse the feed.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PERFORMANCE"
>PERFORMANCE</a></h1>

<p>Here&#39;s a simple benchmark using benchmark.pl in this distribution, using XML::RSS 1.29_02 and XML::RSS::LibXML 0.30</p>

<pre>  daisuke@beefcake XML-RSS-LibXML$ perl -Mblib tools/benchmark.pl t/data/rss20.xml 
  XML::RSS -&#62; 1.29_02
  XML::RSS::LibXML -&#62; 0.30
               Rate        rss rss_libxml
  rss        25.6/s         --       -67%
  rss_libxml 78.1/s       205%         --</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CAVEATS"
>CAVEATS</a></h1>

<p>- Only first level data under &#60;channel&#62; and &#60;item&#62; tags are examined. So if you have complex data, this module will not pick it up. For most of the cases, this will suffice, though.</p>

<p>- Namespace for namespaced attributes aren&#39;t properly parsed as part of the structure. Hopefully your RSS doesn&#39;t do something like this:</p>

<pre>  &#60;foo bar:baz=&#34;whee&#34;&#62;</pre>

<p>You won&#39;t be able to get at &#34;bar&#34; in this case:</p>

<pre>  $xml-&#62;{foo}{baz}; # &#34;whee&#34;
  $xml-&#62;{foo}{bar}{baz}; # nope</pre>

<p>- Some of the structures will need to be handled via XML::RSS::LibXML::MagicElement. For example, XML::RSS&#39;s SYNOPSIS shows a snippet like this:</p>

<pre>  $rss-&#62;add_item(title =&#62; &#34;GTKeyboard 0.85&#34;,
     # creates a guid field with permaLink=true
     permaLink  =&#62; &#34;http://freshmeat.net/news/1999/06/21/930003829.html&#34;,
     # alternately creates a guid field with permaLink=false
     # guid     =&#62; &#34;gtkeyboard-0.85
     enclosure   =&#62; { url=&#62; &#39;http://example.com/torrent&#39;, type=&#62;&#34;application/x-bittorrent&#34; },
     description =&#62; &#39;blah blah&#39;
  );</pre>

<p>However, the enclosure element will need to be an object:</p>

<pre>  enclosure =&#62; XML::RSS::LibXML::MagicElement-&#62;new(
    attributes =&#62; {
       url =&#62; &#39;http://example.com/torrent&#39;, 
       type=&#62;&#34;application/x-bittorrent&#34; 
    },
  );</pre>

<p>- Some elements such as permaLink elements are not really parsed such that it can be serialized and parsed back and force. I could fix this, but that would break some compatibility with XML::RSS</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TODO"
>TODO</a></h1>

<p>Tests. Currently tests are simply stolen from XML::RSS. It would be nice to have tests that do more extensive testing for correctness</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../../XML/RSS.html" class="podlinkpod"
>XML::RSS</a>, <a href="../../XML/LibXML.html" class="podlinkpod"
>XML::LibXML</a>, <a href="../../XML/LibXML/XPathContext.html" class="podlinkpod"
>XML::LibXML::XPathContext</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>Copyright (c) 2005-2007 Daisuke Maki &#60;dmaki@cpan.org&#62;, Tatsuhiko Miyagawa &#60;miyagawa@bulknews.net&#62;. All rights reserved.</p>

<p>Many tests were shamelessly borrowed from XML::RSS 1.29_02</p>

<p>Development partially funded by Brazil, Ltd. &#60;http://b.razil.jp&#62;</p>

<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
