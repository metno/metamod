<html><head><title>XML::LibXSLT</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:29 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#OPTIONS'>OPTIONS</a>
  <li class='indexItem indexItem1'><a href='#API'>API</a>
  <li class='indexItem indexItem1'><a href='#Input_Callbacks'>Input Callbacks</a>
  <li class='indexItem indexItem1'><a href='#Security_Callbacks'>Security Callbacks</a>
  <li class='indexItem indexItem1'><a href='#XML%3A%3ALibXSLT%3A%3AStylesheet'>XML::LibXSLT::Stylesheet</a>
  <li class='indexItem indexItem1'><a href='#Parameters'>Parameters</a>
  <li class='indexItem indexItem1'><a href='#XML%3A%3ALibXSLT%3A%3ASecurity'>XML::LibXSLT::Security</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Using_XML%3A%3ALibXSLT%3A%3ASecurity'>Using XML::LibXSLT::Security</a>
    <li class='indexItem indexItem2'><a href='#Interface'>Interface</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#BENCHMARK'>BENCHMARK</a>
  <li class='indexItem indexItem1'><a href='#LIBRARY_VERSIONS'>LIBRARY VERSIONS</a>
  <li class='indexItem indexItem1'><a href='#LICENSE'>LICENSE</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#MAINTAINER'>MAINTAINER</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>XML::LibXSLT - Interface to the GNOME libxslt library</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use XML::LibXSLT;
  use XML::LibXML;

  my $xslt = XML::LibXSLT-&#62;new();

  my $source = XML::LibXML-&#62;load_xml(location =&#62; &#39;foo.xml&#39;);
  my $style_doc = XML::LibXML-&#62;load_xml(location=&#62;&#39;bar.xsl&#39;, no_cdata=&#62;1);

  my $stylesheet = $xslt-&#62;parse_stylesheet($style_doc);

  my $results = $stylesheet-&#62;transform($source);

  print $stylesheet-&#62;output_as_bytes($results);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This module is an interface to the GNOME project&#39;s libxslt. This is an extremely good XSLT engine, highly compliant and also very fast. I have tests showing this to be more than twice as fast as Sablotron.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="OPTIONS"
>OPTIONS</a></h1>

<p>XML::LibXSLT has some global options. Note that these are probably not thread or even fork safe - so only set them once per process. Each one of these options can be called either as class methods, or as instance methods. However either way you call them, it still sets global options.</p>

<p>Each of the option methods returns its previous value, and can be called without a parameter to retrieve the current value.</p>

<dl>
<dt><a name="max_depth"
>max_depth</a></dt>

<dd>
<pre>  XML::LibXSLT-&#62;max_depth(1000);</pre>

<p>This option sets the maximum recursion depth for a stylesheet. See the very end of section 5.4 of the XSLT specification for more details on recursion and detecting it. If your stylesheet or XML file requires seriously deep recursion, this is the way to set it. Default value is 250.</p>

<dt><a name="debug_callback"
>debug_callback</a></dt>

<dd>
<pre>  XML::LibXSLT-&#62;debug_callback($subref);</pre>

<p>Sets a callback to be used for debug messages. If you don&#39;t set this, debug messages will be ignored.</p>

<dt><a name="register_function"
>register_function</a></dt>

<dd>
<pre>  XML::LibXSLT-&#62;register_function($uri, $name, $subref);
  $stylesheet-&#62;register_function($uri, $name, $subref);</pre>

<p>Registers an XSLT extension function mapped to the given URI. For example:</p>

<pre>  XML::LibXSLT-&#62;register_function(&#34;urn:foo&#34;, &#34;bar&#34;,
    sub { scalar localtime });</pre>

<p>Will register a <code>bar</code> function in the <code>urn:foo</code> namespace (which you have to define in your XSLT using <code>xmlns:...</code>) that will return the current date and time as a string:</p>

<pre>  &#60;xsl:stylesheet version=&#34;1.0&#34;
    xmlns:xsl=&#34;http://www.w3.org/1999/XSL/Transform&#34;
    xmlns:foo=&#34;urn:foo&#34;&#62;
  &#60;xsl:template match=&#34;/&#34;&#62;
    The time is: &#60;xsl:value-of select=&#34;foo:bar()&#34;/&#62;
  &#60;/xsl:template&#62;
  &#60;/xsl:stylesheet&#62;</pre>

<p>Parameters can be in whatever format you like. If you pass in a nodelist it will be a XML::LibXML::NodeList object in your perl code, but ordinary values (strings, numbers and booleans) will be ordinary perl scalars. If you wish them to be <code>XML::LibXML::Literal</code>, <code>XML::LibXML::Number</code> and <code>XML::LibXML::Number</code> values respectively then set the variable <code>$XML::LibXSLT::USE_LIBXML_DATA_TYPES</code> to a true value. Return values can be a nodelist or a plain value - the code will just do the right thing. But only a single return value is supported (a list is not converted to a nodelist).</p>

<dt><a name="register_element"
>register_element</a></dt>

<dd>
<pre>        $stylesheet-&#62;register_element($uri, $name, $subref)</pre>

<p>Registers an XSLT extension element $name mapped to the given URI. For example:</p>

<pre>  $stylesheet-&#62;register_element(&#34;urn:foo&#34;, &#34;hello&#34;, sub {
          my $name = $_[2]-&#62;getAttribute( &#34;name&#34; );
          return XML::LibXML::Text-&#62;new( &#34;Hello, $name!&#34; );
  });</pre>

<p>Will register a <code>hello</code> element in the <code>urn:foo</code> namespace that returns a &#34;Hello, X!&#34; text node. You must define this namespace in your XSLT and include its prefix in the <code>extension-element-prefixes</code> list:</p>

<pre>  &#60;xsl:stylesheet version=&#34;1.0&#34;
    xmlns:xsl=&#34;http://www.w3.org/1999/XSL/Transform&#34;
    xmlns:foo=&#34;urn:foo&#34;
        extension-element-prefixes=&#34;foo&#34;&#62;
  &#60;xsl:template match=&#34;/&#34;&#62;
    &#60;foo:hello name=&#34;bob&#34;/&#62;
  &#60;/xsl:template&#62;
  &#60;/xsl:stylesheet&#62;</pre>

<p>The callback is passed the input document node as $_[1] and the stylesheet node as $_[2]. $_[0] is reserved for future use.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="API"
>API</a></h1>

<p>The following methods are available on the new XML::LibXSLT object:</p>

<dl>
<dt><a name="parse_stylesheet($stylesheet_doc)"
>parse_stylesheet($stylesheet_doc)</a></dt>

<dd>
<p><code>$stylesheet_doc</code> here is an XML::LibXML::Document object (see <a href="../XML/LibXML.html" class="podlinkpod"
>XML::LibXML</a>) representing an XSLT file. This method will return a XML::LibXSLT::Stylesheet object, or undef on failure. If the XSLT is invalid, an exception will be thrown, so wrap the call to parse_stylesheet in an eval{} block to trap this.</p>

<p>IMPORTANT: <code>$stylesheet_doc</code> should not contain CDATA sections, otherwise libxslt may misbehave. The best way to assure this is to load the stylesheet with no_cdata flag, e.g.</p>

<pre>  my $stylesheet_doc = XML::LibXML-&#62;load_xml(location=&#62;&#34;some.xsl&#34;, no_cdata=&#62;1);</pre>

<dt><a name="parse_stylesheet_file($filename)"
>parse_stylesheet_file($filename)</a></dt>

<dd>
<p>Exactly the same as the above, but parses the given filename directly.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Input_Callbacks"
>Input Callbacks</a></h1>

<p>To define XML::LibXSLT or XML::LibXSLT::Stylesheet specific input callbacks, reuse the XML::LibXML input callback API as described in <a href="../XML/LibXML/InputCallback(3).html" class="podlinkpod"
>XML::LibXML::InputCallback(3)</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Security_Callbacks"
>Security Callbacks</a></h1>

<p>To create security preferences for the transformation see <a href="../XML/LibXSLT/Security.html" class="podlinkpod"
>XML::LibXSLT::Security</a>. Once the security preferences have been defined you can apply them to an XML::LibXSLT or XML::LibXSLT::Stylesheet instance using the <code>security_callbacks()</code> method.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="XML::LibXSLT::Stylesheet"
>XML::LibXSLT::Stylesheet</a></h1>

<p>The main API is on the stylesheet, though it is fairly minimal.</p>

<p>One of the main advantages of XML::LibXSLT is that you have a generic stylesheet object which you call the transform() method passing in a document to transform. This allows you to have multiple transformations happen with one stylesheet without requiring a reparse.</p>

<dl>
<dt><a name="transform(doc,_%params)"
>transform(doc, %params)</a></dt>

<dd>
<pre>  my $results = $stylesheet-&#62;transform($doc, foo =&#62; &#34;&#39;bar&#39;&#34;);
  print $stylesheet-&#62;output_as_bytes($results);</pre>

<p>Transforms the passed in XML::LibXML::Document object, and returns a new XML::LibXML::Document. Extra hash entries are used as parameters. Be sure to keep in mind the caveat with regard to quotes explained in the section on <a href="#Parameters" class="podlinkpod"
>&#34;Parameters&#34;</a> below.</p>

<dt><a name="transform_file(filename,_%params)"
>transform_file(filename, %params)</a></dt>

<dd>
<pre>  my $results = $stylesheet-&#62;transform_file($filename, bar =&#62; &#34;&#39;baz&#39;&#34;);</pre>

<p>Note the string parameter caveat, detailed in the section on <a href="#Parameters" class="podlinkpod"
>&#34;Parameters&#34;</a> below.</p>

<dt><a name="output_as_bytes(result)"
>output_as_bytes(result)</a></dt>

<dd>
<p>Returns a scalar that is the XSLT rendering of the XML::LibXML::Document object using the desired output format (specified in the xsl:output tag in the stylesheet). Note that you can also call $result-&#62;toString, but that will *always* output the document in XML format which may not be what you asked for in the xsl:output tag. The scalar is a byte string encoded in the output encoding specified in the stylesheet.</p>

<dt><a name="output_as_chars(result)"
>output_as_chars(result)</a></dt>

<dd>
<p>Like <code>output_as_bytes(result)</code>, but always return the output as (UTF-8 encoded) string of characters.</p>

<dt><a name="output_string(result)"
>output_string(result)</a></dt>

<dd>
<p>DEPRECATED: This method is something between <code>output_as_bytes(result)</code> and <code>output_as_bytes(result)</code>: The scalar returned by this function appears to Perl as characters (UTF8 flag is on) if the output encoding specified in the XSLT stylesheet was UTF-8 and as bytes if no output encoding was specified or if the output encoding was other than UTF-8. Since the behavior of this function depends on the particular stylesheet, it is deprecated in favor of <code>output_as_bytes(result)</code> and <code>output_as_chars(result)</code>.</p>

<dt><a name="output_fh(result,_fh)"
>output_fh(result, fh)</a></dt>

<dd>
<p>Outputs the result to the filehandle given in <code>$fh</code>.</p>

<dt><a name="output_file(result,_filename)"
>output_file(result, filename)</a></dt>

<dd>
<p>Outputs the result to the file named in <code>$filename</code>.</p>

<dt><a name="output_encoding()"
>output_encoding()</a></dt>

<dd>
<p>Returns the output encoding of the results. Defaults to &#34;UTF-8&#34;.</p>

<dt><a name="output_method()"
>output_method()</a></dt>

<dd>
<p>Returns the value of the <code>method</code> attribute from <code>xsl:output</code> (usually <code>xml</code>, <code>html</code> or <code>text</code>). If this attribute is unspecified, the default value is initially <code>xml</code>. If the <a href="../transform.html" class="podlinkpod"
>transform</a> method is used to produce an HTML document, as per the <a href="http://www.w3.org/TR/xslt#output" class="podlinkurl"
>XSLT spec</a>, the default value will change to <code>html</code>. To override this behavior completely, supply an <code>xsl:output</code> element in the stylesheet source document.</p>

<dt><a name="media_type()"
>media_type()</a></dt>

<dd>
<p>Returns the value of the <code>media-type</code> attribute from <code>xsl:output</code>. If this attribute is unspecified, the default media type is initially <code>text/xml</code>. This default changes to <code>text/html</code> under the same conditions as <a href="../output_method.html" class="podlinkpod"
>output_method</a>.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Parameters"
>Parameters</a></h1>

<p>LibXSLT expects parameters in XPath format. That is, if you wish to pass a string to the XSLT engine, you actually have to pass it as a quoted string:</p>

<pre>  $stylesheet-&#62;transform($doc, param =&#62; &#34;&#39;string&#39;&#34;);</pre>

<p>Note the quotes within quotes there!</p>

<p>Obviously this isn&#39;t much fun, so you can make it easy on yourself:</p>

<pre>  $stylesheet-&#62;transform($doc, XML::LibXSLT::xpath_to_string(
        param =&#62; &#34;string&#34;
        ));</pre>

<p>The utility function does the right thing with respect to strings in XPath, including when you have quotes already embedded within your string.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="XML::LibXSLT::Security"
>XML::LibXSLT::Security</a></h1>

<p>Provides an interface to the libxslt security framework by allowing callbacks to be defined that can restrict access to various resources (files or URLs) during a transformation.</p>

<p>The libxslt security framework allows callbacks to be defined for certain actions that a stylesheet may attempt during a transformation. It may be desirable to restrict some of these actions (for example, writing a new file using exsl:document). The actions that may be restricted are:</p>

<dl>
<dt><a name="read_file"
>read_file</a></dt>

<dd>
<p>Called when the stylesheet attempts to open a local file (ie: when using the document() function).</p>

<dt><a name="write_file"
>write_file</a></dt>

<dd>
<p>Called when an attempt is made to write a local file (ie: when using the exsl:document element).</p>

<dt><a name="create_dir"
>create_dir</a></dt>

<dd>
<p>Called when a directory needs to be created in order to write a file.</p>

<p>NOTE: By default, create_dir is not allowed. To enable it a callback must be registered.</p>

<dt><a name="read_net"
>read_net</a></dt>

<dd>
<p>Called when the stylesheet attempts to read from the network.</p>

<dt><a name="write_net"
>write_net</a></dt>

<dd>
<p>Called when the stylesheet attempts to write to the network.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Using_XML::LibXSLT::Security"
>Using XML::LibXSLT::Security</a></h2>

<p>The interface for this module is similar to XML::LibXML::InputCallback. After creating a new instance you may register callbacks for each of the security options listed above. Then you apply the security preferences to the XML::LibXSLT or XML::LibXSLT::Stylesheet object using <code>security_callbacks()</code>.</p>

<pre>  my $security = XML::LibXSLT::Security-&#62;new();
  $security-&#62;register_callback( read_file  =&#62; $read_cb );
  $security-&#62;register_callback( write_file =&#62; $write_cb );
  $security-&#62;register_callback( create_dir =&#62; $create_cb );
  $security-&#62;register_callback( read_net   =&#62; $read_net_cb );
  $security-&#62;register_callback( write_net  =&#62; $write_net_cb );

  $xslt-&#62;security_callbacks( $security );
   -OR-
  $stylesheet-&#62;security_callbacks( $security );</pre>

<p>The registered callback functions are called when access to a resource is requested. If the access should be allowed the callback should return 1, if not it should return 0. The callback functions should accept the following arguments:</p>

<dl>
<dt><a name="$tctxt"
>$tctxt</a></dt>

<dd>
<p>This is the transform context (XML::LibXSLT::TransformContext). You can use this to get the current XML::LibXSLT::Stylesheet object by calling <code>stylesheet()</code>.</p>

<pre>  my $stylesheet = $tctxt-&#62;stylesheet();</pre>

<p>The stylesheet object can then be used to share contextual information between different calls to the security callbacks.</p>

<dt><a name="$value"
>$value</a></dt>

<dd>
<p>This is the name of the resource (file or URI) that has been requested.</p>
</dd>
</dl>

<p>If a particular option (except for <code>create_dir</code>) doesn&#39;t have a registered callback, then the stylesheet will have full access for that action.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Interface"
>Interface</a></h2>

<dl>
<dt><a name="new()"
>new()</a></dt>

<dd>
<p>Creates a new XML::LibXSLT::Security object.</p>

<dt><a name="register_callback(_$option,_$callback_)"
>register_callback( $option, $callback )</a></dt>

<dd>
<p>Registers a callback function for the given security option (listed above).</p>

<dt><a name="unregister_callback(_$option_)"
>unregister_callback( $option )</a></dt>

<dd>
<p>Removes the callback for the given option. This has the effect of allowing all access for the given option (except for <code>create_dir</code>).</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BENCHMARK"
>BENCHMARK</a></h1>

<p>Included in the distribution is a simple benchmark script, which has two drivers - one for LibXSLT and one for Sablotron. The benchmark requires the testcases files from the XSLTMark distribution which you can find at http://www.datapower.com/XSLTMark/</p>

<p>Put the testcases directory in the directory created by this distribution, and then run:</p>

<pre>  perl benchmark.pl -h</pre>

<p>to get a list of options.</p>

<p>The benchmark requires XML::XPath at the moment, but I hope to factor that out of the equation fairly soon. It also requires Time::HiRes, which I could be persuaded to factor out, replacing it with Benchmark.pm, but I haven&#39;t done so yet.</p>

<p>I would love to get drivers for XML::XSLT and XML::Transformiix, if you would like to contribute them. Also if you get this running on Win32, I&#39;d love to get a driver for MSXSLT via OLE, to see what we can do against those Redmond boys!</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LIBRARY_VERSIONS"
>LIBRARY VERSIONS</a></h1>

<p>For debugging purposes, XML::LibXSLT provides version information about the libxslt C library (but do not confuse it with the version number of XML::LibXSLT module itself, i.e. with <code>$XML::LibXSLT::VERSION</code>). XML::LibXSLT issues a warning if the runtime version of the library is less then the compile-time version.</p>

<dl>
<dt><a name="XML::LibXSLT::LIBXSLT_VERSION()"
>XML::LibXSLT::LIBXSLT_VERSION()</a></dt>

<dd>
<p>Returns version number of libxslt library which was used to compile XML::LibXSLT as an integer. For example, for libxslt-1.1.18, it will return 10118.</p>

<dt><a name="XML::LibXSLT::LIBXSLT_DOTTED_VERSION()"
>XML::LibXSLT::LIBXSLT_DOTTED_VERSION()</a></dt>

<dd>
<p>Returns version number of libxslt library which was used to compile XML::LibXSLT as a string, e.g. &#34;1.1.18&#34;.</p>

<dt><a name="XML::LibXSLT::LIBXSLT_RUNTIME_VERSION()"
>XML::LibXSLT::LIBXSLT_RUNTIME_VERSION()</a></dt>

<dd>
<p>Returns version number of libxslt library to which XML::LibXSLT is linked at runtime (either dynamically or statically). For example, for example, for libxslt.so.1.1.18, it will return 10118.</p>

<dt><a name="XML::LibXSLT::HAVE_EXLT()"
>XML::LibXSLT::HAVE_EXLT()</a></dt>

<dd>
<p>Returns 1 if the module was compiled with libexslt, 0 otherwised.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENSE"
>LICENSE</a></h1>

<p>This is free software, you may use it and distribute it under the same terms as Perl itself.</p>

<p>Copyright 2001-2009, AxKit.com Ltd.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Matt Sergeant, matt@sergeant.org</p>

<p>Security callbacks implementation contributed by Shane Corgatelli.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="MAINTAINER"
>MAINTAINER</a></h1>

<p>Petr Pajas , pajas@matfyz.org</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>Please report bugs via</p>

<pre>  http://rt.cpan.org/NoAuth/Bugs.html?Dist=XML-LibXSLT</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>XML::LibXML</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
