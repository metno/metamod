<html><head><title>HTTP::Parser::XS</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:18 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#FUNCTIONS'>FUNCTIONS</a>
  <li class='indexItem indexItem1'><a href='#LIMITATIONS'>LIMITATIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#The_number_of_headers'>The number of headers</a>
    <li class='indexItem indexItem2'><a href='#The_size_of_header_names'>The size of header names</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#THANKS_TO'>THANKS TO</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#LICENSE'>LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>HTTP::Parser::XS - a fast,
primitive HTTP request parser</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use HTTP::Parser::XS qw(parse_http_request);

  # for HTTP servers
  my $ret = parse_http_request(
      &#34;GET / HTTP/1.0\r\nHost: ...\r\n\r\n&#34;,
      \%env,
  );
  if ($ret == -2) {
      # request is incomplete
      ...
  } elsif ($ret == -1) {
      # request is broken
      ...
  } else {
      # $ret includes the size of the request, %env now contains a PSGI
      # request, if it is a POST / PUT request, read request content by
      # yourself
      ...
  }


  # for HTTP clients
  use HTTP::Parser::XS qw(parse_http_response HEADERS_AS_ARRAYREF);
  my %special_headers = (
    &#39;content-length&#39; =&#62; undef,
  );
  my($ret, $minor_version, $status, $message, $headers)
    = parse_http_response($response, HEADERS_AS_ARRAYREF, \%special_headers);

  if($ret == -1) }
    # response is incomplete
  }
  elsif($ret == -2) {
    # response is broken
  }
  else {
    # $ret is the length of the headers, starting the content body

    # the other values are the response messages. For example:
    # $status  = 200
    # $message = &#34;OK&#34;
    # $headers = [ &#39;content-type&#39; =&#62; &#39;text/html&#39;, ... ]

    # and $special_headers{&#39;content-length&#39;} will be filled in
  }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>HTTP::Parser::XS is a fast, primitive HTTP request/response parser.</p>

<p>The request parser can be used either for writing a synchronous HTTP server or a event-driven server.</p>

<p>The response parser can be used for writing HTTP clients.</p>

<p>Note that even if this distribution name ends <code>::XS</code>, <b>pure Perl</b> implementation is supported, so you can use this module on compiler-less environments.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FUNCTIONS"
>FUNCTIONS</a></h1>

<dl>
<dt><a name="parse_http_request($request_string,_\%env)"
>parse_http_request($request_string, \%env)</a></dt>

<dd>
<p>Tries to parse given request string, and if successful, inserts variables into %env. For the name of the variables inserted, please refer to the PSGI specification. The return values are:</p>

<dl>
<dt><a name="&#62;=0"
>&#62;=0</a></dt>

<dd>
<p>length of the request (request line and the request headers), in bytes</p>

<dt><a name="-1"
>-1</a></dt>

<dd>
<p>given request is corrupt</p>

<dt><a name="-2"
>-2</a></dt>

<dd>
<p>given request is incomplete</p>
</dd>
</dl>

<dt><a name="parse_http_response($response_string,_$header_format,_\%special_headers)"
>parse_http_response($response_string, $header_format, \%special_headers)</a></dt>

<dd>
<p>Tries to parse given response string. <i>$header_format</i> must be <code>HEADERS_AS_ARRAYREF</code>, <code>HEADERS_AS_HASHREF</code>, or <code>HEADERS_NONE</code>, which are exportable constants.</p>

<p>The optional <i>%special_headers</i> is for headers you specifically require. You can set any HTTP response header names, which must be lower-cased, and their default values, and then the values are filled in by <code>parse_http_response()</code>. For example, if you want the <code>Cointent-Length</code> field, set its name with default values like <code>%h = (&#39;content-length&#39; =&#62; undef)</code> and pass it as <i>%special_headers</i>. After parsing, <code>$h{&#39;content-length&#39;}</code> is set if the response has the <code>Content-Length</code> field, otherwise it&#39;s not touched.</p>

<p>The return values are:</p>

<dl>
<dt><a name="$ret"
><code>$ret</code></a></dt>

<dd>
<p>The parsering status, which is the same as <code>parse_http_response()</code>. i.e. the length of the response headers in bytes, <code>-1</code> for incomplete headers, or <code>-2</code> for errors.</p>

<p>If the given response string is broken or imcomplete, <code>parse_http_response()</code> returns only this value.</p>

<dt><a name="$minor_version"
><code>$minor_version</code></a></dt>

<dd>
<p>The minor version of the given response. i.e. <code>1</code> for HTTP/1.1, <code>0</code> for HTTP/1.0.</p>

<dt><a name="$status"
><code>$status</code></a></dt>

<dd>
<p>The HTTP status of the given response. e.g. <code>200</code> for success.</p>

<dt><a name="$message"
><code>$message</code></a></dt>

<dd>
<p>The HTTP status message. e.g. <code>OK</code> for success.</p>

<dt><a name="$headers"
><code>$headers</code></a></dt>

<dd>
<p>The HTTP headers for the given response. It is an ARRAY reference if <i>$header_format</i> is <code>HEADERS_AS_ARRAYREF</code>, a HASH reference on <code>HEADERS_AS_HASHREF</code>, an <code>undef</code> on <code>HEADERS_NONE</code>.</p>

<p>The names of the headers are normalized to lower-cased.</p>
</dd>
</dl>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LIMITATIONS"
>LIMITATIONS</a></h1>

<p>Both <code>parse_http_request()</code> and <code>parse_http_response()</code> in XS implementation have some size limitations.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_number_of_headers"
>The number of headers</a></h2>

<p>The number of headers is limited to <code>128</code>. If it exceeds, both parsing routines report parsing errors, i.e. return <code>-1</code> for <code>$ret</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_size_of_header_names"
>The size of header names</a></h2>

<p>The size of header names is limited to <code>1024</code>, but the parsers do not the same action.</p>

<p><code>parse_http_request()</code> returns <code>-1</code> if too-long header names exist.</p>

<p><code>parse_http_request()</code> simply ignores too-long header names.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright 2009- Kazuho Oku</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Kazuho Oku gfx mala tokuhirom</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="THANKS_TO"
>THANKS TO</a></h1>

<p>nothingmuch charsbar</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="http://github.com/kazuho/picohttpparser" class="podlinkurl"
>http://github.com/kazuho/picohttpparser</a></p>

<p><a href="../../HTTP/Parser.html" class="podlinkpod"
>HTTP::Parser</a> <a href="../../HTTP/HeaderParser/XS.html" class="podlinkpod"
>HTTP::HeaderParser::XS</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENSE"
>LICENSE</a></h1>

<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
