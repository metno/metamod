<html><head><title>HTTP::Server::Simple</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:18 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#EXAMPLE'>EXAMPLE</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#HTTP%3A%3AServer%3A%3ASimple-%3Enew(%24port)'>HTTP::Server::Simple-&#62;new($port)</a>
    <li class='indexItem indexItem2'><a href='#lookup_localhost'>lookup_localhost</a>
    <li class='indexItem indexItem2'><a href='#port_%5BNUMBER%5D'>port [NUMBER]</a>
    <li class='indexItem indexItem2'><a href='#host_%5Baddress%5D'>host [address]</a>
    <li class='indexItem indexItem2'><a href='#background_%5BARGUMENTS%5D'>background [ARGUMENTS]</a>
    <li class='indexItem indexItem2'><a href='#run_%5BARGUMENTS%5D'>run [ARGUMENTS]</a>
    <li class='indexItem indexItem2'><a href='#net_server'>net_server</a>
    <li class='indexItem indexItem2'><a href='#restart'>restart</a>
    <li class='indexItem indexItem2'><a href='#stdio_handle_%5BFILEHANDLE%5D'>stdio_handle [FILEHANDLE]</a>
    <li class='indexItem indexItem2'><a href='#stdin_handle'>stdin_handle</a>
    <li class='indexItem indexItem2'><a href='#stdout_handle'>stdout_handle</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#IMPORTANT_SUB-CLASS_METHODS'>IMPORTANT SUB-CLASS METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#handler'>handler</a>
    <li class='indexItem indexItem2'><a href='#setup(name_%3D%3E_%24value%2C_...)'>setup(name =&#62; $value, ...)</a>
    <li class='indexItem indexItem2'><a href='#headers(%5BHeader_%3D%3E_%24value%2C_...%5D)'>headers([Header =&#62; $value, ...])</a>
    <li class='indexItem indexItem2'><a href='#accept_hook'>accept_hook</a>
    <li class='indexItem indexItem2'><a href='#post_setup_hook'>post_setup_hook</a>
    <li class='indexItem indexItem2'><a href='#print_banner'>print_banner</a>
    <li class='indexItem indexItem2'><a href='#parse_request'>parse_request</a>
    <li class='indexItem indexItem2'><a href='#parse_headers'>parse_headers</a>
    <li class='indexItem indexItem2'><a href='#setup_listener'>setup_listener</a>
    <li class='indexItem indexItem2'><a href='#after_setup_listener'>after_setup_listener</a>
    <li class='indexItem indexItem2'><a href='#bad_request'>bad_request</a>
    <li class='indexItem indexItem2'><a href='#valid_http_method(%24method)'>valid_http_method($method)</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#LICENSE'>LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>HTTP::Server::Simple - Lightweight HTTP server</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre> use warnings;
 use strict;
 
 use HTTP::Server::Simple;
 
 my $server = HTTP::Server::Simple-&#62;new();
 $server-&#62;run();</pre>

<p>However, normally you will sub-class the HTTP::Server::Simple::CGI module (see <a href="../../HTTP/Server/Simple/CGI.html" class="podlinkpod"
>HTTP::Server::Simple::CGI</a>);</p>

<pre> package Your::Web::Server;
 use base qw(HTTP::Server::Simple::CGI);
 
 sub handle_request {
     my ($self, $cgi) = @_;

     #... do something, print output to default
     # selected filehandle...

 }
 
 1;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This is a simple standalone HTTP server. By default, it doesn&#39;t thread or fork. It does, however, act as a simple frontend which can be used to build a standalone web-based application or turn a CGI into one.</p>

<p>It is possible to use <a href="../../Net/Server.html" class="podlinkpod"
>Net::Server</a> classes to create forking, pre-forking, and other types of more complicated servers; see <a href="#net_server" class="podlinkpod"
>&#34;net_server&#34;</a>.</p>

<p>By default, the server traps a few signals:</p>

<dl>
<dt><a name="HUP"
>HUP</a></dt>

<dd>
<p>When you <code>kill -HUP</code> the server, it lets the current request finish being processed, then uses the <code>restart</code> method to re-exec itself. Please note that in order to provide restart-on-SIGHUP, HTTP::Server::Simple sets a SIGHUP handler during initialisation. If your request handling code forks you need to make sure you reset this or unexpected things will happen if somebody sends a HUP to all running processes spawned by your app (e.g. by &#34;kill -HUP &#60;script&#62;&#34;)</p>

<dt><a name="PIPE"
>PIPE</a></dt>

<dd>
<p>If the server detects a broken pipe while writing output to the client, it ignores the signal. Otherwise, a client closing the connection early could kill the server.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXAMPLE"
>EXAMPLE</a></h1>

<pre> #!/usr/bin/perl
 {
 package MyWebServer;
 
 use HTTP::Server::Simple::CGI;
 use base qw(HTTP::Server::Simple::CGI);
 
 my %dispatch = (
     &#39;/hello&#39; =&#62; \&#38;resp_hello,
     # ...
 );
 
 sub handle_request {
     my $self = shift;
     my $cgi  = shift;
   
     my $path = $cgi-&#62;path_info();
     my $handler = $dispatch{$path};
 
     if (ref($handler) eq &#34;CODE&#34;) {
         print &#34;HTTP/1.0 200 OK\r\n&#34;;
         $handler-&#62;($cgi);
         
     } else {
         print &#34;HTTP/1.0 404 Not found\r\n&#34;;
         print $cgi-&#62;header,
               $cgi-&#62;start_html(&#39;Not found&#39;),
               $cgi-&#62;h1(&#39;Not found&#39;),
               $cgi-&#62;end_html;
     }
 }
 
 sub resp_hello {
     my $cgi  = shift;   # CGI.pm object
     return if !ref $cgi;
     
     my $who = $cgi-&#62;param(&#39;name&#39;);
     
     print $cgi-&#62;header,
           $cgi-&#62;start_html(&#34;Hello&#34;),
           $cgi-&#62;h1(&#34;Hello $who!&#34;),
           $cgi-&#62;end_html;
 }
 
 } 
 
 # start the server on port 8080
 my $pid = MyWebServer-&#62;new(8080)-&#62;background();
 print &#34;Use &#39;kill $pid&#39; to stop server.\n&#34;;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="HTTP::Server::Simple-&#62;new($port)"
>HTTP::Server::Simple-&#62;new($port)</a></h2>

<p>API call to start a new server. Does not actually start listening until you call <code>-&#62;run()</code>. If omitted, <code>$port</code> defaults to 8080.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="lookup_localhost"
>lookup_localhost</a></h2>

<p>Looks up the local host&#39;s IP address, and returns it. For most hosts, this is <code>127.0.0.1</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="port_[NUMBER]"
>port [NUMBER]</a></h2>

<p>Takes an optional port number for this server to listen on.</p>

<p>Returns this server&#39;s port. (Defaults to 8080)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="host_[address]"
>host [address]</a></h2>

<p>Takes an optional host address for this server to bind to.</p>

<p>Returns this server&#39;s bound address (if any). Defaults to <code>undef</code> (bind to all interfaces).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="background_[ARGUMENTS]"
>background [ARGUMENTS]</a></h2>

<p>Runs the server in the background, and returns the process ID of the started process. Any arguments will be passed through to <a href="#run" class="podlinkpod"
>&#34;run&#34;</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="run_[ARGUMENTS]"
>run [ARGUMENTS]</a></h2>

<p>Run the server. If all goes well, this won&#39;t ever return, but it will start listening for <code>HTTP</code> requests. Any arguments passed to this will be passed on to the underlying <a href="../../Net/Server.html" class="podlinkpod"
>Net::Server</a> implementation, if one is used (see <a href="#net_server" class="podlinkpod"
>&#34;net_server&#34;</a>).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="net_server"
>net_server</a></h2>

<p>User-overridable method. If you set it to a <a href="../../Net/Server.html" class="podlinkpod"
>Net::Server</a> subclass, that subclass is used for the <code>run</code> method. Otherwise, a minimal implementation is used as default.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="restart"
>restart</a></h2>

<p>Restarts the server. Usually called by a HUP signal, not directly.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="stdio_handle_[FILEHANDLE]"
>stdio_handle [FILEHANDLE]</a></h2>

<p>When called with an argument, sets the socket to the server to that arg.</p>

<p>Returns the socket to the server; you should only use this for actual socket-related calls like <code>getsockname</code>. If all you want is to read or write to the socket, you should use <code>stdin_handle</code> and <code>stdout_handle</code> to get the in and out filehandles explicitly.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="stdin_handle"
>stdin_handle</a></h2>

<p>Returns a filehandle used for input from the client. By default, returns whatever was set with <code>stdio_handle</code>, but a subclass could do something interesting here.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="stdout_handle"
>stdout_handle</a></h2>

<p>Returns a filehandle used for output to the client. By default, returns whatever was set with <code>stdio_handle</code>, but a subclass could do something interesting here.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="IMPORTANT_SUB-CLASS_METHODS"
>IMPORTANT SUB-CLASS METHODS</a></h1>

<p>A selection of these methods should be provided by sub-classes of this module.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="handler"
>handler</a></h2>

<p>This method is called after setup, with no parameters. It should print a valid, <i>full</i> HTTP response to the default selected filehandle.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="setup(name_=&#62;_$value,_...)"
>setup(name =&#62; $value, ...)</a></h2>

<p>This method is called with a name =&#62; value list of various things to do with the request. This list is given below.</p>

<p>The default setup handler simply tries to call methods with the names of keys of this list.</p>

<pre>  ITEM/METHOD   Set to                Example
  -----------  ------------------    ------------------------
  method       Request Method        &#34;GET&#34;, &#34;POST&#34;, &#34;HEAD&#34;
  protocol     HTTP version          &#34;HTTP/1.1&#34;
  request_uri  Complete Request URI  &#34;/foobar/baz?foo=bar&#34;
  path         Path part of URI      &#34;/foobar/baz&#34;
  query_string Query String          undef, &#34;foo=bar&#34;
  port         Received Port         80, 8080
  peername     Remote name           &#34;200.2.4.5&#34;, &#34;foo.com&#34;
  peeraddr     Remote address        &#34;200.2.4.5&#34;, &#34;::1&#34;
  peerport     Remote port           42424
  localname    Local interface       &#34;localhost&#34;, &#34;myhost.com&#34;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="headers([Header_=&#62;_$value,_...])"
>headers([Header =&#62; $value, ...])</a></h2>

<p>Receives HTTP headers and does something useful with them. This is called by the default <code>setup()</code> method.</p>

<p>You have lots of options when it comes to how you receive headers.</p>

<p>You can, if you really want, define <code>parse_headers()</code> and parse them raw yourself.</p>

<p>Secondly, you can intercept them very slightly cooked via the <code>setup()</code> method, above.</p>

<p>Thirdly, you can leave the <code>setup()</code> header as-is (or calling the superclass <code>setup()</code> for unknown request items). Then you can define <code>headers()</code> in your sub-class and receive them all at once.</p>

<p>Finally, you can define handlers to receive individual HTTP headers. This can be useful for very simple SOAP servers (to name a crack-fueled standard that defines its own special HTTP headers).</p>

<p>To do so, you&#39;ll want to define the <code>header()</code> method in your subclass. That method will be handed a (key,value) pair of the header name and the value.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="accept_hook"
>accept_hook</a></h2>

<p>If defined by a sub-class, this method is called directly after an accept happens. An accept_hook to add SSL support might look like this:</p>

<pre>    sub accept_hook {
        my $self = shift;
        my $fh   = $self-&#62;stdio_handle;

        $self-&#62;SUPER::accept_hook(@_);

        my $newfh =
        IO::Socket::SSL-&#62;start_SSL( $fh, 
            SSL_server    =&#62; 1,
            SSL_use_cert  =&#62; 1,
            SSL_cert_file =&#62; &#39;myserver.crt&#39;,
            SSL_key_file  =&#62; &#39;myserver.key&#39;,
        )
        or warn &#34;problem setting up SSL socket: &#34; . IO::Socket::SSL::errstr();

        $self-&#62;stdio_handle($newfh) if $newfh;
    }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="post_setup_hook"
>post_setup_hook</a></h2>

<p>If defined by a sub-class, this method is called after all setup has finished, before the handler method.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="print_banner"
>print_banner</a></h2>

<p>This routine prints a banner before the server request-handling loop starts.</p>

<p>Methods below this point are probably not terribly useful to define yourself in subclasses.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="parse_request"
>parse_request</a></h2>

<p>Parse the HTTP request line. Returns three values, the request method, request URI and the protocol.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="parse_headers"
>parse_headers</a></h2>

<p>Parses incoming HTTP headers from STDIN, and returns an arrayref of <code>(header =&#62; value)</code> pairs. See <a href="#headers" class="podlinkpod"
>&#34;headers&#34;</a> for possibilities on how to inspect headers.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="setup_listener"
>setup_listener</a></h2>

<p>This routine binds the server to a port and interface.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="after_setup_listener"
>after_setup_listener</a></h2>

<p>This method is called immediately after setup_listener. It&#39;s here just for you to override.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="bad_request"
>bad_request</a></h2>

<p>This method should print a valid HTTP response that says that the request was invalid.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="valid_http_method($method)"
>valid_http_method($method)</a></h2>

<p>Given a candidate HTTP method in $method, determine if it is valid. Override if, for example, you&#39;d like to do some WebDAV. The default implementation only accepts <code>GET</code>, <code>POST</code>, <code>HEAD</code>, <code>PUT</code>, and <code>DELETE</code>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Copyright (c) 2004-2008 Jesse Vincent, &#60;jesse@bestpractical.com&#62;. All rights reserved.</p>

<p>Marcus Ramberg &#60;drave@thefeed.no&#62; contributed tests, cleanup, etc</p>

<p>Sam Vilain, &#60;samv@cpan.org&#62; contributed the CGI.pm split-out and header/setup API.</p>

<p>Example section by almut on perlmonks, suggested by Mark Fuller.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>There certainly are some. Please report them via rt.cpan.org</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENSE"
>LICENSE</a></h1>

<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
