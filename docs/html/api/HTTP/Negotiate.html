<html><head><title>HTTP::Negotiate</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:18 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#VARIANTS'>VARIANTS</a>
  <li class='indexItem indexItem1'><a href='#ACCEPT_HEADERS'>ACCEPT HEADERS</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>HTTP::Negotiate - choose a variant to serve</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre> use HTTP::Negotiate qw(choose);

 #  ID       QS     Content-Type   Encoding Char-Set        Lang   Size
 $variants =
  [[&#39;var1&#39;,  1.000, &#39;text/html&#39;,   undef,   &#39;iso-8859-1&#39;,   &#39;en&#39;,   3000],
   [&#39;var2&#39;,  0.950, &#39;text/plain&#39;,  &#39;gzip&#39;,  &#39;us-ascii&#39;,     &#39;no&#39;,    400],
   [&#39;var3&#39;,  0.3,   &#39;image/gif&#39;,   undef,   undef,          undef, 43555],
  ];

 @preferred = choose($variants, $request_headers);
 $the_one   = choose($variants);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This module provides a complete implementation of the HTTP content negotiation algorithm specified in <em>draft-ietf-http-v11-spec-00.ps</em> chapter 12. Content negotiation allows for the selection of a preferred content representation based upon attributes of the negotiable variants and the value of the various Accept* header fields in the request.</p>

<p>The variants are ordered by preference by calling the function choose().</p>

<p>The first parameter is reference to an array of the variants to choose among. Each element in this array is an array with the values [$id, $qs, $content_type, $content_encoding, $charset, $content_language, $content_length] whose meanings are described below. The $content_encoding and $content_language can be either a single scalar value or an array reference if there are several values.</p>

<p>The second optional parameter is either a HTTP::Headers or a HTTP::Request object which is searched for &#34;Accept*&#34; headers. If this parameter is missing, then the accept specification is initialized from the CGI environment variables HTTP_ACCEPT, HTTP_ACCEPT_CHARSET, HTTP_ACCEPT_ENCODING and HTTP_ACCEPT_LANGUAGE.</p>

<p>In an array context, choose() returns a list of [variant identifier, calculated quality, size] tuples. The values are sorted by quality, highest quality first. If the calculated quality is the same for two variants, then they are sorted by size (smallest first). <i>E.g.</i>:</p>

<pre>  ([&#39;var1&#39;, 1, 2000], [&#39;var2&#39;, 0.3, 512], [&#39;var3&#39;, 0.3, 1024]);</pre>

<p>Note that also zero quality variants are included in the return list even if these should never be served to the client.</p>

<p>In a scalar context, it returns the identifier of the variant with the highest score or <code>undef</code> if none have non-zero quality.</p>

<p>If the $HTTP::Negotiate::DEBUG variable is set to TRUE, then a lot of noise is generated on STDOUT during evaluation of choose().</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VARIANTS"
>VARIANTS</a></h1>

<p>A variant is described by a list of the following values. If the attribute does not make sense or is unknown for a variant, then use <code>undef</code> instead.</p>

<dl>
<dt><a name="identifier"
>identifier</a></dt>

<dd>
<p>This is a string that you use as the name for the variant. This identifier for the preferred variants returned by choose().</p>

<dt><a name="qs"
>qs</a></dt>

<dd>
<p>This is a number between 0.000 and 1.000 that describes the &#34;source quality&#34;. This is what <em>draft-ietf-http-v11-spec-00.ps</em> says about this value:</p>

<p>Source quality is measured by the content provider as representing the amount of degradation from the original source. For example, a picture in JPEG form would have a lower qs when translated to the XBM format, and much lower qs when translated to an ASCII-art representation. Note, however, that this is a function of the source - an original piece of ASCII-art may degrade in quality if it is captured in JPEG form. The qs values should be assigned to each variant by the content provider; if no qs value has been assigned, the default is generally &#34;qs=1&#34;.</p>

<dt><a name="content-type"
>content-type</a></dt>

<dd>
<p>This is the media type of the variant. The media type does not include a charset attribute, but might contain other parameters. Examples are:</p>

<pre>  text/html
  text/html;version=2.0
  text/plain
  image/gif
  image/jpg</pre>

<dt><a name="content-encoding"
>content-encoding</a></dt>

<dd>
<p>This is one or more content encodings that has been applied to the variant. The content encoding is generally used as a modifier to the content media type. The most common content encodings are:</p>

<pre>  gzip
  compress</pre>

<dt><a name="content-charset"
>content-charset</a></dt>

<dd>
<p>This is the character set used when the variant contains text. The charset value should generally be <code>undef</code> or one of these:</p>

<pre>  us-ascii
  iso-8859-1 ... iso-8859-9
  iso-2022-jp
  iso-2022-jp-2
  iso-2022-kr
  unicode-1-1
  unicode-1-1-utf-7
  unicode-1-1-utf-8</pre>

<dt><a name="content-language"
>content-language</a></dt>

<dd>
<p>This describes one or more languages that are used in the variant. Language is described like this in <em>draft-ietf-http-v11-spec-00.ps</em>: A language is in this context a natural language spoken, written, or otherwise conveyed by human beings for communication of information to other human beings. Computer languages are explicitly excluded.</p>

<p>The language tags are defined by RFC 3066. Examples are:</p>

<pre>  no               Norwegian
  en               International English
  en-US            US English
  en-cockney</pre>

<dt><a name="content-length"
>content-length</a></dt>

<dd>
<p>This is the number of bytes used to represent the content.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ACCEPT_HEADERS"
>ACCEPT HEADERS</a></h1>

<p>The following Accept* headers can be used for describing content preferences in a request (This description is an edited extract from <em>draft-ietf-http-v11-spec-00.ps</em>):</p>

<dl>
<dt><a name="Accept"
>Accept</a></dt>

<dd>
<p>This header can be used to indicate a list of media ranges which are acceptable as a response to the request. The &#34;*&#34; character is used to group media types into ranges, with &#34;*/*&#34; indicating all media types and &#34;type/*&#34; indicating all subtypes of that type.</p>

<p>The parameter q is used to indicate the quality factor, which represents the user&#39;s preference for that range of media types. The parameter mbx gives the maximum acceptable size of the response content. The default values are: q=1 and mbx=infinity. If no Accept header is present, then the client accepts all media types with q=1.</p>

<p>For example:</p>

<pre>  Accept: audio/*;q=0.2;mbx=200000, audio/basic</pre>

<p>would mean: &#34;I prefer audio/basic (of any size), but send me any audio type if it is the best available after an 80% mark-down in quality and its size is less than 200000 bytes&#34;</p>

<dt><a name="Accept-Charset"
>Accept-Charset</a></dt>

<dd>
<p>Used to indicate what character sets are acceptable for the response. The &#34;us-ascii&#34; character set is assumed to be acceptable for all user agents. If no Accept-Charset field is given, the default is that any charset is acceptable. Example:</p>

<pre>  Accept-Charset: iso-8859-1, unicode-1-1</pre>

<dt><a name="Accept-Encoding"
>Accept-Encoding</a></dt>

<dd>
<p>Restricts the Content-Encoding values which are acceptable in the response. If no Accept-Encoding field is present, the server may assume that the client will accept any content encoding. An empty Accept-Encoding means that no content encoding is acceptable. Example:</p>

<pre>  Accept-Encoding: compress, gzip</pre>

<dt><a name="Accept-Language"
>Accept-Language</a></dt>

<dd>
<p>This field is similar to Accept, but restricts the set of natural languages that are preferred in a response. Each language may be given an associated quality value which represents an estimate of the user&#39;s comprehension of that language. For example:</p>

<pre>  Accept-Language: no, en-gb;q=0.8, de;q=0.55</pre>

<p>would mean: &#34;I prefer Norwegian, but will accept British English (with 80% comprehension) or German (with 55% comprehension).</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright 1996,2001 Gisle Aas.</p>

<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Gisle Aas &#60;gisle@aas.no&#62;</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
