<html><head><title>HTTP::Headers::Util</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:18 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>HTTP::Headers::Util - Header value parsing utility functions</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use HTTP::Headers::Util qw(split_header_words);
  @values = split_header_words($h-&#62;header(&#34;Content-Type&#34;));</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This module provides a few functions that helps parsing and construction of valid HTTP header values. None of the functions are exported by default.</p>

<p>The following functions are available:</p>

<dl>
<dt><a name="split_header_words(_@header_values_)"
>split_header_words( @header_values )</a></dt>

<dd>
<p>This function will parse the header values given as argument into a list of anonymous arrays containing key/value pairs. The function knows how to deal with &#34;,&#34;, &#34;;&#34; and &#34;=&#34; as well as quoted values after &#34;=&#34;. A list of space separated tokens are parsed as if they were separated by &#34;;&#34;.</p>

<p>If the @header_values passed as argument contains multiple values, then they are treated as if they were a single value separated by comma &#34;,&#34;.</p>

<p>This means that this function is useful for parsing header fields that follow this syntax (BNF as from the HTTP/1.1 specification, but we relax the requirement for tokens).</p>

<pre>  headers           = #header
  header            = (token | parameter) *( [&#34;;&#34;] (token | parameter))

  token             = 1*&#60;any CHAR except CTLs or separators&#62;
  separators        = &#34;(&#34; | &#34;)&#34; | &#34;&#60;&#34; | &#34;&#62;&#34; | &#34;@&#34;
                    | &#34;,&#34; | &#34;;&#34; | &#34;:&#34; | &#34;\&#34; | &#60;&#34;&#62;
                    | &#34;/&#34; | &#34;[&#34; | &#34;]&#34; | &#34;?&#34; | &#34;=&#34;
                    | &#34;{&#34; | &#34;}&#34; | SP | HT

  quoted-string     = ( &#60;&#34;&#62; *(qdtext | quoted-pair ) &#60;&#34;&#62; )
  qdtext            = &#60;any TEXT except &#60;&#34;&#62;&#62;
  quoted-pair       = &#34;\&#34; CHAR

  parameter         = attribute &#34;=&#34; value
  attribute         = token
  value             = token | quoted-string</pre>

<p>Each <i>header</i> is represented by an anonymous array of key/value pairs. The keys will be all be forced to lower case. The value for a simple token (not part of a parameter) is <code>undef</code>. Syntactically incorrect headers will not necessarily be parsed as you would want.</p>

<p>This is easier to describe with some examples:</p>

<pre>   split_header_words(&#39;foo=&#34;bar&#34;; port=&#34;80,81&#34;; DISCARD, BAR=baz&#39;);
   split_header_words(&#39;text/html; charset=&#34;iso-8859-1&#34;&#39;);
   split_header_words(&#39;Basic realm=&#34;\\&#34;foo\\\\bar\\&#34;&#34;&#39;);</pre>

<p>will return</p>

<pre>   [foo=&#62;&#39;bar&#39;, port=&#62;&#39;80,81&#39;, discard=&#62; undef], [bar=&#62;&#39;baz&#39; ]
   [&#39;text/html&#39; =&#62; undef, charset =&#62; &#39;iso-8859-1&#39;]
   [basic =&#62; undef, realm =&#62; &#34;\&#34;foo\\bar\&#34;&#34;]</pre>

<p>If you don&#39;t want the function to convert tokens and attribute keys to lower case you can call it as <code>_split_header_words</code> instead (with a leading underscore).</p>

<dt><a name="join_header_words(_@arrays_)"
>join_header_words( @arrays )</a></dt>

<dd>
<p>This will do the opposite of the conversion done by split_header_words(). It takes a list of anonymous arrays as arguments (or a list of key/value pairs) and produces a single header value. Attribute values are quoted if needed.</p>

<p>Example:</p>

<pre>   join_header_words([&#34;text/plain&#34; =&#62; undef, charset =&#62; &#34;iso-8859/1&#34;]);
   join_header_words(&#34;text/plain&#34; =&#62; undef, charset =&#62; &#34;iso-8859/1&#34;);</pre>

<p>will both return the string:</p>

<pre>   text/plain; charset=&#34;iso-8859/1&#34;</pre>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright 1997-1998, Gisle Aas</p>

<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
