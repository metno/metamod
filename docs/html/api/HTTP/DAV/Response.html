<html><head><title>HTTP::DAV::Response</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:18 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#HANDLING_A_MULTISTATUS'>HANDLING A MULTISTATUS</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>HTTP::DAV::Response - represents a WebDAV HTTP Response (ala HTTP::Response)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<p>require HTTP::DAV::Response;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>The HTTP::DAV::Response class encapsulates HTTP style responses.
A response consists of a response line,
some headers,
and (potentially empty) content.</p>

<p>HTTP::DAV::Response is a subclass of <code>HTTP::Response</code> and therefore inherits its methods.
(HTTP::Response in turn inherits it&#39;s methods from <code>HTTP::Message</code>).</p>

<p>Therefore,
this class actually inherits a rich library of functions.
You are more likely wanting to read the <code>HTTP::Response</code> class as opposed to this class.</p>

<p>Instances of this class are usually created by a <code>HTTP::DAV::Resource</code> object after it has performed some request (such as get,
lock,
delete,
etc).
You use the object to analyse the success or otherwise of the request.</p>

<p>HTTP::DAV::Response was created to handle two extra functions that normal HTTP Responses don&#39;t require:</p>

<pre> - WebDAV reponses have 6 extra error codes: 102, 207, 422, 423, 424 and 507. Older versions of the LWP&#39;s C&#60;HTTP::Status&#62; class did not have these extra codes. These were added.

 - WebDAV responses can actually contain more than one response (and often DO contain more than one) in the form of a &#34;Multistatus&#34;. These multistatus responses come in the form of an XML document. HTTP::DAV::Response can accurately parse these XML responses and emulate the normal of the C&#60;HTTP::Response&#62;.</pre>

<p>HTTP::DAV::Response transparently implements these extra features without the user having to be aware, so you really should be reading the <code>HTTP::Response</code> documentation for most of the things you want to do (have I already said that?).</p>

<p>There are only a handful of custom functions that HTTP::DAV::Response returns and those are to handle multistatus requests, <code>messages()</code> and <code>codes()</code>.</p>

<p>The six extra status codes that DAV servers can be returned in an HTTP Response are: 102 =&#62; &#34;Processing. Server has accepted the request, but has not yet completed it&#34;, 207 =&#62; &#34;Multistatus&#34;, 422 =&#62; &#34;Unprocessable Entity. Bad client XML sent?&#34;, 423 =&#62; &#34;Locked. The source or destination resource is locked&#34;, 424 =&#62; &#34;Failed Dependency&#34;, 507 =&#62; &#34;Insufficient Storage. The server is unable to store the request&#34;,</p>

<p>See <code>HTTP::Status</code> for the rest.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="HANDLING_A_MULTISTATUS"
>HANDLING A MULTISTATUS</a></h1>

<p>So, many DAV requests may return a multistatus (&#34;207 multistatus&#34;) instead of, say, &#34;200 OK&#34; or &#34;403 Forbidden&#34;.</p>

<p>The HTTP::DAV::Response object stores each &#34;response&#34; sent back in the multistatus. You access them by array number.</p>

<p>The following code snippet shows what you will normally want to do:</p>

<p>... $response = $resource-&#62;lock();</p>

<p>if ( $response-&#62;is_multistatus() ) {</p>

<pre>   foreach $num ( 0 .. $response-&#62;response_count() ) {
      ($err_code,$mesg,$url,$desc) = 
         $response-&#62;response_bynum($num);
      print &#34;$mesg ($err_code) for $url\n&#34;;
   }
}</pre>

<p>Would produce something like this: Failed Dependency (424) for /test/directory Locked (423) for /test/directory/file3</p>

<p>This says that we couldn&#39;t lock /test/directory because file3 which exists inside is already locked by somebody else.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<dl>
<dt><a name="is_multistatus"
><b>is_multistatus</b></a></dt>

<dd>
<p>This function takes no arguments and returns a 1 or a 0.</p>

<p>For example: if ($response-&#62;is_multistatus() ) { }</p>

<p>If the HTTP reply had &#34;207 Multistatus&#34; in the header then that indicates that there are multiple status messages in the XML content that was returned.</p>

<p>In this event, you may be interested in knowing what the individual messages were. To do this you would then use <code>messages</code>.</p>

<dt><a name="response_count"
><b>response_count</b></a></dt>

<dd>
<p>Takes no arguments and returns &#34;the number of error responses -1&#34; that we got. Why -1? Because usually you will want to use this like an array operator:</p>

<p>foreach $num ( 0 .. $response-&#62;response_count() ) { print $response-&#62;message_bynum(); }</p>

<dt><a name="response_bynum"
><b>response_bynum</b></a></dt>

<dd>
<p>Takes one argument, the &#34;response number&#34; that you&#39;re interested in. And returns an array of details:</p>

<pre>   ($code,$message,$url,$description) = response_bynum(2);</pre>

<p>where $code - is the HTTP error code (e.g. 403, 423, etc). $message - is the associated message for that error code. $url - is the url that this error applies to (recall that there can be multiple responses within one response and they all relate to one URL) $description - is server&#39;s attempt at an english description of what happened.</p>

<dt><a name="code_bynum"
><b>code_bynum</b></a></dt>

<dd>
<p>Takes one argument, the &#34;response number&#34; that you&#39;re interested in, and returns it&#39;s code. E.g:</p>

<pre>  $code = $response-&#62;code_bynum(1);</pre>

<p>See <code>response_bynum()</code></p>

<dt><a name="message_bynum"
><b>message_bynum</b></a></dt>

<dd>
<p>Takes one argument, the &#34;response number&#34; that you&#39;re interested in, and returns it&#39;s message. E.g:</p>

<pre>  $code = $response-&#62;message_bynum(1);</pre>

<p>See <code>response_bynum()</code></p>

<dt><a name="url_bynum"
><b>url_bynum</b></a></dt>

<dd>
<p>Takes one argument, the &#34;response number&#34; that you&#39;re interested in, and returns it&#39;s url. E.g:</p>

<pre>  $code = $response-&#62;message_bynum(1);</pre>

<p>See <code>response_bynum()</code></p>

<dt><a name="description_bynum"
><b>description_bynum</b></a></dt>

<dd>
<p>Takes one argument, the &#34;response number&#34; that you&#39;re interested in, and returns it&#39;s description. E.g:</p>

<pre>  $code = $response-&#62;message_description(1);</pre>

<p>See <code>response_bynum()</code></p>

<dt><a name="messages"
><b>messages</b></a></dt>

<dd>
<p>Takes no arguments and returns all of the messages returned in a multistatus response. If called in a scalar context then all of the messages will be returned joined together by newlines. If called in an array context the messages will be returned as an array.</p>

<p>$messages = $response-&#62;messages(); e.g. $messages eq &#34;Forbidden\nLocked&#34;;</p>

<p>@messages = $response-&#62;messages(); e.g. @messages eq [&#34;Forbidden&#34;, &#34;Locked&#34;];</p>

<p>This routine is a variant on the standard <code>HTTP::Response</code> <code>message()</code>.</p>
</dd>
</dl>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
