<html><head><title>Email::Address</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:16 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Package_Variables'>Package Variables</a>
    <li class='indexItem indexItem2'><a href='#Class_Methods'>Class Methods</a>
    <li class='indexItem indexItem2'><a href='#Instance_Methods'>Instance Methods</a>
    <li class='indexItem indexItem2'><a href='#Overloaded_Operators'>Overloaded Operators</a>
    <li class='indexItem indexItem2'><a href='#Did_I_Mention_Fast%3F'>Did I Mention Fast?</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#ACKNOWLEDGEMENTS'>ACKNOWLEDGEMENTS</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Email::Address - RFC 2822 Address Parsing and Creation</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>version 1.900</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use Email::Address;

  my @addresses = Email::Address-&#62;parse($line);
  my $address   = Email::Address-&#62;new(Casey =&#62; &#39;casey@localhost&#39;);

  print $address-&#62;format;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This class implements a regex-based RFC 2822 parser that locates email addresses in strings and returns a list of <code>Email::Address</code> objects found. Alternatively you may construct objects manually. The goal of this software is to be correct, and very very fast.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Package_Variables"
>Package Variables</a></h2>

<p><b>ACHTUNG!</b> Email isn&#39;t easy (if even possible) to parse with a regex, <i>at least</i> if you&#39;re on a <code>perl</code> prior to 5.10.0. Providing regular expressions for use by other programs isn&#39;t a great idea, because it makes it hard to improve the parser without breaking the &#34;it&#39;s a regex&#34; feature. Using these regular expressions is not encouraged, and methods like <code>Email::Address-&#62;is_addr_spec</code> should be provided in the future.</p>

<p>Several regular expressions used in this package are useful to others. For convenience, these variables are declared as package variables that you may access from your program.</p>

<p>These regular expressions conform to the rules specified in RFC 2822.</p>

<p>You can access these variables using the full namespace. If you want short names, define them yourself.</p>

<pre>  my $addr_spec = $Email::Address::addr_spec;</pre>

<dl>
<dt><a name="$Email::Address::addr_spec"
>$Email::Address::addr_spec</a></dt>

<dd>
<p>This regular expression defined what an email address is allowed to look like.</p>

<dt><a name="$Email::Address::angle_addr"
>$Email::Address::angle_addr</a></dt>

<dd>
<p>This regular expression defines an <code>$addr_spec</code> wrapped in angle brackets.</p>

<dt><a name="$Email::Address::name_addr"
>$Email::Address::name_addr</a></dt>

<dd>
<p>This regular expression defines what an email address can look like with an optional preceding display name, also known as the <code>phrase</code>.</p>

<dt><a name="$Email::Address::mailbox"
>$Email::Address::mailbox</a></dt>

<dd>
<p>This is the complete regular expression defining an RFC 2822 email address with an optional preceding display name and optional following comment.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Class_Methods"
>Class Methods</a></h2>

<dl>
<dt><a name="parse"
>parse</a></dt>

<dd>
<pre>  my @addrs = Email::Address-&#62;parse(
    q[me@local, Casey &#60;me@local&#62;, &#34;Casey&#34; &#60;me@local&#62; (West)]
  );</pre>

<p>This method returns a list of <code>Email::Address</code> objects it finds in the input string. <b>Please note</b> that it returns a list, and expects that it may find multiple addresses. The behavior in scalar context is undefined.</p>

<p>The specification for an email address allows for infinitely nestable comments. That&#39;s nice in theory, but a little over done. By default this module allows for two (<code>2</code>) levels of nested comments. If you think you need more, modify the <code>$Email::Address::COMMENT_NEST_LEVEL</code> package variable to allow more.</p>

<pre>  $Email::Address::COMMENT_NEST_LEVEL = 10; # I&#39;m deep</pre>

<p>The reason for this hardly-limiting limitation is simple: efficiency.</p>

<p>Long strings of whitespace can be problematic for this module to parse, a bug which has not yet been adequately addressed. The default behavior is now to collapse multiple spaces into a single space, which avoids this problem. To prevent this behavior, set <code>$Email::Address::COLLAPSE_SPACES</code> to zero. This variable will go away when the bug is resolved properly.</p>

<p>In accordance with RFC 822 and its descendants, this module demands that email addresses be ASCII only. Any non-ASCII content in the parsed addresses will cause the parser to return no results.</p>

<dt><a name="new"
>new</a></dt>

<dd>
<pre>  my $address = Email::Address-&#62;new(undef, &#39;casey@local&#39;);
  my $address = Email::Address-&#62;new(&#39;Casey West&#39;, &#39;casey@local&#39;);
  my $address = Email::Address-&#62;new(undef, &#39;casey@local&#39;, &#39;(Casey)&#39;);</pre>

<p>Constructs and returns a new <code>Email::Address</code> object. Takes four positional arguments: phrase, email, and comment, and original string.</p>

<p>The original string should only really be set using <code>parse</code>.</p>

<dt><a name="purge_cache"
>purge_cache</a></dt>

<dd>
<pre>  Email::Address-&#62;purge_cache;</pre>

<p>One way this module stays fast is with internal caches. Caches live in memory and there is the remote possibility that you will have a memory problem. On the off chance that you think you&#39;re one of those people, this class method will empty those caches.</p>

<p>I&#39;ve loaded over 12000 objects and not encountered a memory problem.</p>

<dt><a name="disable_cache"
>disable_cache</a></dt>

<dd>
<dt><a name="enable_cache"
>enable_cache</a></dt>

<dd>
<pre>  Email::Address-&#62;disable_cache if memory_low();</pre>

<p>If you&#39;d rather not cache address parses at all, you can disable (and re-enable) the Email::Address cache with these methods. The cache is enabled by default.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Instance_Methods"
>Instance Methods</a></h2>

<dl>
<dt><a name="phrase"
>phrase</a></dt>

<dd>
<pre>  my $phrase = $address-&#62;phrase;
  $address-&#62;phrase( &#34;Me oh my&#34; );</pre>

<p>Accessor and mutator for the phrase portion of an address.</p>

<dt><a name="address"
>address</a></dt>

<dd>
<pre>  my $addr = $address-&#62;address;
  $addr-&#62;address( &#34;me@PROTECTED.com&#34; );</pre>

<p>Accessor and mutator for the address portion of an address.</p>

<dt><a name="comment"
>comment</a></dt>

<dd>
<pre>  my $comment = $address-&#62;comment;
  $address-&#62;comment( &#34;(Work address)&#34; );</pre>

<p>Accessor and mutator for the comment portion of an address.</p>

<dt><a name="original"
>original</a></dt>

<dd>
<pre>  my $orig = $address-&#62;original;</pre>

<p>Accessor for the original address found when parsing, or passed to <code>new</code>.</p>

<dt><a name="host"
>host</a></dt>

<dd>
<pre>  my $host = $address-&#62;host;</pre>

<p>Accessor for the host portion of an address&#39;s address.</p>

<dt><a name="user"
>user</a></dt>

<dd>
<pre>  my $user = $address-&#62;user;</pre>

<p>Accessor for the user portion of an address&#39;s address.</p>

<dt><a name="format"
>format</a></dt>

<dd>
<pre>  my $printable = $address-&#62;format;</pre>

<p>Returns a properly formatted RFC 2822 address representing the object.</p>

<dt><a name="name"
>name</a></dt>

<dd>
<pre>  my $name = $address-&#62;name;</pre>

<p>This method tries very hard to determine the name belonging to the address. First the <code>phrase</code> is checked. If that doesn&#39;t work out the <code>comment</code> is looked into. If that still doesn&#39;t work out, the <code>user</code> portion of the <code>address</code> is returned.</p>

<p>This method does <b>not</b> try to massage any name it identifies and instead leaves that up to someone else. Who is it to decide if someone wants their name capitalized, or if they&#39;re Irish?</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Overloaded_Operators"
>Overloaded Operators</a></h2>

<dl>
<dt><a name="stringify"
>stringify</a></dt>

<dd>
<pre>  print &#34;I have your email address, $address.&#34;;</pre>

<p>Objects stringify to <code>format</code> by default. It&#39;s possible that you don&#39;t like that idea. Okay, then, you can change it by modifying <code>$Email:Address::STRINGIFY</code>. Please consider modifying this package variable using <code>local</code>. You might step on someone else&#39;s toes if you don&#39;t.</p>

<pre>  {
    local $Email::Address::STRINGIFY = &#39;host&#39;;
    print &#34;I have your address, $address.&#34;;
    #   geeknest.com
  }
  print &#34;I have your address, $address.&#34;;
  #   &#34;Casey West&#34; &#60;casey@geeknest.com&#62;</pre>

<p>Modifying this package variable is now deprecated. Subclassing is now the recommended approach.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Did_I_Mention_Fast?"
>Did I Mention Fast?</a></h2>

<p>On his 1.8GHz Apple MacBook, rjbs gets these results:</p>

<pre>  $ perl -Ilib bench/ea-vs-ma.pl bench/corpus.txt 5
                   Rate  Mail::Address Email::Address
  Mail::Address  2.59/s             --           -44%
  Email::Address 4.59/s            77%             --

  $ perl -Ilib bench/ea-vs-ma.pl bench/corpus.txt 25
                   Rate  Mail::Address Email::Address
  Mail::Address  2.58/s             --           -67%
  Email::Address 7.84/s           204%             --

  $ perl -Ilib bench/ea-vs-ma.pl bench/corpus.txt 50
                   Rate  Mail::Address Email::Address
  Mail::Address  2.57/s             --           -70%
  Email::Address 8.53/s           232%             --</pre>

<p>...unfortunately, a known bug causes a loss of speed the string to parse has certain known characteristics, and disabling cache will also degrade performance.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>version 1.898</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ACKNOWLEDGEMENTS"
>ACKNOWLEDGEMENTS</a></h1>

<p>Thanks to Kevin Riggle and Tatsuhiko Miyagawa for tests for annoying phrase-quoting bugs!</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<ul>
<li>Casey West</li>

<li>Ricardo SIGNES &#60;rjbs@cpan.org&#62;</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>This software is copyright (c) 2004 by Casey West.</p>

<p>This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
