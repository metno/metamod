<html><head><title>Email::Valid</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:16 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#PREREQUISITES'>PREREQUISITES</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <li class='indexItem indexItem1'><a href='#EXAMPLES'>EXAMPLES</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#CREDITS'>CREDITS</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Email::Valid - Check validity of Internet email addresses</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use Email::Valid;
  print (Email::Valid-&#62;address(&#39;maurice@hevanet.com&#39;) ? &#39;yes&#39; : &#39;no&#39;);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This module determines whether an email address is well-formed, and optionally, whether a mail host exists for the domain.</p>

<p>Please note that there is no way to determine whether an address is deliverable without attempting delivery (for details, see perlfaq 9).</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PREREQUISITES"
>PREREQUISITES</a></h1>

<p>This module requires perl 5.004 or later and the Mail::Address module. Either the Net::DNS module or the nslookup utility is required for DNS checks. The Net::Domain::TLD module is required to check the validity of top level domains.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<pre>  Every method which accepts an &#60;ADDRESS&#62; parameter may
  be passed either a string or an instance of the Mail::Address
  class.  All errors raise an exception.</pre>

<dl>
<dt><a name="new_(_[PARAMS]_)"
>new ( [PARAMS] )</a></dt>

<dd>
<p>This method is used to construct an Email::Valid object. It accepts an optional list of named parameters to control the behavior of the object at instantiation.</p>

<p>The following named parameters are allowed. See the individual methods below of details.</p>

<pre> -mxcheck
 -tldcheck
 -fudge
 -fqdn
 -allow_ip
 -local_rules</pre>

<dt><a name="mx_(_&#60;ADDRESS&#62;|&#60;DOMAIN&#62;_)"
>mx ( &#60;ADDRESS&#62;|&#60;DOMAIN&#62; )</a></dt>

<dd>
<p>This method accepts an email address or domain name and determines whether a DNS record (A or MX) exists for it.</p>

<p>The method returns true if a record is found and undef if not.</p>

<p>Either the Net::DNS module or the nslookup utility is required for DNS checks. Using Net::DNS is the preferred method since error handling is improved. If Net::DNS is available, you can modify the behavior of the resolver (e.g. change the default tcp_timeout value) by manipulating the global Net::DNS::Resolver instance stored in $Email::Valid::Resolver.</p>

<dt><a name="rfc822_(_&#60;ADDRESS&#62;_)"
>rfc822 ( &#60;ADDRESS&#62; )</a></dt>

<dd>
<p>This method determines whether an address conforms to the RFC822 specification (except for nested comments). It returns true if it conforms and undef if not.</p>

<dt><a name="fudge_(_&#60;TRUE&#62;|&#60;FALSE&#62;_)"
>fudge ( &#60;TRUE&#62;|&#60;FALSE&#62; )</a></dt>

<dd>
<p>Specifies whether calls to address() should attempt to correct common addressing errors. Currently, this results in the removal of spaces in AOL addresses, and the conversion of commas to periods in Compuserve addresses. The default is false.</p>

<dt><a name="allow_ip_(_&#60;TRUE&#62;|&#60;FALSE&#62;_)"
>allow_ip ( &#60;TRUE&#62;|&#60;FALSE&#62; )</a></dt>

<dd>
<p>Specifies whether a &#34;domain literal&#34; is acceptable as the domain part. That means addresses like: <code>rjbs@[1.2.3.4]</code></p>

<p>The checking for the domain literal is stricter than the RFC and looser than checking for a valid IP address, <i>but this is subject to change</i>.</p>

<p>The default is true.</p>

<dt><a name="fqdn_(_&#60;TRUE&#62;|&#60;FALSE&#62;_)"
>fqdn ( &#60;TRUE&#62;|&#60;FALSE&#62; )</a></dt>

<dd>
<p>Species whether addresses passed to address() must contain a fully qualified domain name (FQDN). The default is true.</p>

<p><b>Please note!</b> FQDN checks only occur for non-domain-literals. In other words, if you have set <code>allow_ip</code> and the address ends in a bracketed IP address, the FQDN check will not occur.</p>

<dt><a name="tld_(_&#60;ADDRESS&#62;_)"
>tld ( &#60;ADDRESS&#62; )</a></dt>

<dd>
<p>This method determines whether the domain part of an address is in a recognized top-level domain.</p>

<p><b>Please note!</b> TLD checks only occur for non-domain-literals. In other words, if you have set <code>allow_ip</code> and the address ends in a bracketed IP address, the TLD check will not occur.</p>

<dt><a name="local_rules_(_&#60;TRUE&#62;|&#60;FALSE&#62;_)"
>local_rules ( &#60;TRUE&#62;|&#60;FALSE&#62; )</a></dt>

<dd>
<p>Specifies whether addresses passed to address() should be tested for domain specific restrictions. Currently, this is limited to certain AOL restrictions that I&#39;m aware of. The default is false.</p>

<dt><a name="mxcheck_(_&#60;TRUE&#62;|&#60;FALSE&#62;_)"
>mxcheck ( &#60;TRUE&#62;|&#60;FALSE&#62; )</a></dt>

<dd>
<p>Specifies whether addresses passed to address() should be checked for a valid DNS entry. The default is false.</p>

<dt><a name="tldcheck_(_&#60;TRUE&#62;|&#60;FALSE&#62;_)"
>tldcheck ( &#60;TRUE&#62;|&#60;FALSE&#62; )</a></dt>

<dd>
<p>Specifies whether addresses passed to address() should be checked for a valid top level domains. The default is false.</p>

<dt><a name="address_(_&#60;ADDRESS&#62;_)"
>address ( &#60;ADDRESS&#62; )</a></dt>

<dd>
<p>This is the primary method which determines whether an email address is valid. It&#39;s behavior is modified by the values of mxcheck(), tldcheck(), local_rules(), fqdn(), and fudge(). If the address passes all checks, the (possibly modified) address is returned as a string. Otherwise, the undefined value is returned. In a list context, the method also returns an instance of the Mail::Address class representing the email address.</p>

<dt><a name="details_()"
>details ()</a></dt>

<dd>
<p>If the last call to address() returned undef, you can call this method to determine why it failed. Possible values are:</p>

<pre> rfc822
 localpart
 local_rules
 fqdn
 mxcheck
 tldcheck</pre>

<p>If the class is not instantiated, you can get the same information from the global $Email::Valid::Details.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXAMPLES"
>EXAMPLES</a></h1>

<p>Let&#39;s see if the address &#39;maurice@hevanet.com&#39; conforms to the RFC822 specification:</p>

<pre>  print (Email::Valid-&#62;address(&#39;maurice@hevanet.com&#39;) ? &#39;yes&#39; : &#39;no&#39;);</pre>

<p>Additionally, let&#39;s make sure there&#39;s a mail host for it:</p>

<pre>  print (Email::Valid-&#62;address( -address =&#62; &#39;maurice@hevanet.com&#39;,
                                -mxcheck =&#62; 1 ) ? &#39;yes&#39; : &#39;no&#39;);</pre>

<p>Let&#39;s see an example of how the address may be modified:</p>

<pre>  $addr = Email::Valid-&#62;address(&#39;Alfred Neuman &#60;Neuman @ foo.bar&#62;&#39;);
  print &#34;$addr\n&#34;; # prints Neuman@foo.bar</pre>

<p>Now let&#39;s add the check for top level domains:</p>

<pre>  $addr = Email::Valid-&#62;address( -address =&#62; &#39;Neuman@foo.bar&#39;,
                                 -tldcheck =&#62; 1 );
  print &#34;$addr\n&#34;; # doesn&#39;t print anything</pre>

<p>Need to determine why an address failed?</p>

<pre>  unless(Email::Valid-&#62;address(&#39;maurice@hevanet&#39;)) {
    print &#34;address failed $Email::Valid::Details check.\n&#34;;
  }</pre>

<p>If an error is encountered, an exception is raised. This is really only possible when performing DNS queries. Trap any exceptions by wrapping the call in an eval block:</p>

<pre>  eval {
    $addr = Email::Valid-&#62;address( -address =&#62; &#39;maurice@hevanet.com&#39;,
                                   -mxcheck =&#62; 1 );
  };
  warn &#34;an error was encountered: $@&#34; if $@;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>Email::Valid should work with Perl for Win32. In my experience, however, Net::DNS queries seem to take an extremely long time when a record cannot be found.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Copyright 1998-2003, Maurice Aubrey &#60;maurice@hevanet.com&#62;. All rights reserved.</p>

<p>This module is free software; you may redistribute it and/or modify it under the same terms as Perl itself.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CREDITS"
>CREDITS</a></h1>

<p>Significant portions of this module are based on the ckaddr program written by Tom Christiansen and the RFC822 address pattern developed by Jeffrey Friedl. Neither were involved in the construction of this module; all errors are mine.</p>

<p>Thanks very much to the following people for their suggestions and bug fixes:</p>

<pre>  Otis Gospodnetic &#60;otis@DOMINIS.com&#62;
  Kim Ryan &#60;kimaryan@ozemail.com.au&#62;
  Pete Ehlke &#60;pde@listserv.music.sony.com&#62;
  Lupe Christoph
  David Birnbaum
  Achim
  Elizabeth Mattijsen (liz@dijkmat.nl)</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>Mail::Address, Net::DNS, Net::Domain::TLD, perlfaq9</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
