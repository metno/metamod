<html><head><title>AppConfig::State</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:02 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#OVERVIEW'>OVERVIEW</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#USING_THE_AppConfig%3A%3AState_MODULE'>USING THE AppConfig::State MODULE</a>
    <li class='indexItem indexItem2'><a href='#DEFINING_VARIABLES'>DEFINING VARIABLES</a>
    <li class='indexItem indexItem2'><a href='#DEFINING_VARIABLES_USING_THE_COMPACT_FORMAT'>DEFINING VARIABLES USING THE COMPACT FORMAT</a>
    <li class='indexItem indexItem2'><a href='#READING_AND_MODIFYING_VARIABLE_VALUES'>READING AND MODIFYING VARIABLE VALUES</a>
    <li class='indexItem indexItem2'><a href='#INTERNAL_METHODS'>INTERNAL METHODS</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>AppConfig::State - application configuration state</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    use AppConfig::State;

    my $state = AppConfig::State-&#62;new(\%cfg);

    $state-&#62;define(&#34;foo&#34;);            # very simple variable definition
    $state-&#62;define(&#34;bar&#34;, \%varcfg);  # variable specific configuration
    $state-&#62;define(&#34;foo|bar=i@&#34;);     # compact format

    $state-&#62;set(&#34;foo&#34;, 123);          # trivial set/get examples
    $state-&#62;get(&#34;foo&#34;);      
    
    $state-&#62;foo();                    # shortcut variable access 
    $state-&#62;foo(456);                 # shortcut variable update </pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="OVERVIEW"
>OVERVIEW</a></h1>

<p>AppConfig::State is a Perl5 module to handle global configuration variables for perl programs. It maintains the state of any number of variables, handling default values, aliasing, validation, update callbacks and option arguments for use by other AppConfig::* modules.</p>

<p>AppConfig::State is distributed as part of the AppConfig bundle.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="USING_THE_AppConfig::State_MODULE"
>USING THE AppConfig::State MODULE</a></h2>

<p>To import and use the AppConfig::State module the following line should appear in your Perl script:</p>

<pre>     use AppConfig::State;</pre>

<p>The AppConfig::State module is loaded automatically by the new() constructor of the AppConfig module.</p>

<p>AppConfig::State is implemented using object-oriented methods. A new AppConfig::State object is created and initialised using the new() method. This returns a reference to a new AppConfig::State object.</p>

<pre>    my $state = AppConfig::State-&#62;new();</pre>

<p>This will create a reference to a new AppConfig::State with all configuration options set to their default values. You can initialise the object by passing a reference to a hash array containing configuration options:</p>

<pre>    $state = AppConfig::State-&#62;new( {
        CASE      =&#62; 1,
        ERROR     =&#62; \&#38;my_error,
    } );</pre>

<p>The new() constructor of the AppConfig module automatically passes all parameters to the AppConfig::State new() constructor. Thus, any global configuration values and variable definitions for AppConfig::State are also applicable to AppConfig.</p>

<p>The following configuration options may be specified.</p>

<dl>
<dt><a name="CASE"
>CASE</a></dt>

<dd>
<p>Determines if the variable names are treated case sensitively. Any non-zero value makes case significant when naming variables. By default, CASE is set to 0 and thus &#34;Variable&#34;, &#34;VARIABLE&#34; and &#34;VaRiAbLe&#34; are all treated as &#34;variable&#34;.</p>

<dt><a name="CREATE"
>CREATE</a></dt>

<dd>
<p>By default, CREATE is turned off meaning that all variables accessed via set() (which includes access via shortcut such as <code>$state-&#62;variable($value)</code> which delegates to set()) must previously have been defined via define(). When CREATE is set to 1, calling set($variable, $value) on a variable that doesn&#39;t exist will cause it to be created automatically.</p>

<p>When CREATE is set to any other non-zero value, it is assumed to be a regular expression pattern. If the variable name matches the regex, the variable is created. This can be used to specify configuration file blocks in which variables should be created, for example:</p>

<pre>    $state = AppConfig::State-&#62;new( {
        CREATE =&#62; &#39;^define_&#39;,
    } );</pre>

<p>In a config file:</p>

<pre>    [define]
    name = fred           # define_name gets created automatically
    
    [other]
    name = john           # other_name doesn&#39;t - warning raised</pre>

<p>Note that a regex pattern specified in CREATE is applied to the real variable name rather than any alias by which the variables may be accessed.</p>

<dt><a name="PEDANTIC"
>PEDANTIC</a></dt>

<dd>
<p>The PEDANTIC option determines what action the configuration file (AppConfig::File) or argument parser (AppConfig::Args) should take on encountering a warning condition (typically caused when trying to set an undeclared variable). If PEDANTIC is set to any true value, the parsing methods will immediately return a value of 0 on encountering such a condition. If PEDANTIC is not set, the method will continue to parse the remainder of the current file(s) or arguments, returning 0 when complete.</p>

<p>If no warnings or errors are encountered, the method returns 1.</p>

<p>In the case of a system error (e.g. unable to open a file), the method returns undef immediately, regardless of the PEDANTIC option.</p>

<dt><a name="ERROR"
>ERROR</a></dt>

<dd>
<p>Specifies a user-defined error handling routine. When the handler is called, a format string is passed as the first parameter, followed by any additional values, as per printf(3C).</p>

<dt><a name="DEBUG"
>DEBUG</a></dt>

<dd>
<p>Turns debugging on or off when set to 1 or 0 accordingly. Debugging may also be activated by calling _debug() as an object method (<code>$state-&#62;_debug(1)</code>) or as a package function (<code>AppConfig::State::_debug(1)</code>), passing in a true/false value to set the debugging state accordingly. The package variable $AppConfig::State::DEBUG can also be set directly.</p>

<p>The _debug() method returns the current debug value. If a new value is passed in, the internal value is updated, but the previous value is returned.</p>

<p>Note that any AppConfig::File or App::Config::Args objects that are instantiated with a reference to an App::State will inherit the DEBUG (and also PEDANTIC) values of the state at that time. Subsequent changes to the AppConfig::State debug value will not affect them.</p>

<dt><a name="GLOBAL"
>GLOBAL</a></dt>

<dd>
<p>The GLOBAL option allows default values to be set for the DEFAULT, ARGCOUNT, EXPAND, VALIDATE and ACTION options for any subsequently defined variables.</p>

<pre>    $state = AppConfig::State-&#62;new({
        GLOBAL =&#62; {
            DEFAULT  =&#62; &#39;&#60;undef&#62;&#39;,     # default value for new vars
            ARGCOUNT =&#62; 1,             # vars expect an argument
            ACTION   =&#62; \&#38;my_set_var,  # callback when vars get set
        }
    });</pre>

<p>Any attributes specified explicitly when a variable is defined will override any GLOBAL values.</p>

<p>See <a href="#DEFINING_VARIABLES" class="podlinkpod"
>&#34;DEFINING VARIABLES&#34;</a> below which describes these options in detail.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="DEFINING_VARIABLES"
>DEFINING VARIABLES</a></h2>

<p>The <code>define()</code> function is used to pre-declare a variable and specify its configuration.</p>

<pre>    $state-&#62;define(&#34;foo&#34;);</pre>

<p>In the simple example above, a new variable called &#34;foo&#34; is defined. A reference to a hash array may also be passed to specify configuration information for the variable:</p>

<pre>    $state-&#62;define(&#34;foo&#34;, {
            DEFAULT   =&#62; 99,
            ALIAS     =&#62; &#39;metavar1&#39;,
        });</pre>

<p>Any variable-wide GLOBAL values passed to the new() constructor in the configuration hash will also be applied. Values explicitly specified in a variable&#39;s define() configuration will override the respective GLOBAL values.</p>

<p>The following configuration options may be specified</p>

<dl>
<dt><a name="DEFAULT"
>DEFAULT</a></dt>

<dd>
<p>The DEFAULT value is used to initialise the variable.</p>

<pre>    $state-&#62;define(&#34;drink&#34;, {
            DEFAULT =&#62; &#39;coffee&#39;,
        });

    print $state-&#62;drink();        # prints &#34;coffee&#34;</pre>

<dt><a name="ALIAS"
>ALIAS</a></dt>

<dd>
<p>The ALIAS option allows a number of alternative names to be specified for this variable. A single alias should be specified as a string. Multiple aliases can be specified as a reference to an array of alternatives or as a string of names separated by vertical bars, &#39;|&#39;. e.g.:</p>

<pre>    # either
    $state-&#62;define(&#34;name&#34;, {
            ALIAS  =&#62; &#39;person&#39;,
        });

    # or
    $state-&#62;define(&#34;name&#34;, {
            ALIAS =&#62; [ &#39;person&#39;, &#39;user&#39;, &#39;uid&#39; ],
        });
    
    # or
    $state-&#62;define(&#34;name&#34;, {
            ALIAS =&#62; &#39;person|user|uid&#39;,
        });
    
    $state-&#62;user(&#39;abw&#39;);     # equivalent to $state-&#62;name(&#39;abw&#39;);</pre>

<dt><a name="ARGCOUNT"
>ARGCOUNT</a></dt>

<dd>
<p>The ARGCOUNT option specifies the number of arguments that should be supplied for this variable. By default, no additional arguments are expected for variables (ARGCOUNT_NONE).</p>

<p>The ARGCOUNT_* constants can be imported from the AppConfig module:</p>

<pre>    use AppConfig &#39;:argcount&#39;;

    $state-&#62;define(&#39;foo&#39;, { ARGCOUNT =&#62; ARGCOUNT_ONE });</pre>

<p>or can be accessed directly from the AppConfig package:</p>

<pre>    use AppConfig;

    $state-&#62;define(&#39;foo&#39;, { ARGCOUNT =&#62; AppConfig::ARGCOUNT_ONE });</pre>

<p>The following values for ARGCOUNT may be specified.</p>

<dl>
<dt><a name="ARGCOUNT_NONE_(0)"
>ARGCOUNT_NONE (0)</a></dt>

<dd>
<p>Indicates that no additional arguments are expected. If the variable is identified in a confirguration file or in the command line arguments, it is set to a value of 1 regardless of whatever arguments follow it.</p>

<dt><a name="ARGCOUNT_ONE_(1)"
>ARGCOUNT_ONE (1)</a></dt>

<dd>
<p>Indicates that the variable expects a single argument to be provided. The variable value will be overwritten with a new value each time it is encountered.</p>

<dt><a name="ARGCOUNT_LIST_(2)"
>ARGCOUNT_LIST (2)</a></dt>

<dd>
<p>Indicates that the variable expects multiple arguments. The variable value will be appended to the list of previous values each time it is encountered.</p>

<dt><a name="ARGCOUNT_HASH_(3)"
>ARGCOUNT_HASH (3)</a></dt>

<dd>
<p>Indicates that the variable expects multiple arguments and that each argument is of the form &#34;key=value&#34;. The argument will be split into a key/value pair and inserted into the hash of values each time it is encountered.</p>
</dd>
</dl>

<dt><a name="ARGS"
>ARGS</a></dt>

<dd>
<p>The ARGS option can also be used to specify advanced command line options for use with AppConfig::Getopt, which itself delegates to Getopt::Long. See those two modules for more information on the format and meaning of these options.</p>

<pre>    $state-&#62;define(&#34;name&#34;, {
            ARGS =&#62; &#34;=i@&#34;,
        });</pre>

<dt><a name="EXPAND"
>EXPAND</a></dt>

<dd>
<p>The EXPAND option specifies how the AppConfig::File processor should expand embedded variables in the configuration file values it reads. By default, EXPAND is turned off (EXPAND_NONE) and no expansion is made.</p>

<p>The EXPAND_* constants can be imported from the AppConfig module:</p>

<pre>    use AppConfig &#39;:expand&#39;;

    $state-&#62;define(&#39;foo&#39;, { EXPAND =&#62; EXPAND_VAR });</pre>

<p>or can be accessed directly from the AppConfig package:</p>

<pre>    use AppConfig;

    $state-&#62;define(&#39;foo&#39;, { EXPAND =&#62; AppConfig::EXPAND_VAR });</pre>

<p>The following values for EXPAND may be specified. Multiple values should be combined with vertical bars , &#39;|&#39;, e.g. <code>EXPAND_UID | EXPAND_VAR</code>).</p>

<dl>
<dt><a name="EXPAND_NONE"
>EXPAND_NONE</a></dt>

<dd>
<p>Indicates that no variable expansion should be attempted.</p>

<dt><a name="EXPAND_VAR"
>EXPAND_VAR</a></dt>

<dd>
<p>Indicates that variables embedded as $var or $(var) should be expanded to the values of the relevant AppConfig::State variables.</p>

<dt><a name="EXPAND_UID"
>EXPAND_UID</a></dt>

<dd>
<p>Indicates that &#39;~&#39; or &#39;~uid&#39; patterns in the string should be expanded to the current users ($&#60;), or specified user&#39;s home directory. In the first case, <code>~</code> is expanded to the value of the <code>HOME</code> environment variable. In the second case, the <code>getpwnam()</code> method is used if it is available on your system (which it isn&#39;t on Win32).</p>

<dt><a name="EXPAND_ENV"
>EXPAND_ENV</a></dt>

<dd>
<p>Inidicates that variables embedded as ${var} should be expanded to the value of the relevant environment variable.</p>

<dt><a name="EXPAND_ALL"
>EXPAND_ALL</a></dt>

<dd>
<p>Equivalent to <code>EXPAND_VARS | EXPAND_UIDS | EXPAND_ENVS</code>).</p>

<dt><a name="EXPAND_WARN"
>EXPAND_WARN</a></dt>

<dd>
<p>Indicates that embedded variables that are not defined should raise a warning. If PEDANTIC is set, this will cause the read() method to return 0 immediately.</p>
</dd>
</dl>

<dt><a name="VALIDATE"
>VALIDATE</a></dt>

<dd>
<p>Each variable may have a sub-routine or regular expression defined which is used to validate the intended value for a variable before it is set.</p>

<p>If VALIDATE is defined as a regular expression, it is applied to the value and deemed valid if the pattern matches. In this case, the variable is then set to the new value. A warning message is generated if the pattern match fails.</p>

<p>VALIDATE may also be defined as a reference to a sub-routine which takes as its arguments the name of the variable and its intended value. The sub-routine should return 1 or 0 to indicate that the value is valid or invalid, respectively. An invalid value will cause a warning error message to be generated.</p>

<p>If the GLOBAL VALIDATE variable is set (see GLOBAL in <a href="../DESCRIPTION.html" class="podlinkpod"
>DESCRIPTION</a> above) then this value will be used as the default VALIDATE for each variable unless otherwise specified.</p>

<pre>    $state-&#62;define(&#34;age&#34;, {
            VALIDATE =&#62; &#39;\d+&#39;,
        });

    $state-&#62;define(&#34;pin&#34;, {
            VALIDATE =&#62; \&#38;check_pin,
        });</pre>

<dt><a name="ACTION"
>ACTION</a></dt>

<dd>
<p>The ACTION option allows a sub-routine to be bound to a variable as a callback that is executed whenever the variable is set. The ACTION is passed a reference to the AppConfig::State object, the name of the variable and the value of the variable.</p>

<p>The ACTION routine may be used, for example, to post-process variable data, update the value of some other dependant variable, generate a warning message, etc.</p>

<p>Example:</p>

<pre>    $state-&#62;define(&#34;foo&#34;, { ACTION =&#62; \&#38;my_notify });

    sub my_notify {
        my $state = shift;
        my $var   = shift;
        my $val   = shift;

        print &#34;$variable set to $value&#34;;
    }

    $state-&#62;foo(42);        # prints &#34;foo set to 42&#34;</pre>

<p>Be aware that calling <code>$state-&#62;set()</code> to update the same variable from within the ACTION function will cause a recursive loop as the ACTION function is repeatedly called.</p>

<dt><a name="_"
></a></dt>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="DEFINING_VARIABLES_USING_THE_COMPACT_FORMAT"
>DEFINING VARIABLES USING THE COMPACT FORMAT</a></h2>

<p>Variables may be defined in a compact format which allows any ALIAS and ARGS values to be specified as part of the variable name. This is designed to mimic the behaviour of Johan Vromans&#39; Getopt::Long module.</p>

<p>Aliases for a variable should be specified after the variable name, separated by vertical bars, &#39;|&#39;. Any ARGS parameter should be appended after the variable name(s) and/or aliases.</p>

<p>The following examples are equivalent:</p>

<pre>    $state-&#62;define(&#34;foo&#34;, { 
            ALIAS =&#62; [ &#39;bar&#39;, &#39;baz&#39; ],
            ARGS  =&#62; &#39;=i&#39;,
        });

    $state-&#62;define(&#34;foo|bar|baz=i&#34;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="READING_AND_MODIFYING_VARIABLE_VALUES"
>READING AND MODIFYING VARIABLE VALUES</a></h2>

<p>AppConfig::State defines two methods to manipulate variable values:</p>

<pre>    set($variable, $value);
    get($variable);</pre>

<p>Both functions take the variable name as the first parameter and <code>set()</code> takes an additional parameter which is the new value for the variable. <code>set()</code> returns 1 or 0 to indicate successful or unsuccessful update of the variable value. If there is an ACTION routine associated with the named variable, the value returned will be passed back from <code>set()</code>. The <code>get()</code> function returns the current value of the variable.</p>

<p>Once defined, variables may be accessed directly as object methods where the method name is the same as the variable name. i.e.</p>

<pre>    $state-&#62;set(&#34;verbose&#34;, 1);</pre>

<p>is equivalent to</p>

<pre>    $state-&#62;verbose(1); </pre>

<p>Without parameters, the current value of the variable is returned. If a parameter is specified, the variable is set to that value and the result of the set() operation is returned.</p>

<pre>    $state-&#62;age(29);        # sets &#39;age&#39; to 29, returns 1 (ok)</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="INTERNAL_METHODS"
>INTERNAL METHODS</a></h2>

<p>The interal (private) methods of the AppConfig::State class are listed below.</p>

<p>They aren&#39;t intended for regular use and potential users should consider the fact that nothing about the internal implementation is guaranteed to remain the same. Having said that, the AppConfig::State class is intended to co-exist and work with a number of other modules and these are considered &#34;friend&#34; classes. These methods are provided, in part, as services to them. With this acknowledged co-operation in mind, it is safe to assume some stability in this core interface.</p>

<p>The _varname() method can be used to determine the real name of a variable from an alias:</p>

<pre>    $varname-&#62;_varname($alias);</pre>

<p>Note that all methods that take a variable name, including those listed below, can accept an alias and automatically resolve it to the correct variable name. There is no need to call _varname() explicitly to do alias expansion. The _varname() method will fold all variables names to lower case unless CASE sensititvity is set.</p>

<p>The _exists() method can be used to check if a variable has been defined:</p>

<pre>    $state-&#62;_exists($varname);</pre>

<p>The _default() method can be used to reset a variable to its default value:</p>

<pre>    $state-&#62;_default($varname);</pre>

<p>The _expand() method can be used to determine the EXPAND value for a variable:</p>

<pre>    print &#34;$varname EXPAND: &#34;, $state-&#62;_expand($varname), &#34;\n&#34;;</pre>

<p>The _argcount() method returns the value of the ARGCOUNT attribute for a variable:</p>

<pre>    print &#34;$varname ARGCOUNT: &#34;, $state-&#62;_argcount($varname), &#34;\n&#34;;</pre>

<p>The _validate() method can be used to determine if a new value for a variable meets any validation criteria specified for it. The variable name and intended value should be passed in. The methods returns a true/false value depending on whether or not the validation succeeded:</p>

<pre>    print &#34;OK\n&#34; if $state-&#62;_validate($varname, $value);</pre>

<p>The _pedantic() method can be called to determine the current value of the PEDANTIC option.</p>

<pre>    print &#34;pedantic mode is &#34;, $state-&#62;_pedantic() ? &#34;on&#34; ; &#34;off&#34;, &#34;\n&#34;;</pre>

<p>The _debug() method can be used to turn debugging on or off (pass 1 or 0 as a parameter). It can also be used to check the debug state, returning the current internal value of $AppConfig::State::DEBUG. If a new debug value is provided, the debug state is updated and the previous state is returned.</p>

<pre>    $state-&#62;_debug(1);               # debug on, returns previous value</pre>

<p>The _dump_var($varname) and _dump() methods may also be called for debugging purposes.</p>

<pre>    $state-&#62;_dump_var($varname);    # show variable state
    $state-&#62;_dump();                # show internal state and all vars</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Andy Wardley, &#60;abw@wardley.org&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright (C) 1997-2007 Andy Wardley. All Rights Reserved.</p>

<p>Copyright (C) 1997,1998 Canon Research Centre Europe Ltd.</p>

<p>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>AppConfig, AppConfig::File, AppConfig::Args, AppConfig::Getopt</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
