<html><head><title>MooseX::Types</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:22 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Library_Definition'>Library Definition</a>
    <li class='indexItem indexItem2'><a href='#Usage'>Usage</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#LIBRARY_DEFINITION'>LIBRARY DEFINITION</a>
  <li class='indexItem indexItem1'><a href='#LIBRARY_USAGE'>LIBRARY USAGE</a>
  <li class='indexItem indexItem1'><a href='#TYPE_HANDLER_FUNCTIONS'>TYPE HANDLER FUNCTIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#%24type'>$type</a>
    <li class='indexItem indexItem2'><a href='#is_%24type'>is_$type</a>
    <li class='indexItem indexItem2'><a href='#to_%24type'>to_$type</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#WRAPPING_A_LIBRARY'>WRAPPING A LIBRARY</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Generator_methods_you_can_overload'>Generator methods you can overload</a>
    <li class='indexItem indexItem2'><a href='#Provided_Parameters'>Provided Parameters</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#RECURSIVE_SUBTYPES'>RECURSIVE SUBTYPES</a>
  <li class='indexItem indexItem1'><a href='#NOTES_REGARDING_TYPE_UNIONS'>NOTES REGARDING TYPE UNIONS</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#import'>import</a>
    <li class='indexItem indexItem2'><a href='#type_export_generator'>type_export_generator</a>
    <li class='indexItem indexItem2'><a href='#create_arged_type_constraint_(%24name%2C_%40args)'>create_arged_type_constraint ($name, @args)</a>
    <li class='indexItem indexItem2'><a href='#create_base_type_constraint_(%24name)'>create_base_type_constraint ($name)</a>
    <li class='indexItem indexItem2'><a href='#create_type_decorator_(%24type_constraint)'>create_type_decorator ($type_constraint)</a>
    <li class='indexItem indexItem2'><a href='#coercion_export_generator'>coercion_export_generator</a>
    <li class='indexItem indexItem2'><a href='#check_export_generator'>check_export_generator</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#CAVEATS'>CAVEATS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Uniqueness'>Uniqueness</a>
    <li class='indexItem indexItem2'><a href='#Argument_separation_(%27%3D%3E%27_versus_%27%2C%27)'>Argument separation (&#39;=&#62;&#39; versus &#39;,&#39;)</a>
    <li class='indexItem indexItem2'><a href='#Compatibility_with_Sub%3A%3AExporter'>Compatibility with Sub::Exporter</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#COMBINING_TYPE_LIBRARIES'>COMBINING TYPE LIBRARIES</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#ACKNOWLEDGEMENTS'>ACKNOWLEDGEMENTS</a>
  <li class='indexItem indexItem1'><a href='#CONTRIBUTORS'>CONTRIBUTORS</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>MooseX::Types - Organise your Moose types in libraries</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>version 0.35</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Library_Definition"
>Library Definition</a></h2>

<pre>  package MyLibrary;

  # predeclare our own types
  use MooseX::Types -declare =&#62; [
      qw(
          PositiveInt
          NegativeInt
          ArrayRefOfPositiveInt
          ArrayRefOfAtLeastThreeNegativeInts
          LotsOfInnerConstraints
          StrOrArrayRef
          MyDateTime
          )
  ];

  # import builtin types
  use MooseX::Types::Moose qw/Int HashRef/;

  # type definition.
  subtype PositiveInt,
      as Int,
      where { $_ &#62; 0 },
      message { &#34;Int is not larger than 0&#34; };

  subtype NegativeInt,
      as Int,
      where { $_ &#60; 0 },
      message { &#34;Int is not smaller than 0&#34; };

  # type coercion
  coerce PositiveInt,
      from Int,
          via { 1 };

  # with parameterized constraints.

  subtype ArrayRefOfPositiveInt,
    as ArrayRef[PositiveInt];

  subtype ArrayRefOfAtLeastThreeNegativeInts,
    as ArrayRef[NegativeInt],
    where { scalar(@$_) &#62; 2 };

  subtype LotsOfInnerConstraints,
    as ArrayRef[ArrayRef[HashRef[Int]]];

  # with TypeConstraint Unions

  subtype StrOrArrayRef,
    as Str|ArrayRef;

  # class types

  class_type &#39;DateTime&#39;;

  # or better

  class_type MyDateTime, { class =&#62; &#39;DateTime&#39; };

  coerce MyDateTime,
    from HashRef,
    via { DateTime-&#62;new(%$_) };

  1;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Usage"
>Usage</a></h2>

<pre>  package Foo;
  use Moose;
  use MyLibrary qw( PositiveInt NegativeInt );

  # use the exported constants as type names
  has &#39;bar&#39;,
      isa    =&#62; PositiveInt,
      is     =&#62; &#39;rw&#39;;
  has &#39;baz&#39;,
      isa    =&#62; NegativeInt,
      is     =&#62; &#39;rw&#39;;

  sub quux {
      my ($self, $value);

      # test the value
      print &#34;positive\n&#34; if is_PositiveInt($value);
      print &#34;negative\n&#34; if is_NegativeInt($value);

      # coerce the value, NegativeInt doesn&#39;t have a coercion
      # helper, since it didn&#39;t define any coercions.
      $value = to_PositiveInt($value) or die &#34;Cannot coerce&#34;;
  }

  1;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>The type system provided by Moose effectively makes all of its builtin type global, as are any types you declare with Moose. This means that every module that declares a type named &#34;PositiveInt&#34; is sharing the same type object. This can be a problem when different parts of the code base want to use the same name for different things.</p>

<p>This package lets you declare types using short names, but behind the scenes it namespaces all your type declarations, effectively prevent name clashes between packages.</p>

<p>This is done by creating a type library module like <code>MyApp::Types</code> and then importing types from that module into other modules.</p>

<p>As a side effect, the declaration mechanism allows you to write type names as barewords (really function calls), which catches typos in names at compile time rather than run time.</p>

<p>This module also provides some helper functions for using Moose types outside of attribute declarations.</p>

<p>If you mix string-based names with types created by this module, it will warn, with a few exceptions. If you are declaring a <code>class_type()</code> or <code>role_type()</code> within your type library, or if you use a fully qualified name like <code>&#34;MyApp::Foo&#34;</code>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LIBRARY_DEFINITION"
>LIBRARY DEFINITION</a></h1>

<p>A MooseX::Types is just a normal Perl module. Unlike Moose itself, it does not install <code>use strict</code> and <code>use warnings</code> in your class by default, so this is up to you.</p>

<p>The only thing a library is required to do is</p>

<pre>  use MooseX::Types -declare =&#62; \@types;</pre>

<p>with <code>@types</code> being a list of types you wish to define in this library. This line will install a proper base class in your package as well as the full set of <a href="#TYPE_HANDLER_FUNCTIONS" class="podlinkpod"
>handlers</a> for your declared types. It will then hand control over to <a href="../Moose/Util/TypeConstraints.html" class="podlinkpod"
>Moose::Util::TypeConstraints</a>&#39; <code>import</code> method to export the functions you will need to declare your types.</p>

<p>If you want to use Moose&#39; built-in types (e.g. for subtyping) you will want to</p>

<pre>  use MooseX::Types::Moose @types;</pre>

<p>to import the helpers from the shipped <a href="../MooseX/Types/Moose.html" class="podlinkpod"
>MooseX::Types::Moose</a> library which can export all types that come with Moose.</p>

<p>You will have to define coercions for your types or your library won&#39;t export a <a href="#to_%24type" class="podlinkpod"
>&#34;to_$type&#34;</a> coercion helper for it.</p>

<p>Note that you currently cannot define types containing <code>::</code>, since exporting would be a problem.</p>

<p>You also don&#39;t need to use <code>warnings</code> and <code>strict</code>, since the definition of a library automatically exports those.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LIBRARY_USAGE"
>LIBRARY USAGE</a></h1>

<p>You can import the <a href="#TYPE_HANDLER_FUNCTIONS" class="podlinkpod"
>&#34;type helpers&#34;</a> of a library by <code>use</code>ing it with a list of types to import as arguments. If you want all of them, use the <code>:all</code> tag. For example:</p>

<pre>  use MyLibrary      &#39;:all&#39;;
  use MyOtherLibrary qw( TypeA TypeB );</pre>

<p>MooseX::Types comes with a library of Moose&#39; built-in types called <a href="../MooseX/Types/Moose.html" class="podlinkpod"
>MooseX::Types::Moose</a>.</p>

<p>The exporting mechanism is, since version 0.5, implemented via a wrapper around <a href="../Sub/Exporter.html" class="podlinkpod"
>Sub::Exporter</a>. This means you can do something like this:</p>

<pre>  use MyLibrary TypeA =&#62; { -as =&#62; &#39;MyTypeA&#39; },
                TypeB =&#62; { -as =&#62; &#39;MyTypeB&#39; };</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TYPE_HANDLER_FUNCTIONS"
>TYPE HANDLER FUNCTIONS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$type"
>$type</a></h2>

<p>A constant with the name of your type. It contains the type&#39;s fully qualified name. Takes no value, as all constants.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="is_$type"
>is_$type</a></h2>

<p>This handler takes a value and tests if it is a valid value for this <code>$type</code>. It will return true or false.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="to_$type"
>to_$type</a></h2>

<p>A handler that will take a value and coerce it into the <code>$type</code>. It will return a false value if the type could not be coerced.</p>

<p><b>Important Note</b>: This handler will only be exported for types that can do type coercion. This has the advantage that a coercion to a type that has not defined any coercions will lead to a compile-time error.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="WRAPPING_A_LIBRARY"
>WRAPPING A LIBRARY</a></h1>

<p>You can define your own wrapper subclasses to manipulate the behaviour of a set of library exports. Here is an example:</p>

<pre>  package MyWrapper;
  use strict;
  use MRO::Compat;
  use base &#39;MooseX::Types::Wrapper&#39;;

  sub coercion_export_generator {
      my $class = shift;
      my $code = $class-&#62;next::method(@_);
      return sub {
          my $value = $code-&#62;(@_);
          warn &#34;Coercion returned undef!&#34;
              unless defined $value;
          return $value;
      };
  }

  1;</pre>

<p>This class wraps the coercion generator (e.g., <code>to_Int()</code>) and warns if a coercion returned an undefined value. You can wrap any library with this:</p>

<pre>  package Foo;
  use strict;
  use MyWrapper MyLibrary =&#62; [qw( Foo Bar )],
                Moose     =&#62; [qw( Str Int )];

  ...
  1;</pre>

<p>The <code>Moose</code> library name is a special shortcut for <a href="../MooseX/Types/Moose.html" class="podlinkpod"
>MooseX::Types::Moose</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Generator_methods_you_can_overload"
>Generator methods you can overload</a></h2>

<dl>
<dt><a name="type_export_generator(_$short,_$full_)"
>type_export_generator( $short, $full )</a></dt>

<dd>
<p>Creates a closure returning the type&#39;s <a href="../Moose/Meta/TypeConstraint.html" class="podlinkpod"
>Moose::Meta::TypeConstraint</a> object.</p>

<dt><a name="check_export_generator(_$short,_$full,_$undef_message_)"
>check_export_generator( $short, $full, $undef_message )</a></dt>

<dd>
<p>This creates the closure used to test if a value is valid for this type.</p>

<dt><a name="coercion_export_generator(_$short,_$full,_$undef_message_)"
>coercion_export_generator( $short, $full, $undef_message )</a></dt>

<dd>
<p>This is the closure that&#39;s doing coercions.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Provided_Parameters"
>Provided Parameters</a></h2>

<dl>
<dt><a name="$short"
>$short</a></dt>

<dd>
<p>The short, exported name of the type.</p>

<dt><a name="$full"
>$full</a></dt>

<dd>
<p>The fully qualified name of this type as <a href="../Moose.html" class="podlinkpod"
>Moose</a> knows it.</p>

<dt><a name="$undef_message"
>$undef_message</a></dt>

<dd>
<p>A message that will be thrown when type functionality is used but the type does not yet exist.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="RECURSIVE_SUBTYPES"
>RECURSIVE SUBTYPES</a></h1>

<p>As of version 0.08, <a href="../Moose/Types.html" class="podlinkpod"
>Moose::Types</a> has experimental support for Recursive subtypes. This will allow:</p>

<pre>    subtype Tree() =&#62; as HashRef[Str|Tree];</pre>

<p>Which validates things like:</p>

<pre>    {key=&#62;&#39;value&#39;};
    {key=&#62;{subkey1=&#62;&#39;value&#39;, subkey2=&#62;&#39;value&#39;}}</pre>

<p>And so on. This feature is new and there may be lurking bugs so don&#39;t be afraid to hunt me down with patches and test cases if you have trouble.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NOTES_REGARDING_TYPE_UNIONS"
>NOTES REGARDING TYPE UNIONS</a></h1>

<p><a href="../MooseX/Types.html" class="podlinkpod"
>MooseX::Types</a> uses <a href="../MooseX/Types/TypeDecorator.html" class="podlinkpod"
>MooseX::Types::TypeDecorator</a> to do some overloading which generally allows you to easily create union types:</p>

<pre>  subtype StrOrArrayRef,
      as Str|ArrayRef;</pre>

<p>As with parameterized constrains, this overloading extends to modules using the types you define in a type library.</p>

<pre>  use Moose;
  use MooseX::Types::Moose qw(HashRef Int);

  has &#39;attr&#39; =&#62; ( isa =&#62; HashRef | Int );</pre>

<p>And everything should just work as you&#39;d think.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="import"
>import</a></h2>

<p>Installs the <a href="../MooseX/Types/Base.html" class="podlinkpod"
>MooseX::Types::Base</a> class into the caller and exports types according to the specification described in <a href="#LIBRARY_DEFINITION" class="podlinkpod"
>&#34;LIBRARY DEFINITION&#34;</a>. This will continue to <a href="../Moose/Util/TypeConstraints.html" class="podlinkpod"
>Moose::Util::TypeConstraints</a>&#39; <code>import</code> method to export helper functions you will need to declare your types.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="type_export_generator"
>type_export_generator</a></h2>

<p>Generate a type export, e.g. <code>Int()</code>. This will return either a <a href="../Moose/Meta/TypeConstraint.html" class="podlinkpod"
>Moose::Meta::TypeConstraint</a> object, or alternatively a <a href="../MooseX/Types/UndefinedType.html" class="podlinkpod"
>MooseX::Types::UndefinedType</a> object if the type was not yet defined.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="create_arged_type_constraint_($name,_@args)"
>create_arged_type_constraint ($name, @args)</a></h2>

<p>Given a String $name with @args find the matching typeconstraint and parameterize it with @args.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="create_base_type_constraint_($name)"
>create_base_type_constraint ($name)</a></h2>

<p>Given a String $name, find the matching type constraint.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="create_type_decorator_($type_constraint)"
>create_type_decorator ($type_constraint)</a></h2>

<p>Given a $type_constraint, return a lightweight <a href="../MooseX/Types/TypeDecorator.html" class="podlinkpod"
>MooseX::Types::TypeDecorator</a> instance.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="coercion_export_generator"
>coercion_export_generator</a></h2>

<p>This generates a coercion handler function, e.g. <code>to_Int($value)</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="check_export_generator"
>check_export_generator</a></h2>

<p>Generates a constraint check closure, e.g. <code>is_Int($value)</code>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CAVEATS"
>CAVEATS</a></h1>

<p>The following are lists of gotchas and their workarounds for developers coming from the standard string based type constraint names</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Uniqueness"
>Uniqueness</a></h2>

<p>A library makes the types quasi-unique by prefixing their names with (by default) the library package name. If you&#39;re only using the type handler functions provided by MooseX::Types, you shouldn&#39;t ever have to use a type&#39;s actual full name.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Argument_separation_(&#39;=&#62;&#39;_versus_&#39;,&#39;)"
>Argument separation (&#39;=&#62;&#39; versus &#39;,&#39;)</a></h2>

<p>The <a href="../perlop.html" class="podlinkpod"
>perlop</a> manpage has this to say about the &#39;=&#62;&#39; operator: &#34;The =&#62; operator is a synonym for the comma, but forces any word (consisting entirely of word characters) to its left to be interpreted as a string (as of 5.001). This includes words that might otherwise be considered a constant or function call.&#34;</p>

<p>Due to this stringification, the following will NOT work as you might think:</p>

<pre>  subtype StrOrArrayRef =&#62; as Str | ArrayRef;</pre>

<p>The &#39;StrOrArrayRef&#39; will have its stringification activated this causes the subtype to not be created. Since the bareword type constraints are not strings you really should not try to treat them that way. You will have to use the &#39;,&#39; operator instead. The author&#39;s of this package realize that all the <a href="../Moose.html" class="podlinkpod"
>Moose</a> documention and examples nearly uniformly use the &#39;=&#62;&#39; version of the comma operator and this could be an issue if you are converting code.</p>

<p>Patches welcome for discussion.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Compatibility_with_Sub::Exporter"
>Compatibility with Sub::Exporter</a></h2>

<p>If you want to use <a href="../Sub/Exporter.html" class="podlinkpod"
>Sub::Exporter</a> with a Type Library, you need to make sure you export all the type constraints declared AS WELL AS any additional export targets. For example if you do:</p>

<pre>  package TypeAndSubExporter;

  use MooseX::Types::Moose qw(Str);
  use MooseX::Types -declare =&#62; [qw(MyStr)];
  use Sub::Exporter -setup =&#62; { exports =&#62; [qw(something)] };

  subtype MyStr, as Str;

  sub something {
      return 1;
  }

  # then in another module ...

  package Foo;
  use TypeAndSubExporter qw(MyStr);</pre>

<p>You&#39;ll get a &#39;&#34;MyStr&#34; is not exported by the TypeAndSubExporter module&#39; error. Upi can workaround by:</p>

<pre>  - use Sub::Exporter -setup =&#62; { exports =&#62; [ qw(something) ] };
  + use Sub::Exporter -setup =&#62; { exports =&#62; [ qw(something MyStr) ] };</pre>

<p>This is a workaround and I am exploring how to make these modules work better together. I realize this workaround will lead a lot of duplication in your export declarations and will be onerous for large type libraries. Patches and detailed test cases welcome. See the tests directory for a start on this.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COMBINING_TYPE_LIBRARIES"
>COMBINING TYPE LIBRARIES</a></h1>

<p>You may want to combine a set of types for your application with other type libraries, like <a href="../MooseX/Types/Moose.html" class="podlinkpod"
>MooseX::Types::Moose</a> or <a href="../MooseX/Types/Common/String.html" class="podlinkpod"
>MooseX::Types::Common::String</a>.</p>

<p>The <a href="../MooseX/Types/Combine.html" class="podlinkpod"
>MooseX::Types::Combine</a> module provides a simple API for combining a set of type libraries together.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../Moose.html" class="podlinkpod"
>Moose</a>, <a href="../Moose/Util/TypeConstraints.html" class="podlinkpod"
>Moose::Util::TypeConstraints</a>, <a href="../MooseX/Types/Moose.html" class="podlinkpod"
>MooseX::Types::Moose</a>, <a href="../Sub/Exporter.html" class="podlinkpod"
>Sub::Exporter</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ACKNOWLEDGEMENTS"
>ACKNOWLEDGEMENTS</a></h1>

<p>Many thanks to the <code>#moose</code> cabal on <code>irc.perl.org</code>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CONTRIBUTORS"
>CONTRIBUTORS</a></h1>

<p>jnapiorkowski: John Napiorkowski &#60;jjnapiork@cpan.org&#62;</p>

<p>caelum: Rafael Kitover &#60;rkitover@cpan.org&#62;</p>

<p>rafl: Florian Ragwitz &#60;rafl@debian.org&#62;</p>

<p>hdp: Hans Dieter Pearcey &#60;hdp@cpan.org&#62;</p>

<p>autarch: Dave Rolsky &#60;autarch@urth.org&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Robert &#34;phaylon&#34; Sedlacek &#60;rs@474.at&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>This software is copyright (c) 2012 by Robert &#34;phaylon&#34; Sedlacek.</p>

<p>This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
