<html><head><title>CGI::Simple::Standard</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:03 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Autoloading'>Autoloading</a>
    <li class='indexItem indexItem2'><a href='#Specified_Export'>Specified Export</a>
    <li class='indexItem indexItem2'><a href='#Mix_and_Match'>Mix and Match</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#%24POST_MAX_and_%24DISABLE_UPLOADS'>$POST_MAX and $DISABLE_UPLOADS</a>
  <li class='indexItem indexItem1'><a href='#EXPORT'>EXPORT</a>
  <li class='indexItem indexItem1'><a href='#FUNCTION_DETAILS'>FUNCTION DETAILS</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#CREDITS'>CREDITS</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>CGI::Simple::Standard - a wrapper module for CGI::Simple that provides a function style interface</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    use CGI::Simple::Standard qw( -autoload );
    use CGI::Simple::Standard qw( :core :cookie :header :misc );
    use CGI::Simple::Standard qw( param upload );

    $CGI::Simple::Standard::POST_MAX = 1024;       # max upload via post 1kB
    $CGI::Simple::Standard::DISABLE_UPLOADS = 0;   # enable uploads

    @params = param();        # return all param names as a list
    $value =  param(&#39;foo&#39;);   # return the first value supplied for &#39;foo&#39;
    @values = param(&#39;foo&#39;);   # return all values supplied for foo

    %fields   = Vars();       # returns untied key value pair hash
    $hash_ref = Vars();       # or as a hash ref
    %fields   = Vars(&#34;|&#34;);    # packs multiple values with &#34;|&#34; rather than &#34;\0&#34;;

    @keywords = keywords();   # return all keywords as a list

    param( &#39;foo&#39;, &#39;some&#39;, &#39;new&#39;, &#39;values&#39; );        # set new &#39;foo&#39; values
    param( -name=&#62;&#39;foo&#39;, -value=&#62;&#39;bar&#39; );
    param( -name=&#62;&#39;foo&#39;, -value=&#62;[&#39;bar&#39;,&#39;baz&#39;] );

    append( -name=&#62;&#39;foo&#39;, -value=&#62;&#39;bar&#39; );          # append values to &#39;foo&#39;
    append( -name=&#62;&#39;foo&#39;, -value=&#62;[&#39;some&#39;, &#39;new&#39;, &#39;values&#39;] );

    Delete(&#39;foo&#39;);   # delete param &#39;foo&#39; and all its values
    Delete_all();    # delete everything

    &#60;INPUT TYPE=&#34;file&#34; NAME=&#34;upload_file&#34; SIZE=&#34;42&#34;&#62;

    $files    = upload()                   # number of files uploaded
    @files    = upload();                  # names of all uploaded files
    $filename = param(&#39;upload_file&#39;)       # filename of &#39;upload_file&#39; field
    $mime     = upload_info($filename,&#39;mime&#39;); # MIME type of uploaded file
    $size     = upload_info($filename,&#39;size&#39;); # size of uploaded file

    my $fh = $q-&#62;upload($filename);     # open filehandle to read from
    while ( read( $fh, $buffer, 1024 ) ) { ... }

    # short and sweet upload
    $ok = upload( param(&#39;upload_file&#39;), &#39;/path/to/write/file.name&#39; );
    print &#34;Uploaded &#34;.param(&#39;upload_file&#39;).&#34; and wrote it OK!&#34; if $ok;

    $decoded    = url_decode($encoded);
    $encoded    = url_encode($unencoded);
    $escaped    = escapeHTML(&#39;&#60;&#62;&#34;&#38;&#39;);
    $unescaped  = unescapeHTML(&#39;&#38;lt;&#38;gt;&#38;quot;&#38;amp;&#39;);

    $qs = query_string();   # get all data in $q as a query string OK for GET

    no_cache(1);            # set Pragma: no-cache + expires
    print header();         # print a simple header
    # get a complex header
    $header = header(   -type       =&#62; &#39;image/gif&#39;
                        -nph        =&#62; 1,
                        -status     =&#62; &#39;402 Payment required&#39;,
                        -expires    =&#62;&#39;+24h&#39;,
                        -cookie     =&#62; $cookie,
                        -charset    =&#62; &#39;utf-7&#39;,
                        -attachment =&#62; &#39;foo.gif&#39;,
                        -Cost       =&#62; &#39;$2.00&#39;);

    @cookies = cookie();        # get names of all available cookies
    $value   = cookie(&#39;foo&#39;)    # get first value of cookie &#39;foo&#39;
    @value   = cookie(&#39;foo&#39;)    # get all values of cookie &#39;foo&#39;
    # get a cookie formatted for header() method
    $cookie  = cookie(  -name    =&#62; &#39;Password&#39;,
                        -values  =&#62; [&#39;superuser&#39;,&#39;god&#39;,&#39;my dog woofie&#39;],
                        -expires =&#62; &#39;+3d&#39;,
                        -domain  =&#62; &#39;.nowhere.com&#39;,
                        -path    =&#62; &#39;/cgi-bin/database&#39;,
                        -secure  =&#62; 1 );
    print header( -cookie=&#62;$cookie );       # set cookie

    print redirect(&#39;http://go.away.now&#39;);   # print a redirect header

    dienice( cgi_error() ) if cgi_error();</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This module is a wrapper for the completely object oriented CGI::Simple module and provides a simple functional style interface. It provides two different methods to import function names into your namespace.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Autoloading"
>Autoloading</a></h2>

<p>If you specify the &#39;-autoload&#39; pragma like this:</p>

<pre>    use CGI::Simple::Standard qw( -autoload );</pre>

<p>Then it will use AUTOLOAD and a symbol table trick to export only those subs you actually call into your namespace. When you specify the &#39;-autoload&#39; pragma this module exports a single AUTOLOAD subroutine into you namespace. This will clash with any AUTOLOAD sub that exists in the calling namespace so if you are using AUTOLOAD for something else don&#39;t use this pragma.</p>

<p>Anyway, when you call a subroutine that is not defined in your script this AUTOLOAD sub will be called. The first time this happens it will initialize a CGI::Simple object and then apply the requested method (if it exists) to it. A fatal exception will be thrown if you try to use an undefined method (function).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Specified_Export"
>Specified Export</a></h2>

<p>Alternatively you can specify the functions you wish to import. You can do this on a per function basis like this:</p>

<pre>    use CGI::Simple::Standard qw( param upload query_string Dump );</pre>

<p>or utilize the %EXPORT_TAGS that group functions into related groups. Here are the groupings:</p>

<pre>  %EXPORT_TAGS = (
    &#39;:html&#39;     =&#62; [ qw(:misc) ],
    &#39;:standard&#39; =&#62; [ qw(:core :access) ],
    &#39;:cgi&#39;      =&#62; [ qw(:core :access) ],
    &#39;:all&#39;      =&#62; [ qw(:core :misc :cookie :header :push :debug :cgi-lib
                        :access :internal) ],
    &#39;:core&#39;     =&#62; [ qw(param add_param param_fetch url_param keywords
                        append Delete delete_all Delete_all upload
                        query_string parse_query_string  parse_keywordlist
                        Vars save_parameters restore_parameters) ],
    &#39;:misc&#39;     =&#62; [ qw(url_decode url_encode escapeHTML unescapeHTML put) ],
    &#39;:cookie&#39;   =&#62; [ qw(cookie raw_cookie) ],
    &#39;:header&#39;   =&#62; [ qw(header cache no_cache redirect) ],
    &#39;:push&#39;     =&#62; [ qw(multipart_init multipart_start multipart_end
                        multipart_final) ],
    &#39;:debug&#39;    =&#62; [ qw(Dump as_string cgi_error _cgi_object) ],
    &#39;:cgi-lib&#39;  =&#62; [ qw(ReadParse SplitParam MethGet MethPost MyBaseUrl MyURL
                        MyFullUrl PrintHeader HtmlTop HtmlBot PrintVariables
                        PrintEnv CgiDie CgiError Vars) ],
    &#39;:ssl&#39;      =&#62; [ qw(https) ],
    &#39;:access&#39;   =&#62; [ qw(version nph all_parameters charset crlf globals
                        auth_type content_length content_type document_root
                        gateway_interface path_translated referer remote_addr
                        remote_host remote_ident remote_user request_method
                        script_name server_name server_port server_protocol
                        server_software user_name user_agent virtual_host
                        path_info Accept http https protocol url self_url
                        state) ],
    &#39;:internal&#39; =&#62; [ qw(_initialize_globals _use_cgi_pm_global_settings
                        _store_globals _reset_globals) ]
    );</pre>

<p>The familiar CGI.pm tags are available but do not include the HTML functionality. You specify the import of some function groups like this:</p>

<p>use CGI::Simple::Standard qw( :core :cookie :header );</p>

<p>Note that the function groups all start with a : char.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Mix_and_Match"
>Mix and Match</a></h2>

<p>You can use the &#39;-autoload&#39; pragma, specifically named function imports and tag group imports together if you desire.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="$POST_MAX_and_$DISABLE_UPLOADS"
>$POST_MAX and $DISABLE_UPLOADS</a></h1>

<p>If you wish to set $POST_MAX or $DISABLE_UPLOADS you must do this *after* the use statement and *before* the first function call as shown in the synopsis.</p>

<p>Unlike CGI.pm uploads are disabled by default and the maximum acceptable data via post is capped at 102_400kB rather than infinity. This is specifically to avoid denial of service attacks by default. To enable uploads and to allow them to be of infinite size you simply:</p>

<pre>    $CGI::Simple::Standard::POST_MAX = -1;         # infinite size upload
    $CGI::Simple::Standard::$DISABLE_UPLOADS = 0;  # enable uploads</pre>

<p>Alternatively you can specify the CGI.pm default values as shown above by specifying the &#39;-default&#39; pragma in your use statement.</p>

<pre>    use CGI::Simple::Standard qw( -default ..... );</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXPORT"
>EXPORT</a></h1>

<p>Nothing by default.</p>

<p>Under the &#39;-autoload&#39; pragma the AUTOLOAD subroutine is exported into the calling namespace. Additional subroutines are only imported into this namespace if you physically call them. They are installed in the symbol table the first time you use them to save repeated calls to AUTOLOAD.</p>

<p>If you specifically request a function or group of functions via an EXPORT_TAG then stubs of these functions are exported into the calling namespace. These stub functions will be replaced with the real functions only if you actually call them saving wasted compilation effort.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FUNCTION_DETAILS"
>FUNCTION DETAILS</a></h1>

<p>This is a wrapper module for CGI::Simple. Virtually all the methods available in the OO interface are available via the functional interface. Several method names are aliased to prevent namespace conflicts:</p>

<pre>    $q-&#62;delete(&#39;foo&#39;)   =&#62;  Delete(&#39;foo&#39;)
    $q-&#62;delete_all      =&#62;  Delete_all() or delete_all()
    $q-&#62;save(\*FH)      =&#62;  save_parameters(\*FH)
    $q-&#62;accept()        =&#62;  Accept()</pre>

<p>Although you could use the new() function to genrate new OO CGI::Simple objects the restore_parameters() function is a better choice as it operates like new but on the correct underlying CGI::Simple object for the functional interface.</p>

<p>restore_parameters() can be used exactly as you might use new() in that you can supply arguments to it such as query strings, hashes and file handles to re-initialize your underlying object.</p>

<pre>    $q-&#62;new CGI::Simple()                =&#62; restore_parameters()
    $q-&#62;new CGI::Simple({foo=&#62;&#39;bar&#39;})    =&#62; restore_parameters({foo=&#62;&#39;bar&#39;})
    $q-&#62;new CGI::Simple($query_string)   =&#62; restore_parameters($query_string)
    $q-&#62;new CGI::Simple(\*FH)            =&#62; restore_parameters(\*FH)</pre>

<p>For full details of the available functions see the CGI::Simple docs. Just remove the $q-&#62; part and use the method name directly.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>As this is 0.01 there are almost bound to be some.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Dr James Freeman &#60;jfreeman@tassie.net.au&#62; This release by Andy Armstrong &#60;andy@hexten.net&#62;</p>

<p>This package is free software and is provided &#34;as is&#34; without express or implied warranty. It may be used, redistributed and/or modified under the terms of the Perl Artistic License (see http://www.perl.com/perl/misc/Artistic.html)</p>

<p>Address bug reports and comments to: andy@hexten.net</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CREDITS"
>CREDITS</a></h1>

<p>The interface and key sections of the CGI::Simple code come from CGI.pm by Lincoln Stein.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../../CGI/Simple.html" class="podlinkpod"
>CGI::Simple</a> which is the back end for this module, <b>CGI.pm by Lincoln Stein</b></p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
