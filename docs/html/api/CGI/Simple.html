<html><head><title>CGI::Simple</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:03 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#CALLING_CGI%3A%3ASimple_ROUTINES_USING_THE_OBJECT_INTERFACE'>CALLING CGI::Simple ROUTINES USING THE OBJECT INTERFACE</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#First_you_need_to_initialize_an_object'>First you need to initialize an object</a>
    <li class='indexItem indexItem2'><a href='#Next_you_call_methods_on_that_object'>Next you call methods on that object</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#CALLING_CGI%3A%3ASimple_ROUTINES_USING_THE_FUNCTION_INTERFACE'>CALLING CGI::Simple ROUTINES USING THE FUNCTION INTERFACE</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Selecting_which_methods_to_load'>Selecting which methods to load</a>
    <li class='indexItem indexItem2'><a href='#To_Autoload_or_not_to_Autoload%2C_that_is_the_question.'>To Autoload or not to Autoload, that is the question.</a>
    <li class='indexItem indexItem2'><a href='#Setting_globals_using_the_functional_interface'>Setting globals using the functional interface</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#THE_CORE_METHODS'>THE CORE METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#new()_Creating_a_new_query_object'>new() Creating a new query object</a>
    <li class='indexItem indexItem2'><a href='#keywords()_Fetching_a_list_of_keywords_from_a_query'>keywords() Fetching a list of keywords from a query</a>
    <li class='indexItem indexItem2'><a href='#param()_Fetching_the_names_of_all_parameters_passed_to_your_script'>param() Fetching the names of all parameters passed to your script</a>
    <li class='indexItem indexItem2'><a href='#param()_Fetching_the_value_or_values_of_a_simple_named_parameter'>param() Fetching the value or values of a simple named parameter</a>
    <li class='indexItem indexItem2'><a href='#param()_Setting_the_values_of_a_named_parameter'>param() Setting the values of a named parameter</a>
    <li class='indexItem indexItem2'><a href='#param()_Retrieving_non-application%2Fx-www-form-urlencoded_data'>param() Retrieving non-application/x-www-form-urlencoded data</a>
    <li class='indexItem indexItem2'><a href='#add_param()_Setting_the_values_of_a_named_parameter'>add_param() Setting the values of a named parameter</a>
    <li class='indexItem indexItem2'><a href='#append()_Appending_values_to_a_named_parameter'>append() Appending values to a named parameter</a>
    <li class='indexItem indexItem2'><a href='#import_names()_Importing_all_parameters_into_a_namespace.'>import_names() Importing all parameters into a namespace.</a>
    <li class='indexItem indexItem2'><a href='#delete()_Deleting_a_parameter_completely'>delete() Deleting a parameter completely</a>
    <li class='indexItem indexItem2'><a href='#delete_all()_Deleting_all_parameters'>delete_all() Deleting all parameters</a>
    <li class='indexItem indexItem2'><a href='#param_fetch()_Direct_access_to_the_parameter_list'>param_fetch() Direct access to the parameter list</a>
    <li class='indexItem indexItem2'><a href='#Vars()_Fetching_the_entire_parameter_list_as_a_hash'>Vars() Fetching the entire parameter list as a hash</a>
    <li class='indexItem indexItem2'><a href='#url_param()_Access_the_QUERY_STRING_regardless_of_%27GET%27_or_%27POST%27'>url_param() Access the QUERY_STRING regardless of &#39;GET&#39; or &#39;POST&#39;</a>
    <li class='indexItem indexItem2'><a href='#parse_query_string()_Add_QUERY_STRING_data_to_%27POST%27_requests'>parse_query_string() Add QUERY_STRING data to &#39;POST&#39; requests</a>
    <li class='indexItem indexItem2'><a href='#save()_Saving_the_state_of_an_object_to_file'>save() Saving the state of an object to file</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#FILE_UPLOADS'>FILE UPLOADS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#upload()_The_key_file_upload_method'>upload() The key file upload method</a>
    <li class='indexItem indexItem2'><a href='#upload_info()_Get_the_details_about_uploaded_files'>upload_info() Get the details about uploaded files</a>
    <li class='indexItem indexItem2'><a href='#%24POST_MAX_and_%24DISABLE_UPLOADS'>$POST_MAX and $DISABLE_UPLOADS</a>
    <li class='indexItem indexItem2'><a href='#binmode()_and_Win32'>binmode() and Win32</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#MISCELANEOUS_METHODS'>MISCELANEOUS METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#escapeHTML()_Escaping_HTML_special_characters'>escapeHTML() Escaping HTML special characters</a>
    <li class='indexItem indexItem2'><a href='#unescapeHTML()_Unescape_HTML_special_characters'>unescapeHTML() Unescape HTML special characters</a>
    <li class='indexItem indexItem2'><a href='#url_decode()_Decode_a_URL_encoded_string'>url_decode() Decode a URL encoded string</a>
    <li class='indexItem indexItem2'><a href='#url_encode()_URL_encode_a_string'>url_encode() URL encode a string</a>
    <li class='indexItem indexItem2'><a href='#parse_keywordlist()_Parse_a_supplied_keyword_list'>parse_keywordlist() Parse a supplied keyword list</a>
    <li class='indexItem indexItem2'><a href='#put()_Send_output_to_browser'>put() Send output to browser</a>
    <li class='indexItem indexItem2'><a href='#print()_Send_output_to_browser'>print() Send output to browser</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#HTTP_COOKIES'>HTTP COOKIES</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#cookie()_A_simple_access_method_to_cookies'>cookie() A simple access method to cookies</a>
    <li class='indexItem indexItem2'><a href='#raw_cookie()'>raw_cookie()</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#CREATING_HTTP_HEADERS'>CREATING HTTP HEADERS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#header()_Create_simple_or_complex_HTTP_headers'>header() Create simple or complex HTTP headers</a>
    <li class='indexItem indexItem2'><a href='#no_cache()_Preventing_browser_caching_of_scripts'>no_cache() Preventing browser caching of scripts</a>
    <li class='indexItem indexItem2'><a href='#cache()_Preventing_browser_caching_of_scripts'>cache() Preventing browser caching of scripts</a>
    <li class='indexItem indexItem2'><a href='#redirect()_Generating_a_redirection_header'>redirect() Generating a redirection header</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#PRAGMAS'>PRAGMAS</a>
  <li class='indexItem indexItem1'><a href='#USING_NPH_SCRIPTS'>USING NPH SCRIPTS</a>
  <li class='indexItem indexItem1'><a href='#SERVER_PUSH'>SERVER PUSH</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#multipart_init()_Initialize_the_multipart_system'>multipart_init() Initialize the multipart system</a>
    <li class='indexItem indexItem2'><a href='#multipart_start()_Start_a_new_part_of_the_multipart_document'>multipart_start() Start a new part of the multipart document</a>
    <li class='indexItem indexItem2'><a href='#multipart_end()_End_a_multipart_part'>multipart_end() End a multipart part</a>
    <li class='indexItem indexItem2'><a href='#multipart_final()'>multipart_final()</a>
    <li class='indexItem indexItem2'><a href='#CGI%3A%3APush'>CGI::Push</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#DEBUGGING'>DEBUGGING</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Dump()_Dumping_the_current_object_details'>Dump() Dumping the current object details</a>
    <li class='indexItem indexItem2'><a href='#PrintEnv()_Dumping_the_environment'>PrintEnv() Dumping the environment</a>
    <li class='indexItem indexItem2'><a href='#cgi_error()_Retrieving_CGI%3A%3ASimple_error_messages'>cgi_error() Retrieving CGI::Simple error messages</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#ACCESSOR_METHODS'>ACCESSOR METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#version()_Get_the_CGI%3A%3ASimple_version_info'>version() Get the CGI::Simple version info</a>
    <li class='indexItem indexItem2'><a href='#nph()_Enable%2Fdisable_NPH_(Non_Parsed_Header)_mode'>nph() Enable/disable NPH (Non Parsed Header) mode</a>
    <li class='indexItem indexItem2'><a href='#all_parameters()_Get_the_names%2Fvalues_of_all_parameters'>all_parameters() Get the names/values of all parameters</a>
    <li class='indexItem indexItem2'><a href='#charset()_Get%2Fset_the_current_character_set.'>charset() Get/set the current character set.</a>
    <li class='indexItem indexItem2'><a href='#crlf()_Get_the_system_specific_line_ending_sequence'>crlf() Get the system specific line ending sequence</a>
    <li class='indexItem indexItem2'><a href='#globals()_Get%2Fset_the_value_of_the_remaining_global_variables'>globals() Get/set the value of the remaining global variables</a>
    <li class='indexItem indexItem2'><a href='#auth_type()_Get_the_current_authorization%2Fverification_method'>auth_type() Get the current authorization/verification method</a>
    <li class='indexItem indexItem2'><a href='#content_length()_Get_the_content_length_submitted_in_a_POST'>content_length() Get the content length submitted in a POST</a>
    <li class='indexItem indexItem2'><a href='#content_type()_Get_the_content_type_of_data_submitted_in_a_POST'>content_type() Get the content_type of data submitted in a POST</a>
    <li class='indexItem indexItem2'><a href='#document_root()_Get_the_document_root'>document_root() Get the document root</a>
    <li class='indexItem indexItem2'><a href='#gateway_interface()_Get_the_gateway_interface'>gateway_interface() Get the gateway interface</a>
    <li class='indexItem indexItem2'><a href='#path_translated()_Get_the_value_of_path_translated'>path_translated() Get the value of path translated</a>
    <li class='indexItem indexItem2'><a href='#referer()_Spy_on_your_users'>referer() Spy on your users</a>
    <li class='indexItem indexItem2'><a href='#remote_addr()_Get_the_remote_address'>remote_addr() Get the remote address</a>
    <li class='indexItem indexItem2'><a href='#remote_host()_Get_a_value_for_remote_host'>remote_host() Get a value for remote host</a>
    <li class='indexItem indexItem2'><a href='#remote_ident()_Get_the_remote_identity'>remote_ident() Get the remote identity</a>
    <li class='indexItem indexItem2'><a href='#remote_user()_Get_the_remote_user'>remote_user() Get the remote user</a>
    <li class='indexItem indexItem2'><a href='#request_method()_Get_the_request_method'>request_method() Get the request method</a>
    <li class='indexItem indexItem2'><a href='#script_name()_Get_the_script_name'>script_name() Get the script name</a>
    <li class='indexItem indexItem2'><a href='#server_name()_Get_the_server_name'>server_name() Get the server name</a>
    <li class='indexItem indexItem2'><a href='#server_port()_Get_the_port_the_server_is_listening_on'>server_port() Get the port the server is listening on</a>
    <li class='indexItem indexItem2'><a href='#server_protocol()_Get_the_current_server_protocol'>server_protocol() Get the current server protocol</a>
    <li class='indexItem indexItem2'><a href='#server_software()_Get_the_server_software'>server_software() Get the server software</a>
    <li class='indexItem indexItem2'><a href='#user_name()_Get_a_value_for_the_user_name.'>user_name() Get a value for the user name.</a>
    <li class='indexItem indexItem2'><a href='#user_agent()_Get_the_users_browser_type'>user_agent() Get the users browser type</a>
    <li class='indexItem indexItem2'><a href='#virtual_host()_Get_the_virtual_host'>virtual_host() Get the virtual host</a>
    <li class='indexItem indexItem2'><a href='#path_info()_Get_any_extra_path_info_set_to_the_script'>path_info() Get any extra path info set to the script</a>
    <li class='indexItem indexItem2'><a href='#Accept()_Get_the_browser_MIME_types'>Accept() Get the browser MIME types</a>
    <li class='indexItem indexItem2'><a href='#accept()_Alias_for_Accept()'>accept() Alias for Accept()</a>
    <li class='indexItem indexItem2'><a href='#http()_Get_a_range_of_HTTP_related_information'>http() Get a range of HTTP related information</a>
    <li class='indexItem indexItem2'><a href='#https()_Get_a_range_of_HTTPS_related_information'>https() Get a range of HTTPS related information</a>
    <li class='indexItem indexItem2'><a href='#protocol()_Get_the_current_protocol'>protocol() Get the current protocol</a>
    <li class='indexItem indexItem2'><a href='#url()_Return_the_script%27s_URL_in_several_formats'>url() Return the script&#39;s URL in several formats</a>
    <li class='indexItem indexItem2'><a href='#self_url()_Get_the_scripts_complete_URL'>self_url() Get the scripts complete URL</a>
    <li class='indexItem indexItem2'><a href='#state()_Alias_for_self_url()'>state() Alias for self_url()</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#COMPATIBILITY_WITH_cgi-lib.pl_2.18'>COMPATIBILITY WITH cgi-lib.pl 2.18</a>
  <li class='indexItem indexItem1'><a href='#COMPATIBILITY_WITH_CGI.pm'>COMPATIBILITY WITH CGI.pm</a>
  <li class='indexItem indexItem1'><a href='#DIFFERENCES_FROM_CGI.pm'>DIFFERENCES FROM CGI.pm</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Globals_Variables'>Globals Variables</a>
    <li class='indexItem indexItem2'><a href='#Changes_to_pragmas'>Changes to pragmas</a>
    <li class='indexItem indexItem2'><a href='#Filehandles'>Filehandles</a>
    <li class='indexItem indexItem2'><a href='#Hash_interface'>Hash interface</a>
    <li class='indexItem indexItem2'><a href='#cgi-lib.pl'>cgi-lib.pl</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#CGI%3A%3ASimple_COMPLETE_METHOD_LIST'>CGI::Simple COMPLETE METHOD LIST</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Guts_(hands_off%2C_except_of_course_for_new)'>Guts (hands off, except of course for new)</a>
    <li class='indexItem indexItem2'><a href='#Core_Methods'>Core Methods</a>
    <li class='indexItem indexItem2'><a href='#Save_and_Restore_from_File_Methods'>Save and Restore from File Methods</a>
    <li class='indexItem indexItem2'><a href='#Miscellaneous_Methods'>Miscellaneous Methods</a>
    <li class='indexItem indexItem2'><a href='#Cookie_Methods'>Cookie Methods</a>
    <li class='indexItem indexItem2'><a href='#Header_Methods'>Header Methods</a>
    <li class='indexItem indexItem2'><a href='#Server_Push_Methods'>Server Push Methods</a>
    <li class='indexItem indexItem2'><a href='#Debugging_Methods'>Debugging Methods</a>
    <li class='indexItem indexItem2'><a href='#cgi-lib.pl_Compatibility_Routines_-_all_2.18_functions_available'>cgi-lib.pl Compatibility Routines - all 2.18 functions available</a>
    <li class='indexItem indexItem2'><a href='#Accessor_Methods'>Accessor Methods</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#NEW_METHODS_IN_CGI%3A%3ASimple'>NEW METHODS IN CGI::Simple</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Internal_Routines'>Internal Routines</a>
    <li class='indexItem indexItem2'><a href='#New_Public_Methods'>New Public Methods</a>
    <li class='indexItem indexItem2'><a href='#cgi-lib.pl_methods_added_for_completeness'>cgi-lib.pl methods added for completeness</a>
    <li class='indexItem indexItem2'><a href='#New_Accessors'>New Accessors</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#METHODS_IN_CGI.pm_NOT_IN_CGI%3A%3ASimple'>METHODS IN CGI.pm NOT IN CGI::Simple</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Guts_-_rearranged%2C_recoded%2C_renamed_and_hacked_out_of_existence'>Guts - rearranged, recoded, renamed and hacked out of existence</a>
    <li class='indexItem indexItem2'><a href='#HTML_Related'>HTML Related</a>
    <li class='indexItem indexItem2'><a href='#Upload_Related'>Upload Related</a>
    <li class='indexItem indexItem2'><a href='#Really_Private_Subs_(marked_as_so)'>Really Private Subs (marked as so)</a>
    <li class='indexItem indexItem2'><a href='#Internal_Multipart_Parsing_Routines'>Internal Multipart Parsing Routines</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#EXPORT'>EXPORT</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR_INFORMATION'>AUTHOR INFORMATION</a>
  <li class='indexItem indexItem1'><a href='#CREDITS'>CREDITS</a>
  <li class='indexItem indexItem1'><a href='#LICENCE_AND_COPYRIGHT'>LICENCE AND COPYRIGHT</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>CGI::Simple - A Simple totally OO CGI interface that is CGI.pm compliant</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>This document describes CGI::Simple version 1.113.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    use CGI::Simple;
    $CGI::Simple::POST_MAX = 1024;       # max upload via post default 100kB
    $CGI::Simple::DISABLE_UPLOADS = 0;   # enable uploads

    $q = new CGI::Simple;
    $q = new CGI::Simple( { &#39;foo&#39;=&#62;&#39;1&#39;, &#39;bar&#39;=&#62;[2,3,4] } );
    $q = new CGI::Simple( &#39;foo=1&#38;bar=2&#38;bar=3&#38;bar=4&#39; );
    $q = new CGI::Simple( \*FILEHANDLE );

    $q-&#62;save( \*FILEHANDLE );   # save current object to a file as used by new

    @params = $q-&#62;param;        # return all param names as a list
    $value = $q-&#62;param(&#39;foo&#39;);  # return the first value supplied for &#39;foo&#39;
    @values = $q-&#62;param(&#39;foo&#39;); # return all values supplied for foo

    %fields   = $q-&#62;Vars;      # returns untied key value pair hash
    $hash_ref = $q-&#62;Vars;      # or as a hash ref
    %fields   = $q-&#62;Vars(&#34;|&#34;); # packs multiple values with &#34;|&#34; rather than &#34;\0&#34;;

    @keywords = $q-&#62;keywords;  # return all keywords as a list

    $q-&#62;param( &#39;foo&#39;, &#39;some&#39;, &#39;new&#39;, &#39;values&#39; );      # set new &#39;foo&#39; values
    $q-&#62;param( -name=&#62;&#39;foo&#39;, -value=&#62;&#39;bar&#39; );
    $q-&#62;param( -name=&#62;&#39;foo&#39;, -value=&#62;[&#39;bar&#39;,&#39;baz&#39;] );

    $q-&#62;param( &#39;foo&#39;, &#39;some&#39;, &#39;new&#39;, &#39;values&#39; );      # append values to &#39;foo&#39;
    $q-&#62;append( -name=&#62;&#39;foo&#39;, -value=&#62;&#39;bar&#39; );
    $q-&#62;append( -name=&#62;&#39;foo&#39;, -value=&#62;[&#39;some&#39;, &#39;new&#39;, &#39;values&#39;] );

    $q-&#62;delete(&#39;foo&#39;); # delete param &#39;foo&#39; and all its values
    $q-&#62;delete_all;    # delete everything

    &#60;INPUT TYPE=&#34;file&#34; NAME=&#34;upload_file&#34; SIZE=&#34;42&#34;&#62;

    $files    = $q-&#62;upload()                # number of files uploaded
    @files    = $q-&#62;upload();               # names of all uploaded files
    $filename = $q-&#62;param(&#39;upload_file&#39;)    # filename of uploaded file
    $mime     = $q-&#62;upload_info($filename,&#39;mime&#39;); # MIME type of uploaded file
    $size     = $q-&#62;upload_info($filename,&#39;size&#39;); # size of uploaded file

    my $fh = $q-&#62;upload($filename);         # get filehandle to read from
    while ( read( $fh, $buffer, 1024 ) ) { ... }

    # short and sweet upload
    $ok = $q-&#62;upload( $q-&#62;param(&#39;upload_file&#39;), &#39;/path/to/write/file.name&#39; );
    print &#34;Uploaded &#34;.$q-&#62;param(&#39;upload_file&#39;).&#34; and wrote it OK!&#34; if $ok;

    $decoded    = $q-&#62;url_decode($encoded);
    $encoded    = $q-&#62;url_encode($unencoded);
    $escaped    = $q-&#62;escapeHTML(&#39;&#60;&#62;&#34;&#38;&#39;);
    $unescaped  = $q-&#62;unescapeHTML(&#39;&#38;lt;&#38;gt;&#38;quot;&#38;amp;&#39;);

    $qs = $q-&#62;query_string; # get all data in $q as a query string OK for GET

    $q-&#62;no_cache(1);        # set Pragma: no-cache + expires
    print $q-&#62;header();     # print a simple header
    # get a complex header
    $header = $q-&#62;header(   -type       =&#62; &#39;image/gif&#39;
                            -nph        =&#62; 1,
                            -status     =&#62; &#39;402 Payment required&#39;,
                            -expires    =&#62;&#39;+24h&#39;,
                            -cookie     =&#62; $cookie,
                            -charset    =&#62; &#39;utf-7&#39;,
                            -attachment =&#62; &#39;foo.gif&#39;,
                            -Cost       =&#62; &#39;$2.00&#39;
                        );
    # a p3p header (OK for redirect use as well)
    $header = $q-&#62;header( -p3p =&#62; &#39;policyref=&#34;http://somesite.com/P3P/PolicyReferences.xml&#39; );

    @cookies = $q-&#62;cookie();        # get names of all available cookies
    $value   = $q-&#62;cookie(&#39;foo&#39;)    # get first value of cookie &#39;foo&#39;
    @value   = $q-&#62;cookie(&#39;foo&#39;)    # get all values of cookie &#39;foo&#39;
    # get a cookie formatted for header() method
    $cookie  = $q-&#62;cookie(  -name    =&#62; &#39;Password&#39;,
                            -values  =&#62; [&#39;superuser&#39;,&#39;god&#39;,&#39;my dog woofie&#39;],
                            -expires =&#62; &#39;+3d&#39;,
                            -domain  =&#62; &#39;.nowhere.com&#39;,
                            -path    =&#62; &#39;/cgi-bin/database&#39;,
                            -secure  =&#62; 1
                         );
    print $q-&#62;header( -cookie=&#62;$cookie );       # set cookie

    print $q-&#62;redirect(&#39;http://go.away.now&#39;);   # print a redirect header

    dienice( $q-&#62;cgi_error ) if $q-&#62;cgi_error;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>CGI::Simple provides a relatively lightweight drop in replacement for CGI.pm. It shares an identical OO interface to CGI.pm for parameter parsing, file upload, cookie handling and header generation. This module is entirely object oriented, however a complete functional interface is available by using the CGI::Simple::Standard module.</p>

<p>Essentially everything in CGI.pm that relates to the CGI (not HTML) side of things is available. There are even a few new methods and additions to old ones! If you are interested in what has gone on under the hood see the Compatibility with CGI.pm section at the end.</p>

<p>In practical testing this module loads and runs about twice as fast as CGI.pm depending on the precise task.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CALLING_CGI::Simple_ROUTINES_USING_THE_OBJECT_INTERFACE"
>CALLING CGI::Simple ROUTINES USING THE OBJECT INTERFACE</a></h1>

<p>Here is a very brief rundown on how you use the interface. Full details follow.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="First_you_need_to_initialize_an_object"
>First you need to initialize an object</a></h2>

<p>Before you can call a CGI::Simple method you must create a CGI::Simple object. You do that by using the module and then calling the new() constructor:</p>

<pre>    use CGI::Simple;
    my $q = new CGI::Simple;</pre>

<p>It is traditional to call your object $q for query or perhaps $cgi.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Next_you_call_methods_on_that_object"
>Next you call methods on that object</a></h2>

<p>Once you have your object you can call methods on it using the -&#62; arrow syntax For example to get the names of all the parameters passed to your script you would just write:</p>

<pre>    @names = $q-&#62;param();</pre>

<p>Many methods are sensitive to the context in which you call them. In the example above the <b>param()</b> method returns a list of all the parameter names when called without any arguments.</p>

<p>When you call <b>param(&#39;arg&#39;)</b> with a single argument it assumes you want to get the value(s) associated with that argument (parameter). If you ask for an array it gives you an array of all the values associated with it&#39;s argument:</p>

<pre>    @values = $q-&#62;param(&#39;foo&#39;);  # get all the values for &#39;foo&#39;</pre>

<p>whereas if you ask for a scalar like this:</p>

<pre>    $value = $q-&#62;param(&#39;foo&#39;);   # get only the first value for &#39;foo&#39;</pre>

<p>then it returns only the first value (if more than one value for &#39;foo&#39; exists).</p>

<p>Most CGI::Simple routines accept several arguments, sometimes as many as 10 optional ones! To simplify this interface, all routines use a named argument calling style that looks like this:</p>

<pre>    print $q-&#62;header( -type=&#62;&#39;image/gif&#39;, -expires=&#62;&#39;+3d&#39; );</pre>

<p>Each argument name is preceded by a dash. Neither case nor order matters in the argument list. -type, -Type, and -TYPE are all acceptable.</p>

<p>Several routines are commonly called with just one argument. In the case of these routines you can provide the single argument without an argument name. <b>header()</b> happens to be one of these routines. In this case, the single argument is the document type.</p>

<pre>   print $q-&#62;header(&#39;text/html&#39;);</pre>

<p>Sometimes methods expect a scalar, sometimes a reference to an array, and sometimes a reference to a hash. Often, you can pass any type of argument and the routine will do whatever is most appropriate. For example, the <b>param()</b> method can be used to set a CGI parameter to a single or a multi-valued value. The two cases are shown below:</p>

<pre>   $q-&#62;param(-name=&#62;&#39;veggie&#39;,-value=&#62;&#39;tomato&#39;);
   $q-&#62;param(-name=&#62;&#39;veggie&#39;,-value=&#62;[&#39;tomato&#39;,&#39;tomahto&#39;,&#39;potato&#39;,&#39;potahto&#39;]);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CALLING_CGI::Simple_ROUTINES_USING_THE_FUNCTION_INTERFACE"
>CALLING CGI::Simple ROUTINES USING THE FUNCTION INTERFACE</a></h1>

<p>For convenience a functional interface is provided by the CGI::Simple::Standard module. This hides the OO details from you and allows you to simply call methods. You may either use AUTOLOADING of methods or import specific method sets into you namespace. Here are the first few examples again using the function interface.</p>

<pre>    use CGI::Simple::Standard qw(-autoload);
    @names  = param();
    @values = param(&#39;foo&#39;);
    $value  = param(&#39;foo&#39;);
    print header(-type=&#62;&#39;image/gif&#39;,-expires=&#62;&#39;+3d&#39;);
    print header(&#39;text/html&#39;);</pre>

<p>Yes that&#39;s it. Not a $q-&#62; in sight. You just use the module and select how/which methods to load. You then just call the methods you want exactly as before but without the $q-&#62; notation.</p>

<p>When (if) you read the following docs and are using the functional interface just pretend the $q-&#62; is not there.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Selecting_which_methods_to_load"
>Selecting which methods to load</a></h2>

<p>When you use the functional interface Perl needs to be able to find the functions you call. The simplest way of doing this is to use autoloading as shown above. When you use CGI::Simple::Standard with the &#39;-autoload&#39; pragma it exports a single AUTOLOAD sub into you namespace. Every time you call a non existent function AUTOLOAD is called and will load the required function and install it in your namespace. Thus only the AUTOLOAD sub and those functions you specifically call will be imported.</p>

<p>Alternatively CGI::Simple::Standard provides a range of function sets you can import or you can just select exactly what you want. You do this using the familiar</p>

<pre>    use CGI::Simple::Standard qw( :func_set  some_func);</pre>

<p>notation. This will import the &#39;:func_set&#39; function set and the specific function &#39;some_func&#39;.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="To_Autoload_or_not_to_Autoload,_that_is_the_question."
>To Autoload or not to Autoload, that is the question.</a></h2>

<p>If you do not have a AUTOLOAD sub in you script it is generally best to use the &#39;-autoload&#39; option. Under autoload you can use any method you want but only import and compile those functions you actually use.</p>

<p>If you do not use autoload you must specify what functions to import. You can only use functions that you have imported. For comvenience functions are grouped into related sets. If you choose to import one or more &#39;:func_set&#39; you may have potential namespace collisions so check out the docs to see what gets imported. Using the &#39;:all&#39; tag is pretty slack but it is there if you want. Full details of the function sets are provided in the CGI::Simple::Standard docs</p>

<p>If you just want say the param and header methods just load these two.</p>

<pre>    use CGI::Simple::Standard qw(param header);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Setting_globals_using_the_functional_interface"
>Setting globals using the functional interface</a></h2>

<p>Where you see global variables being set using the syntax:</p>

<pre>    $CGI::Simple::DEBUG = 1;</pre>

<p>You use exactly the same syntax when using CGI::Simple::Standard.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="THE_CORE_METHODS"
>THE CORE METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="new()_Creating_a_new_query_object"
>new() Creating a new query object</a></h2>

<p>The first step in using CGI::Simple is to create a new query object using the <b>new()</b> constructor:</p>

<pre>     $q = new CGI::Simple;</pre>

<p>This will parse the input (from both POST and GET methods) and store it into an object called $q.</p>

<p>If you provide a file handle to the <b>new()</b> method, it will read parameters from the file (or STDIN, or whatever).</p>

<pre>     open FH, &#34;test.in&#34; or die $!;
     $q = new CGI::Simple(\*FH);

     open $fh, &#34;test.in&#34; or die $!;
     $q = new CGI::Simple($fh);</pre>

<p>The file should be a series of newline delimited TAG=VALUE pairs. Conveniently, this type of file is created by the <b>save()</b> method (see below). Multiple records can be saved and restored. IO::File objects work fine.</p>

<p>If you are using the function-oriented interface provided by CGI::Simple::Standard and want to initialize from a file handle, the way to do this is with <b>restore_parameters()</b>. This will (re)initialize the default CGI::Simple object from the indicated file handle.</p>

<pre>    restore_parameters(\*FH);</pre>

<p>In fact for all intents and purposes <b>restore_parameters()</b> is identical to <b>new()</b> Note that <b>restore_parameters()</b> does not exist in CGI::Simple itself so you can&#39;t use it.</p>

<p>You can also initialize the query object from an associative array reference:</p>

<pre>    $q = new CGI::Simple( { &#39;dinosaur&#39; =&#62; &#39;barney&#39;,
                            &#39;song&#39;     =&#62; &#39;I love you&#39;,
                            &#39;friends&#39;  =&#62; [qw/Jessica George Nancy/] }
                        );</pre>

<p>or from a properly formatted, URL-escaped query string:</p>

<pre>    $q = new CGI::Simple( &#39;dinosaur=barney&#38;color=purple&#39; );</pre>

<p>or from a previously existing CGI::Simple object (this generates an identical clone including all global variable settings, etc that are stored in the object):</p>

<pre>    $old_query = new CGI::Simple;
    $new_query = new CGI::Simple($old_query);</pre>

<p>To create an empty query, initialize it from an empty string or hash:</p>

<pre>    $empty_query = new CGI::Simple(&#34;&#34;);

       -or-

    $empty_query = new CGI::Simple({});</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="keywords()_Fetching_a_list_of_keywords_from_a_query"
>keywords() Fetching a list of keywords from a query</a></h2>

<pre>    @keywords = $q-&#62;keywords;</pre>

<p>If the script was invoked as the result of an &#60;ISINDEX&#62; search, the parsed keywords can be obtained as an array using the <b>keywords()</b> method.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="param()_Fetching_the_names_of_all_parameters_passed_to_your_script"
>param() Fetching the names of all parameters passed to your script</a></h2>

<pre>    @names = $q-&#62;param;</pre>

<p>If the script was invoked with a parameter list (e.g. &#34;name1=value1&#38;name2=value2&#38;name3=value3&#34;), the <b>param()</b> method will return the parameter names as a list. If the script was invoked as an &#60;ISINDEX&#62; script and contains a string without ampersands (e.g. &#34;value1+value2+value3&#34;) , there will be a single parameter named &#34;keywords&#34; containing the &#34;+&#34;-delimited keywords.</p>

<p>NOTE: The array of parameter names returned will be in the same order as they were submitted by the browser. Usually this order is the same as the order in which the parameters are defined in the form (however, this isn&#39;t part of the spec, and so isn&#39;t guaranteed).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="param()_Fetching_the_value_or_values_of_a_simple_named_parameter"
>param() Fetching the value or values of a simple named parameter</a></h2>

<pre>    @values = $q-&#62;param(&#39;foo&#39;);

          -or-

    $value = $q-&#62;param(&#39;foo&#39;);</pre>

<p>Pass the <b>param()</b> method a single argument to fetch the value of the named parameter. If the parameter is multi-valued (e.g. from multiple selections in a scrolling list), you can ask to receive an array. Otherwise the method will return a single value.</p>

<p>If a value is not given in the query string, as in the queries &#34;name1=&#38;name2=&#34; or &#34;name1&#38;name2&#34;, it will be returned by default as an empty string. If you set the global variable:</p>

<pre>    $CGI::Simple::NO_UNDEF_PARAMS = 1;</pre>

<p>Then value-less parameters will be ignored, and will not exist in the query object. If you try to access them via param you will get an undef return value.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="param()_Setting_the_values_of_a_named_parameter"
>param() Setting the values of a named parameter</a></h2>

<pre>    $q-&#62;param(&#39;foo&#39;,&#39;an&#39;,&#39;array&#39;,&#39;of&#39;,&#39;values&#39;);</pre>

<p>This sets the value for the named parameter &#39;foo&#39; to an array of values. This is one way to change the value of a field.</p>

<p><b>param()</b> also recognizes a named parameter style of calling described in more detail later:</p>

<pre>    $q-&#62;param(-name=&#62;&#39;foo&#39;,-values=&#62;[&#39;an&#39;,&#39;array&#39;,&#39;of&#39;,&#39;values&#39;]);

                  -or-

    $q-&#62;param(-name=&#62;&#39;foo&#39;,-value=&#62;&#39;the value&#39;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="param()_Retrieving_non-application/x-www-form-urlencoded_data"
>param() Retrieving non-application/x-www-form-urlencoded data</a></h2>

<p>If POSTed or PUTed data is not of type application/x-www-form-urlencoded or multipart/form-data, then the data will not be processed, but instead be returned as-is in a parameter named POSTDATA or PUTDATA. To retrieve it, use code like this:</p>

<pre>    my $data = $q-&#62;param( &#39;POSTDATA&#39; );

                  -or-

    my $data = $q-&#62;param( &#39;PUTDATA&#39; );</pre>

<p>(If you don&#39;t know what the preceding means, don&#39;t worry about it. It only affects people trying to use CGI::Simple for REST webservices)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="add_param()_Setting_the_values_of_a_named_parameter"
>add_param() Setting the values of a named parameter</a></h2>

<p>You nay also use the new method <b>add_param</b> to add parameters. This is an alias to the _add_param() internal method that actually does all the work. You can call it like this:</p>

<pre>    $q-&#62;add_param(&#39;foo&#39;, &#39;new&#39;);
    $q-&#62;add_param(&#39;foo&#39;, [1,2,3,4,5]);
    $q-&#62;add_param( &#39;foo&#39;, &#39;bar&#39;, &#39;overwrite&#39; );</pre>

<p>The first argument is the parameter, the second the value or an array ref of values and the optional third argument sets overwrite mode. If the third argument is absent of false the values will be appended. If true the values will overwrite any existing ones</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="append()_Appending_values_to_a_named_parameter"
>append() Appending values to a named parameter</a></h2>

<pre>   $q-&#62;append(-name=&#62;&#39;foo&#39;,-values=&#62;[&#39;yet&#39;,&#39;more&#39;,&#39;values&#39;]);</pre>

<p>This adds a value or list of values to the named parameter. The values are appended to the end of the parameter if it already exists. Otherwise the parameter is created. Note that this method only recognizes the named argument calling syntax.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="import_names()_Importing_all_parameters_into_a_namespace."
>import_names() Importing all parameters into a namespace.</a></h2>

<p>This method was silly, non OO and has been deleted. You can get all the params as a hash using <b>Vars</b> or via all the other accessors.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="delete()_Deleting_a_parameter_completely"
>delete() Deleting a parameter completely</a></h2>

<pre>    $q-&#62;delete(&#39;foo&#39;);</pre>

<p>This completely clears a parameter. If you are using the function call interface, use <b>Delete()</b> instead to avoid conflicts with Perl&#39;s built-in delete operator.</p>

<p>If you are using the function call interface, use <b>Delete()</b> instead to avoid conflicts with Perl&#39;s built-in delete operator.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="delete_all()_Deleting_all_parameters"
>delete_all() Deleting all parameters</a></h2>

<pre>    $q-&#62;delete_all();</pre>

<p>This clears the CGI::Simple object completely. For CGI.pm compatibility <b>Delete_all()</b> is provided however there is no reason to use this in the function call interface other than symmetry.</p>

<p>For CGI.pm compatibility <b>Delete_all()</b> is provided as an alias for <b>delete_all</b> however there is no reason to use this, even in the function call interface.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="param_fetch()_Direct_access_to_the_parameter_list"
>param_fetch() Direct access to the parameter list</a></h2>

<p>This method is provided for CGI.pm compatibility only. It returns an array ref to the values associated with a named param. It is deprecated.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Vars()_Fetching_the_entire_parameter_list_as_a_hash"
>Vars() Fetching the entire parameter list as a hash</a></h2>

<pre>    $params = $q-&#62;Vars;  # as a tied hash ref
    print $params-&#62;{&#39;address&#39;};
    @foo = split &#34;\0&#34;, $params-&#62;{&#39;foo&#39;};

    %params = $q-&#62;Vars;  # as a plain hash
    print $params{&#39;address&#39;};
    @foo = split &#34;\0&#34;, $params{&#39;foo&#39;};

    %params = $q-&#62;Vars(&#39;,&#39;); # specifying a different separator than &#34;\0&#34;
    @foo = split &#39;,&#39;, $params{&#39;foo&#39;};</pre>

<p>Many people want to fetch the entire parameter list as a hash in which the keys are the names of the CGI parameters, and the values are the parameters&#39; values. The <b>Vars()</b> method does this.</p>

<p>Called in a scalar context, it returns the parameter list as a tied hash reference. Because this hash ref is tied changing a key/value changes the underlying CGI::Simple object.</p>

<p>Called in a list context, it returns the parameter list as an ordinary hash. Changing this hash will not change the underlying CGI::Simple object</p>

<p>When using <b>Vars()</b>, the thing you must watch out for are multi-valued CGI parameters. Because a hash cannot distinguish between scalar and list context, multi-valued parameters will be returned as a packed string, separated by the &#34;\0&#34; (null) character. You must split this packed string in order to get at the individual values. This is the convention introduced long ago by Steve Brenner in his cgi-lib.pl module for Perl version 4.</p>

<p>You can change the character used to do the multiple value packing by passing it to <b>Vars()</b> as an argument as shown.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="url_param()_Access_the_QUERY_STRING_regardless_of_&#39;GET&#39;_or_&#39;POST&#39;"
>url_param() Access the QUERY_STRING regardless of &#39;GET&#39; or &#39;POST&#39;</a></h2>

<p>The <b>url_param()</b> method makes the QUERY_STRING data available regardless of whether the REQUEST_METHOD was &#39;GET&#39; or &#39;POST&#39;. You can do anything with <b>url_param</b> that you can do with <b>param()</b>, however the data set is completely independent.</p>

<p>Technically what happens if you use this method is that the QUERY_STRING data is parsed into a new CGI::Simple object which is stored within the current object. <b>url_param</b> then just calls <b>param()</b> on this new object.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="parse_query_string()_Add_QUERY_STRING_data_to_&#39;POST&#39;_requests"
>parse_query_string() Add QUERY_STRING data to &#39;POST&#39; requests</a></h2>

<p>When the REQUEST_METHOD is &#39;POST&#39; the default behavior is to ignore name/value pairs or keywords in the $ENV{&#39;QUERY_STRING&#39;}. You can override this by calling <b>parse_query_string()</b> which will add the QUERY_STRING data to the data already in our CGI::Simple object if the REQUEST_METHOD was &#39;POST&#39;</p>

<pre>    $q = new CGI::Simple;
    $q-&#62;parse_query_string;  # add $ENV{&#39;QUERY_STRING&#39;} data to our $q object</pre>

<p>If the REQUEST_METHOD was &#39;GET&#39; then the QUERY_STRING will already be stored in our object so <b>parse_query_string</b> will be ignored.</p>

<p>This is a new method in CGI::Simple that is not available in CGI.pm</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="save()_Saving_the_state_of_an_object_to_file"
>save() Saving the state of an object to file</a></h2>

<pre>    $q-&#62;save(\*FILEHANDLE)</pre>

<p>This will write the current state of the form to the provided filehandle. You can read it back in by providing a filehandle to the <b>new()</b> method.</p>

<p>The format of the saved file is:</p>

<pre>    NAME1=VALUE1
    NAME1=VALUE1&#39;
    NAME2=VALUE2
    NAME3=VALUE3
    =</pre>

<p>Both name and value are URL escaped. Multi-valued CGI parameters are represented as repeated names. A session record is delimited by a single = symbol. You can write out multiple records and read them back in with several calls to <b>new()</b>.</p>

<pre>    open FH, &#34;test.in&#34; or die $!;
    $q1 = new CGI::Simple(\*FH);  # get the first record
    $q2 = new CGI::Simple(\*FH);  # get the next record</pre>

<p>Note: If you wish to use this method from the function-oriented (non-OO) interface, the exported name for this method is <b>save_parameters()</b>. Also if you want to initialize from a file handle, the way to do this is with <b>restore_parameters()</b>. This will (re)initialize the default CGI::Simple object from the indicated file handle.</p>

<pre>    restore_parameters(\*FH);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FILE_UPLOADS"
>FILE UPLOADS</a></h1>

<p>File uploads are easy with CGI::Simple. You use the <b>upload()</b> method. Assuming you have the following in your HTML:</p>

<pre>    &#60;FORM
     METHOD=&#34;POST&#34;
     ACTION=&#34;http://somewhere.com/cgi-bin/script.cgi&#34;
     ENCTYPE=&#34;multipart/form-data&#34;&#62;
        &#60;INPUT TYPE=&#34;file&#34; NAME=&#34;upload_file1&#34; SIZE=&#34;42&#34;&#62;
        &#60;INPUT TYPE=&#34;file&#34; NAME=&#34;upload_file2&#34; SIZE=&#34;42&#34;&#62;
    &#60;/FORM&#62;</pre>

<p>Note that the ENCTYPE is &#34;multipart/form-data&#34;. You must specify this or the browser will default to &#34;application/x-www-form-urlencoded&#34; which will result in no files being uploaded although on the surface things will appear OK.</p>

<p>When the user submits this form any supplied files will be spooled onto disk and saved in temporary files. These files will be deleted when your script.cgi exits so if you want to keep them you will need to proceed as follows.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="upload()_The_key_file_upload_method"
>upload() The key file upload method</a></h2>

<p>The <b>upload()</b> method is quite versatile. If you call <b>upload()</b> without any arguments it will return a list of uploaded files in list context and the number of uploaded files in scalar context.</p>

<pre>    $number_of_files = $q-&#62;upload;
    @list_of_files   = $q-&#62;upload;</pre>

<p>Having established that you have uploaded files available you can get the browser supplied filename using <b>param()</b> like this:</p>

<pre>    $filename1 = $q-&#62;param(&#39;upload_file1&#39;);</pre>

<p>You can then get a filehandle to read from by calling <b>upload()</b> and supplying this filename as an argument. Warning: do not modify the value you get from <b>param()</b> in any way - you don&#39;t need to untaint it.</p>

<pre>    $fh = $q-&#62;upload( $filename1 );</pre>

<p>Now to save the file you would just do something like:</p>

<pre>    $save_path = &#39;/path/to/write/file.name&#39;;
    open FH, &#34;&#62;$save_path&#34; or die &#34;Oops $!\n&#34;;
    binmode FH;
    print FH $buffer while read( $fh, $buffer, 4096 );
    close FH;</pre>

<p>By utilizing a new feature of the upload method this process can be simplified to:</p>

<pre>    $ok = $q-&#62;upload( $q-&#62;param(&#39;upload_file1&#39;), &#39;/path/to/write/file.name&#39; );
    if ($ok) {
        print &#34;Uploaded and wrote file OK!&#34;;
    } else {
        print $q-&#62;cgi_error();
    }</pre>

<p>As you can see upload will accept an optional second argument and will write the file to this file path. It will return 1 for success and undef if it fails. If it fails you can get the error from <b>cgi_error</b></p>

<p>You can also use just the fieldname as an argument to upload ie:</p>

<pre>    $fh = $q-&#62;upload( &#39;upload_field_name&#39; );

    or

    $ok = $q-&#62;upload( &#39;upload_field_name&#39;, &#39;/path/to/write/file.name&#39; );</pre>

<p>BUT there is a catch. If you have multiple upload fields, all called &#39;upload_field_name&#39; then you will only get the last uploaded file from these fields.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="upload_info()_Get_the_details_about_uploaded_files"
>upload_info() Get the details about uploaded files</a></h2>

<p>The <b>upload_info()</b> method is a new method. Called without arguments it returns the number of uploaded files in scalar context and the names of those files in list context.</p>

<pre>    $number_of_upload_files   = $q-&#62;upload_info();
    @filenames_of_all_uploads = $q-&#62;upload_info();</pre>

<p>You can get the MIME type of an uploaded file like this:</p>

<pre>    $mime = $q-&#62;upload_info( $filename1, &#39;mime&#39; );</pre>

<p>If you want to know how big a file is before you copy it you can get that information from <b>uploadInfo</b> which will return the file size in bytes.</p>

<pre>    $file_size = $q-&#62;upload_info( $filename1, &#39;size&#39; );</pre>

<p>The size attribute is optional as this is the default value returned.</p>

<p>Note: The old CGI.pm <b>uploadInfo()</b> method has been deleted.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$POST_MAX_and_$DISABLE_UPLOADS"
>$POST_MAX and $DISABLE_UPLOADS</a></h2>

<p>CGI.pm has a default setting that allows infinite size file uploads by default. In contrast file uploads are disabled by default in CGI::Simple to discourage Denial of Service attacks. You must enable them before you expect file uploads to work.</p>

<p>When file uploads are disabled the file name and file size details will still be available from <b>param()</b> and <b>upload_info</b> respectively but the upload filehandle returned by <b>upload()</b> will be undefined - not surprising as the underlying temp file will not exist either.</p>

<p>You can enable uploads using the &#39;-upload&#39; pragma. You do this by specifying this in you use statement:</p>

<pre>    use CGI::Simple qw(-upload);</pre>

<p>Alternatively you can enable uploads via the $DISABLE_UPLOADS global like this:</p>

<pre>    use CGI::Simple;
    $CGI::Simple::DISABLE_UPLOADS = 0;
    $q = new CGI::Simple;</pre>

<p>If you wish to set $DISABLE_UPLOADS you must do this *after* the use statement and *before* the new constructor call as shown above.</p>

<p>The maximum acceptable data via post is capped at 102_400kB rather than infinity which is the CGI.pm default. This should be ample for most tasks but you can set this to whatever you want using the $POST_MAX global.</p>

<pre>    use CGI::Simple;
    $CGI::Simple::DISABLE_UPLOADS = 0;      # enable uploads
    $CGI::Simple::POST_MAX = 1_048_576;     # allow 1MB uploads
    $q = new CGI::Simple;</pre>

<p>If you set to -1 infinite size uploads will be permitted, which is the CGI.pm default.</p>

<pre>    $CGI::Simple::POST_MAX = -1;            # infinite size upload</pre>

<p>Alternatively you can specify all the CGI.pm default values which allow file uploads of infinite size in one easy step by specifying the &#39;-default&#39; pragma in your use statement.</p>

<pre>    use CGI::Simple qw( -default ..... );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="binmode()_and_Win32"
>binmode() and Win32</a></h2>

<p>If you are using CGI::Simple be sure to call <b>binmode()</b> on any handle that you create to write the uploaded file to disk. Calling <b>binmode()</b> will do no harm on other systems anyway.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="MISCELANEOUS_METHODS"
>MISCELANEOUS METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="escapeHTML()_Escaping_HTML_special_characters"
>escapeHTML() Escaping HTML special characters</a></h2>

<p>In HTML the &#60; &#62; &#34; and &#38; chars have special meaning and need to be escaped to &#38;lt; &#38;gt; &#38;quot; and &#38;amp; respectively.</p>

<pre>    $escaped = $q-&#62;escapeHTML( $string );

    $escaped = $q-&#62;escapeHTML( $string, &#39;new_lines_too&#39; );</pre>

<p>If the optional second argument is supplied then newlines will be escaped to.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="unescapeHTML()_Unescape_HTML_special_characters"
>unescapeHTML() Unescape HTML special characters</a></h2>

<p>This performs the reverse of <b>escapeHTML()</b>.</p>

<pre>    $unescaped = $q-&#62;unescapeHTML( $HTML_escaped_string );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="url_decode()_Decode_a_URL_encoded_string"
>url_decode() Decode a URL encoded string</a></h2>

<p>This method will correctly decode a url encoded string.</p>

<pre>    $decoded = $q-&#62;url_decode( $encoded );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="url_encode()_URL_encode_a_string"
>url_encode() URL encode a string</a></h2>

<p>This method will correctly URL encode a string.</p>

<pre>    $encoded = $q-&#62;url_encode( $string );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="parse_keywordlist()_Parse_a_supplied_keyword_list"
>parse_keywordlist() Parse a supplied keyword list</a></h2>

<pre>    @keywords = $q-&#62;parse_keywordlist( $keyword_list );</pre>

<p>This method returns a list of keywords, correctly URL escaped and split out of the supplied string</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="put()_Send_output_to_browser"
>put() Send output to browser</a></h2>

<p>CGI.pm alias for print. $q-&#62;put(&#39;Hello World!&#39;) will print the usual</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="print()_Send_output_to_browser"
>print() Send output to browser</a></h2>

<p>CGI.pm alias for print. $q-&#62;print(&#39;Hello World!&#39;) will print the usual</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="HTTP_COOKIES"
>HTTP COOKIES</a></h1>

<p>CGI.pm has several methods that support cookies.</p>

<p>A cookie is a name=value pair much like the named parameters in a CGI query string. CGI scripts create one or more cookies and send them to the browser in the HTTP header. The browser maintains a list of cookies that belong to a particular Web server, and returns them to the CGI script during subsequent interactions.</p>

<p>In addition to the required name=value pair, each cookie has several optional attributes:</p>

<dl>
<dt><a name="1._an_expiration_time"
>1. an expiration time</a></dt>

<dd>
<p>This is a time/date string (in a special GMT format) that indicates when a cookie expires. The cookie will be saved and returned to your script until this expiration date is reached if the user exits the browser and restarts it. If an expiration date isn&#39;t specified, the cookie will remain active until the user quits the browser.</p>

<dt><a name="2._a_domain"
>2. a domain</a></dt>

<dd>
<p>This is a partial or complete domain name for which the cookie is valid. The browser will return the cookie to any host that matches the partial domain name. For example, if you specify a domain name of &#34;.capricorn.com&#34;, then the browser will return the cookie to Web servers running on any of the machines &#34;www.capricorn.com&#34;, &#34;www2.capricorn.com&#34;, &#34;feckless.capricorn.com&#34;, etc. Domain names must contain at least two periods to prevent attempts to match on top level domains like &#34;.edu&#34;. If no domain is specified, then the browser will only return the cookie to servers on the host the cookie originated from.</p>

<dt><a name="3._a_path"
>3. a path</a></dt>

<dd>
<p>If you provide a cookie path attribute, the browser will check it against your script&#39;s URL before returning the cookie. For example, if you specify the path &#34;/cgi-bin&#34;, then the cookie will be returned to each of the scripts &#34;/cgi-bin/tally.pl&#34;, &#34;/cgi-bin/order.pl&#34;, and &#34;/cgi-bin/customer_service/complain.pl&#34;, but not to the script &#34;/cgi-private/site_admin.pl&#34;. By default, path is set to &#34;/&#34;, which causes the cookie to be sent to any CGI script on your site.</p>

<dt><a name="4._a_&#34;secure&#34;_flag"
>4. a &#34;secure&#34; flag</a></dt>

<dd>
<p>If the &#34;secure&#34; attribute is set, the cookie will only be sent to your script if the CGI request is occurring on a secure channel, such as SSL.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="cookie()_A_simple_access_method_to_cookies"
>cookie() A simple access method to cookies</a></h2>

<p>The interface to HTTP cookies is the <b>cookie()</b> method:</p>

<pre>    $cookie = $q-&#62;cookie( -name      =&#62; &#39;sessionID&#39;,
                          -value     =&#62; &#39;xyzzy&#39;,
                          -expires   =&#62; &#39;+1h&#39;,
                          -path      =&#62; &#39;/cgi-bin/database&#39;,
                          -domain    =&#62; &#39;.capricorn.org&#39;,
                          -secure    =&#62; 1
                         );
    print $q-&#62;header(-cookie=&#62;$cookie);</pre>

<p><b>cookie()</b> creates a new cookie. Its parameters include:</p>

<dl>
<dt><a name="-name"
><b>-name</b></a></dt>

<dd>
<p>The name of the cookie (required). This can be any string at all. Although browsers limit their cookie names to non-whitespace alphanumeric characters, CGI.pm removes this restriction by escaping and unescaping cookies behind the scenes.</p>

<dt><a name="-value"
><b>-value</b></a></dt>

<dd>
<p>The value of the cookie. This can be any scalar value, array reference, or even associative array reference. For example, you can store an entire associative array into a cookie this way:</p>

<pre>    $cookie=$q-&#62;cookie( -name   =&#62; &#39;family information&#39;,
                        -value  =&#62; \%childrens_ages );</pre>

<dt><a name="-path"
><b>-path</b></a></dt>

<dd>
<p>The optional partial path for which this cookie will be valid, as described above.</p>

<dt><a name="-domain"
><b>-domain</b></a></dt>

<dd>
<p>The optional partial domain for which this cookie will be valid, as described above.</p>

<dt><a name="-expires"
><b>-expires</b></a></dt>

<dd>
<p>The optional expiration date for this cookie. The format is as described in the section on the <b>header()</b> method:</p>

<pre>    &#34;+1h&#34;  one hour from now</pre>

<dt><a name="-secure"
><b>-secure</b></a></dt>

<dd>
<p>If set to true, this cookie will only be used within a secure SSL session.</p>
</dd>
</dl>

<p>The cookie created by <b>cookie()</b> must be incorporated into the HTTP header within the string returned by the <b>header()</b> method:</p>

<pre>    print $q-&#62;header(-cookie=&#62;$my_cookie);</pre>

<p>To create multiple cookies, give <b>header()</b> an array reference:</p>

<pre>    $cookie1 = $q-&#62;cookie( -name  =&#62; &#39;riddle_name&#39;,
                           -value =&#62; &#34;The Sphynx&#39;s Question&#34;
                         );
    $cookie2 = $q-&#62;cookie( -name  =&#62; &#39;answers&#39;,
                           -value =&#62; \%answers
                         );
    print $q-&#62;header( -cookie =&#62; [ $cookie1, $cookie2 ] );</pre>

<p>To retrieve a cookie, request it by name by calling <b>cookie()</b> method without the <b>-value</b> parameter:</p>

<pre>    use CGI::Simple;
    $q = new CGI::Simple;
    $riddle  = $q-&#62;cookie(&#39;riddle_name&#39;);
    %answers = $q-&#62;cookie(&#39;answers&#39;);</pre>

<p>Cookies created with a single scalar value, such as the &#34;riddle_name&#34; cookie, will be returned in that form. Cookies with array and hash values can also be retrieved.</p>

<p>The cookie and CGI::Simple namespaces are separate. If you have a parameter named &#39;answers&#39; and a cookie named &#39;answers&#39;, the values retrieved by <b>param()</b> and <b>cookie()</b> are independent of each other. However, it&#39;s simple to turn a CGI parameter into a cookie, and vice-versa:</p>

<pre>    # turn a CGI parameter into a cookie
    $c = $q-&#62;cookie( -name=&#62;&#39;answers&#39;, -value=&#62;[$q-&#62;param(&#39;answers&#39;)] );
    # vice-versa
    $q-&#62;param( -name=&#62;&#39;answers&#39;, -value=&#62;[$q-&#62;cookie(&#39;answers&#39;)] );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="raw_cookie()"
>raw_cookie()</a></h2>

<p>Returns the HTTP_COOKIE variable. Cookies have a special format, and this method call just returns the raw form (?cookie dough). See <b>cookie()</b> for ways of setting and retrieving cooked cookies.</p>

<p>Called with no parameters, <b>raw_cookie()</b> returns the packed cookie structure. You can separate it into individual cookies by splitting on the character sequence &#34;; &#34;. Called with the name of a cookie, retrieves the <b>unescaped</b> form of the cookie. You can use the regular <b>cookie()</b> method to get the names, or use the raw_fetch() method from the CGI::Simmple::Cookie module.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CREATING_HTTP_HEADERS"
>CREATING HTTP HEADERS</a></h1>

<p>Normally the first thing you will do in any CGI script is print out an HTTP header. This tells the browser what type of document to expect, and gives other optional information, such as the language, expiration date, and whether to cache the document. The header can also be manipulated for special purposes, such as server push and pay per view pages.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="header()_Create_simple_or_complex_HTTP_headers"
>header() Create simple or complex HTTP headers</a></h2>

<pre>    print $q-&#62;header;

         -or-

    print $q-&#62;header(&#39;image/gif&#39;);

         -or-

    print $q-&#62;header(&#39;text/html&#39;,&#39;204 No response&#39;);

         -or-

    print $q-&#62;header( -type       =&#62; &#39;image/gif&#39;,
                      -nph        =&#62; 1,
                      -status     =&#62; &#39;402 Payment required&#39;,
                      -expires    =&#62; &#39;+3d&#39;,
                      -cookie     =&#62; $cookie,
                      -charset    =&#62; &#39;utf-7&#39;,
                      -attachment =&#62; &#39;foo.gif&#39;,
                      -Cost       =&#62; &#39;$2.00&#39;
                    );</pre>

<p><b>header()</b> returns the Content-type: header. You can provide your own MIME type if you choose, otherwise it defaults to text/html. An optional second parameter specifies the status code and a human-readable message. For example, you can specify 204, &#34;No response&#34; to create a script that tells the browser to do nothing at all.</p>

<p>The last example shows the named argument style for passing arguments to the CGI methods using named parameters. Recognized parameters are <b>-type</b>, <b>-status</b>, <b>-cookie</b>, <b>-target</b>, <b>-expires</b>, <b>-nph</b>, <b>-charset</b> and <b>-attachment</b>. Any other named parameters will be stripped of their initial hyphens and turned into header fields, allowing you to specify any HTTP header you desire.</p>

<p>For example, you can produce non-standard HTTP header fields by providing them as named arguments:</p>

<pre>  print $q-&#62;header( -type            =&#62; &#39;text/html&#39;,
                    -nph             =&#62; 1,
                    -cost            =&#62; &#39;Three smackers&#39;,
                    -annoyance_level =&#62; &#39;high&#39;,
                    -complaints_to   =&#62; &#39;bit bucket&#39;
                  );</pre>

<p>This will produce the following non-standard HTTP header:</p>

<pre>    HTTP/1.0 200 OK
    Cost: Three smackers
    Annoyance-level: high
    Complaints-to: bit bucket
    Content-type: text/html</pre>

<p>Note that underscores are translated automatically into hyphens. This feature allows you to keep up with the rapidly changing HTTP &#34;standards&#34;.</p>

<p>The <b>-type</b> is a key element that tell the browser how to display your document. The default is &#39;text/html&#39;. Common types are:</p>

<pre>    text/html
    text/plain
    image/gif
    image/jpg
    image/png
    application/octet-stream</pre>

<p>The <b>-status</b> code is the HTTP response code. The default is 200 OK. Common status codes are:</p>

<pre>    200 OK
    204 No Response
    301 Moved Permanently
    302 Found
    303 See Other
    307 Temporary Redirect
    400 Bad Request
    401 Unauthorized
    403 Forbidden
    404 Not Found
    405 Not Allowed
    408 Request Timed Out
    500 Internal Server Error
    503 Service Unavailable
    504 Gateway Timed Out</pre>

<p>The <b>-expires</b> parameter lets you indicate to a browser and proxy server how long to cache pages for. When you specify an absolute or relative expiration interval with this parameter, some browsers and proxy servers will cache the script&#39;s output until the indicated expiration date. The following forms are all valid for the -expires field:</p>

<pre>    +30s                                30 seconds from now
    +10m                                ten minutes from now
    +1h                                 one hour from now
    -1d                                 yesterday (i.e. &#34;ASAP!&#34;)
    now                                 immediately
    +3M                                 in three months
    +10y                                in ten years time
    Thursday, 25-Apr-1999 00:40:33 GMT  at the indicated time &#38; date</pre>

<p>The <b>-cookie</b> parameter generates a header that tells the browser to provide a &#34;magic cookie&#34; during all subsequent transactions with your script. Netscape cookies have a special format that includes interesting attributes such as expiration time. Use the <b>cookie()</b> method to create and retrieve session cookies.</p>

<p>The <b>-target</b> is for frames use</p>

<p>The <b>-nph</b> parameter, if set to a true value, will issue the correct headers to work with a NPH (no-parse-header) script. This is important to use with certain servers that expect all their scripts to be NPH.</p>

<p>The <b>-charset</b> parameter can be used to control the character set sent to the browser. If not provided, defaults to ISO-8859-1. As a side effect, this sets the charset() method as well.</p>

<p>The <b>-attachment</b> parameter can be used to turn the page into an attachment. Instead of displaying the page, some browsers will prompt the user to save it to disk. The value of the argument is the suggested name for the saved file. In order for this to work, you may have to set the <b>-type</b> to &#39;application/octet-stream&#39;.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="no_cache()_Preventing_browser_caching_of_scripts"
>no_cache() Preventing browser caching of scripts</a></h2>

<p>Most browsers will not cache the output from CGI scripts. Every time the browser reloads the page, the script is invoked anew. However some browsers do cache pages. You can discourage this behavior using the <b>no_cache()</b> function.</p>

<pre>    $q-&#62;no_cache(1); # turn caching off by sending appropriate headers
    $q-&#62;no_cache(1); # do not send cache related headers.

    $q-&#62;no_cache(1);
    print header (-type=&#62;&#39;image/gif&#39;, -nph=&#62;1);

    This will produce a header like the following:

    HTTP/1.0 200 OK
    Server: Apache - accept no substitutes
    Expires: Thu, 15 Nov 2001 03:37:50 GMT
    Date: Thu, 15 Nov 2001 03:37:50 GMT
    Pragma: no-cache
    Content-Type: image/gif</pre>

<p>Both the Pragma: no-cache header field and an Expires header that corresponds to the current time (ie now) will be sent.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="cache()_Preventing_browser_caching_of_scripts"
>cache() Preventing browser caching of scripts</a></h2>

<p>The somewhat ill named <b>cache()</b> method is a legacy from CGI.pm. It operates the same as the new <b>no_cache()</b> method. The difference is/was that when set it results only in the Pragma: no-cache line being printed. Expires time data is not sent.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="redirect()_Generating_a_redirection_header"
>redirect() Generating a redirection header</a></h2>

<pre>    print $q-&#62;redirect(&#39;http://somewhere.else/in/movie/land&#39;);</pre>

<p>Sometimes you don&#39;t want to produce a document yourself, but simply redirect the browser elsewhere, perhaps choosing a URL based on the time of day or the identity of the user.</p>

<p>The <b>redirect()</b> function redirects the browser to a different URL. If you use redirection like this, you should <b>not</b> print out a header as well.</p>

<p>One hint I can offer is that relative links may not work correctly when you generate a redirection to another document on your site. This is due to a well-intentioned optimization that some servers use. The solution to this is to use the full URL (including the http: part) of the document you are redirecting to.</p>

<p>You can also use named arguments:</p>

<pre>    print $q-&#62;redirect( -uri=&#62;&#39;http://somewhere.else/in/movie/land&#39;,
                        -nph=&#62;1
                      );</pre>

<p>The <b>-nph</b> parameter, if set to a true value, will issue the correct headers to work with a NPH (no-parse-header) script. This is important to use with certain servers, such as Microsoft ones, which expect all their scripts to be NPH.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PRAGMAS"
>PRAGMAS</a></h1>

<p>There are a number of pragmas that you can specify in your use CGI::Simple statement. Pragmas, which are always preceded by a hyphen, change the way that CGI::Simple functions in various ways. You can generally achieve exactly the same results by setting the underlying $GLOBAL_VARIABLES.</p>

<p>For example the &#39;-upload&#39; pargma will enable file uploads:</p>

<pre>    use CGI::Simple qw(-upload);</pre>

<p>In CGI::Simple::Standard Pragmas, function sets , and individual functions can all be imported in the same use() line. For example, the following use statement imports the standard set of functions and enables debugging mode (pragma -debug):</p>

<pre>    use CGI::Simple::Standard qw(:standard -debug);</pre>

<p>The current list of pragmas is as follows:</p>

<dl>
<dt><a name="-no_undef_params"
>-no_undef_params</a></dt>

<dd>
<p>If a value is not given in the query string, as in the queries &#34;name1=&#38;name2=&#34; or &#34;name1&#38;name2&#34;, by default it will be returned as an empty string.</p>

<p>If you specify the &#39;-no_undef_params&#39; pragma then CGI::Simple ignores parameters with no values and they will not appear in the query object.</p>

<dt><a name="-nph"
>-nph</a></dt>

<dd>
<p>This makes CGI.pm produce a header appropriate for an NPH (no parsed header) script. You may need to do other things as well to tell the server that the script is NPH. See the discussion of NPH scripts below.</p>

<dt><a name="-newstyle_urls"
>-newstyle_urls</a></dt>

<dd>
<p>Separate the name=value pairs in CGI parameter query strings with semicolons rather than ampersands. For example:</p>

<pre>    ?name=fred;age=24;favorite_color=3</pre>

<p>Semicolon-delimited query strings are always accepted, but will not be emitted by self_url() and query_string() unless the -newstyle_urls pragma is specified.</p>

<dt><a name="-oldstyle_urls"
>-oldstyle_urls</a></dt>

<dd>
<p>Separate the name=value pairs in CGI parameter query strings with ampersands rather than semicolons. This is the default.</p>

<pre>    ?name=fred&#38;age=24&#38;favorite_color=3</pre>

<dt><a name="-autoload"
>-autoload</a></dt>

<dd>
<p>This is only available for CGI::Simple::Standard and uses AUTOLOAD to load functions on demand. See the CGI::Simple::Standard docs for details.</p>

<dt><a name="-no_debug"
>-no_debug</a></dt>

<dd>
<p>This turns off the command-line processing features. This is the default.</p>

<dt><a name="-debug1_and_debug2"
>-debug1 and debug2</a></dt>

<dd>
<p>This turns on debugging. At debug level 1 CGI::Simple will read arguments from the command-line. At debug level 2 CGI.pm will produce the prompt &#34;(offline mode: enter name=value pairs on standard input)&#34; and wait for input on STDIN. If no number is specified then a debug level of 2 is used.</p>

<p>See the section on debugging for more details.</p>

<dt><a name="-default"
>-default</a></dt>

<dd>
<p>This sets the default global values for CGI.pm which will enable infinite size file uploads, and specify the &#39;-newstyle_urls&#39; and &#39;-debug1&#39; pragmas</p>

<dt><a name="-no_upload"
>-no_upload</a></dt>

<dd>
<p>Disable uploads - the default setting</p>

<dt><a name="-_upload"
>- upload</a></dt>

<dd>
<p>Enable uploads - the CGI.pm default</p>

<dt><a name="-unique_header"
>-unique_header</a></dt>

<dd>
<p>Only allows headers to be generated once per script invocation</p>

<dt><a name="-carp"
>-carp</a></dt>

<dd>
<p>Carp when <b>cgi_error()</b> called, default is to do nothing</p>

<dt><a name="-croak"
>-croak</a></dt>

<dd>
<p>Croak when <b>cgi_error()</b> called, default is to do nothing</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="USING_NPH_SCRIPTS"
>USING NPH SCRIPTS</a></h1>

<p>NPH, or &#34;no-parsed-header&#34;, scripts bypass the server completely by sending the complete HTTP header directly to the browser. This has slight performance benefits, but is of most use for taking advantage of HTTP extensions that are not directly supported by your server, such as server push and PICS headers.</p>

<p>Servers use a variety of conventions for designating CGI scripts as NPH. Many Unix servers look at the beginning of the script&#39;s name for the prefix &#34;nph-&#34;. The Macintosh WebSTAR server and Microsoft&#39;s Internet Information Server, in contrast, try to decide whether a program is an NPH script by examining the first line of script output.</p>

<p>CGI.pm supports NPH scripts with a special NPH mode. When in this mode, CGI.pm will output the necessary extra header information when the <b>header()</b> and <b>redirect()</b> methods are called. You can set NPH mode in any of the following ways:</p>

<dl>
<dt><a name="In_the_use_statement"
>In the <b>use</b> statement</a></dt>

<dd>
<p>Simply add the &#34;-nph&#34; pragma to the use:</p>

<pre>    use CGI::Simple qw(-nph)</pre>

<dt><a name="By_calling_the_nph()_method:"
>By calling the <b>nph()</b> method:</a></dt>

<dd>
<p>Call <b>nph()</b> with a non-zero parameter at any point after using CGI.pm in your program.</p>

<pre>    $q-&#62;nph(1)</pre>

<dt><a name="By_using_-nph_parameters"
>By using <b>-nph</b> parameters</a></dt>

<dd>
<p>in the <b>header()</b> and <b>redirect()</b> statements:</p>

<pre>    print $q-&#62;header(-nph=&#62;1);</pre>
</dd>
</dl>

<p>The Microsoft Internet Information Server requires NPH mode. CGI::Simple will automatically detect when the script is running under IIS and put itself into this mode. You do not need to do this manually, although it won&#39;t hurt anything if you do. However, note that if you have applied Service Pack 6, much of the functionality of NPH scripts, including the ability to redirect while setting a cookie, b&#60;do not work at all&#62; on IIS without a special patch from Microsoft. See http://support.microsoft.com/support/kb/articles/Q280/3/41.ASP: Non-Parsed Headers Stripped From CGI Applications That Have nph- Prefix in Name.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SERVER_PUSH"
>SERVER PUSH</a></h1>

<p>CGI.pm provides four simple functions for producing multipart documents of the type needed to implement server push. These functions were graciously provided by Ed Jordan &#60;ed@fidalgo.net&#62; with additions from Andrew Benham &#60;adsb@bigfoot.com&#62;</p>

<p>You are also advised to put the script into NPH mode and to set $| to 1 to avoid buffering problems.</p>

<p>Browser support for server push is variable.</p>

<p>Here is a simple script that demonstrates server push:</p>

<pre>    #!/usr/local/bin/perl
    use CGI::Simple::Standard qw/:push -nph/;
    $| = 1;
    print multipart_init(-boundary=&#62;&#39;----here we go!&#39;);
    foreach (0 .. 4) {
        print multipart_start(-type=&#62;&#39;text/plain&#39;),
        &#34;The current time is &#34;,scalar(localtime),&#34;\n&#34;;
        if ($_ &#60; 4) {
            print multipart_end;
        }
        else {
            print multipart_final;
        }
        sleep 1;
    }</pre>

<p>This script initializes server push by calling <b>multipart_init()</b>. It then enters a loop in which it begins a new multipart section by calling <b>multipart_start()</b>, prints the current local time, and ends a multipart section with <b>multipart_end()</b>. It then sleeps a second, and begins again. On the final iteration, it ends the multipart section with <b>multipart_final()</b> rather than with <b>multipart_end()</b>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="multipart_init()_Initialize_the_multipart_system"
>multipart_init() Initialize the multipart system</a></h2>

<pre>    multipart_init(-boundary=&#62;$boundary);</pre>

<p>Initialize the multipart system. The -boundary argument specifies what MIME boundary string to use to separate parts of the document. If not provided, CGI.pm chooses a reasonable boundary for you.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="multipart_start()_Start_a_new_part_of_the_multipart_document"
>multipart_start() Start a new part of the multipart document</a></h2>

<pre>    multipart_start(-type=&#62;$type)</pre>

<p>Start a new part of the multipart document using the specified MIME type. If not specified, text/html is assumed.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="multipart_end()_End_a_multipart_part"
>multipart_end() End a multipart part</a></h2>

<pre>    multipart_end()</pre>

<p>End a part. You must remember to call <b>multipart_end()</b> once for each <b>multipart_start()</b>, except at the end of the last part of the multipart document when <b>multipart_final()</b> should be called instead of <b>multipart_end()</b>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="multipart_final()"
>multipart_final()</a></h2>

<pre>    multipart_final()</pre>

<p>End all parts. You should call <b>multipart_final()</b> rather than <b>multipart_end()</b> at the end of the last part of the multipart document.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="CGI::Push"
>CGI::Push</a></h2>

<p>Users interested in server push applications should also have a look at the <b>CGI::Push</b> module.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DEBUGGING"
>DEBUGGING</a></h1>

<p>If you are running the script from the command line or in the perl debugger, you can pass the script a list of keywords or parameter=value pairs on the command line or from standard input (you don&#39;t have to worry about tricking your script into reading from environment variables). Before you do this you will need to change the debug level from the default level of 0 (no debug) to either 1 if you want to debug from @ARGV (the command line) of 2 if you want to debug from STDIN. You can do this using the debug pragma like this:</p>

<pre>    use CGI::Simple qw(-debug2);  # set debug to level 2 =&#62; from STDIN

        or this:

    $CGI::Simple::DEBUG = 1;      # set debug to level 1 =&#62; from @ARGV</pre>

<p>At debug level 1 you can pass keywords and name=value pairs like this:</p>

<pre>    your_script.pl keyword1 keyword2 keyword3

        or this:

    your_script.pl keyword1+keyword2+keyword3

        or this:

    your_script.pl name1=value1 name2=value2

        or this:

    your_script.pl name1=value1&#38;name2=value2</pre>

<p>At debug level 2 you can feed newline-delimited name=value pairs to the script on standard input. You will be presented with the following prompt:</p>

<pre>    (offline mode: enter name=value pairs on standard input)</pre>

<p>You end the input with your system dependent end of file character. You should try ^Z ^X ^D and ^C if all else fails. The ^ means hold down the [Ctrl] button while you press the other key.</p>

<p>When debugging, you can use quotes and backslashes to escape characters in the familiar shell manner, letting you place spaces and other funny characters in your parameter=value pairs:</p>

<pre>    your_script.pl &#34;name1=&#39;I am a long value&#39;&#34; &#34;name2=two\ words&#34;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Dump()_Dumping_the_current_object_details"
>Dump() Dumping the current object details</a></h2>

<p>The <b>Dump()</b> method produces a string consisting of all the query&#39;s object attributes formatted nicely as a nested list. This dump includes the name/value pairs and a number of other details. This is useful for debugging purposes:</p>

<pre>    print $q-&#62;Dump</pre>

<p>The actual result of this is HTML escaped formatted text wrapped in &#60;pre&#62; tags so if you send it straight to the browser it produces something that looks like:</p>

<pre>    $VAR1 = bless( {
         &#39;.parameters&#39; =&#62; [
                            &#39;name&#39;,
                            &#39;color&#39;
                          ],
         &#39;.globals&#39; =&#62; {
                         &#39;FATAL&#39; =&#62; -1,
                         &#39;DEBUG&#39; =&#62; 0,
                         &#39;NO_NULL&#39; =&#62; 1,
                         &#39;POST_MAX&#39; =&#62; 102400,
                         &#39;USE_CGI_PM_DEFAULTS&#39; =&#62; 0,
                         &#39;HEADERS_ONCE&#39; =&#62; 0,
                         &#39;NPH&#39; =&#62; 0,
                         &#39;DISABLE_UPLOADS&#39; =&#62; 1,
                         &#39;NO_UNDEF_PARAMS&#39; =&#62; 0,
                         &#39;USE_PARAM_SEMICOLONS&#39; =&#62; 0
                       },
         &#39;.fieldnames&#39; =&#62; {
                            &#39;color&#39; =&#62; &#39;1&#39;,
                            &#39;name&#39; =&#62; &#39;1&#39;
                          },
         &#39;.mod_perl&#39; =&#62; &#39;&#39;,
         &#39;color&#39; =&#62; [
                      &#39;red&#39;,
                      &#39;green&#39;,
                      &#39;blue&#39;
                    ],
         &#39;name&#39; =&#62; [
                     &#39;JaPh,&#39;
                   ]
        }, &#39;CGI::Simple&#39; );</pre>

<p>You may recognize this as valid Perl syntax (which it is) and/or the output from Data::Dumper (also true). This is the actual guts of how the information is stored in the query object. All the internal params start with a . char</p>

<p>Alternatively you can dump your object and the current environment using:</p>

<pre>    print $q-&#62;Dump(\%ENV);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="PrintEnv()_Dumping_the_environment"
>PrintEnv() Dumping the environment</a></h2>

<p>You can get a similar browser friendly dump of the current %ENV hash using:</p>

<pre>    print $q-&#62;PrintEnv;</pre>

<p>This will produce something like (in the browser):</p>

<pre>    $VAR1 = {
          &#39;QUERY_STRING&#39; =&#62; &#39;name=JaPh%2C&#38;color=red&#38;color=green&#38;color=blue&#39;,
          &#39;CONTENT_TYPE&#39; =&#62; &#39;application/x-www-form-urlencoded&#39;,
          &#39;REGRESSION_TEST&#39; =&#62; &#39;simple.t.pl&#39;,
          &#39;VIM&#39; =&#62; &#39;C:\\WINDOWS\\Desktop\\vim&#39;,
          &#39;HTTP_REFERER&#39; =&#62; &#39;xxx.sex.com&#39;,
          &#39;HTTP_USER_AGENT&#39; =&#62; &#39;LWP&#39;,
          &#39;HTTP_ACCEPT&#39; =&#62; &#39;text/html;q=1, image/gif;q=0.42, */*;q=0.001&#39;,
          &#39;REMOTE_HOST&#39; =&#62; &#39;localhost&#39;,
          &#39;HTTP_HOST&#39; =&#62; &#39;the.restaurant.at.the.end.of.the.universe&#39;,
          &#39;GATEWAY_INTERFACE&#39; =&#62; &#39;bleeding edge&#39;,
          &#39;REMOTE_IDENT&#39; =&#62; &#39;None of your damn business&#39;,
          &#39;SCRIPT_NAME&#39; =&#62; &#39;/cgi-bin/foo.cgi&#39;,
          &#39;SERVER_NAME&#39; =&#62; &#39;nowhere.com&#39;,
          &#39;HTTP_COOKIE&#39; =&#62; &#39;&#39;,
          &#39;CONTENT_LENGTH&#39; =&#62; &#39;42&#39;,
          &#39;HTTPS_A&#39; =&#62; &#39;A&#39;,
          &#39;HTTP_FROM&#39; =&#62; &#39;spammer@nowhere.com&#39;,
          &#39;HTTPS_B&#39; =&#62; &#39;B&#39;,
          &#39;SERVER_PROTOCOL&#39; =&#62; &#39;HTTP/1.0&#39;,
          &#39;PATH_TRANSLATED&#39; =&#62; &#39;/usr/local/somewhere/else&#39;,
          &#39;SERVER_SOFTWARE&#39; =&#62; &#39;Apache - accept no substitutes&#39;,
          &#39;PATH_INFO&#39; =&#62; &#39;/somewhere/else&#39;,
          &#39;REMOTE_USER&#39; =&#62; &#39;Just another Perl hacker,&#39;,
          &#39;REMOTE_ADDR&#39; =&#62; &#39;127.0.0.1&#39;,
          &#39;HTTPS&#39; =&#62; &#39;ON&#39;,
          &#39;DOCUMENT_ROOT&#39; =&#62; &#39;/vs/www/foo&#39;,
          &#39;REQUEST_METHOD&#39; =&#62; &#39;GET&#39;,
          &#39;REDIRECT_QUERY_STRING&#39; =&#62; &#39;&#39;,
          &#39;AUTH_TYPE&#39; =&#62; &#39;PGP MD5 DES rot13&#39;,
          &#39;COOKIE&#39; =&#62; &#39;foo=a%20phrase; bar=yes%2C%20a%20phrase&#38;;I%20say;&#39;,
          &#39;SERVER_PORT&#39; =&#62; &#39;8080&#39;
        };</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="cgi_error()_Retrieving_CGI::Simple_error_messages"
>cgi_error() Retrieving CGI::Simple error messages</a></h2>

<p>Errors can occur while processing user input, particularly when processing uploaded files. When these errors occur, CGI::Simple will stop processing and return an empty parameter list. You can test for the existence and nature of errors using the <b>cgi_error()</b> function. The error messages are formatted as HTTP status codes. You can either incorporate the error text into an HTML page, or use it as the value of the HTTP status:</p>

<pre>    my $error = $q-&#62;cgi_error;
    if ($error) {
        print $q-&#62;header(-status=&#62;$error);
        print &#34;&#60;H2&#62;$error&#60;/H2&#62;;
      exit;
    }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ACCESSOR_METHODS"
>ACCESSOR METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="version()_Get_the_CGI::Simple_version_info"
>version() Get the CGI::Simple version info</a></h2>

<pre>    $version = $q-&#62;version();</pre>

<p>The <b>version()</b> method returns the value of $VERSION</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="nph()_Enable/disable_NPH_(Non_Parsed_Header)_mode"
>nph() Enable/disable NPH (Non Parsed Header) mode</a></h2>

<pre>    $q-&#62;nph(1);  # enable NPH mode
    $q-&#62;nph(0);  # disable NPH mode</pre>

<p>The <b>nph()</b> method enables and disables NPH headers. See the NPH section.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="all_parameters()_Get_the_names/values_of_all_parameters"
>all_parameters() Get the names/values of all parameters</a></h2>

<pre>    @all_parameters = $q-&#62;all_parameters();</pre>

<p>The <b>all_parameters()</b> method is an alias for <b>param()</b></p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="charset()_Get/set_the_current_character_set."
>charset() Get/set the current character set.</a></h2>

<pre>    $charset = $q-&#62;charset(); # get current charset
    $q-&#62;charset(&#39;utf-42&#39;);    # set the charset</pre>

<p>The <b>charset()</b> method gets the current charset value if no argument is supplied or sets it if an argument is supplied.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="crlf()_Get_the_system_specific_line_ending_sequence"
>crlf() Get the system specific line ending sequence</a></h2>

<pre>    $crlf = $q-&#62;crlf();</pre>

<p>The <b>crlf()</b> method returns the system specific line ending sequence.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="globals()_Get/set_the_value_of_the_remaining_global_variables"
>globals() Get/set the value of the remaining global variables</a></h2>

<pre>    $globals = $q-&#62;globals(&#39;FATAL&#39;);     # get the current value of $FATAL
    $globals = $q-&#62;globals(&#39;FATAL&#39;, 1 ); # set croak mode on cgi_error()</pre>

<p>The <b>globals()</b> method gets/sets the values of the global variables after the script has been invoked. For globals like $POST_MAX and $DISABLE_UPLOADS this makes no difference as they must be set prior to calling the new constructor but there might be reason the change the value of others.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="auth_type()_Get_the_current_authorization/verification_method"
>auth_type() Get the current authorization/verification method</a></h2>

<pre>    $auth_type = $q-&#62;auth_type();</pre>

<p>The <b>auth_type()</b> method returns the value of $ENV{&#39;AUTH_TYPE&#39;} which should contain the authorization/verification method in use for this script, if any.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="content_length()_Get_the_content_length_submitted_in_a_POST"
>content_length() Get the content length submitted in a POST</a></h2>

<pre>    $content_length = $q-&#62;content_length();</pre>

<p>The <b>content_length()</b> method returns the value of $ENV{&#39;AUTH_TYPE&#39;}</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="content_type()_Get_the_content_type_of_data_submitted_in_a_POST"
>content_type() Get the content_type of data submitted in a POST</a></h2>

<pre>    $content_type = $q-&#62;content_type();</pre>

<p>The <b>content_type()</b> method returns the content_type of data submitted in a POST, generally &#39;multipart/form-data&#39; or &#39;application/x-www-form-urlencoded&#39; as supplied in $ENV{&#39;CONTENT_TYPE&#39;}</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="document_root()_Get_the_document_root"
>document_root() Get the document root</a></h2>

<pre>    $document_root = $q-&#62;document_root();</pre>

<p>The <b>document_root()</b> method returns the value of $ENV{&#39;DOCUMENT_ROOT&#39;}</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="gateway_interface()_Get_the_gateway_interface"
>gateway_interface() Get the gateway interface</a></h2>

<pre>    $gateway_interface = $q-&#62;gateway_interface();</pre>

<p>The <b>gateway_interface()</b> method returns the value of $ENV{&#39;GATEWAY_INTERFACE&#39;}</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="path_translated()_Get_the_value_of_path_translated"
>path_translated() Get the value of path translated</a></h2>

<pre>    $path_translated = $q-&#62;path_translated();</pre>

<p>The <b>path_translated()</b> method returns the value of $ENV{&#39;PATH_TRANSLATED&#39;}</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="referer()_Spy_on_your_users"
>referer() Spy on your users</a></h2>

<pre>    $referer = $q-&#62;referer();</pre>

<p>The <b>referer()</b> method returns the value of $ENV{&#39;REFERER&#39;} This will return the URL of the page the browser was viewing prior to fetching your script. Not available for all browsers.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="remote_addr()_Get_the_remote_address"
>remote_addr() Get the remote address</a></h2>

<pre>    $remote_addr = $q-&#62;remote_addr();</pre>

<p>The <b>remote_addr()</b> method returns the value of $ENV{&#39;REMOTE_ADDR&#39;} or 127.0.0.1 (localhost) if this is not defined.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="remote_host()_Get_a_value_for_remote_host"
>remote_host() Get a value for remote host</a></h2>

<pre>    $remote_host = $q-&#62;remote_host();</pre>

<p>The <b>remote_host()</b> method returns the value of $ENV{&#39;REMOTE_HOST&#39;} if it is defined. If this is not defined it returns $ENV{&#39;REMOTE_ADDR&#39;} If this is not defined it returns &#39;localhost&#39;</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="remote_ident()_Get_the_remote_identity"
>remote_ident() Get the remote identity</a></h2>

<pre>    $remote_ident = $q-&#62;remote_ident();</pre>

<p>The <b>remote_ident()</b> method returns the value of $ENV{&#39;REMOTE_IDENT&#39;}</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="remote_user()_Get_the_remote_user"
>remote_user() Get the remote user</a></h2>

<pre>    $remote_user = $q-&#62;remote_user();</pre>

<p>The <b>remote_user()</b> method returns the authorization/verification name used for user verification, if this script is protected. The value comes from $ENV{&#39;REMOTE_USER&#39;}</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="request_method()_Get_the_request_method"
>request_method() Get the request method</a></h2>

<pre>    $request_method = $q-&#62;request_method();</pre>

<p>The <b>request_method()</b> method returns the method used to access your script, usually one of &#39;POST&#39;, &#39;GET&#39; or &#39;HEAD&#39; as supplied by $ENV{&#39;REQUEST_METHOD&#39;}</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="script_name()_Get_the_script_name"
>script_name() Get the script name</a></h2>

<pre>    $script_name = $q-&#62;script_name();</pre>

<p>The <b>script_name()</b> method returns the value of $ENV{&#39;SCRIPT_NAME&#39;} if it is defined. Otherwise it returns Perl&#39;s script name from $0. Failing this it returns a null string &#39;&#39;</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="server_name()_Get_the_server_name"
>server_name() Get the server name</a></h2>

<pre>    $server_name = $q-&#62;server_name();</pre>

<p>The <b>server_name()</b> method returns the value of $ENV{&#39;SERVER_NAME&#39;} if defined or &#39;localhost&#39; otherwise</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="server_port()_Get_the_port_the_server_is_listening_on"
>server_port() Get the port the server is listening on</a></h2>

<pre>    $server_port = $q-&#62;server_port();</pre>

<p>The <b>server_port()</b> method returns the value $ENV{&#39;SERVER_PORT&#39;} if defined or 80 if not.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="server_protocol()_Get_the_current_server_protocol"
>server_protocol() Get the current server protocol</a></h2>

<pre>    $server_protocol = $q-&#62;server_protocol();</pre>

<p>The <b>server_protocol()</b> method returns the value of $ENV{&#39;SERVER_PROTOCOL&#39;} if defined or &#39;HTTP/1.0&#39; otherwise</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="server_software()_Get_the_server_software"
>server_software() Get the server software</a></h2>

<pre>    $server_software = $q-&#62;server_software();</pre>

<p>The <b>server_software()</b> method returns the value $ENV{&#39;SERVER_SOFTWARE&#39;} or &#39;cmdline&#39; If the server software is IIS it formats your hard drive, installs Linux, FTPs to www.apache.org, installs Apache, and then restores your system from tape. Well maybe not, but it&#39;s a nice thought.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="user_name()_Get_a_value_for_the_user_name."
>user_name() Get a value for the user name.</a></h2>

<pre>    $user_name = $q-&#62;user_name();</pre>

<p>Attempt to obtain the remote user&#39;s name, using a variety of different techniques. This only works with older browsers such as Mosaic. Newer browsers do not report the user name for privacy reasons!</p>

<p>Technically the <b>user_name()</b> method returns the value of $ENV{&#39;HTTP_FROM&#39;} or failing that $ENV{&#39;REMOTE_IDENT&#39;} or as a last choice $ENV{&#39;REMOTE_USER&#39;}</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="user_agent()_Get_the_users_browser_type"
>user_agent() Get the users browser type</a></h2>

<pre>    $ua = $q-&#62;user_agent();          # return the user agent
    $ok = $q-&#62;user_agent(&#39;mozilla&#39;); # return true if user agent &#39;mozilla&#39;</pre>

<p>The <b>user_agent()</b> method returns the value of $ENV{&#39;HTTP_USER_AGENT&#39;} when called without an argument or true or false if the $ENV{&#39;HTTP_USER_AGENT&#39;} matches the passed argument. The matching is case insensitive and partial.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="virtual_host()_Get_the_virtual_host"
>virtual_host() Get the virtual host</a></h2>

<pre>    $virtual_host = $q-&#62;virtual_host();</pre>

<p>The <b>virtual_host()</b> method returns the value of $ENV{&#39;HTTP_HOST&#39;} if defined or $ENV{&#39;SERVER_NAME&#39;} as a default. Port numbers are removed.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="path_info()_Get_any_extra_path_info_set_to_the_script"
>path_info() Get any extra path info set to the script</a></h2>

<pre>    $path_info = $q-&#62;path_info();</pre>

<p>The <b>path_info()</b> method returns additional path information from the script URL. E.G. fetching /cgi-bin/your_script/additional/stuff will result in $q-&#62;path_info() returning &#34;/additional/stuff&#34;.</p>

<p>NOTE: The Microsoft Internet Information Server is broken with respect to additional path information. If you use the Perl DLL library, the IIS server will attempt to execute the additional path information as a Perl script. If you use the ordinary file associations mapping, the path information will be present in the environment, but incorrect. The best thing to do is to avoid using additional path information in CGI scripts destined for use with IIS.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Accept()_Get_the_browser_MIME_types"
>Accept() Get the browser MIME types</a></h2>

<pre>    $Accept = $q-&#62;Accept();</pre>

<p>The <b>Accept()</b> method returns a list of MIME types that the remote browser accepts. If you give this method a single argument corresponding to a MIME type, as in $q-&#62;Accept(&#39;text/html&#39;), it will return a floating point value corresponding to the browser&#39;s preference for this type from 0.0 (don&#39;t want) to 1.0. Glob types (e.g. text/*) in the browser&#39;s accept list are handled correctly.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="accept()_Alias_for_Accept()"
>accept() Alias for Accept()</a></h2>

<pre>    $accept = $q-&#62;accept();</pre>

<p>The <b>accept()</b> Method is an alias for Accept()</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="http()_Get_a_range_of_HTTP_related_information"
>http() Get a range of HTTP related information</a></h2>

<pre>    $http = $q-&#62;http();</pre>

<p>Called with no arguments the <b>http()</b> method returns the list of HTTP or HTTPS environment variables, including such things as HTTP_USER_AGENT, HTTP_ACCEPT_LANGUAGE, and HTTP_ACCEPT_CHARSET, corresponding to the like-named HTTP header fields in the request. Called with the name of an HTTP header field, returns its value. Capitalization and the use of hyphens versus underscores are not significant.</p>

<p>For example, all three of these examples are equivalent:</p>

<pre>   $requested_language = $q-&#62;http(&#39;Accept-language&#39;);
   $requested_language = $q-&#62;http(&#39;Accept_language&#39;);
   $requested_language = $q-&#62;http(&#39;HTTP_ACCEPT_LANGUAGE&#39;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="https()_Get_a_range_of_HTTPS_related_information"
>https() Get a range of HTTPS related information</a></h2>

<pre>    $https = $q-&#62;https();</pre>

<p>The <b>https()</b> method is similar to the http() method except that when called without an argument it returns the value of $ENV{&#39;HTTPS&#39;} which will be true if a HTTPS connection is in use and false otherwise.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="protocol()_Get_the_current_protocol"
>protocol() Get the current protocol</a></h2>

<pre>    $protocol = $q-&#62;protocol();</pre>

<p>The <b>protocol()</b> method returns &#39;https&#39; if a HTTPS connection is in use or the <b>server_protocol()</b> minus version numbers (&#39;http&#39;) otherwise.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="url()_Return_the_script&#39;s_URL_in_several_formats"
>url() Return the script&#39;s URL in several formats</a></h2>

<pre>    $full_url      = $q-&#62;url();
    $full_url      = $q-&#62;url(-full=&#62;1);
    $relative_url  = $q-&#62;url(-relative=&#62;1);
    $absolute_url  = $q-&#62;url(-absolute=&#62;1);
    $url_with_path = $q-&#62;url(-path_info=&#62;1);
    $url_with_path_and_query = $q-&#62;url(-path_info=&#62;1,-query=&#62;1);
    $netloc        = $q-&#62;url(-base =&#62; 1);</pre>

<p><b>url()</b> returns the script&#39;s URL in a variety of formats. Called without any arguments, it returns the full form of the URL, including host name and port number</p>

<pre>    http://your.host.com/path/to/script.cgi</pre>

<p>You can modify this format with the following named arguments:</p>

<dl>
<dt><a name="-absolute"
><b>-absolute</b></a></dt>

<dd>
<p>If true, produce an absolute URL, e.g.</p>

<pre>    /path/to/script.cgi</pre>

<dt><a name="-relative"
><b>-relative</b></a></dt>

<dd>
<p>Produce a relative URL. This is useful if you want to reinvoke your script with different parameters. For example:</p>

<pre>    script.cgi</pre>

<dt><a name="-full"
><b>-full</b></a></dt>

<dd>
<p>Produce the full URL, exactly as if called without any arguments. This overrides the -relative and -absolute arguments.</p>

<dt><a name="-path_(-path_info)"
><b>-path</b> (<b>-path_info</b>)</a></dt>

<dd>
<p>Append the additional path information to the URL. This can be combined with <b>-full</b>, <b>-absolute</b> or <b>-relative</b>. <b>-path_info</b> is provided as a synonym.</p>

<dt><a name="-query_(-query_string)"
><b>-query</b> (<b>-query_string</b>)</a></dt>

<dd>
<p>Append the query string to the URL. This can be combined with <b>-full</b>, <b>-absolute</b> or <b>-relative</b>. <b>-query_string</b> is provided as a synonym.</p>

<dt><a name="-base"
><b>-base</b></a></dt>

<dd>
<p>Generate just the protocol and net location, as in http://www.foo.com:8000</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="self_url()_Get_the_scripts_complete_URL"
>self_url() Get the scripts complete URL</a></h2>

<pre>    $self_url = $q-&#62;self_url();</pre>

<p>The <b>self_url()</b> method returns the value of:</p>

<pre>   $self-&#62;url( &#39;-path_info&#39;=&#62;1, &#39;-query&#39;=&#62;1, &#39;-full&#39;=&#62;1 );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="state()_Alias_for_self_url()"
>state() Alias for self_url()</a></h2>

<pre>    $state = $q-&#62;state();</pre>

<p>The <b>state()</b> method is an alias for self_url()</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COMPATIBILITY_WITH_cgi-lib.pl_2.18"
>COMPATIBILITY WITH cgi-lib.pl 2.18</a></h1>

<p>To make it easier to port existing programs that use cgi-lib.pl all the subs within cgi-lib.pl are available in CGI::Simple. Using the functional interface of CGI::Simple::Standard porting is as easy as:</p>

<pre>    OLD VERSION
        require &#34;cgi-lib.pl&#34;;
        &#38;ReadParse;
        print &#34;The value of the antique is $in{&#39;antique&#39;}.\n&#34;;

    NEW VERSION
        use CGI::Simple::Standard qw(:cgi-lib);
        &#38;ReadParse;
        print &#34;The value of the antique is $in{&#39;antique&#39;}.\n&#34;;</pre>

<p>CGI:Simple&#39;s <b>ReadParse()</b> routine creates a variable named %in, which can be accessed to obtain the query variables. Like ReadParse, you can also provide your own variable via a glob. Infrequently used features of <b>ReadParse()</b>, such as the creation of @in and $in variables, are not supported.</p>

<p>You can also use the OO interface of CGI::Simple and call <b>ReadParse()</b> and other cgi-lib.pl functions like this:</p>

<pre>    &#38;CGI::Simple::ReadParse;       # get hash values in %in

    my $q = new CGI::Simple;
    $q-&#62;ReadParse();                # same thing

    CGI::Simple::ReadParse(*field); # get hash values in %field function style

    my $q = new CGI::Simple;
    $q-&#62;ReadParse(*field);          # same thing</pre>

<p>Once you use <b>ReadParse()</b> under the functional interface , you can retrieve the query object itself this way if needed:</p>

<pre>    $q = $in{&#39;CGI&#39;};</pre>

<p>Either way it allows you to start using the more interesting features of CGI.pm without rewriting your old scripts from scratch.</p>

<p>Unlike CGI.pm all the cgi-lib.pl functions from Version 2.18 are supported:</p>

<pre>    ReadParse()
    SplitParam()
    MethGet()
    MethPost()
    MyBaseUrl()
    MyURL()
    MyFullUrl()
    PrintHeader()
    HtmlTop()
    HtmlBot()
    PrintVariables()
    PrintEnv()
    CgiDie()
    CgiError()</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COMPATIBILITY_WITH_CGI.pm"
>COMPATIBILITY WITH CGI.pm</a></h1>

<p>I has long been suggested that the CGI and HTML parts of CGI.pm should be split into separate modules (even the author suggests this!), CGI::Simple represents the realization of this and contains the complete CGI side of CGI.pm. Code-wise it weighs in at a little under 30% of the size of CGI.pm at a little under 1000 lines.</p>

<p>A great deal of care has been taken to ensure that the interface remains unchanged although a few tweaks have been made. The test suite is extensive and includes all the CGI.pm test scripts as well as a series of new test scripts. You may like to have a look at /t/concur.t which makes 160 tests of CGI::Simple and CGI in parallel and compares the results to ensure they are identical. This is the case as of CGI.pm 2.78.</p>

<p>You can&#39;t make an omelet without breaking eggs. A large number of methods and global variables have been deleted as detailed below. Some pragmas are also gone. In the tarball there is a script <b>/misc/check.pl</b> that will check if a script seems to be using any of these now non existent methods, globals or pragmas. You call it like this:</p>

<pre>    perl check.pl &#60;files&#62;</pre>

<p>If it finds any likely candidates it will print a line with the line number, problem method/global and the complete line. For example here is some output from running the script on CGI.pm:</p>

<pre>    ...
    3162: Problem:&#39;$CGI::OS&#39;   local($CRLF) = &#34;\015\012&#34; if $CGI::OS eq &#39;VMS&#39;;
    3165: Problem:&#39;fillBuffer&#39; $self-&#62;fillBuffer($FILLUNIT);
    ....</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DIFFERENCES_FROM_CGI.pm"
>DIFFERENCES FROM CGI.pm</a></h1>

<p>CGI::Simple is strict and warnings compliant.</p>

<p>There are 4 modules in this distribution:</p>

<pre>    CGI/Simple.pm           supplies all the core code.
    CGI/Simple/Cookie.pm    supplies the cookie handling functions.
    CGI/Simple/Util.pm      supplies a variety of utility functions
    CGI/Simple/Standard.pm  supplies a functional interface for Simple.pm</pre>

<p>Simple.pm is the core module that provide all the essential functionality. Cookie.pm is a shortened rehash of the CGI.pm module of the same name which supplies the required cookie functionality. Util.pm has been recoded to use an internal object for data storage and supplies rarely needed non core functions and/or functions needed for the HTML side of things. Standard.pm is a wrapper module that supplies a complete functional interface to the OO back end supplied by CGI::Simple.</p>

<p>Although a serious attempt has been made to keep the interface identical, some minor changes and tweaks have been made. They will likely be insignificant to most users but here are the gory details.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Globals_Variables"
>Globals Variables</a></h2>

<p>The list of global variables has been pruned by 75%. Here is the complete list of the global variables used:</p>

<pre>    $VERSION = &#34;0.01&#34;;
    # set this to 1 to use CGI.pm default global settings
    $USE_CGI_PM_DEFAULTS = 0 unless defined $USE_CGI_PM_DEFAULTS;
    # see if user wants old  CGI.pm defaults
    do{ _use_cgi_pm_global_settings(); return } if $USE_CGI_PM_DEFAULTS;
    # no file uploads by default, set to 0 to enable uploads
    $DISABLE_UPLOADS = 1 unless defined $DISABLE_UPLOADS;
    # use a post max of 100K, set to -1 for no limits
    $POST_MAX = 102_400 unless defined $POST_MAX;
    # do not include undefined params parsed from query string
    $NO_UNDEF_PARAMS = 0 unless defined $NO_UNDEF_PARAMS;
    # separate the name=value pairs with ; rather than &#38;
    $USE_PARAM_SEMICOLONS = 0 unless defined $USE_PARAM_SEMICOLONS;
    # only print headers once
    $HEADERS_ONCE = 0 unless defined $HEADERS_ONCE;
    # Set this to 1 to enable NPH scripts
    $NPH = 0 unless defined $NPH;
    # 0 =&#62; no debug, 1 =&#62; from @ARGV,  2 =&#62; from STDIN
    $DEBUG = 0 unless defined $DEBUG;
    # filter out null bytes in param - value pairs
    $NO_NULL  = 1 unless defined $NO_NULL;
    # set behavior when cgi_err() called -1 =&#62; silent, 0 =&#62; carp, 1 =&#62; croak
    $FATAL = -1 unless defined $FATAL;</pre>

<p>Four of the default values of the old CGI.pm variables have been changed. Unlike CGI.pm which by default allows unlimited POST data and file uploads by default CGI::Simple limits POST data size to 100kB and denies file uploads by default. $USE_PARAM_SEMICOLONS is set to 0 by default so we use (old style) &#38; rather than ; as the pair separator for query strings. Debugging is disabled by default.</p>

<p>There are three new global variables. If $NO_NULL is true (the default) then CGI::Simple will strip null bytes out of names, values and keywords. Null bytes can do interesting things to C based code like Perl. Uploaded files are not touched. $FATAL controls the behavior when <b>cgi_error()</b> is called. The default value of -1 makes errors silent. $USE_CGI_PM_DEFAULTS reverts the defaults to the CGI.pm standard values ie unlimited file uploads via POST for DNS attacks. You can also get the defaults back by using the &#39;-default&#39; pragma in the use:</p>

<pre>    use CGI::Simple qw(-default);
    use CGI::Simple::Standard qw(-default);</pre>

<p>The values of the global variables are stored in the CGI::Simple object and can be referenced and changed using the <b>globals()</b> method like this:</p>

<pre>    my $value = $q-&#62;globals( &#39;VARNAME&#39; );      # get
    $q-&#62;globals( &#39;VARNAME&#39;, &#39;some value&#39; );    # set</pre>

<p>As with many CGI.pm methods if you pass the optional value that will be set.</p>

<p>The $CGI::Simple::VARNAME = &#39;N&#39; syntax is only useful prior to calling the <b>new()</b> constructor. After that all reference is to the values stored in the CGI::Simple object so you must change these using the <b>globals()</b> method.</p>

<p>$DISABLE_UPLOADS and $POST_MAX *must* be set prior to calling the constructor if you want the changes to have any effect as they control behavior during initialization. This is the same a CGI.pm although some people seem to miss this rather important point and set these after calling the constructor which does nothing.</p>

<p>The following globals are no longer relevant and have all been deleted:</p>

<pre>    $AUTOLOADED_ROUTINES
    $AUTOLOAD_DEBUG
    $BEEN_THERE
    $CRLF
    $DEFAULT_DTD
    $EBCDIC
    $FH
    $FILLUNIT
    $IIS
    $IN
    $INITIAL_FILLUNIT
    $JSCRIPT
    $MAC
    $MAXTRIES
    $MOD_PERL
    $NOSTICKY
    $OS
    $PERLEX
    $PRIVATE_TEMPFILES
    $Q
    $QUERY_CHARSET
    $QUERY_PARAM
    $SCRATCH
    $SL
    $SPIN_LOOP_MAX
    $TIMEOUT
    $TMPDIRECTORY
    $XHTML
    %EXPORT
    %EXPORT_OK
    %EXPORT_TAGS
    %OVERLOAD
    %QUERY_FIELDNAMES
    %SUBS
    @QUERY_PARAM
    @TEMP</pre>

<p>Notes: CGI::Simple uses IO::File-&#62;new_tmpfile to get tempfile filehandles. These are private by default so $PRIVATE_TEMPFILES is no longer required nor is $TMPDIRECTORY. The value that were stored in $OS, $CRLF, $QUERY_CHARSET and $EBCDIC are now stored in the CGI::Simple::Util object where they find most of their use. The $MOD_PERL and $PERLEX values are now stored in our CGI::Simple object. $IIS was only used once in path_info(). $SL the system specific / \ : path delimiter is not required as we let IO::File handle our tempfile requirements. The rest of the globals are HTML related, export related, hand rolled autoload related or serve obscure purposes in CGI.pm</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Changes_to_pragmas"
>Changes to pragmas</a></h2>

<p>There are some new pragmas available. See the pragmas section for details. The following CGI.pm pragmas are not available:</p>

<pre>    -any
    -compile
    -nosticky
    -no_xhtml
    -private_tempfiles</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Filehandles"
>Filehandles</a></h2>

<p>Unlike CGI.pm which tries to accept all filehandle like objects only \*FH and $fh are accepted by CGI::Simple as file accessors for <b>new()</b> and <b>save()</b>. IO::File objects work fine.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Hash_interface"
>Hash interface</a></h2>

<pre>    %hash = $q-&#62;Vars();     # pack values with &#34;\0&#34;;
    %hash = $q-&#62;Vars(&#34;,&#34;);  # comma separate values</pre>

<p>You may optionally pass <b>Vars()</b> a string that will be used to separate multiple values when they are packed into the single hash value. If no value is supplied the default &#34;\0&#34; (null byte) will be used. Null bytes are dangerous things for C based code (ie Perl).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="cgi-lib.pl"
>cgi-lib.pl</a></h2>

<p>All the cgi-lib.pl 2.18 routines are supported. Unlike CGI.pm all the subroutines from cgi-lib.pl are included. They have been GOLFED down to 25 lines but they all work pretty much the same as the originals.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CGI::Simple_COMPLETE_METHOD_LIST"
>CGI::Simple COMPLETE METHOD LIST</a></h1>

<p>Here is a complete list of all the CGI::Simple methods.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Guts_(hands_off,_except_of_course_for_new)"
>Guts (hands off, except of course for new)</a></h2>

<pre>    _initialize_globals
    _use_cgi_pm_global_settings
    _store_globals
    import
    _reset_globals
    new
    _initialize
    _read_parse
    _parse_params
    _add_param
    _parse_keywordlist
    _parse_multipart
    _save_tmpfile
    _read_data</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Core_Methods"
>Core Methods</a></h2>

<pre>    param
    add_param
    param_fetch
    url_param
    keywords
    Vars
    append
    delete
    Delete
    delete_all
    Delete_all
    upload
    upload_info
    query_string
    parse_query_string
    parse_keywordlist</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Save_and_Restore_from_File_Methods"
>Save and Restore from File Methods</a></h2>

<pre>    _init_from_file
    save
    save_parameters</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Miscellaneous_Methods"
>Miscellaneous Methods</a></h2>

<pre>    url_decode
    url_encode
    escapeHTML
    unescapeHTML
    put
    print</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Cookie_Methods"
>Cookie Methods</a></h2>

<pre>    cookie
    raw_cookie</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Header_Methods"
>Header Methods</a></h2>

<pre>    header
    cache
    no_cache
    redirect</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Server_Push_Methods"
>Server Push Methods</a></h2>

<pre>    multipart_init
    multipart_start
    multipart_end
    multipart_final</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Debugging_Methods"
>Debugging Methods</a></h2>

<pre>    read_from_cmdline
    Dump
    as_string
    cgi_error</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="cgi-lib.pl_Compatibility_Routines_-_all_2.18_functions_available"
>cgi-lib.pl Compatibility Routines - all 2.18 functions available</a></h2>

<pre>    _shift_if_ref
    ReadParse
    SplitParam
    MethGet
    MethPost
    MyBaseUrl
    MyURL
    MyFullUrl
    PrintHeader
    HtmlTop
    HtmlBot
    PrintVariables
    PrintEnv
    CgiDie
    CgiError</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Accessor_Methods"
>Accessor Methods</a></h2>

<pre>    version
    nph
    all_parameters
    charset
    crlf                # new, returns OS specific CRLF sequence
    globals             # get/set global variables
    auth_type
    content_length
    content_type
    document_root
    gateway_interface
    path_translated
    referer
    remote_addr
    remote_host
    remote_ident
    remote_user
    request_method
    script_name
    server_name
    server_port
    server_protocol
    server_software
    user_name
    user_agent
    virtual_host
    path_info
    Accept
    accept
    http
    https
    protocol
    url
    self_url
    state</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NEW_METHODS_IN_CGI::Simple"
>NEW METHODS IN CGI::Simple</a></h1>

<p>There are a few new methods in CGI::Simple as listed below. The highlights are the <b>parse_query_string()</b> method to add the QUERY_STRING data to your object if the method was POST. The <b>no_cache()</b> method adds an expires now directive and the Pragma: no-cache directive to the header to encourage some browsers to do the right thing. <b>PrintEnv()</b> from the cgi-lib.pl routines will dump an HTML friendly list of the %ENV and makes a handy addition to <b>Dump()</b> for use in debugging. The upload method now accepts a filepath as an optional second argument as shown in the synopsis. If this is supplied the uploaded file will be written to there automagically.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Internal_Routines"
>Internal Routines</a></h2>

<pre>    _initialize_globals()
    _use_cgi_pm_global_settings()
    _store_globals()
    _initialize()
    _init_from_file()
    _read_parse()
    _parse_params()
    _add_param()
    _parse_keywordlist()
    _parse_multipart()
    _save_tmpfile()
    _read_data()</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="New_Public_Methods"
>New Public Methods</a></h2>

<pre>    add_param()             # adds a param/value(s) pair +/- overwrite
    upload_info()           # uploaded files MIME type and size
    url_decode()            # decode s url encoded string
    url_encode()            # url encode a string
    parse_query_string()    # add QUERY_STRING data to $q object if &#39;POST&#39;
    no_cache()              # add both the Pragma: no-cache
                            # and Expires/Date =&#62; &#39;now&#39; to header</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="cgi-lib.pl_methods_added_for_completeness"
>cgi-lib.pl methods added for completeness</a></h2>

<pre>    _shift_if_ref()         # internal hack reminiscent of self_or_default :-)
    MyBaseUrl()
    MyURL()
    MyFullUrl()
    PrintVariables()
    PrintEnv()
    CgiDie()
    CgiError()</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="New_Accessors"
>New Accessors</a></h2>

<pre>    crlf()                  # returns CRLF sequence
    globals()               # global vars now stored in $q object - get/set
    content_length()        # returns $ENV{&#39;CONTENT_LENGTH&#39;}
    document_root()         # returns $ENV{&#39;DOCUMENT_ROOT&#39;}
    gateway_interface()     # returns $ENV{&#39;GATEWAY_INTERFACE&#39;}</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS_IN_CGI.pm_NOT_IN_CGI::Simple"
>METHODS IN CGI.pm NOT IN CGI::Simple</a></h1>

<p>Here is a complete list of what is not included in CGI::Simple. Basically all the HTML related stuff plus large redundant chunks of the guts. The check.pl script in the /misc dir will check to see if a script is using any of these.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Guts_-_rearranged,_recoded,_renamed_and_hacked_out_of_existence"
>Guts - rearranged, recoded, renamed and hacked out of existence</a></h2>

<pre>    initialize_globals()
    compile()
    expand_tags()
    self_or_default()
    self_or_CGI()
    init()
    to_filehandle()
    save_request()
    parse_params()
    add_parameter()
    binmode()
    _make_tag_func()
    AUTOLOAD()
    _compile()
    _setup_symbols()
    new_MultipartBuffer()
    read_from_client()
    import_names()     # I dislike this and left it out, so shoot me.</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="HTML_Related"
>HTML Related</a></h2>

<pre>    autoEscape()
    URL_ENCODED()
    MULTIPART()
    SERVER_PUSH()
    start_html()
    _style()
    _script()
    end_html()
    isindex()
    startform()
    start_form()
    end_multipart_form()
    start_multipart_form()
    endform()
    end_form()
    _textfield()
    textfield()
    filefield()
    password_field()
    textarea()
    button()
    submit()
    reset()
    defaults()
    comment()
    checkbox()
    checkbox_group()
    _tableize()
    radio_group()
    popup_menu()
    scrolling_list()
    hidden()
    image_button()
    nosticky()
    default_dtd()</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Upload_Related"
>Upload Related</a></h2>

<p>CGI::Simple uses anonymous tempfiles supplied by IO::File to spool uploaded files to.</p>

<pre>    private_tempfiles() # automatic in CGI::Simple
    tmpFileName()       # all upload files are anonymous
    uploadInfo()        # relied on FH access, replaced with upload_info()</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Really_Private_Subs_(marked_as_so)"
>Really Private Subs (marked as so)</a></h2>

<pre>    previous_or_default()
    register_parameter()
    get_fields()
    _set_values_and_labels()
    _compile_all()
    asString()
    compare()</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Internal_Multipart_Parsing_Routines"
>Internal Multipart Parsing Routines</a></h2>

<pre>    read_multipart()
    readHeader()
    readBody()
    read()
    fillBuffer()
    eof()</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXPORT"
>EXPORT</a></h1>

<p>Nothing.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR_INFORMATION"
>AUTHOR INFORMATION</a></h1>

<p>Originally copyright 2001 Dr James Freeman &#60;jfreeman@tassie.net.au&#62; This release by Andy Armstrong &#60;andy@hexten.net&#62;</p>

<p>This package is free software and is provided &#34;as is&#34; without express or implied warranty. It may be used, redistributed and/or modified under the terms of the Perl Artistic License (see http://www.perl.com/perl/misc/Artistic.html)</p>

<p>Address bug reports and comments to: andy@hexten.net. When sending bug reports, please provide the version of CGI::Simple, the version of Perl, the name and version of your Web server, and the name and version of the operating system you are using. If the problem is even remotely browser dependent, please provide information about the affected browsers as well.</p>

<p>Address bug reports and comments to: andy@hexten.net</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CREDITS"
>CREDITS</a></h1>

<p>Lincoln D. Stein (lstein@cshl.org) and everyone else who worked on the original CGI.pm upon which this module is heavily based</p>

<p>Brandon Black for some heavy duty testing and bug fixes</p>

<p>John D Robinson and Jeroen Latour for helping solve some interesting test failures as well as Perlmonks: tommyw, grinder, Jaap, vek, erasei, jlongino and strider_corinth</p>

<p>Thanks for patches to:</p>

<p>Ewan Edwards, Joshua N Pritikin, Mike Barry, Michael Nachbaur, Chris Williams, Mark Stosberg, Krasimir Berov, Yamada Masahiro</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENCE_AND_COPYRIGHT"
>LICENCE AND COPYRIGHT</a></h1>

<p>Copyright (c) 2007, Andy Armstrong <code>&#60;andy@hexten.net&#62;</code>. All rights reserved.</p>

<p>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself. See <a href="../perlartistic.html" class="podlinkpod"
>perlartistic</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><b>CGI</b>, <a href="../CGI/Simple/Standard.html" class="podlinkpod"
>CGI::Simple::Standard</a>, <a href="../CGI/Simple/Cookie.html" class="podlinkpod"
>CGI::Simple::Cookie</a>, <a href="../CGI/Simple/Util.html" class="podlinkpod"
>CGI::Simple::Util</a>, <a href="../CGI/Minimal.html" class="podlinkpod"
>CGI::Minimal</a></p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
