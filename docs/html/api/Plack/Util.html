<html><head><title>Plack::Util</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:25 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#FUNCTIONS'>FUNCTIONS</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Plack::Util - Utility subroutines for Plack server and framework developers</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FUNCTIONS"
>FUNCTIONS</a></h1>

<dl>
<dt><a name="TRUE,_FALSE"
>TRUE,
FALSE</a></dt>

<dd>
<pre>  my $true  = Plack::Util::TRUE;
  my $false = Plack::Util::FALSE;</pre>

<p>Utility constants to include when you specify boolean variables in <code>$env</code> hash (e.g. <code>psgi.multithread</code>).</p>

<dt><a name="load_class"
>load_class</a></dt>

<dd>
<pre>  my $class = Plack::Util::load_class($class [, $prefix ]);</pre>

<p>Constructs a class name and <code>require</code> the class. Throws an exception if the .pm file for the class is not found, just with the built-in <code>require</code>.</p>

<p>If <code>$prefix</code> is set, the class name is prepended to the <code>$class</code> unless <code>$class</code> begins with <code>+</code> sign, which means the class name is already fully qualified.</p>

<pre>  my $class = Plack::Util::load_class(&#34;Foo&#34;);                   # Foo
  my $class = Plack::Util::load_class(&#34;Baz&#34;, &#34;Foo::Bar&#34;);       # Foo::Bar::Baz
  my $class = Plack::Util::load_class(&#34;+XYZ::ZZZ&#34;, &#34;Foo::Bar&#34;); # XYZ::ZZZ</pre>

<p>Note that this function doesn&#39;t validate (or &#34;sanitize&#34;) the passed string, hence if you pass a user input to this function (which is an insecure thing to do in the first place) it might lead to unexpected behavior of loading files outside your <code>@INC</code> path. If you want a generic module loading function, you should check out CPAN modules such as <a href="../Module/Runtime.html" class="podlinkpod"
>Module::Runtime</a>.</p>

<dt><a name="is_real_fh"
>is_real_fh</a></dt>

<dd>
<pre>  if ( Plack::Util::is_real_fh($fh) ) { }</pre>

<p>returns true if a given <code>$fh</code> is a real file handle that has a file descriptor. It returns false if <code>$fh</code> is PerlIO handle that is not really related to the underlying file etc.</p>

<dt><a name="content_length"
>content_length</a></dt>

<dd>
<pre>  my $cl = Plack::Util::content_length($body);</pre>

<p>Returns the length of content from body if it can be calculated. If <code>$body</code> is an array ref it&#39;s a sum of length of each chunk, if <code>$body</code> is a real filehandle it&#39;s a remaining size of the filehandle, otherwise returns undef.</p>

<dt><a name="set_io_path"
>set_io_path</a></dt>

<dd>
<pre>  Plack::Util::set_io_path($fh, &#34;/path/to/foobar.txt&#34;);</pre>

<p>Sets the (absolute) file path to <code>$fh</code> filehandle object, so you can call <code>$fh-&#62;path</code> on it. As a side effect <code>$fh</code> is blessed to an internal package but it can still be treated as a normal file handle.</p>

<p>This module doesn&#39;t normalize or absolutize the given path, and is intended to be used from Server or Middleware implementations. See also <a href="../IO/File/WithPath.html" class="podlinkpod"
>IO::File::WithPath</a>.</p>

<dt><a name="foreach"
>foreach</a></dt>

<dd>
<pre>  Plack::Util::foreach($body, $cb);</pre>

<p>Iterate through <i>$body</i> which is an array reference or IO::Handle-like object and pass each line (which is NOT really guaranteed to be a <i>line</i>) to the callback function.</p>

<p>It internally sets the buffer length <code>$/</code> to 65536 in case it reads the binary file, unless otherwise set in the caller&#39;s code.</p>

<dt><a name="load_psgi"
>load_psgi</a></dt>

<dd>
<pre>  my $app = Plack::Util::load_psgi $psgi_file_or_class;</pre>

<p>Load <code>app.psgi</code> file or a class name (like <code>MyApp::PSGI</code>) and require the file to get PSGI application handler. If the file can&#39;t be loaded (e.g. file doesn&#39;t exist or has a perl syntax error), it will throw an exception.</p>

<p>Since version 1.0006, this function would not load PSGI files from include paths (<code>@INC</code>) unless it looks like a class name that only consists of <code>[A-Za-z0-9_:]</code>. For example:</p>

<pre>  Plack::Util::load_psgi(&#34;app.psgi&#34;);          # ./app.psgi
  Plack::Util::load_psgi(&#34;/path/to/app.psgi&#34;); # /path/to/app.psgi
  Plack::Util::load_psgi(&#34;MyApp::PSGI&#34;);       # MyApp/PSGI.pm from @INC</pre>

<p><b>Security</b>: If you give this function a class name or module name that is loadable from your system, it will load the module. This could lead to a security hole:</p>

<pre>  my $psgi = ...; # user-input: consider &#34;Moose&#34;
  $app = Plack::Util::load_psgi($psgi); # this would lead to &#39;require &#34;Moose.pm&#34;&#39;!</pre>

<p>Generally speaking, passing an external input to this function is considered very insecure. If you really want to do that, validate that a given file name contains dots (like <code>foo.psgi</code>) and also turn it into a full path in your caller&#39;s code.</p>

<dt><a name="run_app"
>run_app</a></dt>

<dd>
<pre>  my $res = Plack::Util::run_app $app, $env;</pre>

<p>Runs the <i>$app</i> by wrapping errors with <i>eval</i> and if an error is found, logs it to <code>$env-&#62;{&#39;psgi.errors&#39;}</code> and returns the template 500 Error response.</p>

<dt><a name="header_get,_header_exists,_header_set,_header_push,_header_remove"
>header_get, header_exists, header_set, header_push, header_remove</a></dt>

<dd>
<pre>  my $hdrs = [ &#39;Content-Type&#39; =&#62; &#39;text/plain&#39; ];

  my $v = Plack::Util::header_get($hdrs, $key); # First found only
  my @v = Plack::Util::header_get($hdrs, $key);
  my $bool = Plack::Util::header_exists($hdrs, $key);
  Plack::Util::header_set($hdrs, $key, $val);   # overwrites existent header
  Plack::Util::header_push($hdrs, $key, $val);
  Plack::Util::header_remove($hdrs, $key);</pre>

<p>Utility functions to manipulate PSGI response headers array reference. The methods that read existent header value handles header name as case insensitive.</p>

<pre>  my $hdrs = [ &#39;Content-Type&#39; =&#62; &#39;text/plain&#39; ];
  my $v = Plack::Util::header_get($hdrs, &#39;content-type&#39;); # &#39;text/plain&#39;</pre>

<dt><a name="headers"
>headers</a></dt>

<dd>
<pre>  my $headers = [ &#39;Content-Type&#39; =&#62; &#39;text/plain&#39; ];

  my $h = Plack::Util::headers($headers);
  $h-&#62;get($key);
  if ($h-&#62;exists($key)) { ... }
  $h-&#62;set($key =&#62; $val);
  $h-&#62;push($key =&#62; $val);
  $h-&#62;remove($key);
  $h-&#62;headers; # same reference as $headers</pre>

<p>Given a header array reference, returns a convenient object that has an instance methods to access <code>header_*</code> functions with an OO interface. The object holds a reference to the original given <code>$headers</code> argument and updates the reference accordingly when called write methods like <code>set</code>, <code>push</code> or <code>remove</code>. It also has <code>headers</code> method that would return the same reference.</p>

<dt><a name="status_with_no_entity_body"
>status_with_no_entity_body</a></dt>

<dd>
<pre>  if (status_with_no_entity_body($res-&#62;[0])) { }</pre>

<p>Returns true if the given status code doesn&#39;t have any Entity body in HTTP response, i.e. it&#39;s 100, 101, 204 or 304.</p>

<dt><a name="inline_object"
>inline_object</a></dt>

<dd>
<pre>  my $o = Plack::Util::inline_object(
      write =&#62; sub { $h-&#62;push_write(@_) },
      close =&#62; sub { $h-&#62;push_shutdown },
  );
  $o-&#62;write(@stuff);
  $o-&#62;close;</pre>

<p>Creates an instant object that can react to methods passed in the constructor. Handy to create when you need to create an IO stream object for input or errors.</p>

<dt><a name="encode_html"
>encode_html</a></dt>

<dd>
<pre>  my $encoded_string = Plack::Util::encode( $string );</pre>

<p>Entity encodes <code>&#60;</code>, <code>&#62;</code>, <code>&#38;</code>, <code>&#34;</code> and <code>&#39;</code> in the input string and returns it.</p>

<dt><a name="response_cb"
>response_cb</a></dt>

<dd>
<p>See <a href="../Plack/Middleware.html#RESPONSE_CALLBACK" class="podlinkpod"
>&#34;RESPONSE CALLBACK&#34; in Plack::Middleware</a> for details.</p>
</dd>
</dl>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
