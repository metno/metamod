<html><head><title>Plack::Request</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:25 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#CAVEAT'>CAVEAT</a>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#new'>new</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#ATTRIBUTES'>ATTRIBUTES</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Hash%3A%3AMultiValue_parameters'>Hash::MultiValue parameters</a>
    <li class='indexItem indexItem2'><a href='#PARSING_POST_BODY_and_MULTIPLE_OBJECTS'>PARSING POST BODY and MULTIPLE OBJECTS</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#DISPATCHING'>DISPATCHING</a>
  <li class='indexItem indexItem1'><a href='#INCOMPATIBILITIES'>INCOMPATIBILITIES</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS'>AUTHORS</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#LICENSE'>LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Plack::Request - Portable HTTP request object from PSGI env hash</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use Plack::Request;

  my $app_or_middleware = sub {
      my $env = shift; # PSGI env

      my $req = Plack::Request-&#62;new($env);

      my $path_info = $req-&#62;path_info;
      my $query     = $req-&#62;param(&#39;query&#39;);

      my $res = $req-&#62;new_response(200); # new Plack::Response
      $res-&#62;finalize;
  };</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p><a href="../Plack/Request.html" class="podlinkpod"
>Plack::Request</a> provides a consistent API for request objects across web server environments.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CAVEAT"
>CAVEAT</a></h1>

<p>Note that this module is intended to be used by Plack middleware developers and web application framework developers rather than application developers (end users).</p>

<p>Writing your web application directly using Plack::Request is certainly possible but not recommended: it&#39;s like doing so with mod_perl&#39;s Apache::Request: yet too low level.</p>

<p>If you&#39;re writing a web application, not a framework, then you&#39;re encouraged to use one of the web application frameworks that support PSGI (<a href="http://plackperl.org/#frameworks" class="podlinkurl"
>http://plackperl.org/#frameworks</a>), or see modules like <a href="../HTTP/Engine.html" class="podlinkpod"
>HTTP::Engine</a> to provide higher level Request and Response API on top of PSGI.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<p>Some of the methods defined in the earlier versions are deprecated in version 0.99. Take a look at <a href="#INCOMPATIBILITIES" class="podlinkpod"
>&#34;INCOMPATIBILITIES&#34;</a>.</p>

<p>Unless otherwise noted, all methods and attributes are <b>read-only</b>, and passing values to the method like an accessor doesn&#39;t work like you expect it to.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="new"
>new</a></h2>

<pre>    Plack::Request-&#62;new( $env );</pre>

<p>Creates a new request object.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ATTRIBUTES"
>ATTRIBUTES</a></h1>

<dl>
<dt><a name="env"
>env</a></dt>

<dd>
<p>Returns the shared PSGI environment hash reference. This is a reference, so writing to this environment passes through during the whole PSGI request/response cycle.</p>

<dt><a name="address"
>address</a></dt>

<dd>
<p>Returns the IP address of the client (<code>REMOTE_ADDR</code>).</p>

<dt><a name="remote_host"
>remote_host</a></dt>

<dd>
<p>Returns the remote host (<code>REMOTE_HOST</code>) of the client. It may be empty, in which case you have to get the IP address using <code>address</code> method and resolve on your own.</p>

<dt><a name="method"
>method</a></dt>

<dd>
<p>Contains the request method (<code>GET</code>, <code>POST</code>, <code>HEAD</code>, etc).</p>

<dt><a name="protocol"
>protocol</a></dt>

<dd>
<p>Returns the protocol (HTTP/1.0 or HTTP/1.1) used for the current request.</p>

<dt><a name="request_uri"
>request_uri</a></dt>

<dd>
<p>Returns the raw, undecoded request URI path. You probably do <b>NOT</b> want to use this to dispatch requests.</p>

<dt><a name="path_info"
>path_info</a></dt>

<dd>
<p>Returns <b>PATH_INFO</b> in the environment. Use this to get the local path for the requests.</p>

<dt><a name="path"
>path</a></dt>

<dd>
<p>Similar to <code>path_info</code> but returns <code>/</code> in case it is empty. In other words, it returns the virtual path of the request URI after <code>$req-&#62;base</code>. See <a href="#DISPATCHING" class="podlinkpod"
>&#34;DISPATCHING&#34;</a> for details.</p>

<dt><a name="script_name"
>script_name</a></dt>

<dd>
<p>Returns <b>SCRIPT_NAME</b> in the environment. This is the absolute path where your application is hosted.</p>

<dt><a name="scheme"
>scheme</a></dt>

<dd>
<p>Returns the scheme (<code>http</code> or <code>https</code>) of the request.</p>

<dt><a name="secure"
>secure</a></dt>

<dd>
<p>Returns true or false, indicating whether the connection is secure (https).</p>

<dt><a name="body,_input"
>body, input</a></dt>

<dd>
<p>Returns <code>psgi.input</code> handle.</p>

<dt><a name="session"
>session</a></dt>

<dd>
<p>Returns (optional) <code>psgix.session</code> hash. When it exists, you can retrieve and store per-session data from and to this hash.</p>

<dt><a name="session_options"
>session_options</a></dt>

<dd>
<p>Returns (optional) <code>psgix.session.options</code> hash.</p>

<dt><a name="logger"
>logger</a></dt>

<dd>
<p>Returns (optional) <code>psgix.logger</code> code reference. When it exists, your application is supposed to send the log message to this logger, using:</p>

<pre>  $req-&#62;logger-&#62;({ level =&#62; &#39;debug&#39;, message =&#62; &#34;This is a debug message&#34; });</pre>

<dt><a name="cookies"
>cookies</a></dt>

<dd>
<p>Returns a reference to a hash containing the cookies. Values are strings that are sent by clients and are URI decoded.</p>

<p>If there are multiple cookies with the same name in the request, this method will ignore the duplicates and return only the first value. If that causes issues for you, you may have to use modules like CGI::Simple::Cookie to parse <code>$request-</code>header(&#39;Cookies&#39;)&#62; by yourself.</p>

<dt><a name="query_parameters"
>query_parameters</a></dt>

<dd>
<p>Returns a reference to a hash containing query string (GET) parameters. This hash reference is <a href="../Hash/MultiValue.html" class="podlinkpod"
>Hash::MultiValue</a> object.</p>

<dt><a name="body_parameters"
>body_parameters</a></dt>

<dd>
<p>Returns a reference to a hash containing posted parameters in the request body (POST). As with <code>query_parameters</code>, the hash reference is a <a href="../Hash/MultiValue.html" class="podlinkpod"
>Hash::MultiValue</a> object.</p>

<dt><a name="parameters"
>parameters</a></dt>

<dd>
<p>Returns a <a href="../Hash/MultiValue.html" class="podlinkpod"
>Hash::MultiValue</a> hash reference containing (merged) GET and POST parameters.</p>

<dt><a name="content,_raw_body"
>content, raw_body</a></dt>

<dd>
<p>Returns the request content in an undecoded byte string for POST requests.</p>

<dt><a name="uri"
>uri</a></dt>

<dd>
<p>Returns an URI object for the current request. The URI is constructed using various environment values such as <code>SCRIPT_NAME</code>, <code>PATH_INFO</code>, <code>QUERY_STRING</code>, <code>HTTP_HOST</code>, <code>SERVER_NAME</code> and <code>SERVER_PORT</code>.</p>

<p>Every time this method is called it returns a new, cloned URI object.</p>

<dt><a name="base"
>base</a></dt>

<dd>
<p>Returns an URI object for the base path of current request. This is like <code>uri</code> but only contains up to <code>SCRIPT_NAME</code> where your application is hosted at.</p>

<p>Every time this method is called it returns a new, cloned URI object.</p>

<dt><a name="user"
>user</a></dt>

<dd>
<p>Returns <code>REMOTE_USER</code> if it&#39;s set.</p>

<dt><a name="headers"
>headers</a></dt>

<dd>
<p>Returns an <a href="../HTTP/Headers.html" class="podlinkpod"
>HTTP::Headers</a> object containing the headers for the current request.</p>

<dt><a name="uploads"
>uploads</a></dt>

<dd>
<p>Returns a reference to a hash containing uploads. The hash reference is a <a href="../Hash/MultiValue.html" class="podlinkpod"
>Hash::MultiValue</a> object and values are <a href="../Plack/Request/Upload.html" class="podlinkpod"
>Plack::Request::Upload</a> objects.</p>

<dt><a name="content_encoding"
>content_encoding</a></dt>

<dd>
<p>Shortcut to $req-&#62;headers-&#62;content_encoding.</p>

<dt><a name="content_length"
>content_length</a></dt>

<dd>
<p>Shortcut to $req-&#62;headers-&#62;content_length.</p>

<dt><a name="content_type"
>content_type</a></dt>

<dd>
<p>Shortcut to $req-&#62;headers-&#62;content_type.</p>

<dt><a name="header"
>header</a></dt>

<dd>
<p>Shortcut to $req-&#62;headers-&#62;header.</p>

<dt><a name="referer"
>referer</a></dt>

<dd>
<p>Shortcut to $req-&#62;headers-&#62;referer.</p>

<dt><a name="user_agent"
>user_agent</a></dt>

<dd>
<p>Shortcut to $req-&#62;headers-&#62;user_agent.</p>

<dt><a name="param"
>param</a></dt>

<dd>
<p>Returns GET and POST parameters with a CGI.pm-compatible param method. This is an alternative method for accessing parameters in $req-&#62;parameters. Unlike CGI.pm, it does <i>not</i> allow setting or modifying query parameters.</p>

<pre>    $value  = $req-&#62;param( &#39;foo&#39; );
    @values = $req-&#62;param( &#39;foo&#39; );
    @params = $req-&#62;param;</pre>

<dt><a name="upload"
>upload</a></dt>

<dd>
<p>A convenient method to access $req-&#62;uploads.</p>

<pre>    $upload  = $req-&#62;upload(&#39;field&#39;);
    @uploads = $req-&#62;upload(&#39;field&#39;);
    @fields  = $req-&#62;upload;

    for my $upload ( $req-&#62;upload(&#39;field&#39;) ) {
        print $upload-&#62;filename;
    }</pre>

<dt><a name="new_response"
>new_response</a></dt>

<dd>
<pre>  my $res = $req-&#62;new_response;</pre>

<p>Creates a new <a href="../Plack/Response.html" class="podlinkpod"
>Plack::Response</a> object. Handy to remove dependency on <a href="../Plack/Response.html" class="podlinkpod"
>Plack::Response</a> in your code for easy subclassing and duck typing in web application frameworks, as well as overriding Response generation in middlewares.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Hash::MultiValue_parameters"
>Hash::MultiValue parameters</a></h2>

<p>Parameters that can take one or multiple values (i.e. <code>parameters</code>, <code>query_parameters</code>, <code>body_parameters</code> and <code>uploads</code>) store the hash reference as a <a href="../Hash/MultiValue.html" class="podlinkpod"
>Hash::MultiValue</a> object. This means you can use the hash reference as a plain hash where values are <b>always</b> scalars (<b>NOT</b> array references), so you don&#39;t need to code ugly and unsafe <code>ref ... eq &#39;ARRAY&#39;</code> anymore.</p>

<p>And if you explicitly want to get multiple values of the same key, you can call the <code>get_all</code> method on it, such as:</p>

<pre>  my @foo = $req-&#62;query_parameters-&#62;get_all(&#39;foo&#39;);</pre>

<p>You can also call <code>get_one</code> to always get one parameter independent of the context (unlike <code>param</code>), and even call <code>mixed</code> (with Hash::MultiValue 0.05 or later) to get the <i>traditional</i> hash reference,</p>

<pre>  my $params = $req-&#62;parameters-&#62;mixed;</pre>

<p>where values are either a scalar or an array reference depending on input, so it might be useful if you already have the code to deal with that ugliness.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="PARSING_POST_BODY_and_MULTIPLE_OBJECTS"
>PARSING POST BODY and MULTIPLE OBJECTS</a></h2>

<p>The methods to parse request body (<code>content</code>, <code>body_parameters</code> and <code>uploads</code>) are carefully coded to save the parsed body in the environment hash as well as in the temporary buffer, so you can call them multiple times and create Plack::Request objects multiple times in a request and they should work safely, and won&#39;t parse request body more than twice for the efficiency.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DISPATCHING"
>DISPATCHING</a></h1>

<p>If your application or framework wants to dispatch (or route) actions based on request paths, be sure to use <code>$req-&#62;path_info</code> not <code>$req-&#62;uri-&#62;path</code>.</p>

<p>This is because <code>path_info</code> gives you the virtual path of the request, regardless of how your application is mounted. If your application is hosted with mod_perl or CGI scripts, or even multiplexed with tools like <a href="../Plack/App/URLMap.html" class="podlinkpod"
>Plack::App::URLMap</a>, request&#39;s <code>path_info</code> always gives you the action path.</p>

<p>Note that <code>path_info</code> might give you an empty string, in which case you should assume that the path is <code>/</code>.</p>

<p>You will also want to use <code>$req-&#62;base</code> as a base prefix when building URLs in your templates or in redirections. It&#39;s a good idea for you to subclass Plack::Request and define methods such as:</p>

<pre>  sub uri_for {
      my($self, $path, $args) = @_;
      my $uri = $self-&#62;base;
      $uri-&#62;path($uri-&#62;path . $path);
      $uri-&#62;query_form(@$args) if $args;
      $uri;
  }</pre>

<p>So you can say:</p>

<pre>  my $link = $req-&#62;uri_for(&#39;/logout&#39;, [ signoff =&#62; 1 ]);</pre>

<p>and if <code>$req-&#62;base</code> is <code>/app</code> you&#39;ll get the full URI for <code>/app/logout?signoff=1</code>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="INCOMPATIBILITIES"
>INCOMPATIBILITIES</a></h1>

<p>In version 0.99, many utility methods are removed or deprecated, and most methods are made read-only. These methods were deleted in version 1.0001.</p>

<p>All parameter-related methods such as <code>parameters</code>, <code>body_parameters</code>, <code>query_parameters</code> and <code>uploads</code> now contains <a href="../Hash/MultiValue.html" class="podlinkpod"
>Hash::MultiValue</a> objects, rather than <i>scalar or an array reference depending on the user input</i> which is insecure. See <a href="../Hash/MultiValue.html" class="podlinkpod"
>Hash::MultiValue</a> for more about this change.</p>

<p><code>$req-&#62;path</code> method had a bug, where the code and the document was mismatching. The document was suggesting it returns the sub request path after <code>$req-&#62;base</code> but the code was always returning the absolute URI path. The code is now updated to be an alias of <code>$req-&#62;path_info</code> but returns <code>/</code> in case it&#39;s empty. If you need the older behavior, just call <code>$req-&#62;uri-&#62;path</code> instead.</p>

<p>Cookie handling is simplified, and doesn&#39;t use <a href="../CGI/Simple/Cookie.html" class="podlinkpod"
>CGI::Simple::Cookie</a> anymore, which means you <b>CAN NOT</b> set array reference or hash reference as a cookie value and expect it be serialized. You&#39;re always required to set string value, and encoding or decoding them is totally up to your application or framework. Also, <code>cookies</code> hash reference now returns <i>strings</i> for the cookies rather than CGI::Simple::Cookie objects, which means you no longer have to write a wacky code such as:</p>

<pre>  $v = $req-&#62;cookie-&#62;{foo} ? $req-&#62;cookie-&#62;{foo}-&#62;value : undef;</pre>

<p>and instead, simply do:</p>

<pre>  $v = $req-&#62;cookie-&#62;{foo};</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS"
>AUTHORS</a></h1>

<p>Tatsuhiko Miyagawa</p>

<p>Kazuhiro Osawa</p>

<p>Tokuhiro Matsuno</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../Plack/Response.html" class="podlinkpod"
>Plack::Response</a> <a href="../HTTP/Request.html" class="podlinkpod"
>HTTP::Request</a>, <a href="../Catalyst/Request.html" class="podlinkpod"
>Catalyst::Request</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENSE"
>LICENSE</a></h1>

<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
