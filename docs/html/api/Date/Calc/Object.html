<html><head><title>Date::Calc::Object</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:04 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#MOTTO'>MOTTO</a>
  <li class='indexItem indexItem1'><a href='#PREFACE'>PREFACE</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Export_tags'>Export tags</a>
    <li class='indexItem indexItem2'><a href='#Functions'>Functions</a>
    <li class='indexItem indexItem2'><a href='#Methods'>Methods</a>
    <li class='indexItem indexItem2'><a href='#Overloaded_Operators'>Overloaded Operators</a>
    <li class='indexItem indexItem2'><a href='#Comparison_Operators%3A'>Comparison Operators:</a>
    <li class='indexItem indexItem2'><a href='#Plus%3A'>Plus:</a>
    <li class='indexItem indexItem2'><a href='#Unary_Minus%3A'>Unary Minus:</a>
    <li class='indexItem indexItem2'><a href='#Minus%3A'>Minus:</a>
    <li class='indexItem indexItem2'><a href='#Miscellaneous_Operators%3A'>Miscellaneous Operators:</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#EXAMPLES'>EXAMPLES</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
  <li class='indexItem indexItem1'><a href='#LICENSE'>LICENSE</a>
  <li class='indexItem indexItem1'><a href='#DISCLAIMER'>DISCLAIMER</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Date::Calc::Object - Object-oriented add-on for Date::Calc with overloaded operators</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="MOTTO"
>MOTTO</a></h1>

<p>Make frequent things easy and infrequent or hard things possible</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PREFACE"
>PREFACE</a></h1>

<p>Note that you do <b>NOT</b> need to &#34;<code>use Date::Calc qw(...);</code>&#34; in addition to this module.</p>

<p>Simply</p>

<pre>  use Date::Calc::Object qw(...);</pre>

<p><b>INSTEAD OF</b></p>

<pre>  use Date::Calc qw(...);</pre>

<p>with the same &#34;<code>qw(...)</code>&#34; as you would with the &#34;Date::Calc&#34; module, and then forget about &#34;Date::Calc::Object&#34; altogether.</p>

<p>The rest of your existing code doesn&#39;t change at all.</p>

<p>Note also that in order to create a new date object, you do not need to use</p>

<pre>  $date_object = Date::Calc::Object-&#62;new(...);</pre>

<p>(but you may), and should use</p>

<pre>  $date_object = Date::Calc-&#62;new(...);</pre>

<p>instead (saves you some typing and is a trifle faster).</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Export_tags"
>Export tags</a></h2>

<pre>  :all  -  all functions from Date::Calc
  :aux  -  auxiliary functions shift_*
  :ALL  -  both :all and :aux</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Functions"
>Functions</a></h2>

<p>See <a href="../../Date/Calc(3).html" class="podlinkpod"
>Date::Calc(3)</a> for a list of available functions.</p>

<pre>  $year                          = shift_year(\@_);
  ($year,$mm,$dd)                = shift_date(\@_);
  ($hrs,$min,$sec)               = shift_time(\@_);
  ($year,$mm,$dd,$hrs,$min,$sec) = shift_datetime(\@_);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Methods"
>Methods</a></h2>

<pre>  $old = Date::Calc-&#62;accurate_mode([FLAG]);
  $old = Date::Calc-&#62;normalized_mode([FLAG]);
  $old = Date::Calc-&#62;number_format([NUMBER|CODEREF]);
  $old = Date::Calc-&#62;delta_format([NUMBER|CODEREF]);  # global default
  $old = Date::Calc-&#62;date_format([NUMBER|CODEREF]);   # global default
  $old = Date::Calc-&#62;language([LANGUAGE]);            # global default - DEPRECATED

  $old = $date-&#62;accurate_mode([FLAG]);           # is global nevertheless!
  $old = $date-&#62;normalized_mode([FLAG]);         # is global nevertheless!
  $old = $date-&#62;number_format([NUMBER|CODEREF]); # is global nevertheless!
  $old = $date-&#62;delta_format([NUMBER|CODEREF]);  # individual override
  $old = $date-&#62;date_format([NUMBER|CODEREF]);   # individual override
  $old = $date-&#62;language([LANGUAGE]);            # individual override

  $flag = $date-&#62;is_delta();
  $flag = $date-&#62;is_date();
  $flag = $date-&#62;is_short(); # i.e., has no time part
  $flag = $date-&#62;is_long();  # i.e., has time part
  $flag = $date-&#62;is_valid();

  $date = Date::Calc-&#62;new([TYPE]);
  $date = Date::Calc-&#62;new([TYPE,]YEAR,MONTH,DAY[,HRS,MIN,SEC]);
  $date = Date::Calc-&#62;new($arrayref);
  $newdate = $somedate-&#62;new([TYPE]);
  $newdate = $somedate-&#62;new([TYPE,]YEAR,MONTH,DAY[,HRS,MIN,SEC]);
  $newdate = $somedate-&#62;new($arrayref);

  $datecopy = $date-&#62;clone();
  $targetdate-&#62;copy($sourcedate);
  $targetdate-&#62;copy($arrayref);
  $targetdate-&#62;copy(@list);

  ($year,$month,$day) = $date-&#62;date([TYPE]);
  ($year,$month,$day) = $date-&#62;date([TYPE,]YEAR,MONTH,DAY[,HRS,MIN,SEC]);
  ($year,$month,$day) = $date-&#62;date($arrayref);
  ([$hrs,$min,$sec])  = $date-&#62;time([TYPE]);
  ($hrs,$min,$sec)    = $date-&#62;time([TYPE,]HRS,MIN,SEC);
  ([$hrs,$min,$sec])  = $date-&#62;time($arrayref);

  ($year,$month,$day,$hrs,$min,$sec) =
      $date-&#62;datetime([TYPE]);
  ($year,$month,$day,$hrs,$min,$sec) =
      $date-&#62;datetime([TYPE,]YEAR,MONTH,DAY[,HRS,MIN,SEC]);

  $date  = Date::Calc-&#62;today([FLAG]);
  $date  = Date::Calc-&#62;now([FLAG]); # shorthand for --+
  $date  = Date::Calc-&#62;today_and_now([FLAG]); # &#60;-----+
  $date  = Date::Calc-&#62;gmtime([time]);    # UTC/GMT
  $date  = Date::Calc-&#62;localtime([time]); # local time
  $delta = Date::Calc-&#62;tzoffset([time]);
  $date  = Date::Calc-&#62;time2date([time]); # UTC/GMT

  $date-&#62;today([FLAG]);         # updates the date part only
  $date-&#62;now([FLAG]);           # updates the time part only
  $date-&#62;today_and_now([FLAG]); # updates both date and time
  $date-&#62;gmtime([time]);        # updates both date and time (UTC/GMT)
  $date-&#62;localtime([time]);     # updates both date and time (local time)
  $delta-&#62;tzoffset([time]);     # updates both date and time
  $date-&#62;time2date([time]);     # updates both date and time (UTC/GMT)

  $time = Date::Calc-&#62;mktime();    # same as &#34;$time = CORE::time();&#34;
  $time = Date::Calc-&#62;date2time(); # same as &#34;$time = CORE::time();&#34;

  $time = $date-&#62;mktime();      # converts into Unix time (local time)
  $time = $date-&#62;date2time();   # converts into Unix time (UTC/GMT)

  $year    = $date-&#62;year([YEAR]);
  $month   = $date-&#62;month([MONTH]);
  $day     = $date-&#62;day([DAY]);
  $hours   = $date-&#62;hours([HRS]);
  $minutes = $date-&#62;minutes([MIN]);
  $seconds = $date-&#62;seconds([SEC]);

  $number = $date-&#62;number([NUMBER|CODEREF]);
  $string = $date-&#62;string([NUMBER|CODEREF][,LANGUAGE]);

  $delta-&#62;normalize(); # renormalizes a delta vector</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Overloaded_Operators"
>Overloaded Operators</a></h2>

<pre>  #####################################################
  # Scalar operands are always converted into a delta #
  # vector with that many days, i.e., [1,0,0,SCALAR]  #
  #####################################################</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Comparison_Operators:"
>Comparison Operators:</a></h2>

<pre>  if ($date1 &#60;  $date2) { # compares date part only
  if ($date1 &#60;= $date2) { # compares date part only
  if ($date1 &#62;  $date2) { # compares date part only
  if ($date1 &#62;= $date2) { # compares date part only
  if ($date1 == $date2) { # compares date part only
  if ($date1 != $date2) { # compares date part only

  $comp = $date1 &#60;=&#62; $date2; # compares date part only

  if ($date1 lt $date2) { # compares both date and time
  if ($date1 le $date2) { # compares both date and time
  if ($date1 gt $date2) { # compares both date and time
  if ($date1 ge $date2) { # compares both date and time
  if ($date1 eq $date2) { # compares both date and time
  if ($date1 ne $date2) { # compares both date and time

  $comp = $date1 cmp $date2; # compares both date and time</pre>

<p>Note that you can of course also compare two deltas, but not a date and a delta!</p>

<pre>  ##################################################
  # Default TYPE for array refs in comparisons is: #
  # Same as other operand                          #
  ##################################################

  if ([2000,4,1] == $date) {
  if ($today &#62; [2000,4,1]) {

  if ($now ge [2000,3,26,2,0,0]) {

  if ($delta == [18,0,0]) {
  if ($delta == -1) {</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Plus:"
>Plus:</a></h2>

<pre>  $date2 = $date1 + $delta;
  $date2 = $delta + $date1;
  $date += $delta;
  $this = $date++;
  $next = ++$date;

  $delta3 = $delta1 + $delta2;
  $delta1 += $delta2;
  $delta += $date; # beware of implicit type change!
  $delta++;
  ++$delta;

  #####################################################
  # Default TYPE for array refs in &#39;+&#39; operations is: #
  # Opposite of other operand                         #
  #####################################################

  $date2 = [2000,3,26] + $delta;
  $date2 = $date1 + [+1,0,0];
  $date2 = [0,0,-1] + $date1;
  $date2 = $date1 + 1;
  $date += [0,0,+1];
  $date += 2;

  $delta3 = [1,+1,0,-1] + $delta2;
  $delta3 = $delta1 + [1,0,0,+1];
  $delta3 = $delta1 + 1;
  $delta += [1,0,+1,0];
  $delta += [2000,3,26]; # beware of implicit type change!
  $delta += 7;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Unary_Minus:"
>Unary Minus:</a></h2>

<pre>  $delta2 = -$delta1;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Minus:"
>Minus:</a></h2>

<pre>  $delta = $date2 - $date1;
  $date2 = $date1 - $delta;
  $date -= $delta;
  $date2 -= $date1; # beware of implicit type change!
  $this = $date--;
  $prev = --$date;

  $delta3 = $delta2 - $delta1;
  $delta2 -= $delta1;
  $delta--;
  --$delta;

  #####################################################
  # Default TYPE for array refs in &#39;-&#39; operations is: #
  # Always a date                                     #
  #####################################################

  $delta = $today - [2000,3,26];
  $delta = [2000,4,1] - $date;
  $date2 = [2000,3,26] - $delta;
  $date2 = $date1 - [1,0,0,+7];
  $date2 = $date1 - 7;
  $date -= [1,0,0,+1]; # better add [0,0,-1] instead!
  $date2 -= [2000,3,26]; # beware of implicit type change!
  $date2 -= 1;

  $delta3 = [1,0,+1,0] - $delta1;
  $delta3 = $delta2 - [1,0,0,-1];
  $delta -= [1,0,0,+1];
  $delta -= 7;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Miscellaneous_Operators:"
>Miscellaneous Operators:</a></h2>

<pre>  $string = &#34;$date&#34;;
  $string = &#34;$delta&#34;;

  print &#34;$date\n&#34;;
  print &#34;$delta\n&#34;;

  if ($date) { # date is valid
  if ($delta) { # delta is valid

  $days = abs($date);
  $diff = abs($delta); # can be negative!

  $diff = abs(abs($delta)); # always positive</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<ul>
<li>FLAG
<p>&#34;FLAG&#34; is either 0 (for &#34;false&#34;) or 1 (for &#34;true&#34;).</p>

<p>In the case of &#34;<code>accurate_mode()</code>&#34; and &#34;<code>normalized_mode()</code>&#34;, this switches the corresponding mode on and off (see further below for an explanation of what these are).</p>

<p>In the case of &#34;<code>today()</code>&#34;, &#34;<code>now()</code>&#34; and &#34;<code>today_and_now()</code>&#34;, a &#34;true&#34; value indicates &#34;GMT&#34; (Greenwich Mean Time), as opposed to local time, which is the default.</p>
</li>

<li>NUMBER
<p>&#34;NUMBER&#34; is a number between 0 and 2 (for &#34;number_format()&#34; and &#34;number()&#34;) or between 0 and 4 (for &#34;delta_format()&#34;, &#34;date_format()&#34; and &#34;string()&#34;), indicating which of the three/five predefined formats, respectively, should be used for converting a date into numeric representation (needed for comparing dates, for instance) or string representation.</p>

<p>Format #0 is the default at startup and the simplest of all (and should be fastest to calculate, too).</p>

<p>The string representation of dates in format #0 also has the advantage of being sortable in chronological order (and of complying with ISO&#160;8601).</p>

<p>(The numeric formats are (trivially) always sortable in chronological order of course.)</p>

<p>The other formats are (mostly) increasingly more sophisticated (in terms of esthetics and computation time) with increasing number (except for format #4):</p>

<pre>  Delta number formats (short):

      0    13603
      1    13603
      2    13603

  Delta string formats (short):

      0    &#39;+0+0+13603&#39;
      1    &#39;+0 +0 +13603&#39;
      2    &#39;+0Y +0M +13603D&#39;
      3    &#39;+0 Y +0 M +13603 D&#39;
      4    &#39;(0,0,13603)&#39;

  Date number formats (short):

      0    20010401
      1    730576
      2    730576

  Date string formats (short):

      0    &#39;20010401&#39;
      1    &#39;01-Apr-2001&#39;
      2    &#39;Sun 1-Apr-2001&#39;
      3    &#39;Sunday, April 1st 2001&#39;
      4    &#39;[2001,4,1]&#39;

  Delta number formats (long):

      0    13603.012959
      1    13603.012959
      2    13603.0624884259

  Delta string formats (long):

      0    &#39;+0+0+13603+1+29+59&#39;
      1    &#39;+0 +0 +13603 +1 +29 +59&#39;
      2    &#39;+0Y +0M +13603D +1h +29m +59s&#39;
      3    &#39;+0 Y +0 M +13603 D +1 h +29 m +59 s&#39;
      4    &#39;(0,0,13603,1,29,59)&#39;

  Date number formats (long):

      0    20010401.082959
      1    730576.082959
      2    730576.354155093

  Date string formats (long):

      0    &#39;20010401082959&#39;
      1    &#39;01-Apr-2001 08:29:59&#39;
      2    &#39;Sun 1-Apr-2001 08:29:59&#39;
      3    &#39;Sunday, April 1st 2001 08:29:59&#39;
      4    &#39;[2001,4,1,8,29,59]&#39;</pre>

<p>If a number outside of the permitted range is specified, or if the value is not a code reference (see also the next section below for more details), the default format #0 is used instead.</p>
</li>

<li>CODEREF
<p>&#34;CODEREF&#34; is the reference of a subroutine which can be passed to the methods &#34;number_format()&#34;, &#34;delta_format()&#34; and &#34;date_format()&#34; in order to install a callback function which will be called subsequently whenever a date (or delta) object needs to be (implicitly) converted into a number or string.</p>

<p>This happens for instance when you compare two date objects, or when you put a date object reference in a string between double quotes.</p>

<p>Such a &#34;CODEREF&#34; can also be passed to the methods &#34;number()&#34; and &#34;string()&#34; for explicitly converting a date object as desired.</p>
</li>

<li>LANGUAGE
<p>&#34;LANGUAGE&#34; is either a number in the range <code>[1..Languages()]</code>, or one of the strings &#34;<code>Language_to_Text(1..Languages())</code>&#34; (see also <a href="../../Date/Calc(3).html" class="podlinkpod"
>Date::Calc(3)</a>).</p>
</li>

<li>TYPE
<p>&#34;TYPE&#34; is 0 for a regular date and 1 for a delta vector (a list of year, month, day and optionally hours, minutes and seconds offsets).</p>
</li>

<li>Storage
<p>&#34;Date::Calc&#34; objects are implemented as two nested arrays.</p>

<p>The &#34;blessed&#34; array (whose reference is the object reference you receive when calling the &#34;new()&#34; method) contains an anonymous array at position zero and the object&#39;s data in its remaining fields.</p>

<p>The embedded anonymous array is used for storing the object&#39;s attributes (flags).</p>

<p>Dates and delta vectors always comprise either 3 or 6 data values: Year, month, day plus (optionally) hours, minutes and seconds.</p>

<p>These values are stored in the &#34;blessed&#34; array at positions 1..3 or 1..6, respectively.</p>

<p>An object without the time values is therefore called &#34;short&#34;, and an object having time values is called &#34;long&#34; throughout this manual.</p>

<p>Hint: Whenever possible, if you do not need the time values, omit them, i.e., always use the &#34;short&#34; form of the object if possible, this will speed up calculations a little (the short form uses different (faster) functions for all calculations internally).</p>

<p>The embedded anonymous array contains various flags:</p>

<p>At position zero, it contains the &#34;TYPE&#34; indicator which determines whether the object is a date or a delta vector.</p>

<p>At position 1, the object stores the &#34;NUMBER&#34; of one of the delta vector formats, or the reference of a callback function which converts the contents of the object into string representation if it&#39;s a delta vector, or &#34;undef&#34; if the global settings apply.</p>

<p>At position 2, the object stores the &#34;NUMBER&#34; of one of the date formats, or the reference of a callback function which converts the contents of the object into string representation if it&#39;s a date, or &#34;undef&#34; if the global settings apply.</p>

<p>At position 3, the object stores the &#34;LANGUAGE&#34; to be used for all conversions into strings (where applicable), or &#34;undef&#34; if the global language setting applies.</p>

<p>Note that your callback functions (see the section &#34;Callback Functions&#34; further below for more details) should not pay attention to this value at position 3, because they get a parameter which tells them which language to use (this is necessary in order to allow temporary overrides).</p>

<p>If your callback handlers use the &#34;*_to_Text*&#34; functions (or any other language-dependent function) from the &#34;Date::Calc&#34; module, your handlers should pass on this language parameter to these functions (and not the value from position 3).</p>

<p>Be reminded though that you should <b>NEVER</b> access the object&#39;s internal data directly, i.e., through their positional numbers, but <b>ALWAYS</b> through their respective accessor methods, e.g.:</p>

<pre>        year()
        month()
        day()
        hours()
        minutes()
        seconds()
        date()
        time()
        datetime()
        is_delta()
        is_date()
        is_short()
        is_long()
        delta_format()
        date_format()
        language()</pre>

<p>And although position 4 and onward in the embedded anonymous array is currently unused, it might not stay so in future releases of this module.</p>

<p>Therefore, in case you need more attributes in a subclass of the &#34;Date::Calc[::Object]&#34; class, I suggest using values starting at positions a bit further up, e.g. 6, 8 or 10.</p>
</li>

<li>Invalid Dates
<p>Only &#34;new()&#34; allows to create objects containing possibly invalid dates (needed for reading in and evaluating user input, for example).</p>
</li>

<li>Usage
<p>The methods</p>

<pre>        accurate_mode()
        normalized_mode()
        number_format()
        delta_format()
        date_format()
        language()
        date()
        time()
        datetime()
        year()
        month()
        day()
        hours()
        minutes()
        seconds()</pre>

<p>are used for reading as well as for setting attributes. They simply return the values in question if they are called without parameters.</p>

<p>The methods</p>

<pre>        accurate_mode()
        normalized_mode()
        number_format()
        delta_format()
        date_format()
        language()</pre>

<p>always return the previous value if a new value is set. This allows you to change these values temporarily and to restore their old value afterwards more easily (but you can also override the &#34;format&#34; and &#34;language&#34; settings directly when calling the &#34;number()&#34; or &#34;string()&#34; method).</p>

<p>The methods</p>

<pre>        date()
        time()
        datetime()
        year()
        month()
        day()
        hours()
        minutes()
        seconds()</pre>

<p>always return the new values when the corresponding values have been changed.</p>

<p>The method &#34;date()&#34; NEVER returns the time values (hours, minutes, seconds) even if they have just been set using this method (which the method optionally allows). Otherwise it would be very hard to predict the exact number of values it returns, which might lead to errors (wrong number of parameters) elsewhere in your program.</p>

<p>The method &#34;datetime()&#34; ALWAYS returns the time values (hours, minutes, seconds) even if the object in question lacks a time part. In that case, zeros are returned for hours, minutes and seconds instead (but the stored time part is left unchanged, whether it exists or not).</p>

<p>If you do not provide values for hours, minutes and seconds when using the method &#34;date()&#34; to set the values for year, month and day, the time part will not be changed (whether it exists or not).</p>

<p>If you do not provide values for hours, minutes and seconds when using the method &#34;datetime()&#34; to set the values for year, month and day, the time part will be filled with zeros (the time part will be created if necessary).</p>

<p>If the object is short, i.e., if it does not have any time values, the method &#34;time()&#34; returns an empty list.</p>

<p>If the object is short and the methods &#34;hours()&#34;, &#34;minutes()&#34; or &#34;seconds()&#34; are used to set any of these time values, the object is automatically promoted to the &#34;long&#34; form, and the other two time values are filled with zeros.</p>

<p>The following methods can also return &#34;undef&#34; under certain circumstances:</p>

<pre>        delta_format()
        date_format()
        language()
        is_delta()
        is_date()
        is_short()
        is_long()
        is_valid()
        hours()
        minutes()
        seconds()
        number()
        string()</pre>

<p>The methods &#34;delta_format()&#34;, &#34;date_format()&#34; and &#34;language()&#34; return &#34;undef&#34; when they are called as object methods and no individual override has been defined for the object in question.</p>

<p>The &#34;is_*()&#34; predicate methods return &#34;undef&#34; if the object in question does not have the expected internal structure. This can happen for instance when you create an empty object with &#34;new()&#34;.</p>

<p>When called without parameters, the methods &#34;hours()&#34;, &#34;minutes()&#34; and &#34;seconds()&#34; return &#34;undef&#34; if the object in question does not have a time part.</p>

<p>The methods &#34;number()&#34; and &#34;string()&#34; return &#34;undef&#34; if the object in question is not valid (i.e., if &#34;is_valid()&#34; returns &#34;undef&#34; or false).</p>

<p>And finally, the methods</p>

<pre>        copy()
        today()
        now()
        today_and_now()
        gmtime()
        localtime()
        tzoffset()
        time2date()
        normalize()</pre>

<p>return the object reference of the (target) object in question for convenience.</p>
</li>

<li>Import/Export
<p>Note that you can import and export Unix &#34;time&#34; values using the methods &#34;gmtime()&#34;, &#34;localtime()&#34;, &#34;mktime()&#34;, &#34;date2time()&#34; and &#34;time2date()&#34;, both as local time or as UTC/GMT.</p>
</li>

<li>Accurate Mode and Normalized Mode
<p>The method &#34;accurate_mode()&#34; controls the internal flag which determines which of two fundamental modes of operation is used.</p>

<p>When set to true (the default at startup), delta vectors are calculated to give the exact difference in days between two dates. The &#34;year&#34; and &#34;month&#34; entries in the resulting delta vector are always zero in that case.</p>

<p>If &#34;accurate mode&#34; is switched off (when the corresponding flag is set to false), delta vectors are calculated with year and month differences.</p>

<p>E.g., the difference between <code>[1999,12,6]</code> and <code>[2000,6,24]</code> is <code>[+0 +0 +201]</code> (plus 201 days) in accurate mode and <code>[+1 -6 +18]</code> (plus one year, minus 6 months, plus 18 days) when accurate mode is switched off, and is <code>[+0 +6 +18]</code> (plus 6 months, plus 18 days) if additionally, &#34;normalized mode&#34; is switched on.</p>

<p>The delta vector is calculated by simply taking the difference in years, the difference in months and the difference in days (if &#34;accurate mode&#34; is switched off and if &#34;normalized mode&#34; has not been switched on). This is called &#34;one-by-one&#34; semantics or &#34;year-month-day mode&#34;; &#34;YMD mode&#34; for short.</p>

<p>When &#34;normalized mode&#34; is switched on (while &#34;accurate mode&#34; is switched off), the delta vector is calculated in a more complex way involving the functions &#34;<code>Add_Delta_YM()</code>&#34; (for &#34;truncation&#34;) and &#34;<code>Delta_Days()</code>&#34;.</p>

<p>Moreover, the result is normalized, i.e., the return values are guaranteed to all have the same sign (or to be zero), and to all be &#34;minimal&#34;, i.e., not to exceed the ranges <code>[-11..+11]</code> for months, <code>[-30..+30]</code> for days, <code>[-23..+23]</code> for hours and <code>[-59..+59]</code> for minutes and seconds.</p>

<p>The rule is to add these result values to a date in a left-to-right order, and to truncate invalid intermediate dates, such as e.g. <code>[2009,2,29]</code>, to the last valid day of that same month, e.g. <code>[2009,2,28]</code>. This is called &#34;left-to-right with truncation&#34; semantics or &#34;normalized mode&#34;; &#34;N_YMD mode&#34; for short.</p>

<p>The method &#34;normalized_mode()&#34; controls the internal flag which determines whether &#34;YMD mode&#34; is used (the default at startup, for reasons of backward compatibility) or &#34;N_YMD mode&#34;.</p>

<p>Note that also for reasons of backward compatibility, this flag only has effect when &#34;accurate mode&#34; is switched off.</p>

<p>Both flags can be set and reset independently from each other, however.</p>

<p>Therefore, at startup, you can for instance switch &#34;normalized mode&#34; on, without having any immediate effect, and switch off &#34;accurate mode&#34; later, which instantly also causes &#34;normalized mode&#34; to spring into effect.</p>

<p>Because years and months have varying lengths in terms of days, the &#34;YMD&#34; and &#34;N_YMD&#34; modes are less accurate than &#34;accurate mode&#34;, because these modes depend on the context of the two dates of which the delta vector is the difference. Added to a different date, a delta vector calculated in &#34;YMD mode&#34; or &#34;N_YMD mode&#34; may yield a different offset in terms of days, i.e., the final result may sometimes vary seemingly unpredictably (or in other situations may give you the expected result, at the expense of actually representing a varying difference in days, determined exclusively by context).</p>

<p>Beware also that - for the same reason - the absolute value (&#34;<code>abs()</code>&#34;) of a delta vector returns a fictitious number of days if the delta vector contains non-zero values for &#34;year&#34; and/or &#34;month&#34; (see also the next section &#34;Absolute Value&#34; below for more details).</p>

<p>Example:</p>

<p>The difference between <code>[2000,1,1]</code> and <code>[2000,3,1]</code> is <code>[+0 +0 +60]</code> in &#34;accurate mode&#34; and <code>[+0 +2 +0]</code> in &#34;YMD mode&#34; (in this &#34;benign&#34; example, the result is the same in &#34;YMD mode&#34; and in &#34;N_YMD mode&#34;).</p>

<p>When added to the date <code>[2000,4,1]</code>, the &#34;accurate&#34; delta vector yields the date <code>[2000,5,31]</code>, whereas the &#34;YMD mode&#34; delta vector yields the date <code>[2000,6,1]</code> (which is actually a difference of 61 days).</p>

<p>Moreover, when added to the date <code>[1999,1,1]</code>, the &#34;accurate&#34; delta vector yields the date <code>[1999,3,2]</code>, whereas the &#34;inaccurate&#34; &#34;YMD Mode&#34; delta vector yields the date <code>[1999,3,1]</code> (which is actually a difference of 59 days).</p>

<p>Depending on what you want, either mode may suit you better.</p>
</li>

<li>Absolute Value
<p>Note that &#34;<code>abs($date)</code>&#34; and &#34;<code>abs($delta)</code>&#34; are just shorthands for &#34;<code>$date-&#62;number()</code>&#34; and &#34;<code>$delta-&#62;number()</code>&#34;.</p>

<p>The operator &#34;<code>abs()</code>&#34;, when applied to a date or delta vector, returns the corresponding number of days (see below for an exception to this), with the time part (if available) represented by a fraction after the decimal point.</p>

<p>In the case of dates, the absolute value (to the left of the decimal point) is the number of days since the 1st of January 1&#160;A.D. (by extrapolating the Gregorian calendar back beyond its &#34;natural&#34; limit of 1582 A.D.) <b>PLUS ONE</b>.</p>

<p>(I.e., the absolute value of the 1st of January 1 A.D. is 1.)</p>

<p>Exception:</p>

<p>If the &#34;NUMBER&#34; or &#34;number_format()&#34; is set to 0 (the default setting), the absolute value of a date to the left of the decimal point is &#34;yyyymmdd&#34;, i.e., the number in which the uppermost four digits correspond to the year, the next lower two digits to the month and the lowermost two digits to the day.</p>

<p>In the case of delta vectors, the absolute value (to the left of the decimal point) is simply the difference in days (but see also below).</p>

<p>Note that the absolute value of a delta vector can be negative!</p>

<p>If you want a positive value in all cases, apply the &#34;<code>abs()</code>&#34; operator again, i.e., &#34;<code>$posdiff = abs(abs($delta));</code>&#34;.</p>

<p>If the delta vector contains non-zero values for &#34;year&#34; and/or &#34;month&#34; (see also the discussion of &#34;Accurate Mode&#34; in the section above), an exact representation in days cannot be calculated, because years and months do not have fixed equivalents in days.</p>

<p>If nevertheless you attempt to calculate the absolute value of such a delta vector, a fictitious value is returned, which is calculated by simply multiplying the year difference with 12, adding the month difference, multiplying this sum with 31 and finally adding the day difference.</p>

<p>Beware that because of this, the absolute values of delta vectors are not necessarily contiguous.</p>

<p>Moreover, since there is more than one way to express the difference between two dates, comparisons of delta vectors may not always yield the expected result.</p>

<p>Example:</p>

<p>The difference between the two dates <code>[2000,4,30]</code> and <code>[2001,5,1]</code> can be expressed as <code>[+1 +1 -29]</code>, or as <code>[+1 +0 +1]</code>.</p>

<p>The first delta vector has an absolute value of 374, whereas the latter delta vector has an absolute value of only 373 (while the true difference in days between the two dates is 366).</p>

<p>If the date or delta vector has a time part, the time is returned as a fraction of a full day after the decimal point as follows:</p>

<p>If the &#34;NUMBER&#34; or &#34;number_format()&#34; is set to 0 (the default setting) or 1, this fraction is simply &#34;.hhmmss&#34;, i.e., the two digits after the decimal point represent the hours, the next two digits the minutes and the last two digits the seconds.</p>

<p>Note that you cannot simply add and subtract these values to yield meaningful dates or deltas again, you can only use them for comparisons (equal, not equal, less than, greater than, etc.). If you want to add/subtract, read on:</p>

<p>Only when the &#34;NUMBER&#34; or &#34;number_format()&#34; is set to 2, this fraction will be the equivalent number of seconds (i.e., <code>(((hours * 60) + minutes) * 60) + seconds</code>) divided by the number of seconds in a full day (i.e., <code>24*60*60 = 86400</code>), or <code>0/86400</code>, <code>1/86400</code>, ... , <code>86399/86400</code>.</p>

<p>In other words, the (mathematically correct) fraction of a day.</p>

<p>You can safely perform arithmetics with these values as far as the internal precision of your vendor&#39;s implementation of the C run-time library (on which Perl depends) will permit.</p>
</li>

<li>Renormalizing Delta Vectors
<p>When adding or subtracting delta vectors to/from one another, the addition or subtraction takes place component by component.</p>

<p>Example:</p>

<pre>  [+0 +0 +0 +3 +29 +50] + [+0 +0 +0 +0 +55 +5] = [+0 +0 +0 +3 +84 +55]
  [+0 +0 +0 +3 +29 +50] - [+0 +0 +0 +0 +55 +5] = [+0 +0 +0 +3 -26 +45]</pre>

<p>This may result in time values outside the usual ranges (<code>[-23..+23]</code> for hours and <code>[-59..+59]</code> for minutes and seconds).</p>

<p>Note that even though the delta value for days will often become quite large, it is impossible to renormalize this value because there is no constant conversion factor from days to months (should it be 28, 29, 30 or 31?).</p>

<p>If accurate mode (see further above for what that is) is switched off, delta vectors can also contain non-zero values for years and months. If you add or subtract these, the value for months can lie outside the range <code>[-11..11]</code>, which isn&#39;t wrong, but may seem funny.</p>

<p>Therefore, the &#34;normalize()&#34; method will also renormalize the &#34;months&#34; value, if and only if accurate mode has been switched off. (!)</p>

<p>(Hence, switch accurate mode <b>ON</b> temporarily if you <b>DON&#39;T</b> want the renormalization of the &#34;months&#34; value to happen.)</p>

<p>If you want to force the time values from the example above back into their proper ranges, use the &#34;normalize()&#34; method as follows:</p>

<pre>  print &#34;[$delta]\n&#34;;
  $delta-&#62;normalize();
  print &#34;[$delta]\n&#34;;</pre>

<p>This will print</p>

<pre>  [+0 +0 +0 +3 +84 +55]
  [+0 +0 +0 +4 +24 +55]</pre>

<p>for the first and</p>

<pre>  [+0 +0 +0 +3 -26 +45]
  [+0 +0 +0 +2 +34 +45]</pre>

<p>for the second delta vector from the example further above.</p>

<p>Note that the values for days, hours, minutes and seconds are guaranteed to have the same sign after the renormalization.</p>

<p>Under &#34;normal&#34; circumstances, i.e., when accurate mode is on (the default), this method only has an effect on the time part of the delta vector.</p>

<p>If the delta vector in question does not have a time part, nothing happens.</p>

<p>If accurate mode is off, the &#34;months&#34; value is also normalized, i.e., if it lies outside of the range <code>[-11..11]</code>, integer multiples of 12 are added to the &#34;years&#34; value and subtracted from the &#34;months&#34; value. Moreover, the &#34;months&#34; value is guaranteed to have the same sign as the values for days, hours, minutes and seconds, unless the &#34;months&#34; value is zero or the values for days, hours, minutes and seconds are all zero.</p>

<p>If the object in question is a date and if warnings are enabled, the message &#34;normalizing a date is a no-op&#34; will be printed to STDERR.</p>

<p>If the object in question is not a valid &#34;Date::Calc&#34; object, nothing happens.</p>

<p>The method returns its object&#39;s reference, which allows chaining of method calls, as in the following example:</p>

<pre>  @time = $delta-&#62;normalize()-&#62;time();</pre>
</li>

<li>Callback Functions
<p>Note that you are not restricted to the built-in formats (numbered from 0 to 2 for &#34;number_format()&#34; and &#34;number()&#34; and from 0 to 4 for &#34;delta_format()&#34;, &#34;date_format()&#34; and &#34;string()&#34;) for converting a date or delta object into a number or string.</p>

<p>You can also provide your own function(s) for doing so, in order to suit your own taste or needs, by passing a subroutine reference to the appropriate method, i.e., &#34;number_format()&#34;, &#34;number()&#34;, &#34;delta_format()&#34;, &#34;date_format()&#34; and &#34;string()&#34;.</p>

<p>You can pass a handler to only one or more of these methods, or to all of them, as you like. You can use different callback functions, or the same for all.</p>

<p>In order to facilitate the latter, and in order to make the decoding of the various cases easier for you, the callback function receives a uniquely identifying function code as its second parameter:</p>

<pre>  0  =  TO_NUMBER | IS_DATE  | IS_SHORT  (number[_format])
  1  =  TO_NUMBER | IS_DATE  | IS_LONG   (number[_format])
  2  =  TO_NUMBER | IS_DELTA | IS_SHORT  (number[_format])
  3  =  TO_NUMBER | IS_DELTA | IS_LONG   (number[_format])
  4  =  TO_STRING | IS_DATE  | IS_SHORT  (string|date_format)
  5  =  TO_STRING | IS_DATE  | IS_LONG   (string|date_format)
  6  =  TO_STRING | IS_DELTA | IS_SHORT  (string|delta_format)
  7  =  TO_STRING | IS_DELTA | IS_LONG   (string|delta_format)</pre>

<p>The first parameter of the callback function is of course the reference of the object in question itself (therefore, the callback function can actually be an object method - but not a class method, for obvious reasons).</p>

<p>The third parameter is the number of the language (in the range <code>[1..Languages()]</code>) which you should always pass along when using any of the following functions from the &#34;Date::Calc&#34; module in your handler:</p>

<p>&#34;Decode_Month()&#34;, &#34;Decode_Day_of_Week()&#34;, &#34;Compressed_to_Text()&#34;, &#34;Date_to_Text()&#34;, &#34;Date_to_Text_Long()&#34;, &#34;Calendar()&#34;, &#34;Month_to_Text()&#34;, &#34;Day_of_Week_to_Text()&#34;, &#34;Day_of_Week_Abbreviation()&#34;, &#34;Decode_Date_EU()&#34;, &#34;Decode_Date_US()&#34;, &#34;Decode_Date_EU2()&#34;, &#34;Decode_Date_US2()&#34;, &#34;Parse_Date()&#34;.</p>

<p>The callback handler should return the resulting number or string, as requested.</p>

<p>BEWARE that you should NEVER rely upon any knowledge of the object&#39;s internal structure, as this may be subject to change!</p>

<p>ALWAYS use the test and access methods provided by this module!</p>

<p>Example:</p>

<pre>  sub handler
  {
      my($self,$code,$lang) = @_;

      if    ($code == 0) # TO_NUMBER | IS_DATE  | IS_SHORT
      {
          return Date_to_Days( $self-&#62;date() );
      }
      elsif ($code == 1) # TO_NUMBER | IS_DATE  | IS_LONG
      {
          return Date_to_Days( $self-&#62;date() ) +
                           ( ( $self-&#62;hours() * 60 +
                               $self-&#62;minutes() ) * 60 +
                               $self-&#62;seconds() ) / 86400;
      }
      elsif ($code == 2) # TO_NUMBER | IS_DELTA | IS_SHORT
      {
          return ( $self-&#62;year() * 12 +
                   $self-&#62;month() ) * 31 +
                   $self-&#62;day();
      }
      elsif ($code == 3) # TO_NUMBER | IS_DELTA | IS_LONG
      {
          return ( $self-&#62;year() * 12 +
                   $self-&#62;month() ) * 31 +
                   $self-&#62;day() +
               ( ( $self-&#62;hours() * 60 +
                   $self-&#62;minutes() ) * 60 +
                   $self-&#62;seconds() ) / 86400;
      }
      elsif ($code == 4) # TO_STRING | IS_DATE  | IS_SHORT
      {
          return join( &#34;/&#34;, $self-&#62;date() );
      }
      elsif ($code == 5) # TO_STRING | IS_DATE  | IS_LONG
      {
          return join( &#34;/&#34;, $self-&#62;date() ) . &#34; &#34; .
                 join( &#34;:&#34;, $self-&#62;time() );
      }
      elsif ($code == 6) # TO_STRING | IS_DELTA | IS_SHORT
      {
          return join( &#34;|&#34;, $self-&#62;date() );
      }
      elsif ($code == 7) # TO_STRING | IS_DELTA | IS_LONG
      {
          return join( &#34;|&#34;, $self-&#62;datetime() );
      }
      else
      {
          die &#34;internal error&#34;;
      }
  }

  Date::Calc-&#62;number_format(\&#38;handler);
  Date::Calc-&#62;delta_format(\&#38;handler);
  Date::Calc-&#62;date_format(\&#38;handler);</pre>

<p>This sets our handler to take care of all automatic conversions, such as needed when comparing dates or when interpolating a string in double quotes which contains a date object.</p>

<p>To deactivate a handler, simply pass a valid format number to the method in question, e.g.:</p>

<pre>  Date::Calc-&#62;number_format(0);
  Date::Calc-&#62;delta_format(2);
  Date::Calc-&#62;date_format(3);</pre>

<p>When calling the &#34;number()&#34; or &#34;string()&#34; method explicitly, you can pass a different format number (than the global setting), like this:</p>

<pre>  $number = $date-&#62;number(2);
  $string = $date-&#62;string(1);</pre>

<p>You can also pass a handler&#39;s reference, like so:</p>

<pre>  $number = $date-&#62;number(\&#38;handler);
  $string = $date-&#62;string(\&#38;handler);</pre>

<p>This overrides the global setting and the individual object&#39;s local setting for the duration of the call of &#34;number()&#34; or &#34;string()&#34; (but doesn&#39;t change the global or local settings themselves).</p>

<p>Moreover, you can also define individual overrides for the date and the delta vector formats (but not the number format) for individual objects, e.g.:</p>

<pre>  $date-&#62;delta_format(1);
  $date-&#62;date_format(2);

  $date-&#62;delta_format(\&#38;handler);
  $date-&#62;date_format(\&#38;handler);</pre>

<p>In order to deactivate an individual handler for an object, and/or in order to deactivate any override altogether (so that the global settings apply again), you have to pass &#34;undef&#34; explicitly to the method in question:</p>

<pre>  $date-&#62;delta_format(undef);
  $date-&#62;date_format(undef);</pre>

<p>You can also define a language for individual objects (see the next section immediately below for more details).</p>

<p>If such an individual language override has been set, it will be passed to your callback handlers as the third parameter (in the case of &#34;string&#34; conversions, but not in the case of &#34;number&#34; conversions).</p>

<p>Otherwise, the global settings as defined by <code>Language($lang);</code> or <code>Date::Calc-</code>language($lang);&#62; will be passed to your handler.</p>
</li>

<li>Languages
<p>Note that this module is completely transparent to the setting of a language in &#34;Date::Calc&#34;. This means that you can choose a language in &#34;Date::Calc&#34; (with the &#34;Language()&#34; function) and all dates subsequently printed by this module will automatically be in that language - provided that you use the built-in formats of this module, or that you pass the third parameter of the callback funtion to the funtions of the &#34;Date::Calc&#34; module which accept it.</p>

<p>However, this global language setting can be overridden for individual date (or delta) objects by using the <b>OBJECT</b> method</p>

<pre>    $oldlang = $date-&#62;language($newlang);</pre>

<p>(The global setting is not altered by this in any way.)</p>

<p>In order to deactivate such an individual language setting (so that the global setting applies again), simply pass the value &#34;undef&#34; explicitly to the &#34;language()&#34; object method:</p>

<pre>  $date-&#62;language(undef);</pre>

<p>The <b>CLASS</b> method</p>

<pre>    $oldlang = Date::Calc-&#62;language($newlang);</pre>

<p>is just a convenient wrapper around the &#34;Language()&#34; function, which allows you to enter language numbers (as returned by the &#34;Decode_Language()&#34; function) or strings (as returned by the &#34;Language_to_Text()&#34; function), whatever you prefer.</p>

<p>The &#34;language()&#34; method (both class and object) always returns the <b>NAME</b> (one of &#34;<code>Language_to_Text(1..Languages())</code>&#34;) of the current setting (and never its number).</p>

<p>BEWARE that in order to avoid possible conflicts between threads or modules running concurrently, you should NEVER use the global function <code>Language($lang);</code> or the class method <code>Date::Calc-</code>language($lang);&#62; in this module!</p>

<p>The class method is retained only for backward compatibility and for convenience in stand-alone applications when it is guaranteed that no such conflicts can arise.</p>

<p>But you should probably avoid to use global settings anyway, because it may be especially troublesome to fix your code later when suddenly the need arises to use your code with threads or when your code needs to use other modules which also use &#34;Date::Calc&#34; (with different settings!).</p>

<p>By exclusively using local settings, you are making your code invulnerable against other, concurrent modules also using &#34;Date::Calc&#34; which still use global settings.</p>
</li>

<li>Exported Functions
<p>The &#34;Date::Calc::Object&#34; package imports &#34;:all&#34; functions exported by the &#34;Date::Calc&#34; module and re-exports them, for conveniency.</p>

<p>This allows you to write</p>

<pre>  use Date::Calc::Object qw(...);</pre>

<p>instead of</p>

<pre>  use Date::Calc qw(...);</pre>

<p>but with exactly the same semantics. The difference is that the object-oriented frontend is loaded additionally in the first case.</p>

<p>As with &#34;Date::Calc&#34; you can use the &#34;:all&#34; tag to import all of &#34;Date::Calc&#34;&#39;s functions:</p>

<pre>  use Date::Calc::Object qw(:all);</pre>

<p>In addition to the functions exported by &#34;Date::Calc&#34;, the &#34;Date::Calc::Object&#34; package offers some utility functions of its own for export:</p>

<pre>    $year                          = shift_year(\@_);
    ($year,$mm,$dd)                = shift_date(\@_);
    ($hrs,$min,$sec)               = shift_time(\@_);
    ($year,$mm,$dd,$hrs,$min,$sec) = shift_datetime(\@_);</pre>

<p>These functions enable your subroutines or methods to accept a &#34;Date::Calc&#34; (or subclass) date object, an (anonymous) array or a list (containing the necessary values) as parameters <b>INTERCHANGEABLY</b>.</p>

<p>You can import all of these auxiliary functions by using an &#34;:aux&#34; tag:</p>

<pre>  use Date::Calc::Object qw(:aux);</pre>

<p>If you want to import both all of the &#34;Date::Calc&#34; functions as well as all these auxiliary functions, use the &#34;:ALL&#34; tag:</p>

<pre>  use Date::Calc::Object qw(:ALL);</pre>
</li>

<li>Subclassing
<p>In case you want to subclass &#34;Date::Calc&#34; objects and to add new attributes of your own, it is recommended that you proceed as follows (the following will be considered as a part of the module&#39;s &#34;contract of use&#34; - which might be subject to change in the future, however):</p>

<p>Define a constant for the index of each attribute you want to add, currently starting no lower than &#34;4&#34;, at the top of your subclass:</p>

<pre>    use constant ATTRIB1 =&#62; 4;
    use constant ATTRIB2 =&#62; 5;
    use constant ATTRIB3 =&#62; 6;
    ...</pre>

<p>It is recommended that you use constants (which are easy to change), because I someday might want to require the element with index &#34;4&#34; for a new attribute of my own... <code>:-)</code></p>

<p>Then access your attributes like so (e.g. after calling &#34;<code>$self = SUPER-&#62;new();</code>&#34; in your constructor method):</p>

<pre>    $self-&#62;[0][ATTRIB1] = &#39;value1&#39;;
    $self-&#62;[0][ATTRIB2] = &#39;value2&#39;;
    $self-&#62;[0][ATTRIB3] = &#39;value3&#39;;
    ...</pre>

<p>Beware that if you put anything other than numbers or strings into your attributes, the methods &#34;clone()&#34; and &#34;copy()&#34; might not work as expected anymore!</p>

<p>Especially if your attributes contain references to other data structures, only the references will be copied, but not the data structures themselves.</p>

<p>This may not be what you want.</p>

<p>(You will have to override these two methods and write some of your own if not.)</p>

<p>In order for the overloaded operators and the &#34;shift_*()&#34; auxiliary functions from the &#34;Date::Calc::Object&#34; package to work properly (the latter of which are heavily used in the &#34;Date::Calendar[::Year]&#34; modules, for instance), the package name of your subclass (= the one your objects will be blessed into) is <b>REQUIRED</b> to contain a &#34;::&#34;.</p>

<p>Note that you should <b>ONLY</b> subclass &#34;Date::Calc&#34;, <b>NEVER</b> &#34;Date::Calc::Object&#34;, since subclassing the latter is less efficient (because &#34;Date::Calc::Object&#34; is just an empty class which inherits from &#34;Date::Calc&#34; - subclassing &#34;Date::Calc::Object&#34; would thus just introduce an additional name space layer to search during Perl&#39;s runtime method binding process).</p>

<p>If you give your subclass a package name below/inside the &#34;Date::&#34; namespace, you will also benefit from the fact that all error messages produced by the &#34;Date::Calc[::Object]&#34; module (and also the &#34;Date::Calendar[::Year]&#34; modules, by the way) will appear to have originated from the place outside of all &#34;<code>/^Date::/</code>&#34; modules (including yours) where one of the &#34;Date::&#34; modules was first called - i.e., all errors are always blamed on the user, no matter how deeply nested inside the &#34;Date::&#34; modules they occur, and do not usually refer to places inside any of the &#34;Date::&#34; modules (this assumes that there are no bugs in the &#34;Date::&#34; modules, and that all errors are always the user&#39;s fault <code>:-)</code>).</p>

<p>Moreover, your module&#39;s own error messages will behave in the same way if you &#34;<code>use Carp::Clan qw(^Date::);</code>&#34; at the top of your module and if you produce all error messages using &#34;carp()&#34; and &#34;croak()&#34; (instead of &#34;warn()&#34; and &#34;die()&#34;, respectively).</p>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXAMPLES"
>EXAMPLES</a></h1>

<dl>
<dt><a name="1)"
>1)</a></dt>

<dd>
<pre>  # Switch to summer time:
  $now = Date::Calc-&#62;now();
  if (($now ge [2000,3,26,2,0,0]) and
      ($now lt [2000,3,26,3,0,0]))
  {
      $now += [0,0,0,1,0,0];
  }</pre>

<dt><a name="2)"
>2)</a></dt>

<dd>
<pre>  use Date::Calc::Object qw(:all);

  Date::Calc-&#62;date_format(3);

  $date = 0;
  while (!$date)
  {
      print &#34;Please enter the date of your birthday (day-month-year): &#34;;
      $date = Date::Calc-&#62;new( Decode_Date_EU( scalar(&#60;STDIN&#62;) ) );
      if ($date)
      {
          $resp = 0;
          while ($resp !~ /^\s*[YyNn]/)
          {
              print &#34;Your birthday is: $date\n&#34;;
              print &#34;Is that correct? (yes/no) &#34;;
              $resp = &#60;STDIN&#62;;
          }
          $date = 0 unless ($resp =~ /^\s*[Yy]/)
      }
      else
      {
          print &#34;Unable to parse your birthday. Please try again.\n&#34;;
      }
  }

  if ($date + [18,0,0] &#60;= [Today()])
      { print &#34;Ok, you are over 18.\n&#34;; }
  else
      { print &#34;Sorry, you are under 18!\n&#34;; }</pre>
</dd>
</dl>

<p>For more examples, see the &#34;examples&#34; subdirectory in this distribution, and their descriptions in the file &#34;EXAMPLES.txt&#34;.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>Date::Calc(3), Date::Calc::Util(3), Date::Calendar(3), Date::Calendar::Year(3), Date::Calendar::Profiles(3).</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>This man page documents &#34;Date::Calc::Object&#34; version 6.3.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<pre>  Steffen Beyer
  mailto:STBEY@cpan.org
  http://www.engelschall.com/u/sb/download/</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright (c) 2000 - 2009 by Steffen Beyer. All rights reserved.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENSE"
>LICENSE</a></h1>

<p>This package is free software; you can use, modify and redistribute it under the same terms as Perl itself, i.e., at your option, under the terms either of the &#34;Artistic License&#34; or the &#34;GNU General Public License&#34;.</p>

<p>The C library at the core of the module &#34;Date::Calc::XS&#34; can, at your discretion, also be used, modified and redistributed under the terms of the &#34;GNU Library General Public License&#34;.</p>

<p>Please refer to the files &#34;Artistic.txt&#34;, &#34;GNU_GPL.txt&#34; and &#34;GNU_LGPL.txt&#34; in the &#34;license&#34; subdirectory of this distribution for any details!</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DISCLAIMER"
>DISCLAIMER</a></h1>

<p>This package is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</p>

<p>See the &#34;GNU General Public License&#34; for more details.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
