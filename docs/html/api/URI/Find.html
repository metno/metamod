<html><head><title>URI::Find</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:28 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Public_Methods'>Public Methods</a>
    <li class='indexItem indexItem2'><a href='#Protected_Methods'>Protected Methods</a>
    <li class='indexItem indexItem2'><a href='#Old_Functions'>Old Functions</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#EXAMPLES'>EXAMPLES</a>
  <li class='indexItem indexItem1'><a href='#NOTES'>NOTES</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#LICENSE'>LICENSE</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>URI::Find - Find URIs in arbitrary text</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  require URI::Find;

  my $finder = URI::Find-&#62;new(\&#38;callback);

  $how_many_found = $finder-&#62;find(\$text);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This module does one thing: Finds URIs and URLs in plain text. It finds them quickly and it finds them <b>all</b> (or what URI::URL considers a URI to be.) It only finds URIs which include a scheme (http:// or the like), for something a bit less strict have a look at <a href="../URI/Find/Schemeless.html" class="podlinkpod"
>URI::Find::Schemeless</a>.</p>

<p>For a command-line interface, <a href="../urifind.html" class="podlinkpod"
>urifind</a> is provided.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Public_Methods"
>Public Methods</a></h2>

<dl>
<dt><a name="new"
><b>new</b></a></dt>

<dd>
<pre>  my $finder = URI::Find-&#62;new(\&#38;callback);</pre>

<p>Creates a new URI::Find object.</p>

<p>&#38;callback is a function which is called on each URI found. It is passed two arguments, the first is a URI::URL object representing the URI found. The second is the original text of the URI found. The return value of the callback will replace the original URI in the text.</p>

<dt><a name="find"
><b>find</b></a></dt>

<dd>
<pre>  my $how_many_found = $finder-&#62;find(\$text);</pre>

<p>$text is a string to search and possibly modify with your callback.</p>

<p>Alternatively, <code>find</code> can be called with a replacement function for the rest of the text:</p>

<pre>  use CGI qw(escapeHTML);
  # ...
  my $how_many_found = $finder-&#62;find(\$text, \&#38;escapeHTML);</pre>

<p>will not only call the callback function for every URL found (and perform the replacement instructions therein), but also run the rest of the text through <code>escapeHTML()</code>. This makes it easier to turn plain text which contains URLs into HTML (see example below).</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Protected_Methods"
>Protected Methods</a></h2>

<p>I got a bunch of mail from people asking if I&#39;d add certain features to URI::Find. Most wanted the search to be less restrictive, do more heuristics, etc... Since many of the requests were contradictory, I&#39;m letting people create their own custom subclasses to do what they want.</p>

<p>The following are methods internal to URI::Find which a subclass can override to change the way URI::Find acts. They are only to be called <b>inside</b> a URI::Find subclass. Users of this module are NOT to use these methods.</p>

<dl>
<dt><a name="uri_re"
><b>uri_re</b></a></dt>

<dd>
<pre>  my $uri_re = $self-&#62;uri_re;</pre>

<p>Returns the regex for finding absolute, schemed URIs (http://www.foo.com and such). This, combined with schemeless_uri_re() is what finds candidate URIs.</p>

<p>Usually this method does not have to be overridden.</p>

<dt><a name="schemeless_uri_re"
><b>schemeless_uri_re</b></a></dt>

<dd>
<pre>  my $schemeless_re = $self-&#62;schemeless_uri_re;</pre>

<p>Returns the regex for finding schemeless URIs (www.foo.com and such) and other things which might be URIs. By default this will match nothing (though it used to try to find schemeless URIs which started with <code>www</code> and <code>ftp</code>).</p>

<p>Many people will want to override this method. See <a href="../URI/Find/Schemeless.html" class="podlinkpod"
>URI::Find::Schemeless</a> for a subclass does a reasonable job of finding URIs which might be missing the scheme.</p>

<dt><a name="uric_set"
><b>uric_set</b></a></dt>

<dd>
<pre>  my $uric_set = $self-&#62;uric_set;</pre>

<p>Returns a set matching the &#39;uric&#39; set defined in RFC 2396 suitable for putting into a character set ([]) in a regex.</p>

<p>You almost never have to override this.</p>

<dt><a name="cruft_set"
><b>cruft_set</b></a></dt>

<dd>
<pre>  my $cruft_set = $self-&#62;cruft_set;</pre>

<p>Returns a set of characters which are considered garbage. Used by decruft().</p>

<dt><a name="decruft"
><b>decruft</b></a></dt>

<dd>
<pre>  my $uri = $self-&#62;decruft($uri);</pre>

<p>Sometimes garbage characters like periods and parenthesis get accidentally matched along with the URI. In order for the URI to be properly identified, it must sometimes be &#34;decrufted&#34;, the garbage characters stripped.</p>

<p>This method takes a candidate URI and strips off any cruft it finds.</p>

<dt><a name="recruft"
><b>recruft</b></a></dt>

<dd>
<pre>  my $uri = $self-&#62;recruft($uri);</pre>

<p>This method puts back the cruft taken off with decruft(). This is necessary because the cruft is destructively removed from the string before invoking the user&#39;s callback, so it has to be put back afterwards.</p>

<dt><a name="schemeless_to_schemed"
><b>schemeless_to_schemed</b></a></dt>

<dd>
<pre>  my $schemed_uri = $self-&#62;schemeless_to_schemed($schemeless_uri);</pre>

<p>This takes a schemeless URI and returns an absolute, schemed URI. The standard implementation supplies ftp:// for URIs which start with ftp., and http:// otherwise.</p>

<dt><a name="is_schemed"
><b>is_schemed</b></a></dt>

<dd>
<pre>  $obj-&#62;is_schemed($uri);</pre>

<p>Returns whether or not the given URI is schemed or schemeless. True for schemed, false for schemeless.</p>

<dt><a name="badinvo"
><i>badinvo</i></a></dt>

<dd>
<pre>  __PACKAGE__-&#62;badinvo($extra_levels, $msg)</pre>

<p>This is used to complain about bogus subroutine/method invocations. The args are optional.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Old_Functions"
>Old Functions</a></h2>

<p>The old find_uri() function is still around and it works, but its deprecated.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXAMPLES"
>EXAMPLES</a></h1>

<p>Store a list of all URIs (normalized) in the document.</p>

<pre>  my @uris;
  my $finder = URI::Find-&#62;new(sub {
      my($uri) = shift;
      push @uris, $uri;
  });
  $finder-&#62;find(\$text);</pre>

<p>Print the original URI text found and the normalized representation.</p>

<pre>  my $finder = URI::Find-&#62;new(sub {
      my($uri, $orig_uri) = @_;
      print &#34;The text &#39;$orig_uri&#39; represents &#39;$uri&#39;\n&#34;;
      return $orig_uri;
  });
  $finder-&#62;find(\$text);</pre>

<p>Check each URI in document to see if it exists.</p>

<pre>  use LWP::Simple;

  my $finder = URI::Find-&#62;new(sub {
      my($uri, $orig_uri) = @_;
      if( head $uri ) {
          print &#34;$orig_uri is okay\n&#34;;
      }
      else {
          print &#34;$orig_uri cannot be found\n&#34;;
      }
      return $orig_uri;
  });
  $finder-&#62;find(\$text);</pre>

<p>Turn plain text into HTML, with each URI found wrapped in an HTML anchor.</p>

<pre>  use CGI qw(escapeHTML);
  use URI::Find;

  my $finder = URI::Find-&#62;new(sub {
      my($uri, $orig_uri) = @_;
      return qq|&#60;a href=&#34;$uri&#34;&#62;$orig_uri&#60;/a&#62;|;
  });
  $finder-&#62;find(\$text, \&#38;escapeHTML);
  print &#34;&#60;pre&#62;$text&#60;/pre&#62;&#34;;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NOTES"
>NOTES</a></h1>

<p>Will not find URLs with Internationalized Domain Names or pretty much any non-ascii stuff in them. See <a href="http://rt.cpan.org/Ticket/Display.html?id=44226" class="podlinkurl"
>http://rt.cpan.org/Ticket/Display.html?id=44226</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Michael G Schwern &#60;schwern@pobox.com&#62; with insight from Uri Gutman, Greg Bacon, Jeff Pinyan, Roderick Schertler and others.</p>

<p>Roderick Schertler &#60;roderick@argon.org&#62; maintained versions 0.11 to 0.16.</p>

<p>Darren Chamberlain wrote urifind.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENSE"
>LICENSE</a></h1>

<p>Copyright 2000, 2009-2010 by Michael G Schwern &#60;schwern@pobox.com&#62;.</p>

<p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<p>See <em>http://www.perlfoundation.org/artistic_license_1_0</em></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../urifind.html" class="podlinkpod"
>urifind</a>, <a href="../URI/Find/Schemeless.html" class="podlinkpod"
>URI::Find::Schemeless</a>, <a href="../URI/URL.html" class="podlinkpod"
>URI::URL</a>, <a href="../URI.html" class="podlinkpod"
>URI</a>, RFC 3986 Appendix C</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
