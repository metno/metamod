<html><head><title>POE::Filter</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:25 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#PUBLIC_INTERFACE'>PUBLIC INTERFACE</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#new_PARAMETERS'>new PARAMETERS</a>
    <li class='indexItem indexItem2'><a href='#clone'>clone</a>
    <li class='indexItem indexItem2'><a href='#get_one_start_ARRAYREF'>get_one_start ARRAYREF</a>
    <li class='indexItem indexItem2'><a href='#get_one'>get_one</a>
    <li class='indexItem indexItem2'><a href='#get_ARRAYREF'>get ARRAYREF</a>
    <li class='indexItem indexItem2'><a href='#put_ARRAYREF'>put ARRAYREF</a>
    <li class='indexItem indexItem2'><a href='#get_pending'>get_pending</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS_%26_COPYRIGHTS'>AUTHORS &#38; COPYRIGHTS</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>POE::Filter - protocol abstractions for POE::Wheel and standalone use</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<p>To use with POE::Wheel classes,
pass a POE::Filter object to one of the &#34;...Filter&#34; constructor parameters:</p>

<pre>  #!perl

  use POE qw(Filter::Line Wheel::FollowTail);

  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub {
        $_[HEAP]{tailor} = POE::Wheel::FollowTail-&#62;new(
          Filename =&#62; &#34;/var/log/system.log&#34;,
          InputEvent =&#62; &#34;got_log_line&#34;,
          Filter =&#62; POE::Filter::Line-&#62;new(),
        );
      },
      got_log_line =&#62; sub {
        print &#34;Log: $_[ARG0]\n&#34;;
      }
    }
  );

  POE::Kernel-&#62;run();
  exit;</pre>

<p>Standalone use without POE:</p>

<pre>  #!perl

  use warnings;
  use strict;
  use POE::Filter::Line;

  my $filter = POE::Filter::Line-&#62;new( Literal =&#62; &#34;\n&#34; );

  # Prints three lines: one, two three.

  $filter-&#62;get_one_start([&#34;one\ntwo\nthr&#34;, &#34;ee\nfour&#34;]);
  while (1) {
    my $line = $filter-&#62;get_one();
    last unless @$line;
    print $line-&#62;[0], &#34;\n&#34;;
  }

  # Prints two lines: four, five.

  $filter-&#62;get_one_start([&#34;\nfive\n&#34;]);
  while (1) {
    my $line = $filter-&#62;get_one();
    last unless @$line;
    print $line-&#62;[0], &#34;\n&#34;;
  }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>POE::Filter objects plug into the wheels and define how the data will be serialized for writing and parsed after reading. POE::Wheel objects are responsible for moving data, and POE::Filter objects define how the data should look.</p>

<p>POE::Filter objects are simple by design. They do not use POE internally, so they are limited to serialization and parsing. This may complicate implementation of certain protocols (like HTTP 1.x), but it allows filters to be used in stand-alone programs.</p>

<p>Stand-alone use is very important. It allows application developers to create lightweight blocking libraries that may be used as simple clients for POE servers. POE::Component::IKC::ClientLite is a notable example. This lightweight, blocking event-passing client supports thin clients for gridded POE applications. The canonical use case is to inject events into an IKC application or grid from CGI interfaces, which require lightweight resource use.</p>

<p>POE filters and drivers pass data in array references. This is slightly awkward, but it minimizes the amount of data that must be copied on Perl&#39;s stack.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PUBLIC_INTERFACE"
>PUBLIC INTERFACE</a></h1>

<p>All POE::Filter classes must support the minimal interface, defined here. Specific filters may implement and document additional methods.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="new_PARAMETERS"
>new PARAMETERS</a></h2>

<p>new() creates and initializes a new filter. Constructor parameters vary from one POE::Filter subclass to the next, so please consult the documentation for your desired filter.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="clone"
>clone</a></h2>

<p>clone() creates and initializes a new filter based on the constructor parameters of the existing one. The new filter is a near-identical copy, except that its buffers are empty.</p>

<p>Certain components, such as POE::Component::Server::TCP, use clone(). These components accept a master or template filter at creation time, then clone() that filter for each new connection.</p>

<pre>  my $new_filter = $old_filter-&#62;clone();</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_one_start_ARRAYREF"
>get_one_start ARRAYREF</a></h2>

<p>get_one_start() accepts an array reference containing unprocessed stream chunks. The chunks are added to the filter&#39;s internal buffer for parsing by get_one().</p>

<p>The <a href="#SYNOPSIS" class="podlinkpod"
>&#34;SYNOPSIS&#34;</a> shows get_one_start() in use.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_one"
>get_one</a></h2>

<p>get_one() parses zero or one complete item from the filter&#39;s internal buffer. The data is returned as an ARRAYREF suitable for passing to another filter or a POE::Wheel object. Filters will return empty ARRAYREFs if they don&#39;t have enough raw data to build a complete item.</p>

<p>get_one() is the lazy form of get(). It only parses only one item at a time from the filter&#39;s buffer. This is vital for applications that may switch filters in mid-stream, as it ensures that the right filter is in use at any given time.</p>

<p>The <a href="#SYNOPSIS" class="podlinkpod"
>&#34;SYNOPSIS&#34;</a> shows get_one() in use. Note how it assumes the return is always an ARRAYREF, and it implicitly handles empty ones.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_ARRAYREF"
>get ARRAYREF</a></h2>

<p>get() is the greedy form of get_one(). It accepts an array reference containing unprocessed stream chunks, and it adds that data to the filter&#39;s internal buffer. It then parses as many full items as possible from the buffer and returns them in another array reference. Any unprocessed data remains in the filter&#39;s buffer for the next call.</p>

<p>As with get_one(), get() will return an empty array reference if the filter doesn&#39;t contain enough raw data to build a complete item.</p>

<p>In fact, get() is implemented in POE::Filter in terms of get_one_start() and get_one().</p>

<p>Here&#39;s the get() form of the SYNOPSIS stand-alone example:</p>

<pre>  #!perl

  use warnings;
  use strict;
  use POE::Filter::Line;

  my $filter = POE::Filter::Line-&#62;new( Literal =&#62; &#34;\n&#34; );

  # Prints three lines: one, two three.

  my $lines = $filter-&#62;get([&#34;one\ntwo\nthr&#34;, &#34;ee\nfour&#34;]);
  foreach my $line (@$lines) {
    print &#34;$line\n&#34;;
  }

  # Prints two lines: four, five.

  $lines = $filter-&#62;get([&#34;\nfive\n&#34;]);
  foreach my $line (@$lines) {
    print &#34;$line\n&#34;;
  }</pre>

<p>get() should not be used with wheels that support filter switching. Its greedy nature means that it often parses streams well in advance of a wheel&#39;s events. By the time an application changes the wheel&#39;s filter, it&#39;s too late: The old filter has already parsed the rest of the received data.</p>

<p>Consider a stream of letters, numbers, and periods. The periods signal when to switch filters from one that parses letters to one that parses numbers.</p>

<p>In our hypothetical application, letters must be handled one at a time, but numbers may be handled in chunks. We&#39;ll use POE::Filter::Block with a BlockSize of 1 to parse letters, and POE::FIlter::Line with a Literal terminator of &#34;.&#34; to handle numbers.</p>

<p>Here&#39;s the sample stream:</p>

<pre>  abcdefg.1234567.hijklmnop.890.q</pre>

<p>We&#39;ll start with a ReadWrite wheel configured to parse characters.</p>

<pre>  $_[HEAP]{wheel} = POE::Wheel::ReadWrite-&#62;new(
    Filter =&#62; POE::Filter::Block-&#62;new( BlockSize =&#62; 1 ),
    Handle =&#62; $socket,
    InputEvent =&#62; &#34;got_letter&#34;,
  );</pre>

<p>The &#34;got_letter&#34; handler will be called 8 times. One for each letter from a through g, and once for the period following g. Upon receiving the period, it will switch the wheel into number mode.</p>

<pre>  sub handle_letter {
    my $letter = $_[ARG0];
    if ($letter eq &#34;.&#34;) {
      $_[HEAP]{wheel}-&#62;set_filter(
        POE::Filter::Line-&#62;new( Literal =&#62; &#34;.&#34; )
      );
      $_[HEAP]{wheel}-&#62;event( InputEvent =&#62; &#34;got_number&#34; );
    }
    else {
      print &#34;Got letter: $letter\n&#34;;
    }
  }</pre>

<p>If the greedy get() were used, the entire input stream would have been parsed as characters in advance of the first handle_letter() call. The set_filter() call would have been moot, since there would be no data left to be parsed.</p>

<p>The &#34;got_number&#34; handler receives contiguous runs of digits as period-terminated lines. The greedy get() would cause a similar problem as above.</p>

<pre>  sub handle_numbers {
    my $numbers = $_[ARG0];
    print &#34;Got number(s): $numbers\n&#34;;
    $_[HEAP]-&#62;{wheel}-&#62;set_filter(
      POE::Filter::Block-&#62;new( BlockSize =&#62; 1 )
    );
    $_[HEAP]-&#62;{wheel}-&#62;event( InputEvent =&#62; &#34;got_letter&#34; );
  }</pre>

<p>So don&#39;t do it!</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="put_ARRAYREF"
>put ARRAYREF</a></h2>

<p>put() serializes items into a stream of octets that may be written to a file or sent across a socket. It accepts a reference to a list of items, and it returns a reference to a list of marshalled stream chunks. The number of output chunks is not necessarily related to the number of input items.</p>

<p>In stand-alone use, put()&#39;s output may be sent directly:</p>

<pre>  my $line_filter = POE::Filter::Line-&#62;new();
  my $lines = $line_filter-&#62;put(\@list_of_things);
  foreach my $line (@$lines) {
    print $line;
  }</pre>

<p>The list reference it returns may be passed directly to a driver or filter. Drivers and filters deliberately share the same put() interface so that things like this are possible:</p>

<pre>  $driver-&#62;put(
    $transfer_encoding_filter-&#62;put(
      $content_encoding_filter-&#62;put(
        \@items
      )
    )
  );

  1 while $driver-&#62;flush(\*STDOUT);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_pending"
>get_pending</a></h2>

<p>get_pending() returns any data remaining in a filter&#39;s input buffer. The filter&#39;s input buffer is not cleared, however. get_pending() returns a list reference if there&#39;s any data, or undef if the filter was empty.</p>

<p>POE::Wheel objects use get_pending() during filter switching. Unprocessed data is fetched from the old filter with get_pending() and injected into the new filter with get_one_start().</p>

<pre>  use POE::Filter::Line;
  use POE::Filter::Stream;

  my $line_filter = POE::Filter::Line-&#62;new();
  $line_filter-&#62;get_one_start([ &#34;not a complete line&#34; ]);

  my $stream_filter = POE::Filter::Stream-&#62;new();
  my $line_buffer = $line_filter-&#62;get_pending();
  $stream_filter-&#62;get_one_start($line_buffer) if $line_buffer;

  print &#34;Stream: $_\n&#34; foreach (@{ $stream_filter-&#62;get_one });</pre>

<p>Full items are serialized whole, so there is no corresponding &#34;put&#34; buffer or accessor.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>The SEE ALSO section in <a href="../POE.html" class="podlinkpod"
>POE</a> contains a table of contents covering the entire POE distribution.</p>

<p>POE is bundled with the following filters:</p>

<p><a href="../POE/Filter/Block.html" class="podlinkpod"
>POE::Filter::Block</a> <a href="../POE/Filter/Grep.html" class="podlinkpod"
>POE::Filter::Grep</a> <a href="../POE/Filter/HTTPD.html" class="podlinkpod"
>POE::Filter::HTTPD</a> <a href="../POE/Filter/Line.html" class="podlinkpod"
>POE::Filter::Line</a> <a href="../POE/Filter/Map.html" class="podlinkpod"
>POE::Filter::Map</a> <a href="../POE/Filter/RecordBlock.html" class="podlinkpod"
>POE::Filter::RecordBlock</a> <a href="../POE/Filter/Reference.html" class="podlinkpod"
>POE::Filter::Reference</a> <a href="../POE/Filter/Stackable.html" class="podlinkpod"
>POE::Filter::Stackable</a> <a href="../POE/Filter/Stream.html" class="podlinkpod"
>POE::Filter::Stream</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>In theory, filters should be interchangeable. In practice, stream and block protocols tend to be incompatible.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS_&#38;_COPYRIGHTS"
>AUTHORS &#38; COPYRIGHTS</a></h1>

<p>Please see <a href="../POE.html" class="podlinkpod"
>POE</a> for more information about authors and contributors.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
