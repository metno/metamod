<html><head><title>POE::Wheel</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:26 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#FILTERS%2C_AND_DRIVERS'>FILTERS, AND DRIVERS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Filters'>Filters</a>
    <li class='indexItem indexItem2'><a href='#Drivers'>Drivers</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#METHODS'>METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Required_Methods'>Required Methods</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#new_LOTS_OF_STUFF'>new LOTS_OF_STUFF</a>
      <li class='indexItem indexItem3'><a href='#DESTROY'>DESTROY</a>
      <li class='indexItem indexItem3'><a href='#event_EVENT_TYPE%2C_EVENT_NAME_%5B%2C_EVENT_TYPE%2C_EVENT_NAME%2C_....%5D'>event EVENT_TYPE, EVENT_NAME [, EVENT_TYPE, EVENT_NAME, ....]</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#I%2FO_Methods'>I/O Methods</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#put_RECORD_%5B%2C_RECORD_%5B%2C_....%5D%5D'>put RECORD [, RECORD [, ....]]</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Class_Static_Functions'>Class Static Functions</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#allocate_wheel_id'>allocate_wheel_id</a>
      <li class='indexItem indexItem3'><a href='#free_wheel_id_WHEEL_ID'>free_wheel_id WHEEL_ID</a>
      <li class='indexItem indexItem3'><a href='#ID'>ID</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS_%26_COPYRIGHTS'>AUTHORS &#38; COPYRIGHTS</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>POE::Wheel - event-driven mixins for POE::Session</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<p>This base class has no synopsis.
Please consult one of the subclasses instead.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>A POE::Wheel object encapsulates a bundle of event handlers that perform a specific task.
It also manages the event watchers that trigger those handlers.</p>

<p>Object lifetime is very important for POE wheels.
At creation time,
most wheels will add anonymous event handlers to the currently active session.
In other words,
the session that created the wheel is modified to handle new events.
Event watchers may also be initialized as necessary to trigger the new handlers.
These event watchers are also owned by the session that created the wheel.</p>

<p>Sessions must not expose their wheels to other sessions.
Doing so will likely cause problems because wheels are tightly integrated with the sessions that created them.
For example,
calling put() on a POE::Wheel::ReadWrite instance may enable a write-okay watcher.
The handler for this watcher is already defined in the wheel&#39;s owner.
Calling put() outside that session will enable the write-okay watcher in the wrong session,
and the event will never be handled.</p>

<p>Likewise,
wheels must be destroyed from within their creator sessions.
Otherwise breakage will occur when the wheels&#39; DESTROY methods try to unregister event handlers and watchers from the wrong sessions.
To simplify things,
it&#39;s recommended to store POE::Wheel instances in heaps of the sessions that created them.</p>

<p>For example,
creating a POE::Wheel::FollowTail object will register an event handler that periodically polls a file for new information.
It will also start the timer that triggers the periodic polling.</p>

<pre>  use POE;
  use POE::Wheel::FollowTail;

  my @files_to_tail = qw( messages maillog security );

  foreach my $filename (@files_to_tail) {
    POE::Session-&#62;create(
      inline_states =&#62; {
        _start =&#62; sub {
          push @{$_[HEAP]{messages}}, POE::Wheel::FollowTail-&#62;new(
            Filename   =&#62; &#34;/var/log/$filename&#34;,
            InputEvent =&#62; &#34;got_input&#34;,
          );
        },
        got_input =&#62; sub {
          print &#34;$filename: $_[ARG0]\n&#34;;
        },
      }
    );
  }

  POE::Kernel-&#62;run();
  exit;</pre>

<p>As illustrated in the previous example it is possible---sometimes recommended---to create more than one POE::Wheel of a particular type in the same session. A session with multiple wheels may scale better than separate sessions with one wheel apiece. When in doubt, benchmark.</p>

<p>Unlike components (or cheese), wheels do not stand alone. Each wheel must be created by a session in order to register event watchers and handlers within that session. Wheels are thusly tightly coupled to their creator sessions and cannot be passed to other sessions.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FILTERS,_AND_DRIVERS"
>FILTERS, AND DRIVERS</a></h1>

<p>Many wheels perform data transfer operations on filehandles (which, as you probably know, includes sockets, pipes, and just about anything else that can store or transfer data).</p>

<p>To avoid subclass hell, POE::Wheel objects may be customized at creation time by including other objects from the POE::Filter and POE::Driver namespaces.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Filters"
>Filters</a></h2>

<p>POE &#34;filters&#34; implement data parsers and serializers. For example, POE::Filter::Line parses streams into records separated by some string (the traditional network newline by default). The Line filter also adds record separators to data being output.</p>

<p>POE::Filter::HTTPD is a more complex example. It implements a subset of the server-side of the HTTP protocol. Input streams are parsed into HTTP requests and wrapped in HTTP::Request objects. Server code sends HTTP::Response objects back to the client, which are serialized so they may be sent to a socket.</p>

<p>Most wheels use POE::Filter::Line by default.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Drivers"
>Drivers</a></h2>

<p>POE &#34;drivers&#34; implement strategies for sending data to a filehandle and receiving input from it. A single POE::Wheel class may interact with files, pipes, sockets, or devices by using the appropriate driver.</p>

<p>POE::Driver::SysRW is the only driver that comes with POE. sysread() and syswrite() can handle nearly every kind of stream interaction, so there hasn&#39;t been much call for another type of driver.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="METHODS"
>METHODS</a></h1>

<p>POE::Wheel defines a common interface that most subclasses use. Subclasses may implement other methods, especially to help perform their unique tasks. If something useful isn&#39;t documented here, see the subclass before implementing a feature.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Required_Methods"
>Required Methods</a></h2>

<p>These methods are required by all subclasses.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="new_LOTS_OF_STUFF"
>new LOTS_OF_STUFF</a></h3>

<p>new() instantiates and initializes a new wheel object and returns it. The new wheel will continue to function for as long as it exists, although other methods may alter the way it functions.</p>

<p>Part of any wheel&#39;s construction is the registration of anonymous event handlers to perform wheel-specific tasks. Event watchers are also started to trigger the handlers when relevant activity occurs.</p>

<p>Every wheel has a different purpose and requires different constructor parameters, so LOTS_OF_STUFF is documented in each particular subclass.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="DESTROY"
>DESTROY</a></h3>

<p>DESTROY is Ye Olde Perl Object Destructor. When the wheel&#39;s last strong reference is relinquished, DESTROY triggers the wheel&#39;s cleanup. The object removes itself from the session that created it: Active event watchers are stopped, and anonymous event handlers are unregistered.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="event_EVENT_TYPE,_EVENT_NAME_[,_EVENT_TYPE,_EVENT_NAME,_....]"
>event EVENT_TYPE, EVENT_NAME [, EVENT_TYPE, EVENT_NAME, ....]</a></h3>

<p>event() changes the events that a wheel will emit. Its parameters are one or more pairs of EVENT_TYPEs and the EVENT_NAMEs to emit when each type of event occurs. If an EVENT_NAME is undefined, then the wheel will stop emitting that type of event. Or the wheel may throw an error if the event type is required.</p>

<p>EVENT_TYPEs differ for each wheel and correspond to the constructor parameters that match /.*Event$/. For example, POE::Wheel::ReadWrite may emit up to five different kinds of event: InputEvent, ErrorEvent, FlushedEvent, HighEvent, LowEvent. The name of each emitted event may be changed at run time.</p>

<p>This example changes the events to emit on new input and when output is flushed. It stops the wheel from emitting events when errors occur.</p>

<pre>  $wheel-&#62;event(
    InputEvent   =&#62; &#39;new_input_event&#39;,
    ErrorEvent   =&#62; undef,
    FlushedEvent =&#62; &#39;new_flushed_event&#39;,
  );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="I/O_Methods"
>I/O Methods</a></h2>

<p>Wheels that perform input and output may implement some or all of these methods. The put() method is a common omission. Wheels that don&#39;t perform output do not have put() methods.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="put_RECORD_[,_RECORD_[,_....]]"
>put RECORD [, RECORD [, ....]]</a></h3>

<p>put() sends one or more RECORDs to the wheel for transmitting. Each RECORD is serialized by the wheel&#39;s associated POE::Filter so that it will be ready to transmit. The serialized stream may be transmitted immediately by the wheel&#39;s POE::Driver object, or it may be buffered in the POE::Driver until it can be flushed to the output filehandle.</p>

<p>Most wheels use POE::Filter::Line and POE::Driver::SysRW by default, so it&#39;s not necessary to specify them in most cases.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Class_Static_Functions"
>Class Static Functions</a></h2>

<p>These functions expose information that is common to all wheels. They are not methods, so they should <b>not</b> be called as methods.</p>

<pre>  my $new_wheel_id = POE::Wheel::allocate_wheel_id();
  POE::Wheel::free_wheel_id($new_wheel_id);</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="allocate_wheel_id"
>allocate_wheel_id</a></h3>

<p><b>This is not a class method.</b></p>

<p>Every wheel has a unique ID. allocate_wheel_id() returns the next available unique wheel ID. Wheel constructors use it to set their IDs internally.</p>

<pre>  package POE::Wheel::Example;
  use base qw(POE::Wheel);

  sub new {
    # ... among other things ...
    $self-&#62;[MY_WHEEL_ID] = POE::Wheel::allocate_wheel_id();
    return $self;
  }</pre>

<p>Wheel IDs are used to tell apart events from similarly typed wheels. For example, a multi-file tail utility may handle all file input with the same function. Wheel IDs may be used to tell which wheel generated the InputEvent being handled.</p>

<p>Wheel IDs are often used to store wheel-local state in a session&#39;s heap.</p>

<pre>  sub handle_error {
    my $wheel_id = $_[ARG3];
    print &#34;Wheel $wheel_id caught an error.  Shutting it down.\n&#34;;
    delete $_[HEAP]{wheels}{$wheel_id};
  }</pre>

<p>It is vital for wheels to free their allocated IDs when they are destroyed. POE::Wheel class keeps track of allocated wheel IDs to avoid collisions, and they will remain in memory until freed. See free_wheel_id().</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="free_wheel_id_WHEEL_ID"
>free_wheel_id WHEEL_ID</a></h3>

<p><b>This is not a class method.</b></p>

<p>free_wheel_id() deallocates a wheel&#39;s ID so that it stops consuming memory and may be reused later. This is often called from a wheel&#39;s destructor.</p>

<pre>  package POE::Wheel::Example;
  use base qw(POE::Wheel);

  sub DESTROY {
    my $self = shift;
    # ... among other things ...
    POE::Wheel::free_wheel_id($self-&#62;[MY_WHEEL_ID]);
  }</pre>

<p>Wheel IDs may be reused, although it has never been reported. Two active wheels will never share the same ID, however.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="ID"
>ID</a></h3>

<p><b>This is usually implemented in the subclass!</b></p>

<p>The ID() method returns a wheel&#39;s unique ID. It is commonly used to match events with the wheels which generated them.</p>

<p>Again, this method is not implemented in this class! If it&#39;s missing from the subclass, please go pester that module author---thanks!</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>The SEE ALSO section in <a href="../POE.html" class="podlinkpod"
>POE</a> contains a table of contents covering the entire POE distribution.</p>

<p><a href="../POE/Driver.html" class="podlinkpod"
>POE::Driver</a> - A base class for file access drivers that POE::Wheel may use.</p>

<p><a href="../POE/Filter.html" class="podlinkpod"
>POE::Filter</a> - A base class for data parsers and marshalers that POE::Wheel may use.</p>

<p><a href="../POE/Wheel/Curses.html" class="podlinkpod"
>POE::Wheel::Curses</a> - Non-blocking input for Curses.</p>

<p><a href="../POE/Wheel/FollowTail.html" class="podlinkpod"
>POE::Wheel::FollowTail</a> - Non-blocking file and FIFO monitoring.</p>

<p><a href="../POE/Wheel/ListenAccept.html" class="podlinkpod"
>POE::Wheel::ListenAccept</a> - Non-blocking server for existing sockets.</p>

<p><a href="../POE/Wheel/ReadLine.html" class="podlinkpod"
>POE::Wheel::ReadLine</a> - Non-blocking console input, with full readline support.</p>

<p><a href="../POE/Wheel/ReadWrite.html" class="podlinkpod"
>POE::Wheel::ReadWrite</a> - Non-blocking stream I/O.</p>

<p><a href="../POE/Wheel/Run.html" class="podlinkpod"
>POE::Wheel::Run</a> - Non-blocking process creation and management.</p>

<p><a href="../POE/Wheel/SocketFactory.html" class="podlinkpod"
>POE::Wheel::SocketFactory</a> - Non-blocking socket creation, supporting most protocols and modes.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>It would be nice if wheels were more like proper Unix streams.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS_&#38;_COPYRIGHTS"
>AUTHORS &#38; COPYRIGHTS</a></h1>

<p>Please see <a href="../POE.html" class="podlinkpod"
>POE</a> for more information about authors, contributors, and POE;s licensing.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
