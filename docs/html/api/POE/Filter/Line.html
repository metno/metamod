<html><head><title>POE::Filter::Line</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:25 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#PUBLIC_FILTER_METHODS'>PUBLIC FILTER METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#new'>new</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#PUBLIC_FILTER_METHODS'>PUBLIC FILTER METHODS</a>
  <li class='indexItem indexItem1'><a href='#SUBCLASSING'>SUBCLASSING</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS_%26_COPYRIGHTS'>AUTHORS &#38; COPYRIGHTS</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>POE::Filter::Line - serialize and parse terminated records (lines)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  #!perl

  use POE qw(Wheel::FollowTail Filter::Line);

  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub {
        $_[HEAP]{tailor} = POE::Wheel::FollowTail-&#62;new(
          Filename =&#62; &#34;/var/log/system.log&#34;,
          InputEvent =&#62; &#34;got_log_line&#34;,
          Filter =&#62; POE::Filter::Line-&#62;new(),
        );
      },
      got_log_line =&#62; sub {
        print &#34;Log: $_[ARG0]\n&#34;;
      }
    }
  );

  POE::Kernel-&#62;run();
  exit;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>POE::Filter::Line parses stream data into terminated records. The default parser interprets newlines as the record terminator, and the default serializer appends network newlines (CR/LF, or &#34;\x0D\x0A&#34;) to outbound records.</p>

<p>Record terminators are removed from the data POE::Filter::Line returns.</p>

<p>POE::Filter::Line supports a number of other ways to parse lines. Constructor parameters may specify literal newlines, regular expressions, or that the filter should detect newlines on its own.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PUBLIC_FILTER_METHODS"
>PUBLIC FILTER METHODS</a></h1>

<p>POE::Filter::Line&#39;s new() method has some interesting parameters.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="new"
>new</a></h2>

<p>new() accepts a list of named parameters.</p>

<p>In all cases, the data interpreted as the record terminator is stripped from the data POE::Filter::Line returns.</p>

<p><code>InputLiteral</code> may be used to parse records that are terminated by some literal string. For example, POE::Filter::Line may be used to parse and emit C-style lines, which are terminated with an ASCII NUL:</p>

<pre>  my $c_line_filter = POE::Filter::Line-&#62;new(
    InputLiteral =&#62; chr(0),
    OutputLiteral =&#62; chr(0),
  );</pre>

<p><code>OutputLiteral</code> allows a filter to put() records with a different record terminator than it parses. This can be useful in applications that must translate record terminators.</p>

<p><code>Literal</code> is a shorthand for the common case where the input and output literals are identical. The previous example may be written as:</p>

<pre>  my $c_line_filter = POE::Filter::Line-&#62;new(
    Literal =&#62; chr(0),
  );</pre>

<p>An application can also allow POE::Filter::Line to figure out which newline to use. This is done by specifying <code>InputLiteral</code> to be undef:</p>

<pre>  my $whichever_line_filter = POE::Filter::Line-&#62;new(
    InputLiteral =&#62; undef,
    OutputLiteral =&#62; &#34;\n&#34;,
  );</pre>

<p><code>InputRegexp</code> may be used in place of <code>InputLiteral</code> to recognize line terminators based on a regular expression. In this example, input is terminated by two or more consecutive newlines. On output, the paragraph separator is &#34;---&#34; on a line by itself.</p>

<pre>  my $paragraph_filter = POE::Filter::Line-&#62;new(
    InputRegexp =&#62; &#34;([\x0D\x0A]{2,})&#34;,
    OutputLiteral =&#62; &#34;\n---\n&#34;,
  );</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PUBLIC_FILTER_METHODS"
>PUBLIC FILTER METHODS</a></h1>

<p>POE::Filter::Line has no additional public methods.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SUBCLASSING"
>SUBCLASSING</a></h1>

<p>POE::Filter::Line exports the FIRST_UNUSED constant. This points to the first unused element in the $self array reference. Subclasses should store their own data beginning here, and they should export their own FIRST_UNUSED constants to help future subclassers.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>Please see <a href="../../POE/Filter.html" class="podlinkpod"
>POE::Filter</a> for documentation regarding the base interface.</p>

<p>The SEE ALSO section in <a href="../../POE.html" class="podlinkpod"
>POE</a> contains a table of contents covering the entire POE distribution.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>The default input newline parser is a regexp that has an unfortunate race condition. First the regular expression:</p>

<pre>  /(\x0D\x0A?|\x0A\x0D?)/</pre>

<p>While it quickly recognizes most forms of newline, it can sometimes detect an extra blank line. This happens when a two-byte newline character is broken between two reads. Consider this situation:</p>

<pre>  some stream dataCR
  LFother stream data</pre>

<p>The regular expression will see the first CR without its corresponding LF. The filter will properly return &#34;some stream data&#34; as a line. When the next packet arrives, the leading &#34;LF&#34; will be treated as the terminator for a 0-byte line. The filter will faithfully return this empty line.</p>

<p><b>It is advised to specify literal newlines or use the autodetect feature in applications where blank lines are significant.</b></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS_&#38;_COPYRIGHTS"
>AUTHORS &#38; COPYRIGHTS</a></h1>

<p>Please see <a href="../../POE.html" class="podlinkpod"
>POE</a> for more information about authors and contributors.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
