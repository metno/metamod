<html><head><title>POE::Filter::Reference</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:25 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#PUBLIC_FILTER_METHODS'>PUBLIC FILTER METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#new_%5BSERIALIZER_%5B%2C_COMPRESSION_%5B%2C_NO_FATALS%5D%5D%5D'>new [SERIALIZER [, COMPRESSION [, NO_FATALS]]]</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SERIALIZER_API'>SERIALIZER API</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#thaw_SERIALIZED'>thaw SERIALIZED</a>
    <li class='indexItem indexItem2'><a href='#nfreeze_REFERENCE'>nfreeze REFERENCE</a>
    <li class='indexItem indexItem2'><a href='#freeze_REFERENCE'>freeze REFERENCE</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS_%26_COPYRIGHTS'>AUTHORS &#38; COPYRIGHTS</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>POE::Filter::Reference - freeze and thaw arbitrary Perl data</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  #!perl

  use YAML;
  use POE qw(Wheel::ReadWrite Filter::Reference);

  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub {
        pipe(my($read, $write)) or die $!;
        $_[HEAP]{io} = POE::Wheel::ReadWrite-&#62;new(
          InputHandle =&#62; $read,
          OutputHandle =&#62; $write,
          Filter =&#62; POE::Filter::Reference-&#62;new(),
          InputEvent =&#62; &#34;got_perl_data&#34;,
        );

        $_[HEAP]{io}-&#62;put(
          { key_1 =&#62; 111, key_2 =&#62; 222 }
        );
      },
      got_perl_data =&#62; sub {
        print &#34;Got data:\n&#34;, YAML::Dump($_[ARG0]);
        print &#34;Bye!\n&#34;;
        delete $_[HEAP]{io};
      }
    }
  );

  POE::Kernel-&#62;run();
  exit;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>POE::Filter::Reference allows programs to send and receive arbitrary Perl data structures without worrying about a line protocol. Its put() method serializes Perl data into a byte stream suitable for transmission. get_one() parses the data structures back out of such a stream.</p>

<p>By default, POE::Filter::Reference uses Storable to do its magic. A different serializer may be specified at construction time.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PUBLIC_FILTER_METHODS"
>PUBLIC FILTER METHODS</a></h1>

<p>POE::Filter::Reference deviates from the standard POE::Filter API in the following ways.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="new_[SERIALIZER_[,_COMPRESSION_[,_NO_FATALS]]]"
>new [SERIALIZER [, COMPRESSION [, NO_FATALS]]]</a></h2>

<p>new() creates and initializes a POE::Filter::Reference object. It will use Storable as its default SERIALIZER if none other is specified.</p>

<p>If COMPRESSION is true, Compress::Zlib will be called upon to reduce the size of serialized data. It will also decompress the incoming stream data.</p>

<p>If NO_FATALS is true, messages will be thawed inside a block eval. By default, however, thaw() is allowed to die normally. If an error occurs while NO_FATALS is in effect, POE::Filter::Reference will return a string containing the contents of $@ at the time the eval failed. So when using NO_FATALS, it&#39;s important to check whether input is really a reference:</p>

<pre>  sub got_reference {
    my $message = $_[ARG0];
    if (ref $message) {
      print &#34;Got data:\n&#34;, YAML::Dump($message);
    }
    else {
      warn &#34;Input decode error: $message\n&#34;;
    }
  }</pre>

<p>Any class that supports nfreeze() (or freeze()) and thaw() may be used as a SERIALIZER. If a SERIALIZER implements both nfreeze() and freeze(), then the &#34;network&#34; version will be used.</p>

<p>SERIALIZER may be a class name:</p>

<pre>  # Use Storable explicitly, specified by package name.
  my $filter = POE::Filter::Reference-&#62;new(&#34;Storable&#34;);

  # Use YAML instead.  Compress its output, as it may be verbose.
  my $filter = POE::Filter::Reference-&#62;new(&#34;YAML&#34;, 1);</pre>

<p>SERIALIZER may also be an object:</p>

<pre>  # Use an object.
  my $serializer = Data::Serializer::Something-&#62;new();
  my $filter = POE::Filter::Reference-&#62;new($serializer);</pre>

<p>If SERIALIZER is omitted or undef, the Reference filter will try to use Storable, FreezeThaw, and YAML in that order. POE::Filter::Reference will die if it cannot find one of these serializers, but this rarely happens now that Storable and YAML are bundled with Perl.</p>

<pre>  # A choose-your-own-serializer adventure!
  # We&#39;ll still deal with compressed data, however.
  my $filter = POE::Filter::Reference-&#62;new(undef, 1);</pre>

<p>POE::Filter::Reference will try to compress frozen strings and uncompress them before thawing if COMPRESSION is true. It uses Compress::Zlib for this. POE::Filter::Reference doesn&#39;t need Compress::Zlib if COMPRESSION is false.</p>

<p>new() will try to load any classes it needs.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SERIALIZER_API"
>SERIALIZER API</a></h1>

<p>Here&#39;s what POE::Filter::Reference expects of its serializers.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="thaw_SERIALIZED"
>thaw SERIALIZED</a></h2>

<p>thaw() is required. It accepts two parameters: $self and a scalar containing a SERIALIZED byte stream representing a single Perl data structure. It returns a reconstituted Perl data structure.</p>

<pre>  sub thaw {
    my ($self, $stream) = @_;
    my $reference = $self-&#62;_deserialization_magic($stream);
    return $reference;
  }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="nfreeze_REFERENCE"
>nfreeze REFERENCE</a></h2>

<p>Either nfreeze() or freeze() is required. They behave identically, except that nfreeze() is guaranteed to be portable across networks and between machine architectures.</p>

<p>These freezers accept two parameters: $self and a REFERENCE to Perl data. They return a serialized version of the REFERENCEd data.</p>

<pre>  sub nfreeze {
    my ($self, $reference) = @_;
    my $stream = $self-&#62;_serialization_magic($reference);
    return $stream;
  }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="freeze_REFERENCE"
>freeze REFERENCE</a></h2>

<p>freeze() is an alternative form of nfreeze(). It has the same call signature as nfreeze(), but it doesn&#39;t guarantee that serialized data will be portable across machine architectures.</p>

<p>If you must choose between implementing freeze() and nfreeze() for use with POE::Filter::Reference, go with nfreeze().</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>Please see <a href="../../POE/Filter.html" class="podlinkpod"
>POE::Filter</a> for documentation regarding the base interface.</p>

<p>The SEE ALSO section in <a href="../../POE.html" class="podlinkpod"
>POE</a> contains a table of contents covering the entire POE distribution.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>Not so much bugs as caveats:</p>

<p>It&#39;s important to use identical serializers on each end of a connection. Even different versions of the same serializer can break data in transit.</p>

<p>Most (if not all) serializers will re-bless data at the destination, but many of them will not load the necessary classes to make those blessings work. Make sure the same classes and versions are available on either end of the wire.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS_&#38;_COPYRIGHTS"
>AUTHORS &#38; COPYRIGHTS</a></h1>

<p>The Reference filter was contributed by Artur Bergman, with changes by Philip Gwyn.</p>

<p>Please see <a href="../../POE.html" class="podlinkpod"
>POE</a> for more information about authors and contributors.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
