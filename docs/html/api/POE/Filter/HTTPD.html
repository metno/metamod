<html><head><title>POE::Filter::HTTPD</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:25 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#PUBLIC_FILTER_METHODS'>PUBLIC FILTER METHODS</a>
  <li class='indexItem indexItem1'><a href='#CAVEATS'>CAVEATS</a>
  <li class='indexItem indexItem1'><a href='#Streaming_Media'>Streaming Media</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS_%26_COPYRIGHTS'>AUTHORS &#38; COPYRIGHTS</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>POE::Filter::HTTPD - parse simple HTTP requests,
and serialize HTTP::Response</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  #!perl

  use warnings;
  use strict;

  use POE qw(Component::Server::TCP Filter::HTTPD);
  use HTTP::Response;

  POE::Component::Server::TCP-&#62;new(
    Port         =&#62; 8088,
    ClientFilter =&#62; &#39;POE::Filter::HTTPD&#39;,  ### &#60;-- HERE WE ARE!

    ClientInput =&#62; sub {
      my $request = $_[ARG0];

      # It&#39;s a response for the client if there was a problem.
      if ($request-&#62;isa(&#34;HTTP::Response&#34;)) {
        my $response = $request;

        $request = $response-&#62;request;
        warn &#34;ERROR: &#34;, $request-&#62;message if $request;

        $_[HEAP]{client}-&#62;put($response);
        $_[KERNEL]-&#62;yield(&#34;shutdown&#34;);
        return;
      }

      my $request_fields = &#39;&#39;;
      $request-&#62;headers()-&#62;scan(
        sub {
          my ($header, $value) = @_;
          $request_fields .= (
            &#34;&#60;tr&#62;&#60;td&#62;$header&#60;/td&#62;&#60;td&#62;$value&#60;/td&#62;&#60;/tr&#62;&#34;
          );
        }
      );

      my $response = HTTP::Response-&#62;new(200);
      $response-&#62;push_header( &#39;Content-type&#39;, &#39;text/html&#39; );
      $response-&#62;content(
        &#34;&#60;html&#62;&#60;head&#62;&#60;title&#62;Your Request&#60;/title&#62;&#60;/head&#62;&#34; .
        &#34;&#60;body&#62;Details about your request:&#34; .
        &#34;&#60;table border=&#39;1&#39;&#62;$request_fields&#60;/table&#62;&#34; .
        &#34;&#60;/body&#62;&#60;/html&#62;&#34;
      );

      $_[HEAP]{client}-&#62;put($response);
      $_[KERNEL]-&#62;yield(&#34;shutdown&#34;);
    }
  );

  print &#34;Aim your browser at port 8088 of this host.\n&#34;;
  POE::Kernel-&#62;run();
  exit;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>POE::Filter::HTTPD interprets input streams as HTTP 0.9, 1.0 or 1.1 requests. It returns a HTTP::Request objects upon successfully parsing a request.</p>

<p>On failure, it returns an HTTP::Response object describing the failure. The intention is that application code will notice the HTTP::Response and send it back without further processing. The erroneous request object is sometimes available via the <a href="../../HTTP/Response.html#%24r-%3Erequest" class="podlinkpod"
>&#34;$r-&#62;request&#34; in HTTP::Response</a> method. This is illustrated in the <a href="#SYNOPSIS" class="podlinkpod"
>&#34;SYNOPSIS&#34;</a>.</p>

<p>For output, POE::Filter::HTTPD accepts HTTP::Response objects and returns their corresponding streams.</p>

<p>Please see <a href="../../HTTP/Request.html" class="podlinkpod"
>HTTP::Request</a> and <a href="../../HTTP/Response.html" class="podlinkpod"
>HTTP::Response</a> for details about how to use these objects.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PUBLIC_FILTER_METHODS"
>PUBLIC FILTER METHODS</a></h1>

<p>POE::Filter::HTTPD implements the basic POE::Filter interface.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CAVEATS"
>CAVEATS</a></h1>

<p>Some versions of libwww are known to generate invalid HTTP. For example, this code (adapted from the HTTP::Request::Common documentation) will cause an error in a POE::Filter::HTTPD daemon:</p>

<p>NOTE: Using this test with libwww-perl/5.834 showed that it added the proper HTTP/1.1 data! We&#39;re not sure which version of LWP fixed this. This example is valid for older LWP installations, beware!</p>

<pre>  use HTTP::Request::Common;
  use LWP::UserAgent;

  my $ua = LWP::UserAgent-&#62;new();
  $ua-&#62;request(POST &#39;http://example.com&#39;, [ foo =&#62; &#39;bar&#39; ]);</pre>

<p>By default, HTTP::Request is HTTP version agnostic. It makes no attempt to add an HTTP version header unless you specifically declare a protocol using <code>$request-&#62;protocol(&#39;HTTP/1.0&#39;)</code>.</p>

<p>According to the HTTP 1.0 RFC (1945), when faced with no HTTP version header, the parser is to default to HTTP/0.9. POE::Filter::HTTPD follows this convention. In the transaction detailed above, the Filter::HTTPD based daemon will return a 400 error since POST is not a valid HTTP/0.9 request type.</p>

<p>Upon handling a request error, it is most expedient and reliable to respond with the error and shut down the connection. Invalid HTTP requests may corrupt the request stream. For example, the absence of a Content-Length header signals that a request has no content. Requests with content but not that header will be broken into a content-less request and invalid data. The invalid data may also appear to be a request! Hilarity will ensue, possibly repeatedly, until the filter can find the next valid request. By shutting down the connection on the first sign of error, the client can retry its request with a clean connection and filter.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Streaming_Media"
>Streaming Media</a></h1>

<p>It is possible to use POE::Filter::HTTPD for streaming content, but an application can use it to send headers and then switch to POE::Filter::Stream.</p>

<p>From the input handler (the InputEvent handler if you&#39;re using wheels, or the ClientInput handler for POE::Component::Server::TCP):</p>

<pre>  my $response = HTTP::Response-&#62;new(200);
  $response-&#62;push_header(&#39;Content-type&#39;, &#39;audio/x-mpeg&#39;);
  $_[HEAP]{client}-&#62;put($response);
  $_[HEAP]{client}-&#62;set_output_filter(POE::Filter::Stream-&#62;new());</pre>

<p>Then the output-flushed handler (FlushEvent for POE::Wheel::ReadWrite, or ClientFlushed for POE::Component::Server::TCP) can put() chunks of the stream as needed.</p>

<pre>  my $bytes_read = sysread(
    $_[HEAP]{file_to_stream}, my $buffer = &#39;&#39;, 4096
  );

  if ($bytes_read) {
    $_[HEAP]{client}-&#62;put($buffer);
  }
  else {
    delete $_[HEAP]{file_to_stream};
    $_[KERNEL]-&#62;yield(&#34;shutdown&#34;);
  }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>Please see <a href="../../POE/Filter.html" class="podlinkpod"
>POE::Filter</a> for documentation regarding the base interface.</p>

<p>The SEE ALSO section in <a href="../../POE.html" class="podlinkpod"
>POE</a> contains a table of contents covering the entire POE distribution.</p>

<p><a href="../../HTTP/Request.html" class="podlinkpod"
>HTTP::Request</a> and <a href="../../HTTP/Response.html" class="podlinkpod"
>HTTP::Response</a> explain all the wonderful things you can do with these classes.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>Many aspects of HTTP 1.0 and higher are not supported, such as keep-alive. A simple I/O filter can&#39;t support keep-alive, for example. A number of more feature-rich POE HTTP servers are on the CPAN. See <a href="http://search.cpan.org/search?query=POE+http+server&#38;mode=dist" class="podlinkurl"
>http://search.cpan.org/search?query=POE+http+server&#38;mode=dist</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS_&#38;_COPYRIGHTS"
>AUTHORS &#38; COPYRIGHTS</a></h1>

<p>POE::Filter::HTTPD was contributed by Artur Bergman. Documentation is provided by Rocco Caputo.</p>

<p>Please see <a href="../../POE.html" class="podlinkpod"
>POE</a> for more information about authors and contributors.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
