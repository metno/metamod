<html><head><title>POE::Loop</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:25 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#GENERAL_NOTES'>GENERAL NOTES</a>
  <li class='indexItem indexItem1'><a href='#PUBLIC_INTERFACE'>PUBLIC INTERFACE</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Administrative_Methods'>Administrative Methods</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#loop_initialize'>loop_initialize</a>
      <li class='indexItem indexItem3'><a href='#loop_finalize'>loop_finalize</a>
      <li class='indexItem indexItem3'><a href='#loop_do_timeslice'>loop_do_timeslice</a>
      <li class='indexItem indexItem3'><a href='#loop_run'>loop_run</a>
      <li class='indexItem indexItem3'><a href='#loop_halt'>loop_halt</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Signal_Management_Methods'>Signal Management Methods</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#loop_watch_signal_SIGNAL_NAME'>loop_watch_signal SIGNAL_NAME</a>
      <li class='indexItem indexItem3'><a href='#loop_ignore_signal_SIGNAL_NAME'>loop_ignore_signal SIGNAL_NAME</a>
      <li class='indexItem indexItem3'><a href='#loop_attach_uidestroy_WIDGET'>loop_attach_uidestroy WIDGET</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Alarm_and_Time_Management_Methods'>Alarm and Time Management Methods</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#loop_resume_time_watcher_NEXT_EVENT_TIME'>loop_resume_time_watcher NEXT_EVENT_TIME</a>
      <li class='indexItem indexItem3'><a href='#loop_reset_time_watcher_NEXT_EVENT_TIME'>loop_reset_time_watcher NEXT_EVENT_TIME</a>
      <li class='indexItem indexItem3'><a href='#loop_pause_time_watcher'>loop_pause_time_watcher</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#File_Activity_Management_Methods'>File Activity Management Methods</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#loop_watch_filehandle_FILE_HANDLE%2C_IO_MODE'>loop_watch_filehandle FILE_HANDLE, IO_MODE</a>
      <li class='indexItem indexItem3'><a href='#loop_ignore_filehandle_FILE_HANDLE%2C_IO_MODE'>loop_ignore_filehandle FILE_HANDLE, IO_MODE</a>
      <li class='indexItem indexItem3'><a href='#loop_pause_filehandle_FILE_HANDLE%2C_IO_MODE'>loop_pause_filehandle FILE_HANDLE, IO_MODE</a>
      <li class='indexItem indexItem3'><a href='#loop_resume_filehandle_FILE_HANDLE%2C_IO_MODE'>loop_resume_filehandle FILE_HANDLE, IO_MODE</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#HOW_POE_FINDS_EVENT_LOOP_BRIDGES'>HOW POE FINDS EVENT LOOP BRIDGES</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS_%26_LICENSING'>AUTHORS &#38; LICENSING</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>POE::Loop - documentation for POE&#39;s event loop bridge interface</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  $kernel-&#62;loop_initialize();
  $kernel-&#62;loop_finalize();
  $kernel-&#62;loop_do_timeslice();
  $kernel-&#62;loop_run();
  $kernel-&#62;loop_halt();

  $kernel-&#62;loop_watch_signal($signal_name);
  $kernel-&#62;loop_ignore_signal($signal_name);
  $kernel-&#62;loop_attach_uidestroy($gui_window);

  $kernel-&#62;loop_resume_time_watcher($next_time);
  $kernel-&#62;loop_reset_time_watcher($next_time);
  $kernel-&#62;loop_pause_time_watcher();

  $kernel-&#62;loop_watch_filehandle($handle, $mode);
  $kernel-&#62;loop_ignore_filehandle($handle, $mode);
  $kernel-&#62;loop_pause_filehandle($handle, $mode);
  $kernel-&#62;loop_resume_filehandle($handle, $mode);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>POE::Loop is a virtual base class that defines a standard event loop interface. POE::Loop subclasses mix into POE::Kernel and implement the features needed to manage underlying event loops in a consistent fashion. This documentation covers the interface, which is shared by all subclasses.</p>

<p>As POE::Kernel loads, it searches through %INC for event loop modules. POE::Kernel loads the most appropriate POE::Loop subclass for the event loop it finds. The subclass slots its methods into POE::Kernel, completing the class at load time. POE and POE::Kernel provide ways to state the desired event loop in case the auto-detection makes a mistake or the developer prefers to be explicit. See <a href="../POE/Kernel.html#Using_POE_with_Other_Event_Loops" class="podlinkpod"
>&#34;Using POE with Other Event Loops&#34; in POE::Kernel</a> for instructions on how to actually use POE with other event loops, event loop naming conventions, and other details.</p>

<p>POE::Loop subclasses exist for many of the event loops Perl supports: select(), IO::Poll, WxWindows, EV, Glib, Event, and so on. See CPAN for a full list.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="GENERAL_NOTES"
>GENERAL NOTES</a></h1>

<p>As previously noted, POE::Loop subclasses provide additional methods to POE::Kernel and are not proper objects in themselves.</p>

<p>Each POE::Loop subclass first defines its own namespace and version within it. This way CPAN and other things can track its version. They then switch to the POE::Kernel package to define their additional methods.</p>

<p>POE::Loop is designed as a mix-in class because Perl imposed a performance penalty for method inheritance at the time the class was designed. This could be changed in the future, but it will require cascaded changes in several other classes.</p>

<p>Here is a skeleton of a POE::Loop subclass:</p>

<pre>  use strict;

  # YourToolkit bridge for POE::Kernel;

  package POE::Loop::YourToolkit;

  use vars qw($VERSION);
  $VERSION = &#39;1.000&#39;; # NOTE - Should be #.### (three decimal places)

  package POE::Kernel;

  # Define private lexical data here.
  # Implement the POE::Loop interface here.

  1;

  __END__

  =head1 NAME

  ... documentation goes here ...

  =cut</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PUBLIC_INTERFACE"
>PUBLIC INTERFACE</a></h1>

<p>POE::Loop&#39;s public interface is divided into four parts: administrative methods, signal handler methods, time management methods, and filehandle watcher methods. Each group and its members will be described in detail shortly.</p>

<p>POE::Loop subclasses use lexical variables to keep track of things. Exact implementation is left up to the subclass&#39; author. POE::Loop::Select keeps its bit vectors for select() calls in class-scoped (static) lexical variables. POE::Loop::Gtk tracks a single time watcher and multiple file watchers there.</p>

<p>Bridges often employ private methods as callbacks from their event loops. The Event, Gtk, and Tk bridges do this. Private callback names should begin with &#34;_loop_&#34; to avoid colliding with other methods.</p>

<p>Developers should look at existing bridges to get a feel for things. The <code>-m</code> flag for perldoc will show a module in its entirety.</p>

<pre>  perldoc -m POE::Loop::Select
  perldoc -m POE::Loop::Gtk
  ...</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Administrative_Methods"
>Administrative Methods</a></h2>

<p>These methods initialize and finalize an event loop, run the loop to process events, and halt it.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="loop_initialize"
>loop_initialize</a></h3>

<p>Initialize the event loop. Graphical toolkits especially need some sort of init() call or sequence to set up. For example, Tk requires a widget to be created before any events will be processed, and the program&#39;s user interface will be considered destroyed if that widget is closed.</p>

<pre>  sub loop_initialize {
    my $self = shift;

    $poe_main_window = Tk::MainWindow-&#62;new();
    die &#34;could not create a main Tk window&#34; unless defined $poe_main_window;
    $self-&#62;signal_ui_destroy($poe_main_window);
  }</pre>

<p>POE::Loop::Select initializes its select() bit vectors.</p>

<pre>  sub loop_initialize {
    @loop_vectors = ( &#39;&#39;, &#39;&#39;, &#39;&#39; );
    vec($loop_vectors[MODE_RD], 0, 1) = 0;
    vec($loop_vectors[MODE_WR], 0, 1) = 0;
    vec($loop_vectors[MODE_EX], 0, 1) = 0;
  }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="loop_finalize"
>loop_finalize</a></h3>

<p>Finalize the event loop. Most event loops do not require anything here since they have already stopped by the time loop_finalize() is called. However, this is a good place to check that a bridge has not leaked memory or data. This example comes from POE::Loop::Event.</p>

<pre>  sub loop_finalize {
    my $self = shift;

    foreach my $fd (0..$#fileno_watcher) {
      next unless defined $fileno_watcher[$fd];
      foreach my $mode (MODE_RD, MODE_WR, MODE_EX) {
        POE::Kernel::_warn(
          &#34;Mode $mode watcher for fileno $fd is defined during loop finalize&#34;
        ) if defined $fileno_watcher[$fd]-&#62;[$mode];
      }
    }

    $self-&#62;loop_ignore_all_signals();
  }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="loop_do_timeslice"
>loop_do_timeslice</a></h3>

<p>Wait for time to pass or new events to occur, and dispatch any events that become due. If the underlying event loop does this through callbacks, then loop_do_timeslice() will either provide minimal glue or do nothing.</p>

<p>For example, loop_do_timeslice() for POE::Loop::Select sets up and calls select(). If any files or other resources become active, it enqueues events for them. Finally, it triggers dispatch for any events are due.</p>

<p>On the other hand, the Gtk event loop handles all this, so loop_do_timeslice() is empty for the Gtk bridge.</p>

<p>A sample loop_do_timeslice() implementation is not presented here because it would either be quite large or empty. See each POE::Loop::IO_Poll or Select for large ones. Event and Gtk are empty.</p>

<p>The bridges for Poll and Select for large ones. The ones for Event and Gtk are empty, and Tk&#39;s (in POE::Loop::TkCommon) is rather small.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="loop_run"
>loop_run</a></h3>

<p>Run an event loop until POE has no more sessions to handle events. This method tends to be quite small, and it is often implemented in terms of loop_do_timeslice(). For example, POE::Loop::IO_Poll implements it:</p>

<pre>  sub loop_run {
    my $self = shift;
    while ($self-&#62;_data_ses_count()) {
      $self-&#62;loop_do_timeslice();
    }
  }</pre>

<p>This method is even more trivial when an event loop handles it. This is from the Gtk bridge:</p>

<pre>  sub loop_run {
    unless (defined $_watcher_timer) {
      $_watcher_timer = Gtk-&#62;idle_add(\&#38;_loop_resume_timer);
    }
    Gtk-&#62;main;
  }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="loop_halt"
>loop_halt</a></h3>

<p>loop_halt() does what it says: It halts POE&#39;s underlying event loop. It tends to be either trivial for external event loops or empty for ones that are implemented in the bridge itself (IO_Poll, Select).</p>

<p>For example, the loop_run() method in the Poll bridge exits when sessions have run out, so its loop_halt() method is empty:</p>

<pre>  sub loop_halt {
    # does nothing
  }</pre>

<p>Gtk, however, needs to be stopped because it does not know when POE is done.</p>

<pre>  sub loop_halt {
    Gtk-&#62;main_quit();
  }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Signal_Management_Methods"
>Signal Management Methods</a></h2>

<p>These methods enable and disable signal watchers. They are used by POE::Resource::Signals to manage an event loop&#39;s signal watchers.</p>

<p>Most event loops use Perl&#39;s %SIG to watch for signals. This is so common that POE::Loop::PerlSignals implements the interface on behalf of other subclasses.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="loop_watch_signal_SIGNAL_NAME"
>loop_watch_signal SIGNAL_NAME</a></h3>

<p>Watch for a given SIGNAL_NAME. SIGNAL_NAME is the version found in %SIG, which tends to be the operating signal&#39;s name with the leading &#34;SIG&#34; removed.</p>

<p>POE::Loop::PerlSignals&#39; implementation adds callbacks to %SIG except for CHLD/CLD, which begins a waitpid() polling loop instead.</p>

<p>As of this writing, all of the POE::Loop subclasses register their signal handlers through POE::Loop::PerlSignals.</p>

<p>There are three types of signal handlers:</p>

<p>CHLD/CLD handlers, when managed by the bridges themselves, poll for exited children. POE::Kernel does most of this, but loop_watch_signal() still needs to start the process.</p>

<p>PIPE handlers. The PIPE signal event must be sent to the session that is active when the signal occurred.</p>

<p>Everything else. Signal events for everything else are sent to POE::Kernel, where they are distributed to every session.</p>

<p>The loop_watch_signal() methods tends to be very long, so an example is not presented here. The Event and Select bridges have good examples, though.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="loop_ignore_signal_SIGNAL_NAME"
>loop_ignore_signal SIGNAL_NAME</a></h3>

<p>Stop watching SIGNAL_NAME. POE::Loop::PerlSignals does this by resetting the %SIG for the SIGNAL_NAME to a sane value.</p>

<p>$SIG{CHLD} is left alone so as to avoid interfering with system() and other things.</p>

<p>SIGPIPE is generally harmless since POE generates events for this condition. Therefore $SIG{PIPE} is set to &#34;IGNORE&#34; when it&#39;s not being handled.</p>

<p>All other signal handlers default to &#34;DEFAULT&#34; when not in use.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="loop_attach_uidestroy_WIDGET"
>loop_attach_uidestroy WIDGET</a></h3>

<p>POE, when used with a graphical toolkit, should shut down when the user interface is closed. loop_attach_uidestroy() is used to shut down POE when a particular WIDGET is destroyed.</p>

<p>The shutdown is done by firing a UIDESTROY signal when the WIDGET&#39;s closure or destruction callback is invoked. UIDESTROY guarantees the program will shut down by virtue of being terminal and non-maskable.</p>

<p>loop_attach_uidestroy() is only meaningful in POE::Loop subclasses that tie into user interfaces. All other subclasses leave the method empty.</p>

<p>Here&#39;s Gtk&#39;s:</p>

<pre>  sub loop_attach_uidestroy {
    my ($self, $window) = @_;
    $window-&#62;signal_connect(
      delete_event =&#62; sub {
        if ($self-&#62;_data_ses_count()) {
          $self-&#62;_dispatch_event(
            $self, $self,
            EN_SIGNAL, ET_SIGNAL, [ &#39;UIDESTROY&#39; ],
            __FILE__, __LINE__, undef, monotime(), -__LINE__
          );
        }
        return 0;
      }
    );
  }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Alarm_and_Time_Management_Methods"
>Alarm and Time Management Methods</a></h2>

<p>These methods enable and disable a time watcher or alarm in the underlying event loop. POE only requires one, which is reused or re-created as necessary.</p>

<p>Most event loops trigger callbacks when time has passed. It is the bridge&#39;s responsibility to register and unregister a callback as needed. When invoked, the callback should dispatch events that have become due and possibly set up a new callback for the next event to be dispatched.</p>

<p>The time management methods may accept NEXT_EVENT_TIME. This is the time the next event will become due, in UNIX epoch time. NEXT_EVENT_TIME is a real number and may have sub-second accuracy. It is the bridge&#39;s responsibility to convert this value into something the underlying event loop requires.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="loop_resume_time_watcher_NEXT_EVENT_TIME"
>loop_resume_time_watcher NEXT_EVENT_TIME</a></h3>

<p>Resume an already active time watcher. It is used with loop_pause_time_watcher() to provide less expensive timer toggling for frequent use cases. As mentioned above, NEXT_EVENT_TIME is in UNIX epoch time and may have sub-second accuracy.</p>

<p>loop_resume_time_watcher() is used by bridges that set them watchers in the underlying event loop. For example, POE::Loop::Gtk implements it this way:</p>

<pre>  sub loop_resume_time_watcher {
    my ($self, $next_time) = @_;
    $next_time -= time();
    $next_time *= 1000;
    $next_time = 0 if $next_time &#60; 0;
    $_watcher_timer = Gtk-&#62;timeout_add(
      $next_time, \&#38;_loop_event_callback
    );
  }</pre>

<p>This method is usually empty in bridges that implement their own event loops.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="loop_reset_time_watcher_NEXT_EVENT_TIME"
>loop_reset_time_watcher NEXT_EVENT_TIME</a></h3>

<p>Reset a time watcher, often by stopping or destroying an existing one and creating a new one in its place. It is often a wrapper for loop_resume_time_watcher() that first destroys an existing watcher. For example, POE::Loop::Gkt&#39;s implementation:</p>

<pre>  sub loop_reset_time_watcher {
    my ($self, $next_time) = @_;
    Gtk-&#62;timeout_remove($_watcher_timer);
    undef $_watcher_timer;
    $self-&#62;loop_resume_time_watcher($next_time);
  }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="loop_pause_time_watcher"
>loop_pause_time_watcher</a></h3>

<p>Pause a time watcher without destroying it, if the underlying event loop supports such a thing. POE::Loop::Event does support it:</p>

<pre>  sub loop_pause_time_watcher {
    $_watcher_timer or return;
    $_watcher_timer-&#62;stop();
  }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="File_Activity_Management_Methods"
>File Activity Management Methods</a></h2>

<p>These methods enable and disable file activity watchers. There are four methods: loop_watch_filehandle(), loop_ignore_filehandle(), loop_pause_filehandle(), and loop_resume_filehandle(). The &#34;pause&#34; and &#34;resume&#34; methods are lightweight versions of &#34;ignore&#34; and &#34;watch&#34;, respectively.</p>

<p>All the methods take the same two parameters: a file HANDLE and a file access MODE. Modes may be MODE_RD, MODE_WR, or MODE_EX. These constants are defined by POE::Kernel and correspond to the semantics of POE::Kernel&#39;s select_read(), select_write(), and select_expedite() methods.</p>

<p>POE calls MODE_EX &#34;expedited&#34; because it often signals that a file is ready for out-of-band information. Not all event loops handle MODE_EX. For example, Tk:</p>

<pre>  sub loop_watch_filehandle {
    my ($self, $handle, $mode) = @_;
    my $fileno = fileno($handle);

    my $tk_mode;
    if ($mode == MODE_RD) {
      $tk_mode = &#39;readable&#39;;
    }
    elsif ($mode == MODE_WR) {
      $tk_mode = &#39;writable&#39;;
    }
    else {
      # The Tk documentation implies by omission that expedited
      # filehandles aren&#39;t, uh, handled.  This is part 1 of 2.
      confess &#34;Tk does not support expedited filehandles&#34;;
    }

    # ... rest omitted ....
  }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="loop_watch_filehandle_FILE_HANDLE,_IO_MODE"
>loop_watch_filehandle FILE_HANDLE, IO_MODE</a></h3>

<p>Watch a FILE_HANDLE for activity in a given IO_MODE. Depending on the underlying event loop, a watcher or callback will be registered for the FILE_HANDLE. Activity in the specified IO_MODE (read, write, or out of band) will trigger emission of the proper event in application space.</p>

<p>POE::Loop::Select sets the fileno()&#39;s bit in the proper select() bit vector. It also keeps track of which file descriptors are active.</p>

<pre>  sub loop_watch_filehandle {
    my ($self, $handle, $mode) = @_;
    my $fileno = fileno($handle);
    vec($loop_vectors[$mode], $fileno, 1) = 1;
    $loop_filenos{$fileno} |= (1&#60;&#60;$mode);
  }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="loop_ignore_filehandle_FILE_HANDLE,_IO_MODE"
>loop_ignore_filehandle FILE_HANDLE, IO_MODE</a></h3>

<p>Stop watching the FILE_HANDLE in a given IO_MODE. Stops (and possibly destroys) an event watcher corresponding to the FILE_HANDLE and IO_MODE.</p>

<p>POE::Loop::IO_Poll&#39;s loop_ignore_filehandle() manages descriptor/mode bits for its _poll() method here. It also performs some cleanup if a descriptor is no longer being watched after this ignore call.</p>

<pre>  sub loop_ignore_filehandle {
    my ($self, $handle, $mode) = @_;
    my $fileno = fileno($handle);

    my $type = mode_to_poll($mode);
    my $current = $poll_fd_masks{$fileno} || 0;
    my $new = $current &#38; ~$type;

    if (TRACE_FILES) {
      POE::Kernel::_warn(
        sprintf(
          &#34;&#60;fh&#62; Ignore $fileno: &#34; .
          &#34;: Current mask: 0x%02X - removing 0x%02X = 0x%02X\n&#34;,
          $current, $type, $new
        )
      );
    }

    if ($new) {
      $poll_fd_masks{$fileno} = $new;
    }
    else {
      delete $poll_fd_masks{$fileno};
    }
  }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="loop_pause_filehandle_FILE_HANDLE,_IO_MODE"
>loop_pause_filehandle FILE_HANDLE, IO_MODE</a></h3>

<p>This is a lightweight form of loop_ignore_filehandle(). It is used along with loop_resume_filehandle() to temporarily toggle a watcher&#39;s state for a FILE_HANDLE in a particular IO_MODE.</p>

<p>Some event loops, such as Event.pm, support their file watchers being disabled and re-enabled without the need to destroy and re-create the watcher objects.</p>

<pre>  sub loop_pause_filehandle {
    my ($self, $handle, $mode) = @_;
    my $fileno = fileno($handle);
    $fileno_watcher[$fileno]-&#62;[$mode]-&#62;stop();
  }</pre>

<p>By comparison, Event&#39;s loop_ignore_filehandle() method cancels and destroys the watcher object.</p>

<pre>  sub loop_ignore_filehandle {
    my ($self, $handle, $mode) = @_;
    my $fileno = fileno($handle);
    if (defined $fileno_watcher[$fileno]-&#62;[$mode]) {
      $fileno_watcher[$fileno]-&#62;[$mode]-&#62;cancel();
      undef $fileno_watcher[$fileno]-&#62;[$mode];
    }
  }</pre>

<p>Ignoring and re-creating watchers is relatively expensive, so POE::Kernel&#39;s select_pause_read() and select_resume_read() methods (and the corresponding ones for write and expedite) use the faster versions.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="loop_resume_filehandle_FILE_HANDLE,_IO_MODE"
>loop_resume_filehandle FILE_HANDLE, IO_MODE</a></h3>

<p>This is a lightweight form of loop_watch_filehandle(). It is used along with loop_pause_filehandle() to temporarily toggle a a watcher&#39;s state for a FILE_HANDLE in a particular IO_MODE.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="HOW_POE_FINDS_EVENT_LOOP_BRIDGES"
>HOW POE FINDS EVENT LOOP BRIDGES</a></h1>

<p>This is a rehash of <a href="../POE/Kernel.html#Using_POE_with_Other_Event_Loops" class="podlinkpod"
>&#34;Using POE with Other Event Loops&#34; in POE::Kernel</a>.</p>

<p>Firstly, if a POE::Loop subclass is manually loaded before POE::Kernel, then that will be used. End of story.</p>

<p>If one isn&#39;t, POE::Kernel searches for an external event loop module in %INC. For each module in %INC, corresponding POE::XS::Loop and POE::Loop subclasses are tried.</p>

<p>For example, if IO::Poll is loaded, POE::Kernel tries</p>

<pre>  use POE::XS::Loop::IO_Poll;
  use POE::Loop::IO_Poll;</pre>

<p>This is relatively expensive, but it ensures that POE::Kernel can find new POE::Loop subclasses without defining them in a central registry.</p>

<p>POE::Loop::Select is the fallback event loop. It&#39;s loaded if no other event loop can be found in %INC.</p>

<p>It can&#39;t be repeated often enough that event loops must be loaded before POE::Kernel. Otherwise they will not be present in %INC, and POE::Kernel will not detect them.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../POE.html" class="podlinkpod"
>POE</a>, <a href="../POE/Loop/Event.html" class="podlinkpod"
>POE::Loop::Event</a>, <a href="../POE/Loop/Gtk.html" class="podlinkpod"
>POE::Loop::Gtk</a>, <a href="../POE/Loop/IO_Poll.html" class="podlinkpod"
>POE::Loop::IO_Poll</a>, <a href="../POE/Loop/Select.html" class="podlinkpod"
>POE::Loop::Select</a>, <a href="../POE/Loop/Tk.html" class="podlinkpod"
>POE::Loop::Tk</a>.</p>

<p><a href="../POE/Test/Loops.html" class="podlinkpod"
>POE::Test::Loops</a> is POE&#39;s event loop tests released as a separate, reusable distribution. POE::Loop authors are encouraged to use the tests for their own distributions.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>None known.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS_&#38;_LICENSING"
>AUTHORS &#38; LICENSING</a></h1>

<p>Please see <a href="../POE.html" class="podlinkpod"
>POE</a> for more information about authors, contributors, and POE&#39;s licensing.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
