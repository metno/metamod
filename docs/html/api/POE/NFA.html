<html><head><title>POE::NFA</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:25 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#PUBLIC_METHODS'>PUBLIC METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#get_current_state'>get_current_state</a>
    <li class='indexItem indexItem2'><a href='#get_runstate'>get_runstate</a>
    <li class='indexItem indexItem2'><a href='#spawn_STATE_NAME_%3D%3E_HANDLERS_HASHREF%5B%2C_...%5D'>spawn STATE_NAME =&#62; HANDLERS_HASHREF[, ...]</a>
    <li class='indexItem indexItem2'><a href='#goto_state_NEW_STATE%5B%2C_ENTRY_EVENT%5B%2C_EVENT_ARGS%5D%5D'>goto_state NEW_STATE[, ENTRY_EVENT[, EVENT_ARGS]]</a>
    <li class='indexItem indexItem2'><a href='#stop'>stop</a>
    <li class='indexItem indexItem2'><a href='#call_state_RETURN_EVENT%2C_NEW_STATE%5B%2C_ENTRY_EVENT%5B%2C_EVENT_ARGS%5D%5D'>call_state RETURN_EVENT, NEW_STATE[, ENTRY_EVENT[, EVENT_ARGS]]</a>
    <li class='indexItem indexItem2'><a href='#return_state_%5BRETURN_ARGS%5D'>return_state [RETURN_ARGS]</a>
    <li class='indexItem indexItem2'><a href='#Methods_that_match_POE%3A%3ASession'>Methods that match POE::Session</a>
    <li class='indexItem indexItem2'><a href='#About_new()_and_create()'>About new() and create()</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#PREDEFINED_EVENT_FIELDS'>PREDEFINED EVENT FIELDS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#MACHINE'>MACHINE</a>
    <li class='indexItem indexItem2'><a href='#RUNSTATE'>RUNSTATE</a>
    <li class='indexItem indexItem2'><a href='#STATE'>STATE</a>
    <li class='indexItem indexItem2'><a href='#EVENT'>EVENT</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#PREDEFINED_EVENT_NAMES'>PREDEFINED EVENT NAMES</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS_%26_COPYRIGHTS'>AUTHORS &#38; COPYRIGHTS</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>POE::NFA - an event-driven state machine (nondeterministic finite automaton)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use POE::Kernel;
  use POE::NFA;
  use POE::Wheel::ReadLine;

  # Spawn an NFA and enter its initial state.
  POE::NFA-&#62;spawn(
    inline_states =&#62; {
      initial =&#62; {
        setup =&#62; \&#38;setup_stuff,
      },
      state_login =&#62; {
        on_entry =&#62; \&#38;login_prompt,
        on_input =&#62; \&#38;save_login,
      },
      state_password =&#62; {
        on_entry =&#62; \&#38;password_prompt,
        on_input =&#62; \&#38;check_password,
      },
      state_cmd =&#62; {
        on_entry =&#62; \&#38;command_prompt,
        on_input =&#62; \&#38;handle_command,
      },
    },
  )-&#62;goto_state(initial =&#62; &#34;setup&#34;);

  POE::Kernel-&#62;run();
  exit;

  sub setup_stuff {
    $_[RUNSTATE]{io} = POE::Wheel::ReadLine-&#62;new(
      InputEvent =&#62; &#39;on_input&#39;,
    );
    $_[MACHINE]-&#62;goto_state(state_login =&#62; &#34;on_entry&#34;);
  }

  sub login_prompt { $_[RUNSTATE]{io}-&#62;get(&#39;Login: &#39;); }

  sub save_login {
    $_[RUNSTATE]{login} = $_[ARG0];
    $_[MACHINE]-&#62;goto_state(state_password =&#62; &#34;on_entry&#34;);
  }

  sub password_prompt { $_[RUNSTATE]{io}-&#62;get(&#39;Password: &#39;); }

  sub check_password {
    if ($_[RUNSTATE]{login} eq $_[ARG0]) {
      $_[MACHINE]-&#62;goto_state(state_cmd =&#62; &#34;on_entry&#34;);
    }
    else {
      $_[MACHINE]-&#62;goto_state(state_login =&#62; &#34;on_entry&#34;);
    }
  }

  sub command_prompt { $_[RUNSTATE]{io}-&#62;get(&#39;Cmd: &#39;); }

  sub handle_command {
    $_[RUNSTATE]{io}-&#62;put(&#34;  &#60;&#60;$_[ARG0]&#62;&#62;&#34;);
    if ($_[ARG0] =~ /^(?:quit|stop|exit|halt|bye)$/i) {
      $_[RUNSTATE]{io}-&#62;put(&#39;Bye!&#39;);
      $_[MACHINE]-&#62;stop();
    }
    else {
      $_[MACHINE]-&#62;goto_state(state_cmd =&#62; &#34;on_entry&#34;);
    }
  }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>POE::NFA implements a different kind of POE session: A non-deterministic finite automaton. Let&#39;s break that down.</p>

<p>A finite automaton is a state machine with a bounded number of states and transitions. Technically, POE::NFA objects may modify themselves at run time, so they aren&#39;t really &#34;finite&#34;. Run-time modification isn&#39;t currently supported by the API, so plausible deniability is maintained!</p>

<p>Deterministic state machines are ones where all possible transitions are known at compile time. POE::NFA is &#34;non-deterministic&#34; because transitions may change based on run-time conditions.</p>

<p>But more simply, POE::NFA is like POE::Session but with banks of event handlers that may be swapped according to the session&#39;s run-time state. Consider the SYNOPSIS example, which has &#34;on_entry&#34; and &#34;on_input&#34; handlers that do different things depending on the run-time state. POE::Wheel::ReadLine throws &#34;on_input&#34;, but different things happen depending whether the session is in its &#34;login&#34;, &#34;password&#34; or &#34;command&#34; state.</p>

<p>POE::NFA borrows heavily from POE::Session, so this document will only discuss the differences. Please see <a href="../POE/Session.html" class="podlinkpod"
>POE::Session</a> for things which are similar.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PUBLIC_METHODS"
>PUBLIC METHODS</a></h1>

<p>This document mainly focuses on the differences from POE::Session.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_current_state"
>get_current_state</a></h2>

<p>Each machine state has a name. get_current_state() returns the name of the machine&#39;s current state. get_current_state() is mainly used to retrieve the state of some other machine. It&#39;s easier (and faster) to use <code>$_[STATE]</code> in a machine&#39;s own event handlers.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_runstate"
>get_runstate</a></h2>

<p>get_runstate() returns the machine&#39;s current runstate. Runstates are equivalent to POE::Session HEAPs, so this method does pretty much the same as POE::Session&#39;s get_heap(). It&#39;s easier (and faster) to use <code>$_[RUNSTATE]</code> in a machine&#39;s own event handlers, however.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="spawn_STATE_NAME_=&#62;_HANDLERS_HASHREF[,_...]"
>spawn STATE_NAME =&#62; HANDLERS_HASHREF[, ...]</a></h2>

<p>spawn() is POE::NFA&#39;s constructor. The name reflects the idea that new state machines are spawned like threads or processes rather than instantiated like objects.</p>

<p>The machine itself is defined as a list of state names and hashes that map events to handlers within each state.</p>

<pre>  my %states = (
    state_1 =&#62; {
      event_1 =&#62; \&#38;handler_1,
      event_2 =&#62; \&#38;handler_2,
    },
    state_2 =&#62; {
      event_1 =&#62; \&#38;handler_3,
      event_2 =&#62; \&#38;handler_4,
    },
  );</pre>

<p>A single event may be handled by many states. The proper handler will be called depending on the machine&#39;s current state. For example, if <code>event_1</code> is dispatched while the machine is in <code>state_2</code>, then handler_3() will be called to handle the event. The state -&#62; event -&#62; handler map looks like this:</p>

<pre>  $machine{state_2}{event_1} = \&#38;handler_3;</pre>

<p>Instead of <code>inline_states</code>, <code>object_states</code> or <code>package_states</code> may be used. These map the events of a state to an object or package method respectively.</p>

<pre>  object_states =&#62; {
    state_1 =&#62; [
      $object_1 =&#62; [qw(event_1 event_2)],
    ],
    state_2 =&#62; [
      $object_2 =&#62; {
        event_1 =&#62; method_1,
        event_2 =&#62; method_2,
      }
    ]
  }</pre>

<p>In the example above, in the case of <code>event_1</code> coming in while the machine is in <code>state_1</code>, method <code>event_1</code> will be called on $object_1. If the machine is in <code>state_2</code>, method <code>method_1</code> will be called on $object_2.</p>

<p><code>package_states</code> is very similar, but instead of using an $object, you pass in a <code>Package::Name</code></p>

<p>The <code>runstate</code> parameter allows <code>RUNSTATE</code> to be initialized differently at instantiation time. <code>RUNSTATE</code>, like heaps, are usually anonymous hashrefs, but <code>runstate</code> may set them to be array references or even objects.</p>

<p>State transitions are not necessarily executed immediately by default. Rather, they are placed in POEs event queue behind any currently pending events. Enabling the <code>immediate</code> option causes state transitions to occur immediately, regardless of any queued events.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="goto_state_NEW_STATE[,_ENTRY_EVENT[,_EVENT_ARGS]]"
>goto_state NEW_STATE[, ENTRY_EVENT[, EVENT_ARGS]]</a></h2>

<p>goto_state() puts the machine into a new state. If an ENTRY_EVENT is specified, then that event will be dispatched after the machine enters the new state. EVENT_ARGS, if included, will be passed to the entry event&#39;s handler via <code>ARG0..$#_</code>.</p>

<pre>  # Switch to the next state.
  $_[MACHINE]-&#62;goto_state( &#39;next_state&#39; );

  # Switch to the next state, and call a specific entry point.
  $_[MACHINE]-&#62;goto_state( &#39;next_state&#39;, &#39;entry_event&#39; );

  # Switch to the next state; call an entry point with some values.
  $_[MACHINE]-&#62;goto_state( &#39;next_state&#39;, &#39;entry_event&#39;, @parameters );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="stop"
>stop</a></h2>

<p>stop() forces a machine to stop. The machine will also stop gracefully if it runs out of things to do, just like POE::Session.</p>

<p>stop() is heavy-handed. It will force resources to be cleaned up. However, circular references in the machine&#39;s <code>RUNSTATE</code> are not POE&#39;s responsibility and may cause memory leaks.</p>

<pre>  $_[MACHINE]-&#62;stop();</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="call_state_RETURN_EVENT,_NEW_STATE[,_ENTRY_EVENT[,_EVENT_ARGS]]"
>call_state RETURN_EVENT, NEW_STATE[, ENTRY_EVENT[, EVENT_ARGS]]</a></h2>

<p>call_state() is similar to goto_state(), but it pushes the current state on a stack. At some later point, a handler can call return_state() to pop the call stack and return the machine to its old state. At that point, a <code>RETURN_EVENT</code> will be posted to notify the old state of the return.</p>

<pre>  $machine-&#62;call_state( &#39;return_here&#39;, &#39;new_state&#39;, &#39;entry_event&#39; );</pre>

<p>As with goto_state(), <code>ENTRY_EVENT</code> is the event that will be emitted once the machine enters its new state. <code>ENTRY_ARGS</code> are parameters passed to the <code>ENTRY_EVENT</code> handler via <code>ARG0..$#_</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="return_state_[RETURN_ARGS]"
>return_state [RETURN_ARGS]</a></h2>

<p>return_state() returns to the most recent state in which call_state() was invoked. If the preceding call_state() included a return event then its handler will be invoked along with some optional <code>RETURN_ARGS</code>. The <code>RETURN_ARGS</code> will be passed to the return handler via <code>ARG0..$#_</code>.</p>

<pre>  $_[MACHINE]-&#62;return_state( &#39;success&#39;, @success_values );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Methods_that_match_POE::Session"
>Methods that match POE::Session</a></h2>

<p>The following methods behave identically to the ones in POE::Session.</p>

<dl>
<dt><a name="ID"
>ID</a></dt>

<dd>
<dt><a name="option"
>option</a></dt>

<dd>
<dt><a name="postback"
>postback</a></dt>

<dd>
<dt><a name="callback"
>callback</a></dt>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="About_new()_and_create()"
>About new() and create()</a></h2>

<p>POE::NFA&#39;s constructor is spawn(), not new() or create().</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PREDEFINED_EVENT_FIELDS"
>PREDEFINED EVENT FIELDS</a></h1>

<p>POE::NFA&#39;s predefined event fields are the same as POE::Session&#39;s with the following three exceptions.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="MACHINE"
>MACHINE</a></h2>

<p><code>MACHINE</code> is equivalent to Session&#39;s <code>SESSION</code> field. It holds a reference to the current state machine, and is useful for calling its methods.</p>

<p>See POE::Session&#39;s <code>SESSION</code> field for more information.</p>

<pre>  $_[MACHINE]-&#62;goto_state( $next_state, $next_state_entry_event );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="RUNSTATE"
>RUNSTATE</a></h2>

<p><code>RUNSTATE</code> is equivalent to Session&#39;s <code>HEAP</code> field. It holds an anonymous hash reference which POE is guaranteed not to touch. Data stored in <code>RUNSTATE</code> will persist between handler invocations.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="STATE"
>STATE</a></h2>

<p><code>STATE</code> contains the name of the machine&#39;s current state. It is not equivalent to anything from POE::Session.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="EVENT"
>EVENT</a></h2>

<p><code>EVENT</code> is equivalent to Session&#39;s <code>STATE</code> field. It holds the name of the event which invoked the current handler. See POE::Session&#39;s <code>STATE</code> field for more information.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PREDEFINED_EVENT_NAMES"
>PREDEFINED EVENT NAMES</a></h1>

<p>POE::NFA defines four events of its own. These events are used internally and may not be overridden by application code.</p>

<p>See POE::Session&#39;s &#34;PREDEFINED EVENT NAMES&#34; section for more information about other predefined events.</p>

<p>The events are: <code>poe_nfa_goto_state</code>, <code>poe_nfa_push_state</code>, <code>poe_nfa_pop_state</code>, <code>poe_nfa_stop</code>.</p>

<p>Yes, all the internal events begin with &#34;poe_nfa_&#34;. More may be forthcoming, but they will always begin the same way. Therefore please do not define events beginning with &#34;poe_nfa_&#34;.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>Many of POE::NFA&#39;s features are taken directly from POE::Session. Please see <a href="../POE/Session.html" class="podlinkpod"
>POE::Session</a> for more information.</p>

<p>The SEE ALSO section in <a href="../POE.html" class="podlinkpod"
>POE</a> contains a table of contents covering the entire POE distribution.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>See POE::Session&#39;s documentation.</p>

<p>POE::NFA is not as feature-complete as POE::Session. Your feedback is appreciated.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS_&#38;_COPYRIGHTS"
>AUTHORS &#38; COPYRIGHTS</a></h1>

<p>Please see <a href="../POE.html" class="podlinkpod"
>POE</a> for more information about authors and contributors.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
