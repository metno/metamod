<html><head><title>POE::Driver</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:25 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Public_Driver_Methods'>Public Driver Methods</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#new'>new</a>
      <li class='indexItem indexItem3'><a href='#get_FILEHANDLE'>get FILEHANDLE</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS_%26_COPYRIGHTS'>AUTHORS &#38; COPYRIGHTS</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>POE::Driver - an abstract interface for buffered,
non-blocking I/O</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<p>This is a contrived example of how POE::Filter and POE::Driver objects may be used in a stand-alone application.</p>

<pre>  my $driver = POE::Driver::SysRW-&#62;new();
  my $filter = POE::Filter::Line-&#62;new();

  my $list_of_octet_chunks = $filter-&#62;put(&#34;A line of text.&#34;);

  $driver-&#62;put( $list_of_octet_chunks );

  my $octets_remaining_in_buffer = $driver-&#62;flush($filehandle);
  die &#34;couldn&#39;t flush everything&#34; if $octets_remaining_in_buffer;

  while (1) {
    my $octets_list = $driver-&#62;get($filehandle);
    die $! unless defined $octets_list;

    $filter-&#62;get_one_start($octets_list);
    while (my $line = $filter-&#62;get_one()) {
      print &#34;Input: $line\n&#34;;
    }
  }</pre>

<p>Most programs will use POE::Filter and POE::Driver objects as parameters to POE::Wheel constructors. See the synopses for particular classes for details.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>POE::Driver is a common API for I/O drivers that can read from and write to various files, sockets, pipes, and other devices.</p>

<p>POE &#34;drivers&#34; implement the specifics of reading and writing to devices. Drivers plug into POE::Wheel objects so that wheels may support a large number of device types without implementing a separate subclass for each.</p>

<p>As mentioned in the SYNOPSIS, POE::Driver objects may be used in stand-alone applications.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Public_Driver_Methods"
>Public Driver Methods</a></h2>

<p>These methods are the generic Driver interface, and every driver must implement them. Specific drivers may have additional methods related to their particular tasks.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="new"
>new</a></h3>

<p>new() creates, initializes, and returns a new driver. Specific drivers may have different constructor parameters. The default constructor parameters should configure the driver for the most common use case.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="get_FILEHANDLE"
>get FILEHANDLE</a></h3>

<p>get() immediately tries to read information from a FILEHANDLE. It returns an array reference on success---even if nothing was read from the FILEHANDLE. get() returns undef on error, and $! will be set to the reason why get() failed.</p>

<p>The returned arrayref will be empty if nothing was read from the FILEHANDLE.</p>

<p>In an EOF condition, get() returns undef with the numeric value of $! set to zero.</p>

<p>The arrayref returned by get() is suitable for passing to any POE::Filter&#39;s get() or get_one_start() method. Wheels do exactly this internally.</p>

<dl>
<dt><a name="put_ARRAYREF"
>put ARRAYREF</a></dt>

<dd>
<p>put() accepts an ARRAYREF of raw octet chunks. These octets are added to the driver&#39;s internal output queue or buffer. put() returns the number of octets pending output after the new octets are buffered.</p>

<p>Some drivers may flush data immediately from their put() methods.</p>

<dt><a name="flush_FILEHANDLE"
>flush FILEHANDLE</a></dt>

<dd>
<p>flush() attempts to write a driver&#39;s buffered data to a given FILEHANDLE. The driver should flush as much data as possible in a single flush() call.</p>

<p>flush() returns the number of octets remaining in the driver&#39;s output queue or buffer after the maximum amount of data has been written.</p>

<p>flush() denotes success or failure by the value of $! after it returns. $! will always numerically equal zero on success. On failure, $! will contain the usual Errno value. In either case, flush() will return the number of octets in the driver&#39;s output queue.</p>

<dt><a name="get_out_messages_buffered"
>get_out_messages_buffered</a></dt>

<dd>
<p>get_out_messages_buffered() returns the number of messages enqueued in the driver&#39;s output queue, rounded up to the nearest whole message. Some applications require the message count rather than the octet count.</p>

<p>Messages are raw octet chunks enqueued by put(). The following put() call enqueues two messages for a total of six octets:</p>

<pre>  $filter-&#62;put( [ &#34;one&#34;, &#34;two&#34; ] );</pre>

<p>It is possible for a flush() call to write part of a message. A partial message still counts as one message.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>The SEE ALSO section in <a href="../POE.html" class="podlinkpod"
>POE</a> contains a table of contents covering the entire POE distribution.</p>

<p><a href="../POE/Wheel.html" class="podlinkpod"
>POE::Wheel</a> - A base class for POE::Session mix-ins.</p>

<p><a href="../POE/Filter.html" class="podlinkpod"
>POE::Filter</a> - A base class for data parsers and serializers.</p>

<p><a href="../POE/Driver/SysRW.html" class="podlinkpod"
>POE::Driver::SysRW</a> - A driver that encapsulates sysread() and buffered syswrite().</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>There is no POE::Driver::SendRecv, but nobody has needed one so far. sysread() and syswrite() manage to do almost everything people need.</p>

<p>In theory, drivers should be pretty much interchangeable. In practice, there seems to be an impermeable barrier between the different SOCK_* types.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS_&#38;_COPYRIGHTS"
>AUTHORS &#38; COPYRIGHTS</a></h1>

<p>Please see <a href="../POE.html" class="podlinkpod"
>POE</a> for more information about authors and contributors.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
