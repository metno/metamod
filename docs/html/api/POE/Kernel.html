<html><head><title>POE::Kernel</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:25 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#USING_POE'>USING POE</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Literally_Using_POE'>Literally Using POE</a>
    <li class='indexItem indexItem2'><a href='#Using_POE%3A%3AKernel'>Using POE::Kernel</a>
    <li class='indexItem indexItem2'><a href='#Anatomy_of_a_POE-Based_Application'>Anatomy of a POE-Based Application</a>
    <li class='indexItem indexItem2'><a href='#POE%3A%3AKernel_singleton'>POE::Kernel singleton</a>
    <li class='indexItem indexItem2'><a href='#Sessions'>Sessions</a>
    <li class='indexItem indexItem2'><a href='#Resources'>Resources</a>
    <li class='indexItem indexItem2'><a href='#Session_Lifespans'>Session Lifespans</a>
    <li class='indexItem indexItem2'><a href='#Events'>Events</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Event_Handlers'>Event Handlers</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Using_POE_with_Other_Event_Loops'>Using POE with Other Event Loops</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#POE%3A%3ALoop%3A%3ASelect_(bundled)'>POE::Loop::Select (bundled)</a>
      <li class='indexItem indexItem3'><a href='#POE%3A%3ALoop%3A%3AIO_Poll_(bundled)'>POE::Loop::IO_Poll (bundled)</a>
      <li class='indexItem indexItem3'><a href='#POE%3A%3ALoop%3A%3AEvent_(separate_distribution)'>POE::Loop::Event (separate distribution)</a>
      <li class='indexItem indexItem3'><a href='#POE%3A%3ALoop%3A%3AGtk_(separate_distribution)'>POE::Loop::Gtk (separate distribution)</a>
      <li class='indexItem indexItem3'><a href='#POE%3A%3ALoop%3A%3ATk_(separate_distribution)'>POE::Loop::Tk (separate distribution)</a>
      <li class='indexItem indexItem3'><a href='#POE%3A%3ALoop%3A%3AEV_(separate_distribution)'>POE::Loop::EV (separate distribution)</a>
      <li class='indexItem indexItem3'><a href='#POE%3A%3ALoop%3A%3AGlib_(separate_distribution)'>POE::Loop::Glib (separate distribution)</a>
      <li class='indexItem indexItem3'><a href='#POE%3A%3ALoop%3A%3AKqueue_(separate_distribution)'>POE::Loop::Kqueue (separate distribution)</a>
      <li class='indexItem indexItem3'><a href='#POE%3A%3ALoop%3A%3APrima_(separate_distribution)'>POE::Loop::Prima (separate distribution)</a>
      <li class='indexItem indexItem3'><a href='#POE%3A%3ALoop%3A%3AWx_(separate_distribution)'>POE::Loop::Wx (separate distribution)</a>
      <li class='indexItem indexItem3'><a href='#POE%3A%3AXS%3A%3ALoop%3A%3AEPoll_(separate_distribution)'>POE::XS::Loop::EPoll (separate distribution)</a>
      <li class='indexItem indexItem3'><a href='#POE%3A%3AXS%3A%3ALoop%3A%3APoll_(separate_distribution)'>POE::XS::Loop::Poll (separate distribution)</a>
      <li class='indexItem indexItem3'><a href='#Other_Event_Loops_(separate_distributions)'>Other Event Loops (separate distributions)</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#PUBLIC_METHODS'>PUBLIC METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Kernel_Management_and_Accessors'>Kernel Management and Accessors</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#ID'>ID</a>
      <li class='indexItem indexItem3'><a href='#run'>run</a>
      <li class='indexItem indexItem3'><a href='#run_one_timeslice'>run_one_timeslice</a>
      <li class='indexItem indexItem3'><a href='#run_while_SCALAR_REF'>run_while SCALAR_REF</a>
      <li class='indexItem indexItem3'><a href='#has_forked'>has_forked</a>
      <li class='indexItem indexItem3'><a href='#stop'>stop</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Asynchronous_Messages_(FIFO_Events)'>Asynchronous Messages (FIFO Events)</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#post_DESTINATION%2C_EVENT_NAME_%5B%2C_PARAMETER_LIST%5D'>post DESTINATION, EVENT_NAME [, PARAMETER_LIST]</a>
      <li class='indexItem indexItem3'><a href='#yield_EVENT_NAME_%5B%2C_PARAMETER_LIST%5D'>yield EVENT_NAME [, PARAMETER_LIST]</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Synchronous_Messages'>Synchronous Messages</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#call_DESTINATION%2C_EVENT_NAME_%5B%2C_PARAMETER_LIST%5D'>call DESTINATION, EVENT_NAME [, PARAMETER_LIST]</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Timer_Events_(Delayed_Messages)'>Timer Events (Delayed Messages)</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Name-Based_Timers'>Name-Based Timers</a>
      <ul   class='indexList indexList4'>
        <li class='indexItem indexItem4'><a href='#alarm_EVENT_NAME_%5B%2C_EPOCH_TIME_%5B%2C_PARAMETER_LIST%5D_%5D'>alarm EVENT_NAME [, EPOCH_TIME [, PARAMETER_LIST] ]</a>
        <li class='indexItem indexItem4'><a href='#alarm_add_EVENT_NAME%2C_EPOCH_TIME_%5B%2C_PARAMETER_LIST%5D'>alarm_add EVENT_NAME, EPOCH_TIME [, PARAMETER_LIST]</a>
        <li class='indexItem indexItem4'><a href='#delay_EVENT_NAME_%5B%2C_DURATION_SECONDS_%5B%2C_PARAMETER_LIST%5D_%5D'>delay EVENT_NAME [, DURATION_SECONDS [, PARAMETER_LIST] ]</a>
        <li class='indexItem indexItem4'><a href='#delay_add_EVENT_NAME%2C_DURATION_SECONDS_%5B%2C_PARAMETER_LIST%5D'>delay_add EVENT_NAME, DURATION_SECONDS [, PARAMETER_LIST]</a>
      </ul>
      <li class='indexItem indexItem3'><a href='#Identifier-Based_Timers'>Identifier-Based Timers</a>
      <ul   class='indexList indexList4'>
        <li class='indexItem indexItem4'><a href='#alarm_set_EVENT_NAME%2C_EPOCH_TIME_%5B%2C_PARAMETER_LIST%5D'>alarm_set EVENT_NAME, EPOCH_TIME [, PARAMETER_LIST]</a>
        <li class='indexItem indexItem4'><a href='#alarm_adjust_ALARM_ID%2C_DELTA_SECONDS'>alarm_adjust ALARM_ID, DELTA_SECONDS</a>
        <li class='indexItem indexItem4'><a href='#alarm_remove_ALARM_ID'>alarm_remove ALARM_ID</a>
        <li class='indexItem indexItem4'><a href='#alarm_remove_all'>alarm_remove_all</a>
        <li class='indexItem indexItem4'><a href='#delay_set_EVENT_NAME%2C_DURATION_SECONDS_%5B%2C_PARAMETER_LIST%5D'>delay_set EVENT_NAME, DURATION_SECONDS [, PARAMETER_LIST]</a>
        <li class='indexItem indexItem4'><a href='#delay_adjust_ALARM_ID%2C_SECONDS_FROM_NOW'>delay_adjust ALARM_ID, SECONDS_FROM_NOW</a>
        <li class='indexItem indexItem4'><a href='#delay_remove_is_not_needed'>delay_remove is not needed</a>
        <li class='indexItem indexItem4'><a href='#delay_remove_all_is_not_needed'>delay_remove_all is not needed</a>
      </ul>
      <li class='indexItem indexItem3'><a href='#Comparison'>Comparison</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Session_Identifiers_(IDs_and_Aliases)'>Session Identifiers (IDs and Aliases)</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#alias_set_ALIAS'>alias_set ALIAS</a>
      <li class='indexItem indexItem3'><a href='#alias_remove_ALIAS'>alias_remove ALIAS</a>
      <li class='indexItem indexItem3'><a href='#alias_resolve_ALIAS'>alias_resolve ALIAS</a>
      <li class='indexItem indexItem3'><a href='#alias_list_%5BSESSION_REFERENCE%5D'>alias_list [SESSION_REFERENCE]</a>
      <li class='indexItem indexItem3'><a href='#ID_id_to_session_SESSION_ID'>ID_id_to_session SESSION_ID</a>
      <li class='indexItem indexItem3'><a href='#ID_session_to_id_SESSION_REFERENCE'>ID_session_to_id SESSION_REFERENCE</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#I%2FO_Watchers_(Selects)'>I/O Watchers (Selects)</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#select_read_FILE_HANDLE_%5B%2C_EVENT_NAME_%5B%2C_ADDITIONAL_PARAMETERS%5D_%5D'>select_read FILE_HANDLE [, EVENT_NAME [, ADDITIONAL_PARAMETERS] ]</a>
      <li class='indexItem indexItem3'><a href='#select_write_FILE_HANDLE_%5B%2C_EVENT_NAME_%5B%2C_ADDITIONAL_PARAMETERS%5D_%5D'>select_write FILE_HANDLE [, EVENT_NAME [, ADDITIONAL_PARAMETERS] ]</a>
      <li class='indexItem indexItem3'><a href='#select_expedite_FILE_HANDLE_%5B%2C_EVENT_NAME_%5B%2C_ADDITIONAL_PARAMETERS%5D_%5D'>select_expedite FILE_HANDLE [, EVENT_NAME [, ADDITIONAL_PARAMETERS] ]</a>
      <li class='indexItem indexItem3'><a href='#select_pause_read_FILE_HANDLE'>select_pause_read FILE_HANDLE</a>
      <li class='indexItem indexItem3'><a href='#select_resume_read_FILE_HANDLE'>select_resume_read FILE_HANDLE</a>
      <li class='indexItem indexItem3'><a href='#select_pause_write_FILE_HANDLE'>select_pause_write FILE_HANDLE</a>
      <li class='indexItem indexItem3'><a href='#select_resume_write_FILE_HANDLE'>select_resume_write FILE_HANDLE</a>
      <li class='indexItem indexItem3'><a href='#select_FILE_HANDLE_%5B%2C_EV_READ_%5B%2C_EV_WRITE_%5B%2C_EV_EXPEDITE_%5B%2C_ARGS%5D_%5D_%5D_%5D'>select FILE_HANDLE [, EV_READ [, EV_WRITE [, EV_EXPEDITE [, ARGS] ] ] ]</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Session_Management'>Session Management</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Session_Management_Events_(_start%2C__stop%2C__parent%2C__child)'>Session Management Events (_start, _stop, _parent, _child)</a>
      <ul   class='indexList indexList4'>
        <li class='indexItem indexItem4'><a href='#When_a_new_session_is_created%3A'>When a new session is created:</a>
        <li class='indexItem indexItem4'><a href='#When_an_old_session_stops%3A'>When an old session stops:</a>
        <li class='indexItem indexItem4'><a href='#When_a_session_is_detached_from_its_parent%3A'>When a session is detached from its parent:</a>
      </ul>
      <li class='indexItem indexItem3'><a href='#Session_Management_Methods'>Session Management Methods</a>
      <ul   class='indexList indexList4'>
        <li class='indexItem indexItem4'><a href='#detach_child_CHILD_SESSION'>detach_child CHILD_SESSION</a>
        <li class='indexItem indexItem4'><a href='#detach_myself'>detach_myself</a>
      </ul>
    </ul>
    <li class='indexItem indexItem2'><a href='#Signals'>Signals</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Signal_Classes'>Signal Classes</a>
      <ul   class='indexList indexList4'>
        <li class='indexItem indexItem4'><a href='#Benign%2C_advisory%2C_or_informative_signals'>Benign, advisory, or informative signals</a>
        <li class='indexItem indexItem4'><a href='#Terminal_signals'>Terminal signals</a>
        <li class='indexItem indexItem4'><a href='#Nonmaskable_signals'>Nonmaskable signals</a>
      </ul>
      <li class='indexItem indexItem3'><a href='#Common_Signal_Dispatching'>Common Signal Dispatching</a>
      <li class='indexItem indexItem3'><a href='#Signal_Semantics'>Signal Semantics</a>
      <ul   class='indexList indexList4'>
        <li class='indexItem indexItem4'><a href='#SIGCHLD'>SIGCHLD</a>
        <li class='indexItem indexItem4'><a href='#SIGCLD'>SIGCLD</a>
        <li class='indexItem indexItem4'><a href='#SIGPIPE'>SIGPIPE</a>
        <li class='indexItem indexItem4'><a href='#SIGWINCH'>SIGWINCH</a>
      </ul>
      <li class='indexItem indexItem3'><a href='#Exception_Handling'>Exception Handling</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Signal_Watcher_Methods'>Signal Watcher Methods</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#sig_SIGNAL_NAME_%5B%2C_EVENT_NAME_%5B%2C_LIST%5D_%5D'>sig SIGNAL_NAME [, EVENT_NAME [, LIST] ]</a>
      <li class='indexItem indexItem3'><a href='#sig_child_PROCESS_ID_%5B%2C_EVENT_NAME_%5B%2C_LIST%5D_%5D'>sig_child PROCESS_ID [, EVENT_NAME [, LIST] ]</a>
      <li class='indexItem indexItem3'><a href='#sig_handled'>sig_handled</a>
      <li class='indexItem indexItem3'><a href='#signal_SESSION%2C_SIGNAL_NAME_%5B%2C_ARGS_LIST%5D'>signal SESSION, SIGNAL_NAME [, ARGS_LIST]</a>
      <li class='indexItem indexItem3'><a href='#signal_ui_destroy_WIDGET_OBJECT'>signal_ui_destroy WIDGET_OBJECT</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Event_Handler_Management'>Event Handler Management</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#state_EVENT_NAME_%5B%2C_CODE_REFERNCE%5D'>state EVENT_NAME [, CODE_REFERNCE]</a>
      <li class='indexItem indexItem3'><a href='#state_EVENT_NAME_%5B%2C_OBJECT_REFERENCE_%5B%2C_OBJECT_METHOD_NAME%5D_%5D'>state EVENT_NAME [, OBJECT_REFERENCE [, OBJECT_METHOD_NAME] ]</a>
      <li class='indexItem indexItem3'><a href='#state_EVENT_NAME_%5B%2C_CLASS_NAME_%5B%2C_CLASS_METHOD_NAME%5D_%5D'>state EVENT_NAME [, CLASS_NAME [, CLASS_METHOD_NAME] ]</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Public_Reference_Counters'>Public Reference Counters</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#refcount_increment_SESSION_ID%2C_COUNTER_NAME'>refcount_increment SESSION_ID, COUNTER_NAME</a>
      <li class='indexItem indexItem3'><a href='#refcount_decrement_SESSION_ID%2C_COUNTER_NAME'>refcount_decrement SESSION_ID, COUNTER_NAME</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Kernel_State_Accessors'>Kernel State Accessors</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#get_active_session'>get_active_session</a>
      <li class='indexItem indexItem3'><a href='#get_active_event'>get_active_event</a>
      <li class='indexItem indexItem3'><a href='#get_event_count'>get_event_count</a>
      <li class='indexItem indexItem3'><a href='#get_next_event_time'>get_next_event_time</a>
      <li class='indexItem indexItem3'><a href='#poe_kernel_loop'>poe_kernel_loop</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Session_Helper_Methods'>Session Helper Methods</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#session_alloc_SESSION_OBJECT_%5B%2C_START_ARGS%5D'>session_alloc SESSION_OBJECT [, START_ARGS]</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Miscellaneous_Methods'>Miscellaneous Methods</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#new'>new</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#PUBLIC_EXPORTED_VARIABLES'>PUBLIC EXPORTED VARIABLES</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#%24poe_kernel'>$poe_kernel</a>
    <li class='indexItem indexItem2'><a href='#%24poe_main_window'>$poe_main_window</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#DEBUGGING_POE_AND_PROGRAMS_USING_IT'>DEBUGGING POE AND PROGRAMS USING IT</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#ASSERT_DATA'>ASSERT_DATA</a>
    <li class='indexItem indexItem2'><a href='#ASSERT_DEFAULT'>ASSERT_DEFAULT</a>
    <li class='indexItem indexItem2'><a href='#ASSERT_EVENTS'>ASSERT_EVENTS</a>
    <li class='indexItem indexItem2'><a href='#ASSERT_FILES'>ASSERT_FILES</a>
    <li class='indexItem indexItem2'><a href='#ASSERT_RETVALS'>ASSERT_RETVALS</a>
    <li class='indexItem indexItem2'><a href='#ASSERT_USAGE'>ASSERT_USAGE</a>
    <li class='indexItem indexItem2'><a href='#TRACE_DEFAULT'>TRACE_DEFAULT</a>
    <li class='indexItem indexItem2'><a href='#TRACE_DESTROY'>TRACE_DESTROY</a>
    <li class='indexItem indexItem2'><a href='#TRACE_EVENTS'>TRACE_EVENTS</a>
    <li class='indexItem indexItem2'><a href='#TRACE_FILENAME'>TRACE_FILENAME</a>
    <li class='indexItem indexItem2'><a href='#TRACE_FILES'>TRACE_FILES</a>
    <li class='indexItem indexItem2'><a href='#TRACE_REFCNT'>TRACE_REFCNT</a>
    <li class='indexItem indexItem2'><a href='#TRACE_RETVALS'>TRACE_RETVALS</a>
    <li class='indexItem indexItem2'><a href='#TRACE_SESSIONS'>TRACE_SESSIONS</a>
    <li class='indexItem indexItem2'><a href='#TRACE_SIGNALS'>TRACE_SIGNALS</a>
    <li class='indexItem indexItem2'><a href='#USE_SIGCHLD'>USE_SIGCHLD</a>
    <li class='indexItem indexItem2'><a href='#CHILD_POLLING_INTERVAL'>CHILD_POLLING_INTERVAL</a>
    <li class='indexItem indexItem2'><a href='#USE_SIGNAL_PIPE'>USE_SIGNAL_PIPE</a>
    <li class='indexItem indexItem2'><a href='#CATCH_EXCEPTIONS'>CATCH_EXCEPTIONS</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#ENVIRONMENT_VARIABLES_FOR_TESTING'>ENVIRONMENT VARIABLES FOR TESTING</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#POE_DANTIC'>POE_DANTIC</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS_%26_COPYRIGHTS'>AUTHORS &#38; COPYRIGHTS</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>POE::Kernel - an event-based application kernel in Perl</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use POE; # auto-includes POE::Kernel and POE::Session

  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub { $_[KERNEL]-&#62;yield(&#34;next&#34;) },
      next   =&#62; sub {
        print &#34;tick...\n&#34;;
        $_[KERNEL]-&#62;delay(next =&#62; 1);
      },
    },
  );

  POE::Kernel-&#62;run();
  exit;</pre>

<p>In the spirit of Perl, there are a lot of other ways to use POE.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>POE::Kernel is the heart of POE. It provides the lowest-level features: non-blocking multiplexed I/O, timers, and signal watchers are the most significant. Everything else is built upon this foundation.</p>

<p>POE::Kernel is not an event loop in itself. For that it uses one of several available POE::Loop interface modules. See CPAN for modules in the POE::Loop namespace.</p>

<p>POE&#39;s documentation assumes the reader understands the @_ offset constants (KERNEL, HEAP, ARG0, etc.). The curious or confused reader will find more detailed explanation in <a href="../POE/Session.html" class="podlinkpod"
>POE::Session</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="USING_POE"
>USING POE</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Literally_Using_POE"
>Literally Using POE</a></h2>

<p>POE.pm is little more than a class loader. It implements some magic to cut down on the setup work.</p>

<p>Parameters to <code>use POE</code> are not treated as normal imports. Rather, they&#39;re abbreviated modules to be included along with POE.</p>

<pre>  use POE qw(Component::Client::TCP).</pre>

<p>As you can see, the leading &#34;POE::&#34; can be omitted this way.</p>

<p>POE.pm also includes POE::Kernel and POE::Session by default. These two modules are used by nearly all POE-based programs. So the above example is actually the equivalent of:</p>

<pre>  use POE;
  use POE::Kernel;
  use POE::Session;
  use POE::Component::Client::TCP;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Using_POE::Kernel"
>Using POE::Kernel</a></h2>

<p>POE::Kernel needs to know which event loop you want to use. This is supported in three different ways:</p>

<p>The first way is to use an event loop module before using POE::Kernel (or POE, which loads POE::Kernel for you):</p>

<pre>  use Tk; # or one of several others
  use POE::Kernel.</pre>

<p>POE::Kernel scans the list of modules already loaded, and it loads an appropriate POE::Loop adapter if it finds a known event loop.</p>

<p>The next way is to explicitly load the POE::Loop class you want:</p>

<pre>  use POE qw(Loop::Gtk);</pre>

<p>Finally POE::Kernel&#39;s <code>import()</code> supports more programmer-friendly configuration:</p>

<pre>  use POE::Kernel { loop =&#62; &#34;Gtk&#34; };
  use POE::Session;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Anatomy_of_a_POE-Based_Application"
>Anatomy of a POE-Based Application</a></h2>

<p>Programs using POE work like any other. They load required modules, perform some setup, run some code, and eventually exit. Halting Problem notwithstanding.</p>

<p>A POE-based application loads some modules, sets up one or more sessions, runs the code in those sessions, and eventually exits.</p>

<pre>  use POE;
  POE::Session-&#62;create( ... map events to code here ... );
  POE::Kernel-&#62;run();
  exit;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="POE::Kernel_singleton"
>POE::Kernel singleton</a></h2>

<p>The POE::Kernel is a singleton object; there can be only one POE::Kernel instance within a process. This allows many object methods to also be package methods.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Sessions"
>Sessions</a></h2>

<p>POE implements isolated compartments called <i>sessions</i>. Sessions play the role of tasks or threads within POE. POE::Kernel acts as POE&#39;s task scheduler, doling out timeslices to each session by invoking callbacks within them.</p>

<p>Callbacks are not preemptive. As long as one is running, no others will be dispatched. This is known as <i>cooperative</i> multitasking. Each session must cooperate by returning to the central dispatching kernel.</p>

<p>Cooperative multitasking vastly simplifies data sharing, since no two pieces of code may alter data at once.</p>

<p>A session may also take exclusive control of a program&#39;s time, if necessary, by simply not returning in a timely fashion. It&#39;s even possible to write completely blocking programs that use POE as a state machine rather than a cooperative dispatcher.</p>

<p>Every POE-based application needs at least one session. Code cannot run <i>within POE</i> without being a part of some session. Likewise, a threaded program always has a &#34;thread zero&#34;.</p>

<p>Sessions in POE::Kernel should not be confused with <a href="../POE/Session.html" class="podlinkpod"
>POE::Session</a> even though the two are inextricably associated. POE::Session adapts POE::Kernel&#39;s dispatcher to a particular calling convention. Other POE::Session classes exist on the CPAN. Some radically alter the way event handlers are called. <a href="http://search.cpan.org/search?query=poe+session" class="podlinkurl"
>http://search.cpan.org/search?query=poe+session</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Resources"
>Resources</a></h2>

<p>Resources are events and things which may create new events, such as timers, I/O watchers, and even other sessions.</p>

<p>POE::Kernel tracks resources on behalf of its active sessions. It generates events corresponding to these resources&#39; activity, notifying sessions when it&#39;s time to do things.</p>

<p>The conversation goes something like this:</p>

<pre>  Session: Be a dear, Kernel, and let me know when someone clicks on
           this widget.  Thanks so much!

  [TIME PASSES]  [SFX: MOUSE CLICK]

  Kernel: Right, then.  Someone&#39;s clicked on your widget.
          Here you go.</pre>

<p>Furthermore, since the Kernel keeps track of everything sessions do, it knows when a session has run out of tasks to perform. When this happens, the Kernel emits a <code>_stop</code> event at the dead session so it can clean up and shutdown.</p>

<pre>  Kernel: Please switch off the lights and lock up; it&#39;s time to go.</pre>

<p>Likewise, if a session stops on its own and there still are opened resource watchers, the Kernel knows about them and cleans them up on the session&#39;s behalf. POE excels at long-running services because it so meticulously tracks and cleans up resources.</p>

<p>POE::Resources and the POE::Resource classes implement each kind of resource, which are summarized here and covered in greater detail later.</p>

<dl>
<dt><a name="Events."
>Events.</a></dt>

<dd>
<p>An event is a message to a sessions. Posting an event keeps both the sender and the receiver alive until after the event has been dispatched. This is only guaranteed if both the sender and receiver are in the same process. Inter-Kernel message passing add-ons may have other guarantees. Please see their documentation for details.</p>

<p>The rationale is that the event is in play, so the receiver must remain active for it to be dispatched. The sender remains alive in case the receiver would like to send back a response.</p>

<p>Posted events cannot be preemptively canceled. They tend to be short-lived in practice, so this generally isn&#39;t an issue.</p>

<dt><a name="Timers."
>Timers.</a></dt>

<dd>
<p>Timers allow an application to send a message to the future. Once set, a timer will keep the destination session active until it goes off and the resulting event is dispatched.</p>

<dt><a name="Aliases."
>Aliases.</a></dt>

<dd>
<p>Session aliases are an application-controlled way of addressing a session. Aliases act as passive event watchers. As long as a session has an alias, some other session may send events to that session by that name. Aliases keep sessions alive as long as a process has active sessions.</p>

<p>If the only sessions remaining are being kept alive solely by their aliases, POE::Kernel will send them a terminal <a href="#IDLE" class="podlinkpod"
>&#34;IDLE&#34;</a> signal. In most cases this will terminate the remaining sessions and allow the program to exit. If the sessions remain in memory without waking up on the <code>IDLE</code> signal, POE::Kernel sends them a non-maskable <a href="#ZOMBIE" class="podlinkpod"
>&#34;ZOMBIE&#34;</a> signal. They are then forcibly removed, and the program will finally exit.</p>

<dt><a name="I/O_watchers."
>I/O watchers.</a></dt>

<dd>
<p>A session will remain active as long as a session is paying attention to some external data source or sink. See <a href="#select_read_FILE_HANDLE_%5B%2C_EVENT_NAME_%5B%2C_ADDITIONAL_PARAMETERS%5D_%5D" class="podlinkpod"
>select_read</a> and <a href="#select_write_FILE_HANDLE_%5B%2C_EVENT_NAME_%5B%2C_ADDITIONAL_PARAMETERS%5D_%5D" class="podlinkpod"
>select_write</a>.</p>

<dt><a name="Child_sessions."
>Child sessions.</a></dt>

<dd>
<p>A session acting as a parent of one or more other sessions will remain active until all the child sessions stop. This may be bypassed by detaching the children from the parent.</p>

<dt><a name="Child_processes."
>Child processes.</a></dt>

<dd>
<p>Child process are watched by sig_child(). The sig_child() watcher will keep the watching session active until the child process has been reaped by POE::Kernel and the resulting event has been dispatched.</p>

<p>All other signal watchers, including using <a href="#sig" class="podlinkpod"
>&#34;sig&#34;</a> to watch for <code>CHLD</code>, do not keep their sessions active. If you need a session to remain active when it&#39;s only watching for signals, have it set an alias or one of its own public reference counters.</p>

<dt><a name="Public_reference_counters."
>Public reference counters.</a></dt>

<dd>
<p>A session will remain active as long as it has one or more nonzero public (or external) reference counter.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Session_Lifespans"
>Session Lifespans</a></h2>

<p>&#34;Session&#34; as a term is somewhat overloaded. There are two related concepts that share the name. First there is the class POE::Session, and objects created with it or related classes. Second there is a data structure within POE::Kernel that tracks the POE::Session objects in play and the various resources owned by each.</p>

<p>The way POE&#39;s garbage collector works is that a session object gives itself to POE::Kernel at creation time. The Kernel then holds onto that object as long as resources exist that require the session to remain alive. When all of these resources are destroyed or released, the session object has nothing left to trigger activity. POE::Kernel notifies the object it&#39;s through, and cleans up its internal session context. The session object is released, and self-destructs in the normal Perlish fashion.</p>

<p>Sessions may be stopped even if they have active resources. For example, a session may fail to handle a terminal signal. In this case, POE::Kernel forces the session to stop, and all resources associated with the session are preemptively released.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Events"
>Events</a></h2>

<p>An event is a message that is sent from one part of the POE application to another. An event consists of the event&#39;s name, optional event-specific parameters and OOB information. An event may be sent from the kernel, from a wheel or from a session.</p>

<p>An application creates an event with <a href="#post" class="podlinkpod"
>&#34;post&#34;</a>, <a href="#yield" class="podlinkpod"
>&#34;yield&#34;</a>, <a href="#call" class="podlinkpod"
>&#34;call&#34;</a> or even <a href="#signal" class="podlinkpod"
>&#34;signal&#34;</a>. POE::Kernel creates events in response external stimulus (signals, select, etc).</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Event_Handlers"
>Event Handlers</a></h3>

<p>An event is handled by a function called an <i>event handler</i>, which is some code that is designated to be called when a particular event is dispatched. See <a href="#Event_Handler_Management" class="podlinkpod"
>&#34;Event Handler Management&#34;</a> and <a href="../POE/Session.html" class="podlinkpod"
>POE::Session</a>.</p>

<p>The term <i>state</i> is often used in place of <i>event handler</i>, especially when treating sessions as event driven state machines.</p>

<p>Handlers are always called in scalar context for asynchronous events (i.e. via post()). Synchronous events, invoked with call(), are handled in the same context that call() was called.</p>

<p>Event handlers may not directly return references to objects in the &#34;POE&#34; namespace. POE::Kernel will stringify these references to prevent timing issues with certain objects&#39; destruction. For example, this error handler would cause errors because a deleted wheel would not be destructed when one might think:</p>

<pre>  sub handle_error {
    warn &#34;Got an error&#34;;
    delete $_[HEAP]{wheel};
  }</pre>

<p>The delete() call returns the deleted wheel member, which is then returned implicitly by handle_error().</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Using_POE_with_Other_Event_Loops"
>Using POE with Other Event Loops</a></h2>

<p>POE::Kernel supports any number of event loops. Two are included in the base distribution. Historically, POE included other loops but they were moved into a separate distribution. You can find them and other loops on the CPAN.</p>

<p>POE&#39;s public interfaces remain the same regardless of the event loop being used. Since most graphical toolkits include some form of event loop, back-end code should be portable to all of them.</p>

<p>POE&#39;s cooperation with other event loops lets POE be embedded into other software. The common underlying event loop drives both the application and POE. For example, by using POE::Loop::Glib, one can embed POE into Vim, irssi, and so on. Application scripts can then take advantage of POE::Component::Client::HTTP (and everything else) to do large-scale work without blocking the rest of the program.</p>

<p>Because this is Perl, there are multiple ways to load an alternate event loop. The simplest way is to load the event loop before loading POE::Kernel.</p>

<pre>  use Gtk;
  use POE;</pre>

<p>Remember that POE loads POE::Kernel internally.</p>

<p>POE::Kernel examines the modules loaded before it and detects that <a href="../Gtk.html" class="podlinkpod"
>Gtk</a> has been loaded. If <a href="../POE/Loop/Gtk.html" class="podlinkpod"
>POE::Loop::Gtk</a> is available, POE loads and hooks it into POE::Kernel automatically.</p>

<p>It&#39;s less mysterious to load the appropriate <a href="../POE/Loop.html" class="podlinkpod"
>POE::Loop</a> class directly. Their names follow the format <code>POE::Loop::$loop_module_name</code>, where <code>$loop_module_name</code> is the name of the event loop module after each <code>::</code> has been substituted with an underscore. It can be abbreviated using POE&#39;s loader magic.</p>

<pre>  use POE qw( Loop::Event_Lib );</pre>

<p>POE also recognizes XS loops, they reside in the <code>POE::XS::Loop::$loop_module_name</code> namespace. Using them may give you a performance improvement on your platform, as the eventloop are some of the hottest code in the system. As always, benchmark your application against various loops to see which one is best for your workload and platform.</p>

<pre>  use POE qw( XS::Loop::EPoll );</pre>

<p>Please don&#39;t load the loop modules directly, because POE will not have a chance to initialize it&#39;s internal structures yet. Code written like this will throw errors on startup. It might look like a bug in POE, but it&#39;s just the way POE is designed.</p>

<pre>  use POE::Loop::IO_Poll;
  use POE;</pre>

<p>POE::Kernel also supports configuration directives on its own <code>use</code> line. A loop explicitly specified this way will override the search logic.</p>

<pre>  use POE::Kernel { loop =&#62; &#34;Glib&#34; };</pre>

<p>Finally, one may specify the loop class by setting the POE::Loop or POE::XS:Loop class name in the POE_EVENT_LOOP environment variable. This mechanism was added for tests that need to specify the loop from a distance.</p>

<pre>  BEGIN { $ENV{POE_EVENT_LOOP} = &#34;POE::XS::Loop::Poll&#34; }
  use POE;</pre>

<p>Of course this may also be set from your shell:</p>

<pre>  % export POE_EVENT_LOOP=&#39;POE::XS::Loop::Poll&#39;
  % make test</pre>

<p>Many external event loops support their own callback mechanisms. <a href="../POE/Session.html" class="podlinkpod"
>POE::Session</a>&#39;s <a href="../POE/Session.html#postback" class="podlinkpod"
>&#34;postback()&#34;</a> and <a href="../POE/Session.html#callback" class="podlinkpod"
>&#34;callback()&#34;</a> methods return plain Perl code references that will generate POE events when called. Applications can pass these code references to event loops for use as callbacks.</p>

<p>POE&#39;s distribution includes two event loop interfaces. CPAN holds several more:</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="POE::Loop::Select_(bundled)"
>POE::Loop::Select (bundled)</a></h3>

<p>By default POE uses its select() based loop to drive its event system. This is perhaps the least efficient loop, but it is also the most portable. POE optimizes for correctness above all.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="POE::Loop::IO_Poll_(bundled)"
>POE::Loop::IO_Poll (bundled)</a></h3>

<p>The <a href="../IO/Poll.html" class="podlinkpod"
>IO::Poll</a> event loop provides an alternative that theoretically scales better than select().</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="POE::Loop::Event_(separate_distribution)"
>POE::Loop::Event (separate distribution)</a></h3>

<p>This event loop provides interoperability with other modules that use <a href="../Event.html" class="podlinkpod"
>Event</a>. It may also provide a performance boost because <a href="../Event.html" class="podlinkpod"
>Event</a> is written in a compiled language. Unfortunately, this makes <a href="../Event.html" class="podlinkpod"
>Event</a> less portable than Perl&#39;s built-in select().</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="POE::Loop::Gtk_(separate_distribution)"
>POE::Loop::Gtk (separate distribution)</a></h3>

<p>This event loop allows programs to work under the <a href="../Gtk.html" class="podlinkpod"
>Gtk</a> graphical toolkit.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="POE::Loop::Tk_(separate_distribution)"
>POE::Loop::Tk (separate distribution)</a></h3>

<p>This event loop allows programs to work under the <a href="../Tk.html" class="podlinkpod"
>Tk</a> graphical toolkit. Tk has some restrictions that require POE to behave oddly.</p>

<p>Tk&#39;s event loop will not run unless one or more widgets are created. POE must therefore create such a widget before it can run. POE::Kernel exports $poe_main_window so that the application developer may use the widget (which is a <a href="../Tk/MainWindow.html" class="podlinkpod"
>MainWindow</a>), since POE doesn&#39;t need it other than for dispatching events.</p>

<p>Creating and using a different MainWindow often has an undesired outcome.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="POE::Loop::EV_(separate_distribution)"
>POE::Loop::EV (separate distribution)</a></h3>

<p><a href="../POE/Loop/EV.html" class="podlinkpod"
>POE::Loop::EV</a> allows POE-based programs to use the EV event library with little or no change.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="POE::Loop::Glib_(separate_distribution)"
>POE::Loop::Glib (separate distribution)</a></h3>

<p><a href="../POE/Loop/Glib.html" class="podlinkpod"
>POE::Loop::Glib</a> allows POE-based programs to use Glib with little or no change. It also supports embedding POE-based programs into applications that already use Glib. For example, we have heard that POE has successfully embedded into vim, irssi and xchat via this loop.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="POE::Loop::Kqueue_(separate_distribution)"
>POE::Loop::Kqueue (separate distribution)</a></h3>

<p><a href="../POE/Loop/Kqueue.html" class="podlinkpod"
>POE::Loop::Kqueue</a> allows POE-based programs to transparently use the BSD kqueue event library on operating systems that support it.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="POE::Loop::Prima_(separate_distribution)"
>POE::Loop::Prima (separate distribution)</a></h3>

<p><a href="../POE/Loop/Prima.html" class="podlinkpod"
>POE::Loop::Prima</a> allows POE-based programs to use Prima&#39;s event loop with little or no change. It allows POE libraries to be used within Prima applications.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="POE::Loop::Wx_(separate_distribution)"
>POE::Loop::Wx (separate distribution)</a></h3>

<p><a href="../POE/Loop/Wx.html" class="podlinkpod"
>POE::Loop::Wx</a> allows POE-based programs to use Wx&#39;s event loop with little or no change. It allows POE libraries to be used within Wx applications, such as Padre.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="POE::XS::Loop::EPoll_(separate_distribution)"
>POE::XS::Loop::EPoll (separate distribution)</a></h3>

<p><a href="../POE/XS/Loop/EPoll.html" class="podlinkpod"
>POE::XS::Loop::EPoll</a> allows POE components to transparently use the EPoll event library on operating systems that support it.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="POE::XS::Loop::Poll_(separate_distribution)"
>POE::XS::Loop::Poll (separate distribution)</a></h3>

<p><a href="../POE/XS/Loop/Poll.html" class="podlinkpod"
>POE::XS::Loop::Poll</a> is a higher-performance C-based libpoll event loop. It replaces some of POE&#39;s hot Perl code with C for better performance.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Other_Event_Loops_(separate_distributions)"
>Other Event Loops (separate distributions)</a></h3>

<p>POE may be extended to handle other event loops. Developers are invited to work with us to support their favorite loops.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PUBLIC_METHODS"
>PUBLIC METHODS</a></h1>

<p>POE::Kernel encapsulates a lot of features. The documentation for each set of features is grouped by purpose.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Kernel_Management_and_Accessors"
>Kernel Management and Accessors</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="ID"
>ID</a></h3>

<p>ID() currently returns POE::Kernel&#39;s unique identifier. Every Kernel instance is assigned a globally unique ID at birth. has_forked() alters the ID so that each forked process has a unique one, too.</p>

<pre>  % perl -wl -MPOE -e &#39;print $poe_kernel-&#62;ID&#39;
  macbookpoe.local-4d5305de-0000e6b8-00000001</pre>

<p>The content of these IDs may change from time to time. Your code should not depend upon the current format.</p>

<p><b>Deprecation Warning 2011-02-09</b></p>

<p>Your code should not depend upon ID() remaining unique. The uniqueness will be removed in a future release of POE. If you require unique IDs, please see one of the fine GUID and/or UUID modules on the CPAN:</p>

<pre>  http://search.cpan.org/search?query=GUID&#38;mode=dist
  http://search.cpan.org/search?query=UUID&#38;mode=dist</pre>

<p>POE doesn&#39;t require globally or universally unique kernel IDs. The creation and maintenance of these IDs adds overhead to POE::Kernel&#39;s has_forked() method. Other modules do it better, upon demand, without incurring overhead for those who don&#39;t need them.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="run"
>run</a></h3>

<p>run() runs POE::Kernel&#39;s event dispatcher. It will not return until all sessions have ended. run() is a class method so a POE::Kernel reference is not needed to start a program&#39;s execution.</p>

<pre>  use POE;
  POE::Session-&#62;create( ... ); # one or more
  POE::Kernel-&#62;run();          # set them all running
  exit;</pre>

<p>POE implements the Reactor pattern at its core. Events are dispatched to functions and methods through callbacks. The code behind run() waits for and dispatches events.</p>

<p>run() will not return until every session has ended. This includes sessions that were created while run() was running.</p>

<p>POE::Kernel will print a strong message if a program creates sessions but fails to call run(). Prior to this warning, we received tons of bug reports along the lines of &#34;my POE program isn&#39;t doing anything&#34;. It turned out that people forgot to start an event dispatcher, so events were never dispatched.</p>

<p>If the lack of a run() call is deliberate, perhaps because some other event loop already has control, you can avoid the message by calling it before creating a session. run() at that point will initialize POE and return immediately. POE::Kernel will be satisfied that run() was called, although POE will not have actually taken control of the event loop.</p>

<pre>  use POE;
  POE::Kernel-&#62;run(); # silence the warning
  POE::Session-&#62;create( ... );
  exit;</pre>

<p>Note, however, that this varies from one event loop to another. If a particular POE::Loop implementation doesn&#39;t support it, that&#39;s probably a bug. Please file a bug report with the owner of the relevant POE::Loop module.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="run_one_timeslice"
>run_one_timeslice</a></h3>

<p>run_one_timeslice() dispatches any events that are due to be delivered. These events include timers that are due, asynchronous messages that need to be delivered, signals that require handling, and notifications for files with pending I/O. Do not rely too much on event ordering. run_one_timeslice() is defined by the underlying event loop, and its timing may vary.</p>

<p>run() is implemented similar to</p>

<pre>  run_one_timeslice() while $session_count &#62; 0;</pre>

<p>run_one_timeslice() can be used to keep running POE::Kernel&#39;s dispatcher while emulating blocking behavior. The pattern is implemented with a flag that is set when some asynchronous event occurs. A loop calls run_one_timeslice() until that flag is set. For example:</p>

<pre>  my $done = 0;

  sub handle_some_event {
    $done = 1;
  }

  $kernel-&#62;run_one_timeslice() while not $done;</pre>

<p>Do be careful. The above example will spin if POE::Kernel is done but $done is never set. The loop will never be done, even though there&#39;s nothing left that will set $done.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="run_while_SCALAR_REF"
>run_while SCALAR_REF</a></h3>

<p>run_while() is an <b>experimental</b> version of run_one_timeslice() that will only return when there are no more active sessions, or the value of the referenced scalar becomes false.</p>

<p>Here&#39;s a version of the run_one_timeslice() example using run_while() instead:</p>

<pre>  my $job_count = 3;

  sub handle_some_event {
    $job_count--;
  }

  $kernel-&#62;run_while(\$job_count);</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="has_forked"
>has_forked</a></h3>

<pre>    my $pid = fork();
    die &#34;Unable to fork&#34; unless defined $pid;
    unless( $pid ) {
        $poe_kernel-&#62;has_forked;
    }</pre>

<p>Inform the kernel that it is now running in a new process. This allows the kernel to reset some internal data to adjust to the new situation.</p>

<p>has_forked() must be called in the child process if you wish to run the same kernel. However, if you want the child process to have new kernel, you must call <a href="#stop" class="podlinkpod"
>&#34;stop&#34;</a> instead.</p>

<p><b>Note:</b> POE&#39;s internals will detect if a fork occurred before <code>run()</code> and will call <code>has_forked()</code> automatically. If you are unsure whether you need to call it or not, please enable <a href="#ASSERT_USAGE" class="podlinkpod"
>&#34;ASSERT_USAGE&#34;</a> and POE will emit a warning if it&#39;s necessary.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="stop"
>stop</a></h3>

<p>stop() causes POE::Kernel-&#62;run() to return early. It does this by emptying the event queue, freeing all used resources, and stopping every active session. stop() is not meant to be used lightly. Proceed with caution.</p>

<p>Caveats:</p>

<p>The session that calls stop() will not be fully DESTROYed until it returns. Invoking an event handler in the session requires a reference to that session, and weak references are prohibited in POE for backward compatibility reasons, so it makes sense that the last session won&#39;t be garbage collected right away.</p>

<p>Sessions are not notified about their destruction. If anything relies on _stop being delivered, it will break and/or leak memory.</p>

<p>stop() is still considered experimental. It was added to improve fork() support for <a href="../POE/Wheel/Run.html" class="podlinkpod"
>POE::Wheel::Run</a>. If it proves unfixably problematic, it will be removed without much notice.</p>

<p>stop() is advanced magic. Programmers who think they need it are invited to become familiar with its source.</p>

<p>See <a href="../POE/Wheel/Run.html#Running_POE%3A%3AKernel_in_the_Child" class="podlinkpod"
>&#34;Running POE::Kernel in the Child&#34; in POE::Wheel::Run</a> for an example of how to use this facility.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Asynchronous_Messages_(FIFO_Events)"
>Asynchronous Messages (FIFO Events)</a></h2>

<p>Asynchronous messages are events that are dispatched in the order in which they were enqueued (the first one in is the first one out, otherwise known as first-in/first-out, or FIFO order). These methods enqueue new messages for delivery. The act of enqueuing a message keeps the sender alive at least until the message is delivered.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="post_DESTINATION,_EVENT_NAME_[,_PARAMETER_LIST]"
>post DESTINATION, EVENT_NAME [, PARAMETER_LIST]</a></h3>

<p>post() enqueues a message to be dispatched to a particular DESTINATION session. The message will be handled by the code associated with EVENT_NAME. If a PARAMETER_LIST is included, its values will also be passed along.</p>

<pre>  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub {
        $_[KERNEL]-&#62;post( $_[SESSION], &#34;event_name&#34;, 0 );
      },
      event_name =&#62; sub {
        print &#34;$_[ARG0]\n&#34;;
        $_[KERNEL]-&#62;post( $_[SESSION], &#34;event_name&#34;, $_[ARG0] + 1 );
      },
    }
  );</pre>

<p>post() returns a Boolean value indicating whether the message was successfully enqueued. If post() returns false, $! is set to explain the failure:</p>

<p>ESRCH (&#34;No such process&#34;) - The DESTINATION session did not exist at the time post() was called.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="yield_EVENT_NAME_[,_PARAMETER_LIST]"
>yield EVENT_NAME [, PARAMETER_LIST]</a></h3>

<p>yield() is a shortcut for post() where the destination session is the same as the sender. This example is equivalent to the one for post():</p>

<pre>  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub {
        $_[KERNEL]-&#62;yield( &#34;event_name&#34;, 0 );
      },
      event_name =&#62; sub {
        print &#34;$_[ARG0]\n&#34;;
        $_[KERNEL]-&#62;yield( &#34;event_name&#34;, $_[ARG0] + 1 );
      },
    }
  );</pre>

<p>As with post(), yield() returns right away, and the enqueued EVENT_NAME is dispatched later. This may be confusing if you&#39;re already familiar with threading.</p>

<p>yield() should always succeed, so it does not return a meaningful value.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Synchronous_Messages"
>Synchronous Messages</a></h2>

<p>It is sometimes necessary for code to be invoked right away. For example, some resources must be serviced right away, or they&#39;ll faithfully continue reporting their readiness. These reports would appear as a stream of duplicate events. Synchronous events can also prevent data from going stale between the time an event is enqueued and the time it&#39;s delivered.</p>

<p>Synchronous event handlers preempt POE&#39;s event queue, so they should perform simple tasks of limited duration. Synchronous events that need to do more than just service a resource should pass the resource&#39;s information to an asynchronous handler. Otherwise synchronous operations will occur out of order in relation to asynchronous events. It&#39;s very easy to have race conditions or break causality this way, so try to avoid it unless you&#39;re okay with the consequences.</p>

<p>POE provides these ways to call message handlers right away.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="call_DESTINATION,_EVENT_NAME_[,_PARAMETER_LIST]"
>call DESTINATION, EVENT_NAME [, PARAMETER_LIST]</a></h3>

<p>call()&#39;s semantics are nearly identical to post()&#39;s. call() invokes a DESTINATION&#39;s handler associated with an EVENT_NAME. An optional PARAMETER_LIST will be passed along to the message&#39;s handler. The difference, however, is that the handler will be invoked immediately, even before call() returns.</p>

<p>call() returns the value returned by the EVENT_NAME handler. It can do this because the handler is invoked before call() returns. call() can therefore be used as an accessor, although there are better ways to accomplish simple accessor behavior.</p>

<pre>  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub {
        print &#34;Got: &#34;, $_[KERNEL]-&#62;call($_[SESSION], &#34;do_now&#34;), &#34;\n&#34;;
      },
      do_now =&#62; sub {
        return &#34;some value&#34;;
      }
    }
  );</pre>

<p>The <a href="../POE/Wheel.html" class="podlinkpod"
>POE::Wheel</a> classes uses call() to synchronously deliver I/O notifications. This avoids a host of race conditions.</p>

<p>call() may fail in the same way and for the same reasons as post(). On failure, $! is set to some nonzero value indicating why. Since call() may return undef as a matter of course, it&#39;s recommended that $! be checked for the error condition as well as the explanation.</p>

<p>ESRCH (&#34;No such process&#34;) - The DESTINATION session did not exist at the time post() was called.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Timer_Events_(Delayed_Messages)"
>Timer Events (Delayed Messages)</a></h2>

<p>It&#39;s often useful to wait for a certain time or until a certain amount of time has passed. POE supports this with events that are deferred until either an absolute time (&#34;alarms&#34;) or until a certain duration of time has elapsed (&#34;delays&#34;).</p>

<p>Timer interfaces are further divided into two groups. One group identifies timers by the names of their associated events. Another group identifies timers by a unique identifier returned by the timer constructors. Technically, the two are both name-based, but the &#34;identifier-based&#34; timers provide a second, more specific handle to identify individual timers.</p>

<p>Timers may only be set up for the current session. This design was modeled after alarm() and SIGALRM, which only affect the current UNIX process. Each session has a separate namespace for timer names. Timer methods called in one session cannot affect the timers in another. As you may have noticed, quite a lot of POE&#39;s API is designed to prevent sessions from interfering with each other.</p>

<p>The best way to simulate deferred inter-session messages is to send an immediate message that causes the destination to set a timer. The destination&#39;s timer then defers the action requested of it. This way is preferred because the time spent communicating the request between sessions may not be trivial, especially if the sessions are separated by a network. The destination can determine how much time remains on the requested timer and adjust its wait time accordingly.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Name-Based_Timers"
>Name-Based Timers</a></h3>

<p>Name-based timers are identified by the event names used to set them. It is possible for different sessions to use the same timer event names, since each session is a separate compartment with its own timer namespace. It is possible for a session to have multiple timers for a given event, but results may be surprising. Be careful to use the right timer methods.</p>

<p>The name-based timer methods are alarm(), alarm_add(), delay(), and delay_add().</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="alarm_EVENT_NAME_[,_EPOCH_TIME_[,_PARAMETER_LIST]_]"
>alarm EVENT_NAME [, EPOCH_TIME [, PARAMETER_LIST] ]</a></h4>

<p>alarm() clears all existing timers in the current session with the same EVENT_NAME. It then sets a new timer, named EVENT_NAME, that will fire EVENT_NAME at the current session when EPOCH_TIME has been reached. An optional PARAMETER_LIST may be passed along to the timer&#39;s handler.</p>

<p>Omitting the EPOCH_TIME and subsequent parameters causes alarm() to clear the EVENT_NAME timers in the current session without setting a new one.</p>

<p>EPOCH_TIME is the UNIX epoch time. You know, seconds since midnight, 1970-01-01. POE uses Time::HiRes::time(), which allows EPOCH_TIME to be (or include) fractional seconds.</p>

<p>POE supports fractional seconds, but accuracy falls off steeply after 1/100 second. Mileage will vary depending on your CPU speed and your OS time resolution.</p>

<p>Be sure to use Time::HiRes::time() rather than Perl&#39;s built-in time() if sub-second accuracy matters at all. The built-in time() returns floor(Time::HiRes::time()), which is nearly always some fraction of a second in the past. For example the high-resolution time might be 1200941422.89996. At that same instant, time() would be 1200941422. An alarm for time() + 0.5 would be 0.39996 seconds in the past, so it would be dispatched immediately (if not sooner).</p>

<p>POE&#39;s event queue is time-ordered, so a timer due before time() will be delivered ahead of other events but not before timers with even earlier due times. Therefore an alarm() with an EPOCH_TIME before time() jumps ahead of the queue.</p>

<p>All timers are implemented identically internally, regardless of how they are set. alarm() will therefore blithely clear timers set by other means.</p>

<pre>  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub {
        $_[KERNEL]-&#62;alarm( tick =&#62; time() + 1, 0 );
      },
      tick =&#62; sub {
        print &#34;tick $_[ARG0]\n&#34;;
        $_[KERNEL]-&#62;alarm( tock =&#62; time() + 1, $_[ARG0] + 1 );
      },
      tock =&#62; sub {
        print &#34;tock $_[ARG0]\n&#34;;
        $_[KERNEL]-&#62;alarm( tick =&#62; time() + 1, $_[ARG0] + 1 );
      },
    }
  );</pre>

<p>alarm() returns 0 on success or a true value on failure. Usually EINVAL to signal an invalid parameter, such as an undefined EVENT_NAME.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="alarm_add_EVENT_NAME,_EPOCH_TIME_[,_PARAMETER_LIST]"
>alarm_add EVENT_NAME, EPOCH_TIME [, PARAMETER_LIST]</a></h4>

<p>alarm_add() is used to add a new alarm timer named EVENT_NAME without clearing existing timers. EPOCH_TIME is a required parameter. Otherwise the semantics are identical to alarm().</p>

<p>A program may use alarm_add() without first using alarm().</p>

<pre>  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub {
        $_[KERNEL]-&#62;alarm_add( tick =&#62; time() + 1.0, 1_000_000 );
        $_[KERNEL]-&#62;alarm_add( tick =&#62; time() + 1.5, 2_000_000 );
      },
      tick =&#62; sub {
        print &#34;tick $_[ARG0]\n&#34;;
        $_[KERNEL]-&#62;alarm_add( tock =&#62; time() + 1, $_[ARG0] + 1 );
      },
      tock =&#62; sub {
        print &#34;tock $_[ARG0]\n&#34;;
        $_[KERNEL]-&#62;alarm_add( tick =&#62; time() + 1, $_[ARG0] + 1 );
      },
    }
  );</pre>

<p>alarm_add() returns 0 on success or EINVAL if EVENT_NAME or EPOCH_TIME is undefined.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="delay_EVENT_NAME_[,_DURATION_SECONDS_[,_PARAMETER_LIST]_]"
>delay EVENT_NAME [, DURATION_SECONDS [, PARAMETER_LIST] ]</a></h4>

<p>delay() clears all existing timers in the current session with the same EVENT_NAME. It then sets a new timer, named EVENT_NAME, that will fire EVENT_NAME at the current session when DURATION_SECONDS have elapsed from &#34;now&#34;. An optional PARAMETER_LIST may be passed along to the timer&#39;s handler.</p>

<p>Omitting the DURATION_SECONDS and subsequent parameters causes delay() to clear the EVENT_NAME timers in the current session without setting a new one.</p>

<p>DURATION_SECONDS may be or include fractional seconds. As with all of POE&#39;s timers, accuracy falls off steeply after 1/100 second. Mileage will vary depending on your CPU speed and your OS time resolution.</p>

<p>POE&#39;s event queue is time-ordered, so a timer due before time() will be delivered ahead of other events but not before timers with even earlier due times. Therefore a delay () with a zero or negative DURATION_SECONDS jumps ahead of the queue.</p>

<p>delay() may be considered a shorthand form of alarm(), but there are subtle differences in timing issues. This code is roughly equivalent to the alarm() example.</p>

<pre>  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub {
        $_[KERNEL]-&#62;delay( tick =&#62; 1, 0 );
      },
      tick =&#62; sub {
        print &#34;tick $_[ARG0]\n&#34;;
        $_[KERNEL]-&#62;delay( tock =&#62; 1, $_[ARG0] + 1 );
      },
      tock =&#62; sub {
        print &#34;tock $_[ARG0]\n&#34;;
        $_[KERNEL]-&#62;delay( tick =&#62; 1, $_[ARG0] + 1 );
      },
    }
  );</pre>

<p>delay() returns 0 on success or a reason for failure: EINVAL if EVENT_NAME is undefined.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="delay_add_EVENT_NAME,_DURATION_SECONDS_[,_PARAMETER_LIST]"
>delay_add EVENT_NAME, DURATION_SECONDS [, PARAMETER_LIST]</a></h4>

<p>delay_add() is used to add a new delay timer named EVENT_NAME without clearing existing timers. DURATION_SECONDS is a required parameter. Otherwise the semantics are identical to delay().</p>

<p>A program may use delay_add() without first using delay().</p>

<pre>  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub {
        $_[KERNEL]-&#62;delay_add( tick =&#62; 1.0, 1_000_000 );
        $_[KERNEL]-&#62;delay_add( tick =&#62; 1.5, 2_000_000 );
      },
      tick =&#62; sub {
        print &#34;tick $_[ARG0]\n&#34;;
        $_[KERNEL]-&#62;delay_add( tock =&#62; 1, $_[ARG0] + 1 );
      },
      tock =&#62; sub {
        print &#34;tock $_[ARG0]\n&#34;;
        $_[KERNEL]-&#62;delay_add( tick =&#62; 1, $_[ARG0] + 1 );
      },
    }
  );</pre>

<p>delay_add() returns 0 on success or EINVAL if EVENT_NAME or EPOCH_TIME is undefined.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Identifier-Based_Timers"
>Identifier-Based Timers</a></h3>

<p>A second way to manage timers is through identifiers. Setting an alarm or delay with the &#34;identifier&#34; methods allows a program to manipulate several timers with the same name in the same session. As covered in alarm() and delay() however, it&#39;s possible to mix named and identified timer calls, but the consequences may not always be expected.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="alarm_set_EVENT_NAME,_EPOCH_TIME_[,_PARAMETER_LIST]"
>alarm_set EVENT_NAME, EPOCH_TIME [, PARAMETER_LIST]</a></h4>

<p>alarm_set() sets an alarm, returning a unique identifier that can be used to adjust or remove the alarm later. Unlike alarm(), it does not first clear existing timers with the same EVENT_NAME. Otherwise the semantics are identical to alarm().</p>

<pre>  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub {
        $_[HEAP]{alarm_id} = $_[KERNEL]-&#62;alarm_set(
          party =&#62; time() + 1999
        );
        $_[KERNEL]-&#62;delay(raid =&#62; 1);
      },
      raid =&#62; sub {
        $_[KERNEL]-&#62;alarm_remove( delete $_[HEAP]{alarm_id} );
      },
    }
  );</pre>

<p>alarm_set() returns false if it fails and sets $! with the explanation. $! will be EINVAL if EVENT_NAME or TIME is undefined.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="alarm_adjust_ALARM_ID,_DELTA_SECONDS"
>alarm_adjust ALARM_ID, DELTA_SECONDS</a></h4>

<p>alarm_adjust() adjusts an existing timer&#39;s due time by DELTA_SECONDS, which may be positive or negative. It may even be zero, but that&#39;s not as useful. On success, it returns the timer&#39;s new due time since the start of the UNIX epoch.</p>

<p>It&#39;s possible to alarm_adjust() timers created by delay_set() as well as alarm_set().</p>

<p>This example moves an alarm&#39;s due time ten seconds earlier.</p>

<pre>  use POSIX qw(strftime);

  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub {
        $_[HEAP]{alarm_id} = $_[KERNEL]-&#62;alarm_set(
          party =&#62; time() + 1999
        );
        $_[KERNEL]-&#62;delay(postpone =&#62; 1);
      },
      postpone =&#62; sub {
        my $new_time = $_[KERNEL]-&#62;alarm_adjust(
          $_[HEAP]{alarm_id}, -10
        );
        print(
          &#34;Now we&#39;re gonna party like it&#39;s &#34;,
          strftime(&#34;%F %T&#34;, gmtime($new_time)), &#34;\n&#34;
        );
      },
    }
  );</pre>

<p>alarm_adjust() returns Boolean false if it fails, setting $! to the reason why. $! may be EINVAL if ALARM_ID or DELTA_SECONDS are undefined. It may be ESRCH if ALARM_ID no longer refers to a pending timer. $! may also contain EPERM if ALARM_ID is valid but belongs to a different session.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="alarm_remove_ALARM_ID"
>alarm_remove ALARM_ID</a></h4>

<p>alarm_remove() removes the alarm identified by ALARM_ID. ALARM_ID comes from a previous alarm_set() or delay_set() call.</p>

<p>Upon success, alarm_remove() returns something true based on its context. In a list context, it returns three things: The removed alarm&#39;s event name, the UNIX time it was due to go off, and a reference to the PARAMETER_LIST (if any) assigned to the timer when it was created. If necessary, the timer can be re-set with this information.</p>

<pre>  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub {
        $_[HEAP]{alarm_id} = $_[KERNEL]-&#62;alarm_set(
          party =&#62; time() + 1999
        );
        $_[KERNEL]-&#62;delay(raid =&#62; 1);
      },
      raid =&#62; sub {
        my ($name, $time, $param) = $_[KERNEL]-&#62;alarm_remove(
          $_[HEAP]{alarm_id}
        );
        print(
          &#34;Removed alarm for event $name due at $time with @$param\n&#34;
        );

        # Or reset it, if you&#39;d like.  Possibly after modification.
        $_[KERNEL]-&#62;alarm_set($name, $time, @$param);
      },
    }
  );</pre>

<p>In a scalar context, it returns a reference to a list of the three things above.</p>

<pre>  # Remove and reset an alarm.
  my $alarm_info = $_[KERNEL]-&#62;alarm_remove( $alarm_id );
  my $new_id = $_[KERNEL]-&#62;alarm_set(
    $alarm_info[0], $alarm_info[1], @{$alarm_info[2]}
  );</pre>

<p>Upon failure, however, alarm_remove() returns a Boolean false value and sets $! with the reason why the call failed:</p>

<p>EINVAL (&#34;Invalid argument&#34;) indicates a problem with one or more parameters, usually an undefined ALARM_ID.</p>

<p>ESRCH (&#34;No such process&#34;) indicates that ALARM_ID did not refer to a pending alarm.</p>

<p>EPERM (&#34;Operation not permitted&#34;). A session cannot remove an alarm it does not own.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="alarm_remove_all"
>alarm_remove_all</a></h4>

<p>alarm_remove_all() removes all the pending timers for the current session, regardless of creation method or type. This method takes no arguments. It returns information about the alarms that were removed, either as a list of alarms or a list reference depending whether alarm_remove_all() is called in scalar or list context.</p>

<p>Each removed alarm&#39;s information is identical to the format explained in alarm_remove().</p>

<pre>  sub some_event_handler {
    my @removed_alarms = $_[KERNEL]-&#62;alarm_remove_all();
    foreach my $alarm (@removed_alarms) {
      my ($name, $time, $param) = @$alarm;
      ...;
    }
  }</pre>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="delay_set_EVENT_NAME,_DURATION_SECONDS_[,_PARAMETER_LIST]"
>delay_set EVENT_NAME, DURATION_SECONDS [, PARAMETER_LIST]</a></h4>

<p>delay_set() sets a timer for DURATION_SECONDS in the future. The timer will be dispatched to the code associated with EVENT_NAME in the current session. An optional PARAMETER_LIST will be passed through to the handler. It returns the same sort of things that alarm_set() does.</p>

<pre>  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub {
        $_[KERNEL]-&#62;delay_set(&#34;later&#34;, 5, &#34;hello&#34;, &#34;world&#34;);
      },
      later =&#62; sub {
        print &#34;@_[ARG0..#$_]\n&#34;;
      }
    }
  );</pre>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="delay_adjust_ALARM_ID,_SECONDS_FROM_NOW"
>delay_adjust ALARM_ID, SECONDS_FROM_NOW</a></h4>

<p>delay_adjust() changes a timer&#39;s due time to be SECONDS_FROM_NOW. It&#39;s useful for refreshing watchdog- or timeout-style timers. On success it returns the new absolute UNIX time the timer will be due.</p>

<p>It&#39;s possible for delay_adjust() to adjust timers created by alarm_set() as well as delay_set().</p>

<pre>  use POSIX qw(strftime);

  POE::Session-&#62;create(
    inline_states =&#62; {
      # Setup.
      # ... omitted.

      got_input =&#62; sub {
        my $new_time = $_[KERNEL]-&#62;delay_adjust(
          $_[HEAP]{input_timeout}, 60
        );
        print(
          &#34;Refreshed the input timeout.  Next may occur at &#34;,
          strftime(&#34;%F %T&#34;, gmtime($new_time)), &#34;\n&#34;
        );
      },
    }
  );</pre>

<p>On failure it returns Boolean false and sets $! to a reason for the failure. See the explanation of $! for alarm_adjust().</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="delay_remove_is_not_needed"
>delay_remove is not needed</a></h4>

<p>There is no delay_remove(). Timers are all identical internally, so alarm_remove() will work with timer IDs returned by delay_set().</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="delay_remove_all_is_not_needed"
>delay_remove_all is not needed</a></h4>

<p>There is no delay_remove_all(). Timers are all identical internally, so alarm_remove_all() clears them all regardless how they were created.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Comparison"
>Comparison</a></h3>

<p>Below is a table to help compare the various delayed message-sending methods</p>

<pre>  +-----------+------------------+---------------------+------------+
  |           | time argument    | clears other events | returns on |
  | method    | passed to method | of the same name    | success    |
  +-----------+------------------+---------------------+------------+
  | delay_set | seconds from now | N                   | alarm_id   |
  | delay     | seconds from now | Y                   | 0 (false)  |
  | alarm_set | unix epoch time  | N                   | alarm_id   |
  | alarm     | unix epoch time  | Y                   | 0 (false)  |
  +-----------+------------------+---------------------+------------+</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Session_Identifiers_(IDs_and_Aliases)"
>Session Identifiers (IDs and Aliases)</a></h2>

<p>A session may be referred to by its object references (either blessed or stringified), a session ID, or one or more symbolic names we call aliases.</p>

<p>Every session is represented by an object, so session references are fairly straightforward. POE::Kernel may reference these objects. For instance, post() may use $_[SENDER] as a destination:</p>

<pre>  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub { $_[KERNEL]-&#62;alias_set(&#34;echoer&#34;) },
      ping =&#62; sub {
        $_[KERNEL]-&#62;post( $_[SENDER], &#34;pong&#34;, @_[ARG0..$#_] );
      }
    }
  );</pre>

<p>POE also recognized stringified Session objects for convenience and as a form of weak reference. Here $_[SENDER] is wrapped in quotes to stringify it:</p>

<pre>  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub { $_[KERNEL]-&#62;alias_set(&#34;echoer&#34;) },
      ping =&#62; sub {
        $_[KERNEL]-&#62;post( &#34;$_[SENDER]&#34;, &#34;pong&#34;, @_[ARG0..$#_] );
      }
    }
  );</pre>

<p>Every session is assigned a unique ID at creation time. No two active sessions will have the same ID, but IDs may be reused over time. The combination of a kernel ID and a session ID should be sufficient as a global unique identifier.</p>

<pre>  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub { $_[KERNEL]-&#62;alias_set(&#34;echoer&#34;) },
      ping =&#62; sub {
        $_[KERNEL]-&#62;delay(
          pong_later =&#62; rand(5), $_[SENDER]-&#62;ID, @_[ARG0..$#_]
        );
      },
      pong_later =&#62; sub {
        $_[KERNEL]-&#62;post( $_[ARG0], &#34;pong&#34;, @_[ARG1..$#_] );
      }
    }
  );</pre>

<p>Kernels also maintain a global session namespace or dictionary from which may be used to map a symbolic aliases to a session. Once an alias is mapping has been created, that alias may be used to refer to the session wherever a session may be specified.</p>

<p>In the previous examples, each echoer service has set an &#34;echoer&#34; alias. Another session can post a ping request to the echoer session by using that alias rather than a session object or ID. For example:</p>

<pre>  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub { $_[KERNEL]-&#62;post(echoer =&#62; ping =&#62; &#34;whee!&#34; ) },
      pong =&#62; sub { print &#34;@_[ARG0..$#_]\n&#34; }
    }
  );</pre>

<p>A session with an alias will not stop until all other activity has stopped. Aliases are treated as a kind of event watcher. Events come from active sessions. Aliases therefore become useless when there are no active sessions left. Rather than leaving the program running in a &#34;zombie&#34; state, POE detects this deadlock condition and triggers a cleanup. See <a href="#Signal_Classes" class="podlinkpod"
>&#34;Signal Classes&#34;</a> for more information.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="alias_set_ALIAS"
>alias_set ALIAS</a></h3>

<p>alias_set() maps an ALIAS in POE::Kernel&#39;s dictionary to the current session. The ALIAS may then be used nearly everywhere a session reference, stringified reference, or ID is expected.</p>

<p>Sessions may have more than one alias. Each alias must be defined in a separate alias_set() call. A single alias may not refer to more than one session.</p>

<p>Multiple alias examples are above.</p>

<p>alias_set() returns 0 on success, or a nonzero failure indicator: EEXIST (&#34;File exists&#34;) indicates that the alias is already assigned to to a different session.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="alias_remove_ALIAS"
>alias_remove ALIAS</a></h3>

<p>alias_remove() removes an ALIAS for the current session from POE::Kernel&#39;s dictionary. The ALIAS will no longer refer to the current session. This does not negatively affect events already posted to POE&#39;s queue. Alias resolution occurs at post() time, not at delivery time.</p>

<pre>  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub {
        $_[KERNEL]-&#62;alias_set(&#34;short_window&#34;);
        $_[KERNEL]-&#62;delay(close_window =&#62; 1);
      },
      close_window =&#62; {
        $_[KERNEL]-&#62;alias_remove(&#34;short_window&#34;);
      }
    }
  );</pre>

<p>alias_remove() returns 0 on success or a nonzero failure code: ESRCH (&#34;No such process&#34;) indicates that the ALIAS is not currently in POE::Kernel&#39;s dictionary. EPERM (&#34;Operation not permitted&#34;) means that the current session may not remove the ALIAS because it is in use by some other session.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="alias_resolve_ALIAS"
>alias_resolve ALIAS</a></h3>

<p>alias_resolve() returns a session reference corresponding to a given ALIAS. Actually, the ALIAS may be a stringified session reference, a session ID, or an alias previously registered by alias_set().</p>

<p>One use for alias_resolve() is to detect whether another session has gone away:</p>

<pre>  unless (defined $_[KERNEL]-&#62;alias_resolve(&#34;Elvis&#34;)) {
    print &#34;Elvis has left the building.\n&#34;;
  }</pre>

<p>As previously mentioned, alias_resolve() returns a session reference or undef on failure. Failure also sets $! to ESRCH (&#34;No such process&#34;) when the ALIAS is not currently in POE::Kernel&#39;s.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="alias_list_[SESSION_REFERENCE]"
>alias_list [SESSION_REFERENCE]</a></h3>

<p>alias_list() returns a list of aliases associated with a specific SESSION, or with the current session if SESSION is omitted. alias_list() returns an empty list if the requested SESSION has no aliases.</p>

<p>SESSION may be a session reference (blessed or stringified), a session ID, or a session alias.</p>

<pre>  POE::Session-&#62;create(
    inline_states =&#62; {
      $_[KERNEL]-&#62;alias_set(&#34;mi&#34;);
      print(
        &#34;The names I call myself: &#34;,
        join(&#34;, &#34;, $_[KERNEL]-&#62;alias_list()),
        &#34;\n&#34;
      );
    }
  );</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="ID_id_to_session_SESSION_ID"
>ID_id_to_session SESSION_ID</a></h3>

<p>ID_id_to_session() translates a session ID into a session reference. It&#39;s a special-purpose subset of alias_resolve(), so it&#39;s a little faster and somewhat less flexible.</p>

<pre>  unless (defined $_[KERNEL]-&#62;ID_id_to_session($session_id)) {
    print &#34;Session $session_id doesn&#39;t exist.\n&#34;;
  }</pre>

<p>ID_id_to_session() returns undef if a lookup failed. $! will be set to ESRCH (&#34;No such process&#34;).</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="ID_session_to_id_SESSION_REFERENCE"
>ID_session_to_id SESSION_REFERENCE</a></h3>

<p>ID_session_to_id() converts a blessed or stringified SESSION_REFERENCE into a session ID. It&#39;s more practical for stringified references, as programs can call the POE::Session ID() method on the blessed ones. These statements are equivalent:</p>

<pre>  $id = $_[SENDER]-&#62;ID();
  $id = $_[KERNEL]-&#62;ID_session_to_id($_[SENDER]);
  $id = $_[KERNEL]-&#62;ID_session_to_id(&#34;$_[SENDER]&#34;);</pre>

<p>As with other POE::Kernel lookup methods, ID_session_to_id() returns undef on failure, setting $! to ESRCH (&#34;No such process&#34;).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="I/O_Watchers_(Selects)"
>I/O Watchers (Selects)</a></h2>

<p>No event system would be complete without the ability to asynchronously watch for I/O events. POE::Kernel implements the lowest level watchers, which are called &#34;selects&#34; because they were historically implemented using Perl&#39;s built-in select(2) function.</p>

<p>Applications handle I/O readiness events by performing some activity on the underlying filehandle. Read-readiness might be handled by reading from the handle. Write-readiness by writing to it.</p>

<p>All I/O watcher events include two parameters. <code>ARG0</code> contains the handle that is ready for work. <code>ARG1</code> contains an integer describing what&#39;s ready.</p>

<pre>  sub handle_io {
    my ($handle, $mode) = @_[ARG0, ARG1];
    print &#34;File $handle is ready for &#34;;
    if ($mode == 0) {
      print &#34;reading&#34;;
    }
    elsif ($mode == 1) {
      print &#34;writing&#34;;
    }
    elsif ($mode == 2) {
      print &#34;out-of-band reading&#34;;
    }
    else {
      die &#34;unknown mode $mode&#34;;
    }
    print &#34;\n&#34;;
    # ... do something here
  }</pre>

<p>The remaining parameters, <code>@_[ARG2..$%_]</code>, contain additional parameters that were passed to the POE::Kernel method that created the watcher.</p>

<p>POE::Kernel conditions filehandles to be 8-bit clean and non-blocking. Programs that need them conditioned differently should set them up after starting POE I/O watchers. If you are running a Perl older than 5.8.1 and is using tied filehandles, you need to set non-blocking mode yourself as <a href="../IO/Handle.html" class="podlinkpod"
>IO::Handle</a> does not work well. See <a href="https://rt.cpan.org/Ticket/Display.html?id=67545" class="podlinkurl"
>https://rt.cpan.org/Ticket/Display.html?id=67545</a> for more info.</p>

<p>I/O watchers will prevent sessions from stopping.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="select_read_FILE_HANDLE_[,_EVENT_NAME_[,_ADDITIONAL_PARAMETERS]_]"
>select_read FILE_HANDLE [, EVENT_NAME [, ADDITIONAL_PARAMETERS] ]</a></h3>

<p>select_read() starts or stops the current session from watching for incoming data on a given FILE_HANDLE. The watcher is started if EVENT_NAME is specified, or stopped if it&#39;s not. ADDITIONAL_PARAMETERS, if specified, will be passed to the EVENT_NAME handler as <code>@_[ARG2..$#_]</code>.</p>

<pre>  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub {
        $_[HEAP]{socket} = IO::Socket::INET-&#62;new(
          PeerAddr =&#62; &#34;localhost&#34;,
          PeerPort =&#62; 25,
        );
        $_[KERNEL]-&#62;select_read( $_[HEAP]{socket}, &#34;got_input&#34; );
        $_[KERNEL]-&#62;delay(timed_out =&#62; 1);
      },
      got_input =&#62; sub {
        my $socket = $_[ARG0];
        while (sysread($socket, my $buf = &#34;&#34;, 8192)) {
          print $buf;
        }
      },
      timed_out =&#62; sub {
        $_[KERNEL]-&#62;select_read( delete $_[HEAP]{socket} );
      },
    }
  );</pre>

<p>select_read() does not return anything significant.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="select_write_FILE_HANDLE_[,_EVENT_NAME_[,_ADDITIONAL_PARAMETERS]_]"
>select_write FILE_HANDLE [, EVENT_NAME [, ADDITIONAL_PARAMETERS] ]</a></h3>

<p>select_write() follows the same semantics as select_read(), but it starts or stops a watcher that looks for write-readiness. That is, when EVENT_NAME is delivered, it means that FILE_HANDLE is ready to be written to.</p>

<p>select_write() does not return anything significant.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="select_expedite_FILE_HANDLE_[,_EVENT_NAME_[,_ADDITIONAL_PARAMETERS]_]"
>select_expedite FILE_HANDLE [, EVENT_NAME [, ADDITIONAL_PARAMETERS] ]</a></h3>

<p>select_expedite() does the same sort of thing as select_read() and select_write(), but it watches a FILE_HANDLE for out-of-band data ready to be input from a FILE_HANDLE. Hardly anybody uses this, but it exists for completeness&#39; sake.</p>

<p>An EVENT_NAME event will be delivered whenever the FILE_HANDLE can be read from out-of-band. Out-of-band data is considered &#34;expedited&#34; because it is often ahead of a socket&#39;s normal data.</p>

<p>select_expedite() does not return anything significant.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="select_pause_read_FILE_HANDLE"
>select_pause_read FILE_HANDLE</a></h3>

<p>select_pause_read() is a lightweight way to pause a FILE_HANDLE input watcher without performing all the bookkeeping of a select_read(). It&#39;s used with select_resume_read() to implement input flow control.</p>

<p>Input that occurs on FILE_HANDLE will backlog in the operating system buffers until select_resume_read() is called.</p>

<p>A side effect of bypassing the select_read() bookkeeping is that a paused FILE_HANDLE will not prematurely stop the current session.</p>

<p>select_pause_read() does not return anything significant.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="select_resume_read_FILE_HANDLE"
>select_resume_read FILE_HANDLE</a></h3>

<p>select_resume_read() resumes a FILE_HANDLE input watcher that was previously paused by select_pause_read(). See select_pause_read() for more discussion on lightweight input flow control.</p>

<p>Data backlogged in the operating system due to a select_pause_read() call will become available after select_resume_read() is called.</p>

<p>select_resume_read() does not return anything significant.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="select_pause_write_FILE_HANDLE"
>select_pause_write FILE_HANDLE</a></h3>

<p>select_pause_write() pauses a FILE_HANDLE output watcher the same way select_pause_read() does for input. Please see select_pause_read() for further discussion.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="select_resume_write_FILE_HANDLE"
>select_resume_write FILE_HANDLE</a></h3>

<p>select_resume_write() resumes a FILE_HANDLE output watcher the same way that select_resume_read() does for input. See select_resume_read() for further discussion.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="select_FILE_HANDLE_[,_EV_READ_[,_EV_WRITE_[,_EV_EXPEDITE_[,_ARGS]_]_]_]"
>select FILE_HANDLE [, EV_READ [, EV_WRITE [, EV_EXPEDITE [, ARGS] ] ] ]</a></h3>

<p>POE::Kernel&#39;s select() method sets or clears a FILE_HANDLE&#39;s read, write and expedite watchers at once. It&#39;s a little more expensive than calling select_read(), select_write() and select_expedite() manually, but it&#39;s significantly more convenient.</p>

<p>Defined event names enable their corresponding watchers, and undefined event names disable them. This turns off all the watchers for a FILE_HANDLE:</p>

<pre>  sub stop_io {
    $_[KERNEL]-&#62;select( $_[HEAP]{file_handle} );
  }</pre>

<p>This statement:</p>

<pre>  $_[KERNEL]-&#62;select( $file_handle, undef, &#34;write_event&#34;, undef, @stuff );</pre>

<p>is equivalent to:</p>

<pre>  $_[KERNEL]-&#62;select_read( $file_handle );
  $_[KERNEL]-&#62;select_write( $file_handle, &#34;write_event&#34;, @stuff );
  $_[KERNEL]-&#62;select_expedite( $file_handle );</pre>

<p>POE::Kernel&#39;s select() should not be confused with Perl&#39;s built-in select() function.</p>

<p>As with the other I/O watcher methods, select() does not return a meaningful value.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Session_Management"
>Session Management</a></h2>

<p>Sessions are dynamic. They may be created and destroyed during a program&#39;s lifespan. When a session is created, it becomes the &#34;child&#34; of the current session. The creator -- the current session -- becomes its &#34;parent&#34; session. This is loosely modeled after UNIX processes.</p>

<p>The most common session management is done by creating new sessions and allowing them to eventually stop.</p>

<p>Every session has a parent, even the very first session created. Sessions without obvious parents are children of the program&#39;s POE::Kernel instance.</p>

<p>Child sessions will keep their parents active. See <a href="#Session_Lifespans" class="podlinkpod"
>&#34;Session Lifespans&#34;</a> for more about why sessions stay alive.</p>

<p>The parent/child relationship tree also governs the way many signals are dispatched. See <a href="#Common_Signal_Dispatching" class="podlinkpod"
>&#34;Common Signal Dispatching&#34;</a> for more information on that.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Session_Management_Events_(_start,__stop,__parent,__child)"
>Session Management Events (_start, _stop, _parent, _child)</a></h3>

<p>POE::Kernel provides four session management events: _start, _stop, _parent and _child. They are invoked synchronously whenever a session is newly created or just about to be destroyed.</p>

<dl>
<dt><a name="_start"
>_start</a></dt>

<dd>
<p>_start should be familiar by now. POE dispatches the _start event to initialize a session after it has been registered under POE::Kernel. What is not readily apparent, however, is that it is invoked before the <a href="../POE/Session.html" class="podlinkpod"
>POE::Session</a> constructor returns.</p>

<p>Within the _start handler, the event&#39;s sender is the session that created the new session. Otherwise known as the new session&#39;s <i>parent</i>. Sessions created before POE::Kernel-&#62;run() is called will be descendents of the program&#39;s POE::Kernel singleton.</p>

<p>The _start handler&#39;s return value is passed to the parent session in a _child event, along with the notification that the parent&#39;s new child was created successfully. See the discussion of _child for more details.</p>

<pre>  POE::Session-&#62;create(
    inline_states =&#62; { _start=&#62; \&#38;_start },
    args =&#62; [ $some, $args ]
  );

  sub _start {
    my ( $some, $args ) = @_[ ARG0, ARG1 ];
    # ....
  }</pre>

<dt><a name="_stop"
>_stop</a></dt>

<dd>
<p>_stop is a little more mysterious. POE calls a _stop handler when a session is irrevocably about to be destroyed. Part of session destruction is the forcible reclamation of its resources (events, timers, message events, etc.) so it&#39;s not possible to post() a message from _stop&#39;s handler. A program is free to try, but the event will be destroyed before it has a chance to be dispatched.</p>

<p>the _stop handler&#39;s return value is passed to the parent&#39;s _child event. See _child for more details.</p>

<p>_stop is usually invoked when a session has no further reason to live, although signals may cause them to stop sooner.</p>

<p>The corresponding _child handler is invoked synchronously just after _stop returns.</p>

<dt><a name="_parent"
>_parent</a></dt>

<dd>
<p>_parent is used to notify a child session when its parent has changed. This usually happens when a session is first created. It can also happen when a child session is detached from its parent. See <a href="#detach_child_CHILD_SESSION" class="podlinkpod"
>detach_child</a> and <a href="#detach_myself" class="podlinkpod"
>&#34;detach_myself&#34;</a>.</p>

<p>_parent&#39;s ARG0 contains the session&#39;s previous parent, and ARG1 contains its new parent.</p>

<pre>  sub _parent {
    my ( $old_parent, $new_parent ) = @_[ ARG0, ARG1 ];
    print(
      &#34;Session &#34;, $_[SESSION]-&#62;ID,
      &#34; parent changed from session &#34;, $old_parent-&#62;ID,
      &#34; to session &#34;, $new_parent-&#62;ID,
      &#34;\n&#34;
    );
  }</pre>

<dt><a name="_child"
>_child</a></dt>

<dd>
<p>_child notifies one session when a child session has been created, destroyed, or reassigned to or from another parent. It&#39;s usually dispatched when sessions are created or destroyed. It can also happen when a session is detached from its parent.</p>

<p>_child includes some information in the &#34;arguments&#34; portion of @_. Typically ARG0, ARG1 and ARG2, but these may be overridden by a different POE::Session class:</p>

<p>ARG0 contains a string describing what has happened to the child. The string may be &#39;create&#39; (the child session has been created), &#39;gain&#39; (the child has been given by another session), or &#39;lose&#39; (the child session has stopped or been given away).</p>

<p>In all cases, ARG1 contains a reference to the child session.</p>

<p>In the &#39;create&#39; case, ARG2 holds the value returned by the child session&#39;s _start handler. Likewise, ARG2 holds the _stop handler&#39;s return value for the &#39;lose&#39; case.</p>

<pre>  sub _child {
    my( $reason, $child ) = @_[ ARG0, ARG1 ];
    if( $reason eq &#39;create&#39; ) {
      my $retval = $_[ ARG2 ];
    }
    # ...
  }</pre>
</dd>
</dl>

<p>The events are delivered in specific orders.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="When_a_new_session_is_created:"
>When a new session is created:</a></h4>

<ol>
<li>The session&#39;s constructor is called.</li>

<li>The session is put into play. That is, POE::Kernel enters the session into its bookkeeping.</li>

<li>The new session receives _start.</li>

<li>The parent session receives _child (&#39;create&#39;), the new session reference, and the new session&#39;s _start&#39;s return value.</li>

<li>The session&#39;s constructor returns.</li>
</ol>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="When_an_old_session_stops:"
>When an old session stops:</a></h4>

<ol>
<li>If the session has children of its own, they are given to the session&#39;s parent. This triggers one or more _child (&#39;gain&#39;) events in the parent, and a _parent in each child.</li>

<li>Once divested of its children, the stopping session receives a _stop event.</li>

<li>The stopped session&#39;s parent receives a _child (&#39;lose&#39;) event with the departing child&#39;s reference and _stop handler&#39;s return value.</li>

<li>The stopped session is removed from play, as are all its remaining resources.</li>

<li>The parent session is checked for idleness. If so, garbage collection will commence on it, and it too will be stopped</li>
</ol>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="When_a_session_is_detached_from_its_parent:"
>When a session is detached from its parent:</a></h4>

<ol>
<li>The parent session of the session being detached is notified with a _child (&#39;lose&#39;) event. The _stop handler&#39;s return value is undef since the child is not actually stopping.</li>

<li>The detached session is notified with a _parent event that its new parent is POE::Kernel itself.</li>

<li>POE::Kernel&#39;s bookkeeping data is adjusted to reflect the change of parentage.</li>

<li>The old parent session is checked for idleness. If so, garbage collection will commence on it, and it too will be stopped</li>
</ol>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Session_Management_Methods"
>Session Management Methods</a></h3>

<p>These methods allow sessions to be detached from their parents in the rare cases where the parent/child relationship gets in the way.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="detach_child_CHILD_SESSION"
>detach_child CHILD_SESSION</a></h4>

<p>detach_child() detaches a particular CHILD_SESSION from the current session. On success, the CHILD_SESSION will become a child of the POE::Kernel instance, and detach_child() will return true. On failure however, detach_child() returns false and sets $! to explain the nature of the failure:</p>

<dl>
<dt><a name="ESRCH_(&#34;No_such_process&#34;)."
>ESRCH (&#34;No such process&#34;).</a></dt>

<dd>
<p>The CHILD_SESSION is not a valid session.</p>

<dt><a name="EPERM_(&#34;Operation_not_permitted&#34;)."
>EPERM (&#34;Operation not permitted&#34;).</a></dt>

<dd>
<p>The CHILD_SESSION exists, but it is not a child of the current session.</p>
</dd>
</dl>

<p>detach_child() will generate <a href="#_parent" class="podlinkpod"
>&#34;_parent&#34;</a> and/or <a href="#_child" class="podlinkpod"
>&#34;_child&#34;</a> events to the appropriate sessions. See <a href="#Session_Management" class="podlinkpod"
>Session Management Events</a> for a detailed explanation of these events. See <a href="#When_a_session_is_detached_from_its_parent%3A" class="podlinkpod"
>above</a> for the order the events are generated.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="detach_myself"
>detach_myself</a></h4>

<p>detach_myself() detaches the current session from its current parent. The new parent will be the running POE::Kernel instance. It returns true on success. On failure it returns false and sets <code>$!</code> to explain the nature of the failure:</p>

<dl>
<dt><a name="EPERM_(&#34;Operation_not_permitted&#34;)."
>EPERM (&#34;Operation not permitted&#34;).</a></dt>

<dd>
<p>The current session is already a child of POE::Kernel, so it may not be detached.</p>
</dd>
</dl>

<p>detach_child() will generate <a href="#_parent" class="podlinkpod"
>&#34;_parent&#34;</a> and/or <a href="#_child" class="podlinkpod"
>&#34;_child&#34;</a> events to the appropriate sessions. See <a href="#Session_Management" class="podlinkpod"
>Session Management Events</a> for a detailed explanation of these events. See <a href="#When_a_session_is_detached_from_its_parent%3A" class="podlinkpod"
>above</a> for the order the events are generated.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Signals"
>Signals</a></h2>

<p>POE::Kernel provides methods through which a program can register interest in signals that come along, can deliver its own signals without resorting to system calls, and can indicate that signals have been handled so that default behaviors are not necessary.</p>

<p>Signals are <i>action at a distance</i> by nature, and their implementation requires widespread synchronization between sessions (and reentrancy in the dispatcher, but that&#39;s an implementation detail). Perfecting the semantics has proven difficult, but POE tries to do the Right Thing whenever possible.</p>

<p>POE does not register %SIG handlers for signals until sig() is called to watch for them. Therefore a signal&#39;s default behavior occurs for unhandled signals. That is, SIGINT will gracelessly stop a program, SIGWINCH will do nothing, SIGTSTP will pause a program, and so on.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Signal_Classes"
>Signal Classes</a></h3>

<p>There are three signal classes. Each class defines a default behavior for the signal and whether the default can be overridden. They are:</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="Benign,_advisory,_or_informative_signals"
>Benign, advisory, or informative signals</a></h4>

<p>These are three names for the same signal class. Signals in this class notify a session of an event but do not terminate the session if they are not handled.</p>

<p>It is possible for an application to create its own benign signals. See <a href="#signal" class="podlinkpod"
>&#34;signal&#34;</a> below.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="Terminal_signals"
>Terminal signals</a></h4>

<p>Terminal signals will kill sessions if they are not handled by a <a href="#sig_handled" class="podlinkpod"
>&#34;sig_handled&#34;</a>() call. The OS signals that usually kill or dump a process are considered terminal in POE, but they never trigger a coredump. These are: HUP, INT, QUIT and TERM.</p>

<p>There are two terminal signals created by and used within POE:</p>

<dl>
<dt><a name="DIE"
>DIE</a></dt>

<dd>
<p><code>DIE</code> notifies sessions that a Perl exception has occurred. See <a href="#Exception_Handling" class="podlinkpod"
>&#34;Exception Handling&#34;</a> for details.</p>

<dt><a name="IDLE"
>IDLE</a></dt>

<dd>
<p>The <code>IDLE</code> signal is used to notify leftover sessions that a program has run out of things to do.</p>
</dd>
</dl>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="Nonmaskable_signals"
>Nonmaskable signals</a></h4>

<p>Nonmaskable signals are terminal regardless whether sig_handled() is called. The term comes from &#34;NMI&#34;, the non-maskable CPU interrupt usually generated by an unrecoverable hardware exception.</p>

<p>Sessions that receive a non-maskable signal will unavoidably stop. POE implements two non-maskable signals:</p>

<dl>
<dt><a name="ZOMBIE"
>ZOMBIE</a></dt>

<dd>
<p>This non-maskable signal is fired if a program has received an <code>IDLE</code> signal but neither restarted nor exited. The program has become a zombie (that is, it&#39;s neither dead nor alive, and only exists to consume braaaains ...er... memory). The <code>ZOMBIE</code> signal acts like a cricket bat to the head, bringing the zombie down, for good.</p>

<dt><a name="UIDESTROY"
>UIDESTROY</a></dt>

<dd>
<p>This non-maskable signal indicates that a program&#39;s user interface has been closed, and the program should take the user&#39;s hint and buzz off as well. It&#39;s usually generated when a particular GUI widget is closed.</p>
</dd>
</dl>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Common_Signal_Dispatching"
>Common Signal Dispatching</a></h3>

<p>Most signals are not dispatched to a single session. POE&#39;s session lineage (parents and children) form a sort of family tree. When a signal is sent to a session, it first passes through any children (and grandchildren, and so on) that are also interested in the signal.</p>

<p>In the case of terminal signals, if any of the sessions a signal passes through calls <a href="#sig_handled" class="podlinkpod"
>&#34;sig_handled&#34;</a>(), then the signal is considered taken care of. However if none of them do, then the entire session tree rooted at the destination session is terminated. For example, consider this tree of sessions:</p>

<pre>  POE::Kernel
    Session 2
      Session 4
      Session 5
    Session 3
      Session 6
      Session 7</pre>

<p>POE::Kernel is the parent of sessions 2 and 3. Session 2 is the parent of sessions 4 and 5. And session 3 is the parent of 6 and 7.</p>

<p>A signal sent to Session 2 may also be dispatched to session 4 and 5 because they are 2&#39;s children. Sessions 4 and 5 will only receive the signal if they have registered the appropriate watcher. If the signal is terminal, and none of the signal watchers in sessions 2, 4 and 5 called <code>sig_handled()</code>, all 3 sessions will be terminated.</p>

<p>The program&#39;s POE::Kernel instance is considered to be a session for the purpose of signal dispatch. So any signal sent to POE::Kernel will propagate through every interested session in the entire program. This is in fact how OS signals are handled: A global signal handler is registered to forward the signal to POE::Kernel.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Signal_Semantics"
>Signal Semantics</a></h3>

<p>All signals come with the signal name in ARG0. The signal name is as it appears in %SIG, with one exception: Child process signals are always &#34;CHLD&#34; even if the current operating system recognizes them as &#34;CLD&#34;.</p>

<p>Certain signals have special semantics:</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="SIGCHLD"
>SIGCHLD</a></h4>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="SIGCLD"
>SIGCLD</a></h4>

<p>Both <code>SIGCHLD</code> and <code>SIGCLD</code> indicate that a child process has exited or been terminated by some signal. The actual signal name varies between operating systems, but POE uses <code>CHLD</code> regardless.</p>

<p>Interest in <code>SIGCHLD</code> is registered using the <a href="#sig_child" class="podlinkpod"
>&#34;sig_child&#34;</a> method. The <a href="#sig" class="podlinkpod"
>&#34;sig&#34;</a>() method also works, but it&#39;s not as nice.</p>

<p>The <code>SIGCHLD</code> event includes three parameters:</p>

<dl>
<dt><a name="ARG0"
>ARG0</a></dt>

<dd>
<p><code>ARG0</code> contains the string &#39;CHLD&#39; (even if the OS calls it SIGCLD, SIGMONKEY, or something else).</p>

<dt><a name="ARG1"
>ARG1</a></dt>

<dd>
<p><code>ARG1</code> contains the process ID of the finished child process.</p>

<dt><a name="ARG2"
>ARG2</a></dt>

<dd>
<p>And <code>ARG2</code> holds the value of <code>$?</code> for the finished process.</p>
</dd>
</dl>

<p>Example:</p>

<pre>  sub sig_CHLD {
    my( $name, $PID, $exit_val ) = @_[ ARG0, ARG1, ARG2 ];
    # ...
  }</pre>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="SIGPIPE"
>SIGPIPE</a></h4>

<p>SIGPIPE is rarely used since POE provides events that do the same thing. Nevertheless SIGPIPE is supported if you need it. Unlike most events, however, SIGPIPE is dispatched directly to the active session when it&#39;s caught. Barring race conditions, the active session should be the one that caused the OS to send the signal in the first place.</p>

<p>The SIGPIPE signal will still propagate to child sessions.</p>

<p>ARG0 is &#34;PIPE&#34;. There is no other information associated with this signal.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="SIGWINCH"
>SIGWINCH</a></h4>

<p>Window resizes can generate a large number of signals very quickly. This may not be a problem when using perl 5.8.0 or later, but earlier versions may not take kindly to such abuse. You have been warned.</p>

<p>ARG0 is &#34;WINCH&#34;. There is no other information associated with this signal.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Exception_Handling"
>Exception Handling</a></h3>

<p>POE::Kernel provides only one form of exception handling: the <code>DIE</code> signal.</p>

<p>When exception handling is enabled (the default), POE::Kernel wraps state invocation in <code>eval{}</code>. If the event handler raises an exception, generally with <code>die</code>, POE::Kernel will dispatch a <code>DIE</code> signal to the event&#39;s destination session.</p>

<p><code>ARG0</code> is the signal name, <code>DIE</code>.</p>

<p><code>ARG1</code> is a hashref describing the exception:</p>

<dl>
<dt><a name="error_str"
>error_str</a></dt>

<dd>
<p>The text of the exception. In other words, <code>$@</code>.</p>

<dt><a name="dest_session"
>dest_session</a></dt>

<dd>
<p>Session object of the state that the raised the exception. In other words, <code>$_[SESSION]</code> in the function that died.</p>

<dt><a name="event"
>event</a></dt>

<dd>
<p>Name of the event that died.</p>

<dt><a name="source_session"
>source_session</a></dt>

<dd>
<p>Session object that sent the original event. That is, <code>$_[SENDER]</code> in the function that died.</p>

<dt><a name="from_state"
>from_state</a></dt>

<dd>
<p>State from which the original event was sent. That is, <code>$_[CALLER_STATE]</code> in the function that died.</p>

<dt><a name="file"
>file</a></dt>

<dd>
<p>Name of the file the event was sent from. That is, <code>$_[CALLER_FILE]</code> in the function that died.</p>

<dt><a name="line"
>line</a></dt>

<dd>
<p>Line number the event was sent from. That is, <code>$_[CALLER_LINE]</code> in the function that died.</p>
</dd>
</dl>

<p><i>Note that the preceding discussion assumes you are using <a href="../POE/Session.html" class="podlinkpod"
>POE::Session</a>&#39;s call semantics.</i></p>

<p>Note that the <code>DIE</code> signal is sent to the session that raised the exception, not the session that sent the event that caused the exception to be raised.</p>

<pre>  sub _start {
    $poe_kernel-&#62;sig( DIE =&#62; &#39;sig_DIE&#39; );
    $poe_kernel-&#62;yield( &#39;some_event&#39; );
  }

  sub some_event {
    die &#34;I didn&#39;t like that!&#34;;
  }

  sub sig_DIE {
    my( $sig, $ex ) = @_[ ARG0, ARG1 ];
    # $sig is &#39;DIE&#39;
    # $ex is the exception hash
    warn &#34;$$: error in $ex-&#62;{event}: $ex-&#62;{error_str}&#34;;
    $poe_kernel-&#62;sig_handled();

    # Send the signal to session that sent the original event.
    if( $ex-&#62;{source_session} ne $_[SESSION] ) {
      $poe_kernel-&#62;signal( $ex-&#62;{source_session}, &#39;DIE&#39;, $sig, $ex );
    }
  }</pre>

<p>POE::Kernel&#39;s built-in exception handling can be disabled by setting the <code>POE::Kernel::CATCH_EXCEPTIONS</code> constant to zero. As with other compile-time configuration constants, it must be set before POE::Kernel is compiled:</p>

<pre>  BEGIN {
    package POE::Kernel;
    use constant CATCH_EXCEPTIONS =&#62; 0;
  }
  use POE;</pre>

<p>or</p>

<pre>  sub POE::Kernel::CATCH_EXCEPTIONS () { 0 }
  use POE;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Signal_Watcher_Methods"
>Signal Watcher Methods</a></h2>

<p>And finally the methods themselves.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="sig_SIGNAL_NAME_[,_EVENT_NAME_[,_LIST]_]"
>sig SIGNAL_NAME [, EVENT_NAME [, LIST] ]</a></h3>

<p>sig() registers or unregisters an EVENT_NAME event for a particular SIGNAL_NAME, with an optional LIST of parameters that will be passed to the signal&#39;s handler---after any data that comes wit the signal.</p>

<p>If EVENT_NAME is defined, the signal handler is registered. Otherwise it&#39;s unregistered.</p>

<p>Each session can register only one handler per SIGNAL_NAME. Subsequent registrations will replace previous ones. Multiple sessions may however watch the same signal.</p>

<p>SIGNAL_NAMEs are generally the same as members of <code>%SIG</code>, with two exceptions. First, <code>CLD</code> is an alias for <code>CHLD</code> (although see <a href="#sig_child" class="podlinkpod"
>&#34;sig_child&#34;</a>). And second, it&#39;s possible to send and handle signals created by the application and have no basis in the operating system.</p>

<pre>  sub handle_start {
    $_[KERNEL]-&#62;sig( INT =&#62; &#34;event_ui_shutdown&#34; );
    $_[KERNEL]-&#62;sig( bat =&#62; &#34;holy_searchlight_batman&#34; );
    $_[KERNEL]-&#62;sig( signal =&#62; &#34;main_screen_turn_on&#34; );
  }</pre>

<p>The operating system may never be able to generate the last two signals, but a POE session can by using POE::Kernel&#39;s <a href="#signal" class="podlinkpod"
>&#34;signal&#34;</a>() method.</p>

<p>Later on the session may decide not to handle the signals:</p>

<pre>  sub handle_ui_shutdown {
    $_[KERNEL]-&#62;sig( &#34;INT&#34; );
    $_[KERNEL]-&#62;sig( &#34;bat&#34; );
    $_[KERNEL]-&#62;sig( &#34;signal&#34; );
  }</pre>

<p>More than one session may register interest in the same signal, and a session may clear its own signal watchers without affecting those in other sessions.</p>

<p>sig() does not return a meaningful value.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="sig_child_PROCESS_ID_[,_EVENT_NAME_[,_LIST]_]"
>sig_child PROCESS_ID [, EVENT_NAME [, LIST] ]</a></h3>

<p>sig_child() is a convenient way to deliver an EVENT_NAME event when a particular PROCESS_ID has exited. An optional LIST of parameters will be passed to the signal handler after the waitpid() information.</p>

<p>The watcher can be cleared at any time by calling sig_child() with just the PROCESS_ID.</p>

<p>A session may register as many sig_child() handlers as necessary, but a session may only have one per PROCESS_ID.</p>

<p>sig_child() watchers are one-shot. They automatically unregister themselves once the EVENT_NAME has been delivered. There&#39;s no point in continuing to watch for a signal that will never come again. Other signal handlers persist until they are cleared.</p>

<p>sig_child() watchers keep a session alive for as long as they are active. This is unique among POE&#39;s signal watchers.</p>

<p>Programs that wish to reliably reap child processes should be sure to call sig_child() before returning from the event handler that forked the process. Otherwise POE::Kernel may have an opportunity to call waitpid() before an appropriate event watcher has been registered.</p>

<p>Programs that reap processes with waitpid() must clear POE&#39;s watchers for the same process IDs, otherwise POE will wait indefinitely for processes that never send signals.</p>

<p>sig_child() does not return a meaningful value.</p>

<pre>  sub forked_parent {
    my( $heap, $pid, $details ) = @_[ HEAP, ARG0, ARG1 ];
    $poe_kernel-&#62;sig_child( $pid, &#39;sig_child&#39;, $details );
  }

  sub sig_child {
    my( $heap, $sig, $pid, $exit_val, $details ) = @_[ HEAP, ARG0..ARG3 ];
    my $details = delete $heap-&#62;{ $pid };
    warn &#34;$$: Child $pid exited&#34;
    # .... also, $details has been passed from forked_parent()
    # through sig_child()
  }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="sig_handled"
>sig_handled</a></h3>

<p>sig_handled() informs POE::Kernel that the currently dispatched signal has been handled by the currently active session. If the signal is terminal, the sig_handled() call prevents POE::Kernel from stopping the sessions that received the signal.</p>

<p>A single signal may be dispatched to several sessions. Only one needs to call sig_handled() to prevent the entire group from being stopped. If none of them call it, however, then they are all stopped together.</p>

<p>sig_handled() does not return a meaningful value.</p>

<pre>  sub _start {
    $_[KERNEL]-&#62;sig( INT =&#62; &#39;sig_INT&#39; );
  }

  sub sig_INT {
    warn &#34;$$ SIGINT&#34;;
    $_[KERNEL]-&#62;sig_handled();
  }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="signal_SESSION,_SIGNAL_NAME_[,_ARGS_LIST]"
>signal SESSION, SIGNAL_NAME [, ARGS_LIST]</a></h3>

<p>signal() posts a SIGNAL_NAME signal to a specific SESSION with an optional ARGS_LIST that will be passed to every interested handler. As mentioned elsewhere, the signal may be delivered to SESSION&#39;s children, grandchildren, and so on. And if SESSION is the POE::Kernel itself, then all interested sessions will receive the signal.</p>

<p>It is possible to send a signal in POE that doesn&#39;t exist in the operating system. signal() places the signal directly into POE&#39;s event queue as if they came from the operating system, but they are not limited to signals recognized by kill(). POE uses a few of these fictitious signals for its own global notifications.</p>

<p>For example:</p>

<pre>  sub some_event_handler {
    # Turn on all main screens.
    $_[KERNEL]-&#62;signal( $_[KERNEL], &#34;signal&#34; );
  }</pre>

<p>signal() returns true on success. On failure, it returns false after setting $! to explain the nature of the failure:</p>

<dl>
<dt><a name="ESRCH_(&#34;No_such_process&#34;)"
>ESRCH (&#34;No such process&#34;)</a></dt>

<dd>
<p>The SESSION does not exist.</p>
</dd>
</dl>

<p>Because all sessions are a child of POE::Kernel, sending a signal to the kernel will propagate the signal to all sessions. This is a cheap form of <i>multicast</i>.</p>

<pre>  $_[KERNEL]-&#62;signal( $_[KERNEL], &#39;shutdown&#39; );</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="signal_ui_destroy_WIDGET_OBJECT"
>signal_ui_destroy WIDGET_OBJECT</a></h3>

<p>signal_ui_destroy() associates the destruction of a particular WIDGET_OBJECT with the complete destruction of the program&#39;s user interface. When the WIDGET_OBJECT destructs, POE::Kernel issues the non-maskable UIDESTROY signal, which quickly triggers mass destruction of all active sessions. POE::Kernel-&#62;run() returns shortly thereafter.</p>

<pre>  sub setup_ui {
    $_[HEAP]{main_widget} = Gtk-&#62;new(&#34;toplevel&#34;);
    # ... populate the main widget here ...
    $_[KERNEL]-&#62;signal_ui_destroy( $_[HEAP]{main_widget} );
  }</pre>

<p>Detecting widget destruction is specific to each toolkit.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Event_Handler_Management"
>Event Handler Management</a></h2>

<p>Event handler management methods let sessions hot swap their event handlers at run time. For example, the <a href="../POE/Wheel.html" class="podlinkpod"
>POE::Wheel</a> objects use state() to dynamically mix their own event handlers into the sessions that create them.</p>

<p>These methods only affect the current session; it would be rude to change another session&#39;s handlers.</p>

<p>There is only one method in this group. Since it may be called in several different ways, it may be easier to understand if each is documented separately.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="state_EVENT_NAME_[,_CODE_REFERNCE]"
>state EVENT_NAME [, CODE_REFERNCE]</a></h3>

<p>state() sets or removes a handler for EVENT_NAME in the current session. The function referred to by CODE_REFERENCE will be called whenever EVENT_NAME events are dispatched to the current session. If CODE_REFERENCE is omitted, the handler for EVENT_NAME will be removed.</p>

<p>A session may only have one handler for a given EVENT_NAME. Subsequent attempts to set an EVENT_NAME handler will replace earlier handlers with the same name.</p>

<pre>  # Stop paying attention to input.  Say goodbye, and
  # trigger a socket close when the message is sent.
  sub send_final_response {
    $_[HEAP]{wheel}-&#62;put(&#34;KTHXBYE&#34;);
    $_[KERNEL]-&#62;state( &#39;on_client_input&#39; );
    $_[KERNEL]-&#62;state( on_flush =&#62; \&#38;close_connection );
  }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="state_EVENT_NAME_[,_OBJECT_REFERENCE_[,_OBJECT_METHOD_NAME]_]"
>state EVENT_NAME [, OBJECT_REFERENCE [, OBJECT_METHOD_NAME] ]</a></h3>

<p>Set or remove a handler for EVENT_NAME in the current session. If an OBJECT_REFERENCE is given, that object will handle the event. An optional OBJECT_METHOD_NAME may be provided. If the method name is not given, POE will look for a method matching the EVENT_NAME instead. If the OBJECT_REFERENCE is omitted, the handler for EVENT_NAME will be removed.</p>

<p>A session may only have one handler for a given EVENT_NAME. Subsequent attempts to set an EVENT_NAME handler will replace earlier handlers with the same name.</p>

<pre>  $_[KERNEL]-&#62;state( &#39;some_event&#39;, $self );
  $_[KERNEL]-&#62;state( &#39;other_event&#39;, $self, &#39;other_method&#39; );</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="state_EVENT_NAME_[,_CLASS_NAME_[,_CLASS_METHOD_NAME]_]"
>state EVENT_NAME [, CLASS_NAME [, CLASS_METHOD_NAME] ]</a></h3>

<p>This form of state() call is virtually identical to that of the object form.</p>

<p>Set or remove a handler for EVENT_NAME in the current session. If an CLASS_NAME is given, that class will handle the event. An optional CLASS_METHOD_NAME may be provided. If the method name is not given, POE will look for a method matching the EVENT_NAME instead. If the CLASS_NAME is omitted, the handler for EVENT_NAME will be removed.</p>

<p>A session may only have one handler for a given EVENT_NAME. Subsequent attempts to set an EVENT_NAME handler will replace earlier handlers with the same name.</p>

<pre>  $_[KERNEL]-&#62;state( &#39;some_event&#39;, __PACKAGE__ );
  $_[KERNEL]-&#62;state( &#39;other_event&#39;, __PACKAGE__, &#39;other_method&#39; );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Public_Reference_Counters"
>Public Reference Counters</a></h2>

<p>The methods in this section manipulate reference counters on the current session or another session.</p>

<p>Each session has a namespace for user-manipulated reference counters. These namespaces are associated with the target SESSION_ID for the reference counter methods, not the caller. Nothing currently prevents one session from decrementing a reference counter that was incremented by another, but this behavior is not guaranteed to remain. For now, it&#39;s up to the users of these methods to choose obscure counter names to avoid conflicts.</p>

<p>Reference counting is a big part of POE&#39;s magic. Various objects (mainly event watchers and components) hold references to the sessions that own them. <a href="#Session_Lifespans" class="podlinkpod"
>&#34;Session Lifespans&#34;</a> explains the concept in more detail.</p>

<p>The ability to keep a session alive is sometimes useful in an application or library. For example, a component may hold a public reference to another session while it processes a request from that session. In doing so, the component guarantees that the requester is still around when a response is eventually ready. Keeping a reference to the session&#39;s object is not enough. POE::Kernel has its own internal reference counting mechanism.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="refcount_increment_SESSION_ID,_COUNTER_NAME"
>refcount_increment SESSION_ID, COUNTER_NAME</a></h3>

<p>refcount_increment() increases the value of the COUNTER_NAME reference counter for the session identified by a SESSION_ID. To discourage the use of session references, the refcount_increment() target session must be specified by its session ID.</p>

<p>The target session will not stop until the value of any and all of its COUNTER_NAME reference counters are zero. (Actually, it may stop in some cases, such as failing to handle a terminal signal.)</p>

<p>Negative reference counters are legal. They still must be incremented back to zero before a session is eligible for stopping.</p>

<pre>  sub handle_request {
    # Among other things, hold a reference count on the sender.
    $_[KERNEL]-&#62;refcount_increment( $_[SENDER]-&#62;ID, &#34;pending request&#34;);
    $_[HEAP]{requesters}{$request_id} = $_[SENDER]-&#62;ID;
  }</pre>

<p>For this to work, the session needs a way to remember the $_[SENDER]-&#62;ID for a given request. Customarily the session generates a request ID and uses that to track the request until it is fulfilled.</p>

<p>refcount_increment() returns the resulting reference count (which may be zero) on success. On failure, it returns undef and sets $! to be the reason for the error.</p>

<p>ESRCH: The SESSION_ID does not refer to a currently active session.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="refcount_decrement_SESSION_ID,_COUNTER_NAME"
>refcount_decrement SESSION_ID, COUNTER_NAME</a></h3>

<p>refcount_decrement() reduces the value of the COUNTER_NAME reference counter for the session identified by a SESSION_ID. It is the counterpoint for refcount_increment(). Please see refcount_increment() for more context.</p>

<pre>  sub finally_send_response {
    # Among other things, release the reference count for the
    # requester.
    my $requester_id = delete $_[HEAP]{requesters}{$request_id};
    $_[KERNEL]-&#62;refcount_decrement( $requester_id, &#34;pending request&#34;);
  }</pre>

<p>The requester&#39;s $_[SENDER]-&#62;ID is remembered and removed from the heap (lest there be memory leaks). It&#39;s used to decrement the reference counter that was incremented at the start of the request.</p>

<p>refcount_decrement() returns the resulting reference count (which may be zero) on success. On failure, it returns undef, and $! will be set to the reason for the failure:</p>

<p>ESRCH: The SESSION_ID does not refer to a currently active session.</p>

<p>It is not possible to discover currently active public references. See <a href="../POE/API/Peek.html" class="podlinkpod"
>POE::API::Peek</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Kernel_State_Accessors"
>Kernel State Accessors</a></h2>

<p>POE::Kernel provides a few accessors into its massive brain so that library developers may have convenient access to necessary data without relying on their callers to provide it.</p>

<p>These accessors expose ways to break session encapsulation. Please use them sparingly and carefully.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="get_active_session"
>get_active_session</a></h3>

<p>get_active_session() returns a reference to the session that is currently running, or a reference to the program&#39;s POE::Kernel instance if no session is running at that moment. The value is equivalent to <a href="../POE/Session.html" class="podlinkpod"
>POE::Session</a>&#39;s <code>$_[SESSION]</code>.</p>

<p>This method was added for libraries that need <code>$_[SESSION]</code> but don&#39;t want to include it as a parameter in their APIs.</p>

<pre>  sub some_housekeeping {
    my( $self ) = @_;
    my $session = $poe_kernel-&#62;get_active_session;
    # do some housekeeping on $session
  }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="get_active_event"
>get_active_event</a></h3>

<p>get_active_event() returns the name of the event currently being dispatched. It returns an empty string when called outside event dispatch. The value is equivalent to <a href="../POE/Session.html" class="podlinkpod"
>POE::Session</a>&#39;s <code>$_[STATE]</code>.</p>

<pre>  sub waypoint {
    my( $message ) = @_;
    my $event = $poe_kernel-&#62;get_active_event;
    print STDERR &#34;$$:$event:$mesage\n&#34;;
  }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="get_event_count"
>get_event_count</a></h3>

<p>get_event_count() returns the number of events pending in POE&#39;s event queue. It is exposed for <a href="../POE/Loop.html" class="podlinkpod"
>POE::Loop</a> class authors. It may be deprecated in the future.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="get_next_event_time"
>get_next_event_time</a></h3>

<p>get_next_event_time() returns the time the next event is due, in a form compatible with the UNIX time() function. It is exposed for <a href="../POE/Loop.html" class="podlinkpod"
>POE::Loop</a> class authors. It may be deprecated in the future.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="poe_kernel_loop"
>poe_kernel_loop</a></h3>

<p>poe_kernel_loop() returns the name of the POE::Loop class that is used to detect and dispatch events.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Session_Helper_Methods"
>Session Helper Methods</a></h2>

<p>The methods in this group expose features for <a href="../POE/Session.html" class="podlinkpod"
>POE::Session</a> class authors.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="session_alloc_SESSION_OBJECT_[,_START_ARGS]"
>session_alloc SESSION_OBJECT [, START_ARGS]</a></h3>

<p>session_alloc() allocates a session context within POE::Kernel for a newly created SESSION_OBJECT. A list of optional START_ARGS will be passed to the session as part of the <a href="#_start" class="podlinkpod"
>&#34;_start&#34;</a> event.</p>

<p>The SESSION_OBJECT is expected to follow a subset of POE::Session&#39;s interface.</p>

<p>There is no session_free(). POE::Kernel determines when the session should stop and performs the necessary cleanup after dispatching _stop to the session.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Miscellaneous_Methods"
>Miscellaneous Methods</a></h2>

<p>We don&#39;t know where to classify the methods in this section.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="new"
>new</a></h3>

<p>It is not necessary to call POE::Kernel&#39;s new() method. Doing so will return the program&#39;s singleton POE::Kernel object, however.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PUBLIC_EXPORTED_VARIABLES"
>PUBLIC EXPORTED VARIABLES</a></h1>

<p>POE::Kernel exports two variables for your coding enjoyment: <code>$poe_kernel</code> and <code>$poe_main_window</code>. POE::Kernel is implicitly used by POE itself, so using POE gets you POE::Kernel (and its exports) for free.</p>

<p>In more detail:</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$poe_kernel"
>$poe_kernel</a></h2>

<p><code>$poe_kernel</code> contains a reference to the process&#39; POE::Kernel singleton instance. It&#39;s mainly used for accessing POE::Kernel methods from places where <code>$_[KERNEL]</code> is not available. It&#39;s most commonly used in helper libraries.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="$poe_main_window"
>$poe_main_window</a></h2>

<p>$poe_main_window is used by graphical toolkits that require at least one widget to be created before their event loops are usable. This is currently only Tk.</p>

<p><a href="../POE/Loop/Tk.html" class="podlinkpod"
>POE::Loop::Tk</a> creates a main window to satisfy Tk&#39;s event loop. The window is given to the application since POE has no other use for it.</p>

<p><code>$poe_main_window</code> is undefined in toolkits that don&#39;t require a widget to dispatch events.</p>

<p>On a related note, POE will shut down if the widget in <code>$poe_main_window</code> is destroyed. This can be changed with POE::Kernel&#39;s <a href="#signal_ui_destroy" class="podlinkpod"
>&#34;signal_ui_destroy&#34;</a> method.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DEBUGGING_POE_AND_PROGRAMS_USING_IT"
>DEBUGGING POE AND PROGRAMS USING IT</a></h1>

<p>POE includes quite a lot of debugging code, in the form of both fatal assertions and run-time traces. They may be enabled at compile time, but there is no way to toggle them at run-time. This was done to avoid run-time penalties in programs where debugging is not necessary. That is, in most production cases.</p>

<p>Traces are verbose reminders of what&#39;s going on within POE. Each is prefixed with a four-character field describing the POE subsystem that generated it.</p>

<p>Assertions (asserts) are quiet but deadly, both in performance (they cause a significant run-time performance hit) and because they cause fatal errors when triggered.</p>

<p>The assertions and traces are useful for developing programs with POE, but they were originally added to debug POE itself.</p>

<p>Each assertion and tracing group is enabled by setting a constant in the POE::Kernel namespace to a true value.</p>

<pre>  BEGIN {
    package POE::Kernel;
    use constant ASSERT_DEFAULT =&#62; 1;
  }
  use POE;</pre>

<p>Or the old-fashioned (and more concise) &#34;constant subroutine&#34; method. This doesn&#39;t need the <code>BEGIN{}</code> block since subroutine definitions are done at compile time.</p>

<pre>  sub POE::Kernel::ASSERT_DEFAULT () { 1 }
  use POE;</pre>

<p>The switches must be defined as constants before POE::Kernel is first loaded. Otherwise Perl&#39;s compiler will not see the constants when first compiling POE::Kernel, and the features will not be properly enabled.</p>

<p>Assertions and traces may also be enabled by setting shell environment variables. The environment variables are named after the POE::Kernel constants with a &#34;POE_&#34; prefix.</p>

<pre>  POE_ASSERT_DEFAULT=1 POE_TRACE_DEFAULT=1 ./my_poe_program</pre>

<p>In alphabetical order:</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ASSERT_DATA"
>ASSERT_DATA</a></h2>

<p>ASSERT_DATA enables run-time data integrity checks within POE::Kernel and the classes that mix into it. POE::Kernel tracks a lot of cross-referenced data, and this group of assertions ensures that it&#39;s consistent.</p>

<p>Prefix: &#60;dt&#62;</p>

<p>Environment variable: POE_ASSERT_DATA</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ASSERT_DEFAULT"
>ASSERT_DEFAULT</a></h2>

<p>ASSERT_DEFAULT specifies the default value for assertions that are not explicitly enabled or disabled. This is a quick and reliable way to make sure all assertions are on.</p>

<p>No assertion uses ASSERT_DEFAULT directly, and this assertion flag has no corresponding output prefix.</p>

<p>Turn on all assertions except ASSERT_EVENTS:</p>

<pre>  sub POE::Kernel::ASSERT_DEFAULT () { 1 }
  sub POE::Kernel::ASSERT_EVENTS  () { 0 }
  use POE::Kernel;</pre>

<p>Prefix: (none)</p>

<p>Environment variable: POE_ASSERT_DEFAULT</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ASSERT_EVENTS"
>ASSERT_EVENTS</a></h2>

<p>ASSERT_EVENTS mainly checks for attempts to dispatch events to sessions that don&#39;t exist. This assertion can assist in the debugging of strange, silent cases where event handlers are not called.</p>

<p>Prefix: &#60;ev&#62;</p>

<p>Environment variable: POE_ASSERT_EVENTS</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ASSERT_FILES"
>ASSERT_FILES</a></h2>

<p>ASSERT_FILES enables some run-time checks in POE&#39;s filehandle watchers and the code that manages them.</p>

<p>Prefix: &#60;fh&#62;</p>

<p>Environment variable: POE_ASSERT_FILES</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ASSERT_RETVALS"
>ASSERT_RETVALS</a></h2>

<p>ASSERT_RETVALS upgrades failure codes from POE::Kernel&#39;s methods from advisory return values to fatal errors. Most programmers don&#39;t check the values these methods return, so ASSERT_RETVALS is a quick way to validate one&#39;s assumption that all is correct.</p>

<p>Prefix: &#60;rv&#62;</p>

<p>Environment variable: POE_ASSERT_RETVALS</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ASSERT_USAGE"
>ASSERT_USAGE</a></h2>

<p>ASSERT_USAGE is the counterpoint to ASSERT_RETVALS. It enables run-time checks that the parameters to POE::Kernel&#39;s methods are correct. It&#39;s a quick (but not foolproof) way to verify a program&#39;s use of POE.</p>

<p>Prefix: &#60;us&#62;</p>

<p>Environment variable: POE_ASSERT_USAGE</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="TRACE_DEFAULT"
>TRACE_DEFAULT</a></h2>

<p>TRACE_DEFAULT specifies the default value for traces that are not explicitly enabled or disabled. This is a quick and reliable way to ensure your program generates copious output on the file named in TRACE_FILENAME or STDERR by default.</p>

<p>To enable all traces except a few noisier ones:</p>

<pre>  sub POE::Kernel::TRACE_DEFAULT () { 1 }
  sub POE::Kernel::TRACE_EVENTS  () { 0 }
  use POE::Kernel;</pre>

<p>Prefix: (none)</p>

<p>Environment variable: POE_TRACE_DEFAULT</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="TRACE_DESTROY"
>TRACE_DESTROY</a></h2>

<p>TRACE_DESTROY causes every POE::Session object to dump the contents of its <code>$_[HEAP]</code> when Perl destroys it. This trace was added to help developers find memory leaks in their programs.</p>

<p>Prefix: A line that reads &#34;----- Session $self Leak Check -----&#34;.</p>

<p>Environment variable: POE_TRACE_DESTROY</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="TRACE_EVENTS"
>TRACE_EVENTS</a></h2>

<p>TRACE_EVENTS enables messages pertaining to POE&#39;s event queue&#39;s activities: when events are enqueued, dispatched or discarded, and more. It&#39;s great for determining where events go and when. Understandably this is one of POE&#39;s more verbose traces.</p>

<p>Prefix: &#60;ev&#62;</p>

<p>Environment variable: POE_TRACE_EVENTS</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="TRACE_FILENAME"
>TRACE_FILENAME</a></h2>

<p>TRACE_FILENAME specifies the name of a file where POE&#39;s tracing and assertion messages should go. It&#39;s useful if you want the messages but have other plans for STDERR, which is where the messages go by default.</p>

<p>POE&#39;s tests use this so the trace and assertion code can be instrumented during testing without spewing all over the terminal.</p>

<p>Prefix: (none)</p>

<p>Environment variable: POE_TRACE_FILENAME</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="TRACE_FILES"
>TRACE_FILES</a></h2>

<p>TRACE_FILES enables or disables traces in POE&#39;s filehandle watchers and the <a href="../POE/Loop.html" class="podlinkpod"
>POE::Loop</a> class that implements the lowest-level filehandle multiplexing. This may be useful when tracking down strange behavior related to filehandles.</p>

<p>Prefix: &#60;fh&#62;</p>

<p>Environment variable: POE_TRACE_FILES</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="TRACE_REFCNT"
>TRACE_REFCNT</a></h2>

<p>TRACE_REFCNT governs whether POE::Kernel will trace sessions&#39; reference counts. As discussed in <a href="#Session_Lifespans" class="podlinkpod"
>&#34;Session Lifespans&#34;</a>, POE does a lot of reference counting, and the current state of a session&#39;s reference counts determines whether the session lives or dies. It&#39;s common for developers to wonder why a session stops too early or remains active too long. TRACE_REFCNT can help explain why.</p>

<p>Prefix: &#60;rc&#62;</p>

<p>Environment variable: POE_TRACE_REFCNT</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="TRACE_RETVALS"
>TRACE_RETVALS</a></h2>

<p>TRACE_RETVALS can enable carping whenever a POE::Kernel method is about to fail. It&#39;s a non-fatal but noisier form of ASSERT_RETVALS.</p>

<p>Prefix: &#60;rv&#62;</p>

<p>Environment variable: POE_TRACE_RETVALS</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="TRACE_SESSIONS"
>TRACE_SESSIONS</a></h2>

<p>TRACE_SESSIONS enables trace messages that pertain to session management. Notice will be given when sessions are created or destroyed, and when the parent or child status of a session changes.</p>

<p>Prefix: &#60;ss&#62;</p>

<p>Environment variable: POE_TRACE_SESSIONS</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="TRACE_SIGNALS"
>TRACE_SIGNALS</a></h2>

<p>TRACE_SIGNALS turns on (or off) traces in POE&#39;s signal handling subsystem. Signal dispatch is one of POE&#39;s more complex parts, and the trace messages may help application developers understand signal propagation and timing.</p>

<p>Prefix: &#60;sg&#62;</p>

<p>Environment variable: POE_TRACE_SIGNALS</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="USE_SIGCHLD"
>USE_SIGCHLD</a></h2>

<p>Whether to use <code>$SIG{CHLD}</code> or to poll at an interval.</p>

<p>This flag is enabled by default on Perl &#62;= 5.8.1 as it has support for &#34;safe signals&#34;. Please see <a href="../perlipc.html" class="podlinkpod"
>perlipc</a> for the gory details.</p>

<p>You might want to disable this if you are running a version of Perl that is known to have bad signal handling, or if anything hijacks <code>$SIG{CHLD}</code>. One module that is known to do this is <a href="../Apache.html" class="podlinkpod"
>Apache</a>.</p>

<p>Enabling this flag will cause child reaping to happen almost immediately, as opposed to once per <a href="#CHILD_POLLING_INTERVAL" class="podlinkpod"
>&#34;CHILD_POLLING_INTERVAL&#34;</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="CHILD_POLLING_INTERVAL"
>CHILD_POLLING_INTERVAL</a></h2>

<p>The interval at which <code>wait</code> is called to determine if child processes need to be reaped and the <code>CHLD</code> signal emulated.</p>

<p>Defaults to 1 second.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="USE_SIGNAL_PIPE"
>USE_SIGNAL_PIPE</a></h2>

<p>The only safe way to handle signals is to implement a shared-nothing model. POE builds a <i>signal pipe</i> that communicates between the signal handlers and the POE kernel loop in a safe and atomic manner. The signal pipe is implemented with <a href="../POE/Pipe/OneWay.html" class="podlinkpod"
>POE::Pipe::OneWay</a>, using a <code>pipe</code> conduit on Unix. Unfortunately, the signal pipe is not compatible with Windows and is not used on that platform.</p>

<p>If you wish to revert to the previous unsafe signal behaviour, you must set <code>USE_SIGNAL_PIPE</code> to 0, or the environment variable <code>POE_USE_SIGNAL_PIPE</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="CATCH_EXCEPTIONS"
>CATCH_EXCEPTIONS</a></h2>

<p>Whether or not POE should run event handler code in an eval { } and deliver the <code>DIE</code> signal on errors.</p>

<p>See <a href="#Exception_Handling" class="podlinkpod"
>&#34;Exception Handling&#34;</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ENVIRONMENT_VARIABLES_FOR_TESTING"
>ENVIRONMENT VARIABLES FOR TESTING</a></h1>

<p>POE&#39;s tests are lovely, dark and deep. These environment variables allow testers to take roads less traveled.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="POE_DANTIC"
>POE_DANTIC</a></h2>

<p>Windows and Perls built for it tend to be poor at doing UNIXy things, although they do try. POE being very UNIXy itself must skip a lot of Windows tests. The POE_DANTIC environment variable will, when true, enable all these tests. It&#39;s intended to be used from time to time to see whether Windows has improved in some area.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>The SEE ALSO section in <a href="../POE.html" class="podlinkpod"
>POE</a> contains a table of contents covering the entire POE distribution.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<ul>
<li>There is no mechanism in place to prevent external reference count names from clashing.</li>

<li>There is no mechanism to catch exceptions generated in another session.</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS_&#38;_COPYRIGHTS"
>AUTHORS &#38; COPYRIGHTS</a></h1>

<p>Please see <a href="../POE.html" class="podlinkpod"
>POE</a> for more information about authors and contributors.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
