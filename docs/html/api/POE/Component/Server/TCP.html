<html><head><title>POE::Component::Server::TCP</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:25 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Accepting_Connections_Yourself'>Accepting Connections Yourself</a>
    <li class='indexItem indexItem2'><a href='#Master_Listener_Session'>Master Listener Session</a>
    <li class='indexItem indexItem2'><a href='#Default_Child_Connection_Sessions'>Default Child Connection Sessions</a>
    <li class='indexItem indexItem2'><a href='#Performance_Considerations'>Performance Considerations</a>
    <li class='indexItem indexItem2'><a href='#Special_Needs_Considerations'>Special Needs Considerations</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#PUBLIC_METHODS'>PUBLIC METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#new'>new</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Server_Session_Configuration'>Server Session Configuration</a>
      <ul   class='indexList indexList4'>
        <li class='indexItem indexItem4'><a href='#Acceptor'>Acceptor</a>
        <li class='indexItem indexItem4'><a href='#Address'>Address</a>
        <li class='indexItem indexItem4'><a href='#Alias'>Alias</a>
        <li class='indexItem indexItem4'><a href='#Concurrency'>Concurrency</a>
        <li class='indexItem indexItem4'><a href='#Domain'>Domain</a>
        <li class='indexItem indexItem4'><a href='#Error'>Error</a>
        <li class='indexItem indexItem4'><a href='#Hostname'>Hostname</a>
        <li class='indexItem indexItem4'><a href='#InlineStates'>InlineStates</a>
        <li class='indexItem indexItem4'><a href='#ObjectStates'>ObjectStates</a>
        <li class='indexItem indexItem4'><a href='#PackageStates'>PackageStates</a>
        <li class='indexItem indexItem4'><a href='#Port'>Port</a>
        <li class='indexItem indexItem4'><a href='#Started'>Started</a>
        <li class='indexItem indexItem4'><a href='#ListenerArgs'>ListenerArgs</a>
      </ul>
      <li class='indexItem indexItem3'><a href='#Connection_Session_Configuration'>Connection Session Configuration</a>
      <ul   class='indexList indexList4'>
        <li class='indexItem indexItem4'><a href='#ClientArgs'>ClientArgs</a>
        <li class='indexItem indexItem4'><a href='#ClientConnected'>ClientConnected</a>
        <li class='indexItem indexItem4'><a href='#ClientDisconnected'>ClientDisconnected</a>
        <li class='indexItem indexItem4'><a href='#ClientError'>ClientError</a>
        <li class='indexItem indexItem4'><a href='#ClientFilter'>ClientFilter</a>
        <li class='indexItem indexItem4'><a href='#ClientFlushed'>ClientFlushed</a>
        <li class='indexItem indexItem4'><a href='#ClientInput'>ClientInput</a>
        <li class='indexItem indexItem4'><a href='#ClientInputFilter'>ClientInputFilter</a>
        <li class='indexItem indexItem4'><a href='#ClientOutputFilter'>ClientOutputFilter</a>
        <li class='indexItem indexItem4'><a href='#ClientShutdownOnError'>ClientShutdownOnError</a>
        <li class='indexItem indexItem4'><a href='#SessionParams'>SessionParams</a>
        <li class='indexItem indexItem4'><a href='#SessionType'>SessionType</a>
      </ul>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#EVENTS'>EVENTS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Main_Server_Commands'>Main Server Commands</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#disconnected'>disconnected</a>
      <li class='indexItem indexItem3'><a href='#set_concurrency'>set_concurrency</a>
      <li class='indexItem indexItem3'><a href='#shutdown'>shutdown</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Per-Connection_Commands'>Per-Connection Commands</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#shutdown'>shutdown</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#Reserved_HEAP_Members'>Reserved HEAP Members</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#HEAP_Members_for_Master_Listening_Sessions'>HEAP Members for Master Listening Sessions</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#alias'>alias</a>
      <li class='indexItem indexItem3'><a href='#concurrency'>concurrency</a>
      <li class='indexItem indexItem3'><a href='#connections'>connections</a>
      <li class='indexItem indexItem3'><a href='#listener'>listener</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#HEAP_Members_for_Connection_Sessions'>HEAP Members for Connection Sessions</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#client'>client</a>
      <li class='indexItem indexItem3'><a href='#got_an_error'>got_an_error</a>
      <li class='indexItem indexItem3'><a href='#remote_ip'>remote_ip</a>
      <li class='indexItem indexItem3'><a href='#remote_port'>remote_port</a>
      <li class='indexItem indexItem3'><a href='#remote_addr'>remote_addr</a>
      <li class='indexItem indexItem3'><a href='#shutdown'>shutdown</a>
      <li class='indexItem indexItem3'><a href='#shutdown_on_error'>shutdown_on_error</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS_%26_COPYRIGHTS'>AUTHORS &#38; COPYRIGHTS</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>POE::Component::Server::TCP - a simplified TCP server</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  #!perl

  use warnings;
  use strict;

  use POE qw(Component::Server::TCP);

  POE::Component::Server::TCP-&#62;new(
    Port =&#62; 12345,
    ClientConnected =&#62; sub {
      print &#34;got a connection from $_[HEAP]{remote_ip}\n&#34;;
      $_[HEAP]{client}-&#62;put(&#34;Smile from the server!&#34;);
    },
    ClientInput =&#62; sub {
      my $client_input = $_[ARG0];
      $client_input =~ tr[a-zA-Z][n-za-mN-ZA-M];
      $_[HEAP]{client}-&#62;put($client_input);
    },
  );

  POE::Kernel-&#62;run;
  exit;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>POE::Component::Server::TCP implements a generic multi-Session server. Simple services may be put together in a few lines of code. For example, a server that echoes input back to the client:</p>

<pre>  use POE qw(Component::Server::TCP);
  POE::Component::Server::TCP-&#62;new(
    Port =&#62; 12345,
    ClientInput =&#62; sub { $_[HEAP]{client}-&#62;put($_[ARG0]) },
  );
  POE::Kernel-&#62;run();</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Accepting_Connections_Yourself"
>Accepting Connections Yourself</a></h2>

<p>POE::Component::Server::TCP has a default mode where it accepts new connections and creates the sessions to handle them. Programs can do this themselves by providing their own <code>Acceptor</code> callbacks. See <a href="#Acceptor" class="podlinkpod"
>&#34;Acceptor&#34;</a> for details.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Master_Listener_Session"
>Master Listener Session</a></h2>

<p>At creation time, POE::Component::Server::TCP starts one POE::Session to listen for new connections. The component&#39;s <code>Alias</code> refers to this master session.</p>

<p>If <code>Acceptor</code> is specified, then it&#39;s up to that callback to deal with newly accepted sockets. Its parameters are that of POE::Wheel::SocketFactory&#39;s <code>SuccessEvent</code>.</p>

<p>Otherwise, the default <code>Acceptor</code> callback will start a new session to handle each connection. These child sessions do not have their own aliases, but their <code>ClientConnected</code> and <code>ClientDisconnected</code> callbacks may be used to register and unregister the sessions with a shared namespace, such as a hash keyed on session IDs, or an object that manages such a hash.</p>

<pre>  my %client_namespace;

  sub handle_client_connected {
    my $client_session_id = $_[SESSION]-&#62;ID;
    $client_namespace{$client_session_id} = \%anything;
  }

  sub handle_client_disconnected {
    my $client_session_id = $_[SESSION]-&#62;ID;
    $client_namespace{$client_session_id} = \%anything;
  }</pre>

<p>The component&#39;s <code>Started</code> callback is invoked at the end of the master session&#39;s start-up routine. The @_[ARG0..$#_] parameters are set to a copy of the values in the server&#39;s <code>ListenerArgs</code> constructor parameter. The other parameters are standard for POE::Session&#39;s _start handlers.</p>

<p>The component&#39;s <code>Error</code> callback is invoked when the server has a problem listening for connections. <code>Error</code> may also be called if the component&#39;s default acceptor has trouble accepting a connection. <code>Error</code> receives the usual ones for <a href="../../../POE/Wheel/SocketFactory.html#FailureEvent" class="podlinkpod"
>&#34;FailureEvent&#34; in POE::Wheel::SocketFactory</a> and <a href="../../../POE/Wheel/ReadWrite.html#ErrorEvent" class="podlinkpod"
>&#34;ErrorEvent&#34; in POE::Wheel::ReadWrite</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Default_Child_Connection_Sessions"
>Default Child Connection Sessions</a></h2>

<p>If <code>Acceptor</code> isn&#39;t specified, POE::Component::Server::TCP&#39;s default handler will start a new session for each new client connection. As mentioned above, these child sessions have no aliases of their own, but they may set aliases or register themselves another way during their <code>ClientConnected</code> and <code>ClientDisconnected</code> callbacks.</p>

<p>It can&#39;t be stressed enough that the following callbacks are executed within the context of dynamic child sessions---one per client connection---and not in the master listening session. This has been a major point of confusion. We welcome suggestions for making this clearer.</p>

<p>The component&#39;s <code>ClientInput</code> callback defines how child sessions will handle input from their clients. Its parameters are that of POE::Wheel::ReadWrite&#39;s <code>InputEvent</code>.</p>

<p>As mentioned <code>ClientConnected</code> is called at the end of the child session&#39;s <code>_start</code> routine. The <code>ClientConneted</code> callback receives the same parameters as the client session&#39;s _start does. The arrayref passed to the constructor&#39;s <code>Args</code> parameter is flattened and included in <code>ClientConnected</code>&#39;s parameters as @_[ARG0..$#_].</p>

<pre>  sub handle_client_connected {
    my @constructor_args = @_[ARG0..$#_];
    ...
  }</pre>

<p><code>ClientPreConnect</code> is called before <code>ClientConnected</code>, and its purpose is to allow programs to reject connections or condition sockets before they&#39;re given to POE::Wheel::ReadWrite for management.</p>

<p>The <code>ClientPreConnect</code> handler is called with the client socket in $_[ARG0], and its return value is significant. It must return a valid client socket if the connection is acceptable. It must return undef to reject the connection.</p>

<p>Most $_[HEAP] values are valid in the <code>ClientPreConnect</code> handler. Obviously, $_[HEAP]{client} is not because that wheel hasn&#39;t been created yet.</p>

<p>In the following example, the <code>ClientPreConnect</code> handler returns the client socket after it has been upgraded to an SSL connection.</p>

<pre>  sub handle_client_pre_connect {

    # Make sure the remote address and port are valid.
    return undef unless validate(
      $_[HEAP]{remote_ip}, $_[HEAP]{remote_port}
    );

    # SSLify the socket, which is in $_[ARG0].
    my $socket = eval { Server_SSLify($_[ARG0]) };
    return undef if $@;

    # Return the SSL-ified socket.
    return $socket;
  }</pre>

<p><code>ClientDisconnected</code> is called when the client has disconnected, either because the remote socket endpoint has closed or the local endpoint has been closed by the server. This doesn&#39;t mean the client&#39;s session has ended, but the session most likely will very shortly. <code>ClientDisconnected</code> is called from a couple disparate places within the component, so its parameters are neither consistent nor generally useful.</p>

<p><code>ClientError</code> is called when an error has occurred on the socket. Its parameters are those of POE::Wheel::ReadWrite&#39;s <code>ErrorEvent</code>.</p>

<p><code>ClientFlushed</code> is called when all pending output has been flushed to the client socket. Its parameters come from POE::Wheel::ReadWrite&#39;s <code>ErrorEvent</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Performance_Considerations"
>Performance Considerations</a></h2>

<p>This ease of use comes at a price: POE::Component::Server::TCP often performs significantly slower than a comparable server written with POE::Wheel::SocketFactory and POE::Wheel::ReadWrite.</p>

<p>If performance is your primary goal, POE::Kernel&#39;s select_read() and select_write() perform about the same as IO::Select, but your code will be portable across every event loop POE supports.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Special_Needs_Considerations"
>Special Needs Considerations</a></h2>

<p>POE::Component::Server::TCP is written to be easy for the most common use cases. Programs with more special needs should consider using POE::Wheel::SocketFactory and POE::Wheel::ReadWrite instead. These are lower-level modules, and using them requires more effort. They are more flexible and customizable, however.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PUBLIC_METHODS"
>PUBLIC METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="new"
>new</a></h2>

<p>new() starts a server based on POE::Component::Server::TCP and returns a session ID for the master listening session. All error handling is done within the server, via the <code>Error</code> and <code>ClientError</code> callbacks.</p>

<p>The server may be shut down by posting a &#34;shutdown&#34; event to the master session, either by its ID or the name given to it by the <code>Alias</code> parameter.</p>

<p>POE::Component::Server::TCP does a lot of work in its constructor. The design goal is to push as much overhead into one-time construction so that ongoing run-time has less overhead. Because of this, the server&#39;s constructor can take quite a daunting number of parameters.</p>

<p>POE::Component::Server::TCP always returns a POE::Session ID for the session that will be listening for new connections.</p>

<p>Many of the constructor parameters have been previously described. They are covered briefly again below.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Server_Session_Configuration"
>Server Session Configuration</a></h3>

<p>These constructor parameters affect POE::Component::Server::TCP&#39;s main listening session.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="Acceptor"
>Acceptor</a></h4>

<p><code>Acceptor</code> defines a CODE reference that POE::Wheel::SocketFactory&#39;s <code>SuccessEvent</code> will trigger to handle new connections. Therefore the parameters passed to <code>Acceptor</code> are identical to those given to <code>SuccessEvent</code>.</p>

<p><code>Acceptor</code> is optional; the default handler will create a new session for each connection. All the &#34;Client&#34; constructor parameters are used to customize this session. In other words, <code>ClientInput</code> and such <b>are not used when <code>Acceptor</code> is set</b>.</p>

<p>The default <code>Acceptor</code> adds significant convenience and flexibility to POE::Component::Server::TCP, but it&#39;s not always a good fit for every application. In some cases, a custom <code>Acceptor</code> or even rolling one&#39;s own server with POE::Wheel::SocketFactory and POE::Wheel::ReadWrite may be better and/or faster.</p>

<pre>  Acceptor =&#62; sub {
    my ($socket, $remote_address, $remote_port) = @_[ARG0..ARG2];
    # Set up something to interact with the client.
  }</pre>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="Address"
>Address</a></h4>

<p><code>Address</code> defines a single interface address the server will bind to. It defaults to INADDR_ANY or INADDR6_ANY, when using IPv4 or IPv6, respectively. It is often used with <code>Port</code>.</p>

<p>The value in <code>Address</code> is passed to POE::Wheel::SocketFactory&#39;s <code>BindAddress</code> parameter, so it may be in whatever form that module supports. At the time of this writing, that may be a dotted IPv4 quad, an IPv6 address, a host name, or a packed Internet address. See also <a href="#Hostname" class="podlinkpod"
>&#34;Hostname&#34;</a>.</p>

<pre>  Address =&#62; &#39;127.0.0.1&#39;   # Localhost IPv4
  Address =&#62; &#34;::1&#34;         # Localhost IPv6</pre>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="Alias"
>Alias</a></h4>

<p><code>Alias</code> is an optional name that will be given to the server&#39;s master listening session. Events sent to this name will not be delivered to individual connections.</p>

<p>The server&#39;s <code>Alias</code> may be important if it&#39;s necessary to shut a server down.</p>

<pre>  sub sigusr1_handler {
    $_[KERNEL]-&#62;post(chargen_server =&#62; &#39;shutdown&#39;);
    $_[KERNEL]-&#62;sig_handled();
  }</pre>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="Concurrency"
>Concurrency</a></h4>

<p><code>Concurrency</code> controls how many connections may be active at the same time. It defaults to -1, which allows POE::Component::Server::TCP to accept concurrent connections until the process runs out of resources.</p>

<p>Setting <code>Concurrency</code> to 0 prevents the server from accepting new connections. This may be useful if a server must perform lengthy initialization before allowing connections. When the initialization finishes, it can yield(set_concurrency =&#62; -1) to enable connections. Likewise, a running server may yield(set_concurrency =&#62; 0) or any other number to dynamically tune its concurrency. See <a href="#EVENTS" class="podlinkpod"
>&#34;EVENTS&#34;</a> for more about the set_concurrency event.</p>

<p>Note: For <code>Concurrency</code> to work with a custom <code>Acceptor</code>, the server&#39;s listening session must receive a <code>disconnected</code> event whenever clients disconnect. Otherwise the listener cannot mediate between its connections.</p>

<p>Example:</p>

<pre>  Acceptor =&#62; sub {
    # ....
    POE::Session-&#62;create(
      # ....
      inline_states =&#62; {
        _start =&#62; sub {
          # ....
          # remember who our parent is
          $_[HEAP]-&#62;{server_tcp} = $_[SENDER]-&#62;ID;
          # ....
        },
        got_client_disconnect =&#62; sub {
          # ....
          $_[KERNEL]-&#62;post( $_[HEAP]-&#62;{server_tcp} =&#62; &#39;disconnected&#39; );
          # ....
        }
      }
    );
  }</pre>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="Domain"
>Domain</a></h4>

<p><code>Domain</code> sets the address or protocol family within which to operate. The <code>Domain</code> may be any value that POE::Wheel::SocketFactory supports. AF_INET (Internet address space) is used by default.</p>

<p>Use AF_INET6 for IPv6 support. This constant is exported by <a href="../../../Socket.html" class="podlinkpod"
>Socket</a> or <a href="../../../Socket6.html" class="podlinkpod"
>Socket6</a>, depending on your version of Perl. Also be sure to have <a href="../../../Socket/GetAddrInfo.html" class="podlinkpod"
>Socket::GetAddrInfo</a> installed, which is required by <a href="../../../POE/Wheel/SocketFactory.html" class="podlinkpod"
>POE::Wheel::SocketFactory</a> for IPv6 support.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="Error"
>Error</a></h4>

<p><code>Error</code> is the callback that will be invoked when the server socket reports an error. The Error callback will be used to handle POE::Wheel::SocketFactory&#39;s FailureEvent, so it will receive the same parameters as discussed there.</p>

<p>A default error handler will be provided if Error is omitted. The default handler will log the error to STDERR and shut down the server. Active connections will be permitted to to complete their transactions.</p>

<pre>  Error =&#62; sub {
    my ($syscall_name, $err_num, $err_str) = @_[ARG0..ARG2];
    # Handle the error.
  }</pre>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="Hostname"
>Hostname</a></h4>

<p><code>Hostname</code> is the optional non-packed name of the interface the TCP server will bind to. The hostname will always be resolved via inet_aton() and so can either be a dotted quad or a name. Name resolution is a one-time start-up action; there are no ongoing run-time penalties for using it.</p>

<p><code>Hostname</code> guarantees name resolution, where <code>Address</code> does not. It&#39;s therefore preferred to use <code>Hostname</code> in cases where resolution must always be done.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="InlineStates"
>InlineStates</a></h4>

<p><code>InlineStates</code> is optional. If specified, it must hold a hashref of named callbacks. Its syntax is that of POE:Session-&#62;create()&#39;s inline_states parameter.</p>

<p>Remember: These InlineStates handlers will be added to the client sessions, not to the main listening session. A yield() in the listener will not reach these handlers.</p>

<p>If POE::Kernel::ASSERT_USAGE is enabled, the constructor will croak() if it detects a state that it uses internally. For example, please use the &#34;Started&#34; callback if you want to specify your own &#34;_start&#34; event.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="ObjectStates"
>ObjectStates</a></h4>

<p>If <code>ObjectStates</code> is specified, it must holde an arrayref of objects and the events they will handle. The arrayref must follow the syntax for POE::Session-&#62;create()&#39;s object_states parameter.</p>

<p>Remember: These ObjectStates handlers will be added to the client sessions, not to the main listening session. A yield() in the listener will not reach these handlers.</p>

<p>If POE::Kernel::ASSERT_USAGE is enabled, the constructor will croak() if it detects a state that it uses internally. For example, please use the &#34;Started&#34; callback if you want to specify your own &#34;_start&#34; event.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="PackageStates"
>PackageStates</a></h4>

<p>When the optional <code>PackageStates</code> is set, it must hold an arrayref of package names and the events they will handle The arrayref must follow the syntax for POE::Session-&#62;create()&#39;s package_states parameter.</p>

<p>Remember: These PackageStates handlers will be added to the client sessions, not to the main listening session. A yield() in the listener will not reach these handlers.</p>

<p>If POE::Kernel::ASSERT_USAGE is enabled, the constructor will croak() if it detects a state that it uses internally. For example, please use the &#34;Started&#34; callback if you want to specify your own &#34;_start&#34; event.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="Port"
>Port</a></h4>

<p><code>Port</code> contains the port the listening socket will be bound to. It defaults to 0, which usually lets the operating system pick a port at random.</p>

<pre>  Port =&#62; 30023</pre>

<p>It is often used with <code>Address</code>.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="Started"
>Started</a></h4>

<p><code>Started</code> sets an optional callback that will be invoked within the main server session&#39;s context. It notifies the server that it has fully started. The callback&#39;s parameters are the usual for a session&#39;s _start handler.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="ListenerArgs"
>ListenerArgs</a></h4>

<p><code>ListenerArgs</code> is passed to the listener session as the <code>args</code> parameter. In other words, it must be an arrayref, and the values are are passed into the <code>Started</code> handler as ARG0, ARG1, etc.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Connection_Session_Configuration"
>Connection Session Configuration</a></h3>

<p>These constructor parameters affect the individual sessions that interact with established connections.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="ClientArgs"
>ClientArgs</a></h4>

<p><code>ClientArgs</code> is optional. When specified, it holds an ARRAYREF that will be expanded one level and passed to the <code>ClientConnected</code> callback in @_[ARG0..$#_].</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="ClientConnected"
>ClientConnected</a></h4>

<p>Each new client connection is handled by a new POE::Session instance. <code>ClientConnected</code> is a callback that notifies the application when a client&#39;s session is started and ready for operation. Banners are often sent to the remote client from this callback.</p>

<p>The @_[ARG0..$#_] parameters to <code>ClientConnected</code> are a copy of the values in the <code>ClientArgs</code> constructor parameter&#39;s array reference. The other @_ members are standard for a POE::Session _start handler.</p>

<p><code>ClientConnected</code> is called once per session start-up. It will never be called twice for the same connection.</p>

<pre>  ClientConnected =&#62; sub {
    $_[HEAP]{client}-&#62;put(&#34;Hello, client!&#34;);
    # Other client initialization here.
  },</pre>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="ClientDisconnected"
>ClientDisconnected</a></h4>

<p><code>ClientDisconnected</code> is a callback that will be invoked when the client disconnects or has been disconnected by the server. It&#39;s useful for cleaning up global client information, such as chat room structures. <code>ClientDisconnected</code> callbacks receive the usual POE parameters, but nothing special is included.</p>

<pre>  ClientDisconnected =&#62; sub {
    warn &#34;Client disconnected&#34;; # log it
  }</pre>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="ClientError"
>ClientError</a></h4>

<p>The <code>ClientError</code> callback is invoked when a client socket reports an error. <code>ClientError</code> is called with POE&#39;s usual parameters, plus the common error parameters: $_[ARG0] describes what was happening at the time of failure. $_[ARG1] and $_[ARG2] contain the numeric and string versions of $!, respectively.</p>

<p><code>ClientError</code> is optional. If omitted, POE::Component::Server::TCP will provide a default callback that logs most errors to STDERR.</p>

<p>If <code>ClientShutdownOnError</code> is set, the connection will be shut down after <code>ClientError</code> returns. If <code>ClientDisconnected</code> is specified, it will be called as the client session is cleaned up.</p>

<p><code>ClientError</code> is triggered by POE::Wheel::ReadWrite&#39;s ErrorEvent, so it follows that event&#39;s form. Please see the ErrorEvent documentation in POE::Wheel::ReadWrite for more details.</p>

<pre>  ClientError =&#62; sub {
    my ($syscall_name, $error_num, $error_str) = @_[ARG0..ARG2];
    # Handle the client error here.
  }</pre>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="ClientFilter"
>ClientFilter</a></h4>

<p><code>ClientFilter</code> specifies the POE::Filter object or class that will parse input from each client and serialize output before it&#39;s sent to each client.</p>

<p><code>ClientFilter</code> may be a SCALAR, in which case it should name the POE::Filter class to use. Each new connection will be given a freshly instantiated filter of that class. No constructor parameters will be passed.</p>

<pre>  ClientFilter =&#62; &#34;POE::Filter::Stream&#34;,</pre>

<p>Some filters require constructor parameters. These may be specified by an ARRAYREF. The first element is the POE::Filter class name, and subsequent elements are passed to the class&#39; constructor.</p>

<pre>  ClientFilter =&#62; [ &#34;POE::Filter::Line&#34;, Literal =&#62; &#34;\n&#34; ],</pre>

<p><code>ClientFilter</code> may also be given an archetypical POE::Filter OBJECT. In this case, each new client session will receive a clone() of the given object.</p>

<pre>  ClientFilter =&#62; POE::Filter::Line-&#62;new(Literal =&#62; &#34;\n&#34;),</pre>

<p><code>ClientFilter</code> is optional. The component will use &#34;POE::Filter::Line&#34; if it is omitted. There is <a href="#ClientInputFilter" class="podlinkpod"
>&#34;ClientInputFilter&#34;</a> and <a href="#ClientOutputFilter" class="podlinkpod"
>&#34;ClientOutputFilter&#34;</a> if you want to specify a different filter for both directions.</p>

<p>Filter modules are not automatically loaded. Be sure that the program loads the class before using it.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="ClientFlushed"
>ClientFlushed</a></h4>

<p><code>ClientFlushed</code> exposes POE::Wheel::ReadWrite&#39;s <code>FlushedEvent</code> as a callback. It is called whenever the client&#39;s output buffer has been fully flushed to the client socket. At this point it&#39;s safe to shut down the socket without losing data.</p>

<p><code>ClientFlushed</code> is useful for streaming servers, where a &#34;flushed&#34; event signals the need to send more data.</p>

<pre>  ClientFlushed =&#62; sub {
    my $data_source = $_[HEAP]{file_handle};
    my $read_count = sysread($data_source, my $buffer = &#34;&#34;, 65536);
    if ($read_count) {
      $_[HEAP]{client}-&#62;put($buffer);
    }
    else {
      $_[KERNEL]-&#62;yield(&#34;shutdown&#34;);
    }
  },</pre>

<p>POE::Component::Server::TCP&#39;s default <code>Acceptor</code> ensures that data is flushed before finishing a client shutdown.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="ClientInput"
>ClientInput</a></h4>

<p><code>ClientInput</code> defines a per-connection callback to handle client input. This callback receives its parameters directly from POE::Wheel::ReadWrite&#39;s <code>InputEvent</code>. ARG0 contains the input record, the format of which is defined by <code>ClientFilter</code> or <code>ClientInputFilter</code>. ARG1 has the wheel&#39;s unique ID, and so on. Please see POE:Wheel::ReadWrite for an in-depth description of <code>InputEvent</code>.</p>

<p><code>ClientInput</code> and <code>Acceptor</code> are mutually exclusive. Enabling one prohibits the other.</p>

<pre>  ClientInput =&#62; sub {
    my $input = $_[ARG0];
    $_[HEAP]{wheel}-&#62;put(&#34;You said: $input&#34;);
  },</pre>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="ClientInputFilter"
>ClientInputFilter</a></h4>

<p><code>ClientInputFilter</code> is used with <code>ClientOutputFilter</code> to specify different protocols for input and output. Both must be used together. Both follow the same usage as <a href="#ClientFilter" class="podlinkpod"
>&#34;ClientFilter&#34;</a>. Overrides the filter set by <a href="#ClientFilter" class="podlinkpod"
>&#34;ClientFilter&#34;</a>.</p>

<pre>  ClientInputFilter  =&#62; [ &#34;POE::Filter::Line&#34;, Literal =&#62; &#34;\n&#34; ],
  ClientOutputFilter =&#62; &#39;POE::Filter::Stream&#39;,</pre>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="ClientOutputFilter"
>ClientOutputFilter</a></h4>

<p><code>ClientOutputFilter</code> is used with <code>ClientInputFilter</code> to specify different protocols for input and output. Both must be used together. Both follow the same usage as <a href="#ClientFilter" class="podlinkpod"
>&#34;ClientFilter&#34;</a>. Overrides the filter set by <a href="#ClientFilter" class="podlinkpod"
>&#34;ClientFilter&#34;</a>.</p>

<pre>  ClientInputFilter  =&#62; POE::Filter::Line-&#62;new(Literal =&#62; &#34;\n&#34;),
  ClientOutputFilter =&#62; &#39;POE::Filter::Stream&#39;,</pre>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="ClientShutdownOnError"
>ClientShutdownOnError</a></h4>

<p><code>ClientShutdownOnError</code> tells the component whether client connections should be shut down automatically if an error is detected. It defaults to &#34;true&#34;. Setting it to false (0, undef, &#34;&#34;) turns off this feature.</p>

<p>The application is responsible for dealing with client errors if this feature is disabled. Not doing so may cause the component to emit a constant stream of errors, eventually bogging down the application with dead connections that spin out of control.</p>

<p>Yes, this is terrible. You have been warned.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="SessionParams"
>SessionParams</a></h4>

<p><code>SessionParams</code> specifies additional parameters that will be passed to the <code>SessionType</code> constructor at creation time. It must be an array reference.</p>

<pre>  SessionParams =&#62; [ options =&#62; { debug =&#62; 1, trace =&#62; 1 } ],</pre>

<p>Note: POE::Component::Server::TCP supplies its own POE::Session constructor parameters. Conflicts between them and <code>SessionParams</code> may cause the component to behave erratically. To avoid such problems, please limit SessionParams to the <code>options</code> hash. See <a href="../../../POE/Session.html" class="podlinkpod"
>POE::Session</a> for an known options.</p>

<p>We may enable other options later. Please let us know if you need something.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="SessionType"
>SessionType</a></h4>

<p><code>SessionType</code> specifies the POE::Session subclass that will be created for each new client connection. &#34;POE::Session&#34; is the default.</p>

<pre>  SessionType =&#62; &#34;POE::Session::MultiDispatch&#34;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EVENTS"
>EVENTS</a></h1>

<p>It&#39;s possible to manipulate a TCP server component by sending it messages.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Main_Server_Commands"
>Main Server Commands</a></h2>

<p>These events must be sent to the main server, usually by the alias set in its <a href="../../../Alias.html" class="podlinkpod"
>Alias</a> parameter.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="disconnected"
>disconnected</a></h3>

<p>The &#34;disconnected&#34; event informs the TCP server that a connection was closed. It is needed when using <a href="#Concurrency" class="podlinkpod"
>&#34;Concurrency&#34;</a> with an <a href="#Acceptor" class="podlinkpod"
>&#34;Acceptor&#34;</a> callback. The custom Acceptor must provide its own disconnect notification so that the server&#39;s connection counting logic works.</p>

<p>Otherwise Concurrency clients will be accepted, and then no more. The server will never know when clients have disconnected.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="set_concurrency"
>set_concurrency</a></h3>

<p>&#34;set_concurrency&#34; set the number of simultaneous connections the server will be willing to accept. See <a href="#Concurrency" class="podlinkpod"
>&#34;Concurrency&#34;</a> for more details. &#34;set_concurrency&#34; must have one parameter: the new maximum connection count.</p>

<pre>  $kernel-&#62;call(&#34;my_server_alias&#34;, &#34;set_concurrency&#34;, $max_count);</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="shutdown"
>shutdown</a></h3>

<p>The &#34;shutdown&#34; event starts a graceful server shutdown. No new connections will be accepted. Existing connections will be allowed to finish. The server will be destroyed after the last connection ends.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Per-Connection_Commands"
>Per-Connection Commands</a></h2>

<p>These commands affect each client connection session.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="shutdown"
>shutdown</a></h3>

<p>Sending &#34;shutdown&#34; to an individual client session instructs the server to gracefully shut down that connection. No new input will be received, and any buffered output will be sent before the session ends.</p>

<p>Client sessions usually yield(&#34;shutdown&#34;) when they wish to disconnect the client.</p>

<pre>  ClientInput =&#62; sub {
    if ($_[ARG0] eq &#34;quit&#34;) {
      $_[HEAP]{client}-&#62;put(&#34;B&#39;bye!&#34;);
      $_[KERNEL]-&#62;yield(&#34;shutdown&#34;);
      return;
    }

    # Handle other input here.
  },</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Reserved_HEAP_Members"
>Reserved HEAP Members</a></h1>

<p>Unlike most POE modules, POE::Component::Server::TCP stores data in the client sessions&#39; HEAPs. These values are provided as conveniences for application developers.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="HEAP_Members_for_Master_Listening_Sessions"
>HEAP Members for Master Listening Sessions</a></h2>

<p>The master listening session holds different data than client connections.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="alias"
>alias</a></h3>

<p>$_[HEAP]{alias} contains the server&#39;s Alias.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="concurrency"
>concurrency</a></h3>

<p>$_[HEAP]{concurrency} remembers the server&#39;s <code>Concurrency</code> parameter.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="connections"
>connections</a></h3>

<p>$_[HEAP]{connections} is used to track the current number of concurrent client connections. It&#39;s incremented whenever a new connection is accepted, and it&#39;s decremented whenever a client disconnects.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="listener"
>listener</a></h3>

<p>$_[HEAP]{listener} contains the POE::Wheel::SocketFactory object used to listen for connections and accept them.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="HEAP_Members_for_Connection_Sessions"
>HEAP Members for Connection Sessions</a></h2>

<p>These data members exist within the individual connections&#39; sessions.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="client"
>client</a></h3>

<p>$_[HEAP]{client} contains a POE::Wheel::ReadWrite object used to interact with the client. All POE::Wheel::ReadWrite methods work.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="got_an_error"
>got_an_error</a></h3>

<p>$_[HEAP]{got_an_error} remembers whether the client connection has already encountered an error. It is part of the shutdown-on-error procedure.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="remote_ip"
>remote_ip</a></h3>

<p>$_[HEAP]{remote_ip} contains the remote client&#39;s numeric address in human-readable form.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="remote_port"
>remote_port</a></h3>

<p>$_[HEAP]{remote_port} contains the remote client&#39;s numeric socket port in human-readable form.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="remote_addr"
>remote_addr</a></h3>

<p>$_[HEAP]{remote_addr} contains the remote client&#39;s packed socket address in computer-readable form.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="shutdown"
>shutdown</a></h3>

<p>$_[HEAP]{shutdown} is true if the client is in the process of shutting down. The component uses it to ignore client input during shutdown, and to close the connection after pending output has been flushed.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="shutdown_on_error"
>shutdown_on_error</a></h3>

<p>$_[HEAP]{shutdown_on_error} remembers whether the client connection should automatically shut down if an error occurs.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>The SEE ALSO section in <a href="../../../POE.html" class="podlinkpod"
>POE</a> contains a table of contents covering the entire POE distribution.</p>

<p><a href="../../../POE/Component/Client/TCP.html" class="podlinkpod"
>POE::Component::Client::TCP</a> is the client-side counterpart to this module.</p>

<p>This component uses and exposes features from <a href="../../../POE/Filter.html" class="podlinkpod"
>POE::Filter</a>, <a href="../../../POE/Wheel/SocketFactory.html" class="podlinkpod"
>POE::Wheel::SocketFactory</a>, and <a href="../../../POE/Wheel/ReadWrite.html" class="podlinkpod"
>POE::Wheel::ReadWrite</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>This looks nothing like what Ann envisioned.</p>

<p>This component currently does not accept many of the options that POE::Wheel::SocketFactory does.</p>

<p>This component will not bind to several addresses at once. This may be a limitation in SocketFactory, but it&#39;s not by design.</p>

<p>This component needs better error handling.</p>

<p>Some use cases require different session classes for the listener and the connection handlers. This isn&#39;t currently supported. Please send patches. :)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS_&#38;_COPYRIGHTS"
>AUTHORS &#38; COPYRIGHTS</a></h1>

<p>POE::Component::Server::TCP is Copyright 2000-2013 by Rocco Caputo. All rights are reserved. POE::Component::Server::TCP is free software, and it may be redistributed and/or modified under the same terms as Perl itself.</p>

<p>POE::Component::Server::TCP is based on code, used with permission, from Ann Barcomb &#60;kudra@domaintje.com&#62;.</p>

<p>POE::Component::Server::TCP is based on code, used with permission, from Jos Boumans &#60;kane@cpan.org&#62;.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
