<html><head><title>POE::Wheel::ReadLine</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:26 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#PUBLIC_METHODS'>PUBLIC METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Constructor'>Constructor</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#new'>new</a>
      <ul   class='indexList indexList4'>
        <li class='indexItem indexItem4'><a href='#InputEvent'>InputEvent</a>
        <li class='indexItem indexItem4'><a href='#PutMode'>PutMode</a>
        <li class='indexItem indexItem4'><a href='#IdleTime'>IdleTime</a>
        <li class='indexItem indexItem4'><a href='#AppName'>AppName</a>
      </ul>
    </ul>
    <li class='indexItem indexItem2'><a href='#History_List_Management'>History List Management</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#add_history'>add_history</a>
      <li class='indexItem indexItem3'><a href='#get_history'>get_history</a>
      <li class='indexItem indexItem3'><a href='#write_history'>write_history</a>
      <li class='indexItem indexItem3'><a href='#read_history'>read_history</a>
      <li class='indexItem indexItem3'><a href='#history_truncate_file'>history_truncate_file</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Key_Binding_Methods'>Key Binding Methods</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#bind_key'>bind_key</a>
      <li class='indexItem indexItem3'><a href='#add_defun_NAME_FN'>add_defun NAME FN</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Console_I%2FO_Methods'>Console I/O Methods</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#clear'>clear</a>
      <li class='indexItem indexItem3'><a href='#terminal_size'>terminal_size</a>
      <li class='indexItem indexItem3'><a href='#get'>get</a>
      <li class='indexItem indexItem3'><a href='#put'>put</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#ReadLine_Option_Methods'>ReadLine Option Methods</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#attribs'>attribs</a>
      <li class='indexItem indexItem3'><a href='#option'>option</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#PUBLIC_EVENTS'>PUBLIC EVENTS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#InputEvent'>InputEvent</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#CUSTOM_BINDINGS'>CUSTOM BINDINGS</a>
  <li class='indexItem indexItem1'><a href='#CUSTOM_COMPLETION'>CUSTOM COMPLETION</a>
  <li class='indexItem indexItem1'><a href='#IMPLEMENTATION_DIFFERENCES'>IMPLEMENTATION DIFFERENCES</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Perl_5.8.0_is_Broken'>Perl 5.8.0 is Broken</a>
    <li class='indexItem indexItem2'><a href='#Non-Optimal_Code'>Non-Optimal Code</a>
    <li class='indexItem indexItem2'><a href='#Unimplemented_Features'>Unimplemented Features</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#GOTCHAS_%2F_FAQ'>GOTCHAS / FAQ</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Lost_Prompts'>Lost Prompts</a>
    <li class='indexItem indexItem2'><a href='#Edit_Keystrokes_Display_as_%5EC'>Edit Keystrokes Display as ^C</a>
    <li class='indexItem indexItem2'><a href='#Lack_of_Windows_Support'>Lack of Windows Support</a>
    <li class='indexItem indexItem2'><a href='#Cygwin_Support'>Cygwin Support</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#AUTHORS_%26_COPYRIGHTS'>AUTHORS &#38; COPYRIGHTS</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>POE::Wheel::ReadLine - non-blocking Term::ReadLine for POE</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  #!perl

  use warnings;
  use strict;

  use POE qw(Wheel::ReadLine);

  POE::Session-&#62;create(
    inline_states=&#62; {
      _start =&#62; \&#38;setup_console,
      got_user_input =&#62; \&#38;handle_user_input,
    }
  );

  POE::Kernel-&#62;run();
  exit;

  sub handle_user_input {
    my ($input, $exception) = @_[ARG0, ARG1];
    my $console = $_[HEAP]{console};

    unless (defined $input) {
      $console-&#62;put(&#34;$exception caught.  B&#39;bye!&#34;);
      $_[KERNEL]-&#62;signal($_[KERNEL], &#34;UIDESTROY&#34;);
      $console-&#62;write_history(&#34;./test_history&#34;);
      return;
    }

    $console-&#62;put(&#34;  You entered: $input&#34;);
    $console-&#62;addhistory($input);
    $console-&#62;get(&#34;Go: &#34;);
  }

  sub setup_console {
    $_[HEAP]{console} = POE::Wheel::ReadLine-&#62;new(
      InputEvent =&#62; &#39;got_user_input&#39;
    );
    $_[HEAP]{console}-&#62;read_history(&#34;./test_history&#34;);
    $_[HEAP]{console}-&#62;clear();
    $_[HEAP]{console}-&#62;put(
      &#34;Enter some text.&#34;,
      &#34;Ctrl+C or Ctrl+D exits.&#34;
    );
    $_[HEAP]{console}-&#62;get(&#34;Go: &#34;);
  }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>POE::Wheel::ReadLine is a non-blocking form of Term::ReadLine that&#39;s compatible with POE. It uses Term::Cap to interact with the terminal display and Term::ReadKey to interact with the keyboard.</p>

<p>POE::Wheel::ReadLine handles almost all common input editing keys. It provides an input history list. It has both vi and emacs modes. It supports incremental input search. It&#39;s fully customizable, and it&#39;s compatible with standard readline(3) implementations such as Term::ReadLine::Gnu.</p>

<p>POE::Wheel::ReadLine is configured by placing commands in an &#34;inputrc&#34; initialization file. The file&#39;s name is taken from the <code>INPUTRC</code> environment variable, or ~/.inputrc by default. POE::Wheel::ReadLine will read the inputrc file and configure itself according to the commands and variables therein. See readline(3) for details about inputrc files.</p>

<p>The default editing mode will be emacs-style, although this can be configured by setting the &#39;editing-mode&#39; variable within an inputrc file. If all else fails, POE::Wheel::ReadLine will determine the user&#39;s favorite editor by examining the EDITOR environment variable.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PUBLIC_METHODS"
>PUBLIC METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Constructor"
>Constructor</a></h2>

<p>Most of POE::Wheel::ReadLine&#39;s interaction is through its constructor, new().</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="new"
>new</a></h3>

<p>new() creates and returns a new POE::Wheel::ReadLine object. Be sure to instantiate only one, as multiple console readers would conflict.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="InputEvent"
>InputEvent</a></h4>

<p><code>InputEvent</code> names the event that will indicate a new line of console input. See <a href="#PUBLIC_EVENTS" class="podlinkpod"
>&#34;PUBLIC EVENTS&#34;</a> for more details.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="PutMode"
>PutMode</a></h4>

<p><code>PutMode</code> controls how output is displayed when put() is called during user input.</p>

<p>When set to &#34;immediate&#34;, put() pre-empts the user immediately. The input prompt and user&#39;s input to date are redisplayed after put() is done.</p>

<p>The &#34;after&#34; <code>PutMode</code> tells put() to wait until after the user enters or cancels her input.</p>

<p>Finally, &#34;idle&#34; will allow put() to pre-empt user input if the user stops typing for <a href="#IdleTime" class="podlinkpod"
>&#34;IdleTime&#34;</a> seconds. This mode behaves like &#34;after&#34; if the user can&#39;t stop typing long enough. This is POE::Wheel::ReadLine&#39;s default mode.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="IdleTime"
>IdleTime</a></h4>

<p><code>IdleTime</code> tells POE::Wheel::ReadLine how long the keyboard must be idle before <code>put()</code> becomes immediate or buffered text is flushed to the display. It is only meaningful when <a href="#PutMode" class="podlinkpod"
>&#34;PutMode&#34;</a> is &#34;idle&#34;. <code>IdleTime</code> defaults to 2 seconds.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="AppName"
>AppName</a></h4>

<p><code>AppName</code> registers an application name which is used to retrieve application-specific key bindings from the inputrc file. The default <code>AppName</code> is &#34;poe-readline&#34;.</p>

<pre>  # If using POE::Wheel::ReadLine, set
  # the key mapping to emacs mode and
  # trigger debugging output on a certain
  # key sequence.
  $if poe-readline
  set keymap emacs
  Control-xP: poe-wheel-debug
  $endif</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="History_List_Management"
>History List Management</a></h2>

<p>POE::Wheel::ReadLine supports an input history, with searching.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="add_history"
>add_history</a></h3>

<p>add_history() accepts a list of lines to add to the input history. Generally it&#39;s called with a single line: the last line of input received from the terminal. The <a href="#SYNOPSIS" class="podlinkpod"
>&#34;SYNOPSIS&#34;</a> shows add_history() in action.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="get_history"
>get_history</a></h3>

<p>get_history() returns a list containing POE::Wheel::ReadLine&#39;s current input history. It may not contain everything entered into the wheel</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="write_history"
>write_history</a></h3>

<p>write_history() writes the current input history to a file. It accepts one optional parameter: the name of the file where the input history will be written. write_history() will write to ~/.history if no file name is specified.</p>

<p>Returns true on success, or false if not.</p>

<p>The <a href="#SYNOPSIS" class="podlinkpod"
>&#34;SYNOPSIS&#34;</a> shows an example of write_history() and the corresponding read_history().</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="read_history"
>read_history</a></h3>

<p>read_history(FILENAME, START, END) reads a previously saved input history from a named file, or from ~/.history if no file name is specified. It may also read a subset of the history file if it&#39;s given optional START and END parameters. The file will be read from the beginning if START is omitted or zero. It will be read to the end if END is omitted or earlier than START.</p>

<p>Returns true on success, or false if not.</p>

<p>The <a href="#SYNOPSIS" class="podlinkpod"
>&#34;SYNOPSIS&#34;</a> shows an example of read_history() and the corresponding write_history().</p>

<p>Read the first ten history lines:</p>

<pre>  $_[HEAP]{console}-&#62;read_history(&#34;filename&#34;, 0, 9);</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="history_truncate_file"
>history_truncate_file</a></h3>

<p>history_truncate_file() truncates a history file to a certain number of lines. It accepts two parameters: the name of the file to truncate, and the maximum number of history lines to leave in the file. The history file will be cleared entirely if the line count is zero or omitted.</p>

<p>The file to be truncated defaults to ~/.history. So calling history_truncate_file() with no parameters clears ~/.history.</p>

<p>Returns true on success, or false if not.</p>

<p>Note that history_trucate_file() removes the earliest lines from the file. The later lines remain intact since they were the ones most recently entered.</p>

<p>Keep ~/.history down to a manageable 100 lines:</p>

<pre>  $_[HEAP]{console}-&#62;history_truncate_file(undef, 100);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Key_Binding_Methods"
>Key Binding Methods</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="bind_key"
>bind_key</a></h3>

<p>bind_key(KEYSTROKE, FUNCTION) binds a FUNCTION to a named KEYSTROKE sequence. The keystroke sequence can be in any of the forms defined within readline(3). The function should either be a pre-defined name, such as &#34;self-insert&#34; or a function reference. The binding is made in the current keymap. Use the rl_set_keymap() method to change keymaps, if desired.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="add_defun_NAME_FN"
>add_defun NAME FN</a></h3>

<p>add_defun(NAME, FUNCTION) defines a new global FUNCTION, giving it a specific NAME. The function may then be bound to keystrokes by that NAME.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Console_I/O_Methods"
>Console I/O Methods</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="clear"
>clear</a></h3>

<p>Clears the terminal.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="terminal_size"
>terminal_size</a></h3>

<p>Returns what POE::Wheel::ReadLine thinks are the current dimensions of the terminal. Returns a list of two values: the number of columns and number of rows, respectively.</p>

<pre>  sub some_event_handler {
    my ($columns, $rows) = $_[HEAP]{console}-&#62;terminal_size;
    $_[HEAP]{console}-&#62;put(
      &#34;Terminal columns: $columns&#34;,
      &#34;Terminal rows: $rows&#34;,
    );
  }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="get"
>get</a></h3>

<p>get() causes POE::Wheel::ReadLine to display a prompt and then wait for input. Input is not noticed unless get() has enabled the wheel&#39;s internal I/O watcher.</p>

<p>After get() is called, the next line of input or exception on the console will trigger an <code>InputEvent</code> with the appropriate parameters. POE::Wheel::ReadLine will then enter an inactive state until get() is called again.</p>

<p>Calls to get() without an argument will preserve the current prompt. Calling get() with an argument before a whole line of input is received will change the prompt on the fly.</p>

<p>See the <a href="#SYNOPSIS" class="podlinkpod"
>&#34;SYNOPSIS&#34;</a> for sample usage.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="put"
>put</a></h3>

<p>put() accepts a list of lines to put on the terminal. POE::Wheel::ReadLine is line-based. See <a href="../../POE/Wheel/Curses.html" class="podlinkpod"
>POE::Wheel::Curses</a> for more funky display options.</p>

<p>Please do not use print() with POE::Wheel::ReadLine. print() invariably gets the newline wrong, leaving an application&#39;s output to stairstep down the terminal. Also, put() understands when a user is entering text, and <code>PutMode</code> may be used to avoid interrupting the user.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ReadLine_Option_Methods"
>ReadLine Option Methods</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="attribs"
>attribs</a></h3>

<p>attribs() returns a reference to a hash of readline options. The returned hash may be used to query or modify POE::Wheel::ReadLine&#39;s behavior.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="option"
>option</a></h3>

<p>option(NAME) returns a specific member of the hash returned by attribs(). It&#39;s a more convenient way to query POE::Wheel::ReadLine options.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PUBLIC_EVENTS"
>PUBLIC EVENTS</a></h1>

<p>POE::Wheel::ReadLine emits only a single event.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="InputEvent"
>InputEvent</a></h2>

<p><code>InputEvent</code> names the event that will be emitted upon any kind of complete terminal input. Every <code>InputEvent</code> handler receives three parameters:</p>

<p><code>$_[ARG0]</code> contains a line of input. It may be an empty string if the user entered an empty line. An undefined <code>$_[ARG0]</code> indicates some exception such as end-of-input or the fact that the user canceled their input or pressed C-c (^C).</p>

<p><code>$_[ARG1]</code> describes an exception, if one occurred. It may contain one of the following strings:</p>

<dl>
<dt><a name="cancel"
>cancel</a></dt>

<dd>
<p>The &#34;cancel&#34; exception indicates when a user has canceled a line of input. It&#39;s sent when the user triggers the &#34;abort&#34; function, which is bound to C-g (^G) by default.</p>

<dt><a name="eot"
>eot</a></dt>

<dd>
<p>&#34;eot&#34; is the ASCII code for &#34;end of tape&#34;. It&#39;s emitted when the user requests that the terminal be closed. By default, it&#39;s triggered when the user presses C-d (^D) on an empty line.</p>

<dt><a name="interrupt"
>interrupt</a></dt>

<dd>
<p>&#34;interrupt&#34; is sent as a result of the user pressing C-c (^C) or otherwise triggering the &#34;interrupt&#34; function.</p>
</dd>
</dl>

<p>Finally, <code>$_[ARG2]</code> contains the ID for the POE::Wheel::ReadLine object that sent the <code>InputEvent</code>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CUSTOM_BINDINGS"
>CUSTOM BINDINGS</a></h1>

<p>POE::Wheel::ReadLine allows custom functions to be bound to keystrokes. The function must be made visible to the wheel before it can be bound. To register a function, use POE::Wheel::ReadLine&#39;s add_defun() method:</p>

<pre>  POE::Wheel::ReadLine-&#62;add_defun(&#39;reverse-line&#39;, \&#38;reverse_line);</pre>

<p>When adding a new defun, an optional third parameter may be provided which is a key sequence to bind to. This should be in the same format as that understood by the inputrc parsing.</p>

<p>Bound functions receive three parameters: A reference to the wheel object itself, the key sequence that triggered the function (in printable form), and the raw key sequence. The bound function is expected to dig into the POE::Wheel::ReadLine data members to do its work and display the new line contents itself.</p>

<p>This is less than ideal, and it may change in the future.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CUSTOM_COMPLETION"
>CUSTOM COMPLETION</a></h1>

<p>An application may modify POE::Wheel::ReadLine&#39;s &#34;completion_function&#34; in order to customize how input should be completed. The new completion function must accept three scalar parameters: the word being completed, the entire input text, and the position within the input text of the word being completed.</p>

<p>The completion function should return a list of possible matches. For example:</p>

<pre>  my $attribs = $wheel-&#62;attribs();
  $attribs-&#62;{completion_function} = sub {
    my ($text, $line, $start) = @_;
    return qw(a list of candidates to complete);
  }</pre>

<p>This is the only form of completion currently supported.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="IMPLEMENTATION_DIFFERENCES"
>IMPLEMENTATION DIFFERENCES</a></h1>

<p>Although POE::Wheel::ReadLine is modeled after the readline(3) library, there are some areas which have not been implemented. The only option settings which have effect in this implementation are: bell-style, editing-mode, isearch-terminators, comment-begin, print-completions-horizontally, show-all-if-ambiguous and completion_function.</p>

<p>The function &#39;tab-insert&#39; is not implemented, nor are tabs displayed properly.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../../POE/Wheel.html" class="podlinkpod"
>POE::Wheel</a> describes the basic operations of all wheels in more depth. You need to know this.</p>

<p>readline(3), <a href="../../Term/Cap.html" class="podlinkpod"
>Term::Cap</a>, <a href="../../Term/ReadKey.html" class="podlinkpod"
>Term::ReadKey</a>.</p>

<p>The SEE ALSO section in <a href="../../POE.html" class="podlinkpod"
>POE</a> contains a table of contents covering the entire POE distribution.</p>

<p><a href="../../Term/Visual.html" class="podlinkpod"
>Term::Visual</a> is an alternative to POE::Wheel::ReadLine. It provides scrollback and a status bar in addition to editable user input. Term::Visual supports POE despite the lack of &#34;POE&#34; in its name.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>POE::Wheel::ReadLine has some known issues:</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Perl_5.8.0_is_Broken"
>Perl 5.8.0 is Broken</a></h2>

<p>Non-blocking input with Term::ReadKey does not work with Perl 5.8.0, especially on Linux systems for some reason. Upgrading Perl will fix things. If you can&#39;t upgrade Perl, consider alternative input methods, such as Term::Visual.</p>

<p><a href="http://rt.cpan.org/Ticket/Display.html?id=4524" class="podlinkurl"
>http://rt.cpan.org/Ticket/Display.html?id=4524</a> and related tickets explain the issue in detail. If you suspect your system is one where Term::ReadKey fails, you can run this test program to be sure.</p>

<pre>  #!/usr/bin/perl
  use Term::ReadKey;
  print &#34;Press &#39;q&#39; to quit this test.\n&#34;;
  ReadMode 5; # Turns off controls keys
  while (1) {
    while (not defined ($key = ReadKey(-1))) {
      print &#34;Didn&#39;t get a key.  Sleeping 1 second.\015\012&#34;;
      sleep (1);
    }
    print &#34;Got key: $key\015\012&#34;;
    ($key eq &#39;q&#39;) and last;
  }
  ReadMode 0; # Reset tty mode before exiting
  exit;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Non-Optimal_Code"
>Non-Optimal Code</a></h2>

<p>Dissociating the input and display cursors introduced a lot of code. Much of this code was thrown in hastily, and things can probably be done with less work.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Unimplemented_Features"
>Unimplemented Features</a></h2>

<p>Input editing is not kept on one line. If it wraps, and a terminal cannot wrap back through a line division, the cursor will become lost.</p>

<p>Unicode support. I feel real bad about throwing away native representation of all the 8th-bit-set characters. I also have no idea how to do this, and I don&#39;t have a system to test this. Patches are very much welcome.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="GOTCHAS_/_FAQ"
>GOTCHAS / FAQ</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Lost_Prompts"
>Lost Prompts</a></h2>

<p>Q: Why do I lose my prompt every time I send output to the screen?</p>

<p>A: You probably are using print or printf to write screen output. ReadLine doesn&#39;t track STDOUT itself, so it doesn&#39;t know when to refresh the prompt after you do this. Use ReadLine&#39;s put() method to write lines to the console.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Edit_Keystrokes_Display_as_^C"
>Edit Keystrokes Display as ^C</a></h2>

<p>Q: None of the editing keystrokes work. Ctrl-C displays &#34;^c&#34; rather than generating an interrupt. The arrow keys don&#39;t scroll through my input history. It&#39;s generally a bad experience.</p>

<p>A: You&#39;re probably a vi/vim user. In the absence of a ~/.inputrc file, POE::Wheel::ReadLine checks your EDITOR environment variable for clues about your editing preference. If it sees /vi/ in there, it starts in vi mode. You can override this by creating a ~/.inputrc file containing the line &#34;set editing-mode emacs&#34;, or adding that line to your existing ~/.inputrc. While you&#39;re in there, you should totally get acquainted with all the other cool stuff you can do with .inputrc files.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Lack_of_Windows_Support"
>Lack of Windows Support</a></h2>

<p>Q: Why doesn&#39;t POE::Wheel::ReadLine work on Windows? Term::ReadLine does.</p>

<p>A: POE::Wheel::ReadLine requires select(), because that&#39;s what POE uses by default to detect keystrokes without blocking. About half the flavors of Perl on Windows implement select() in terms of the same function in the WinSock library, which limits select() to working only with sockets. Your console isn&#39;t a socket, so select() doesn&#39;t work with your version of Perl on Windows.</p>

<p>Really good workarounds are possible but don&#39;t exist as of this writing. They involve writing a special POE::Loop for Windows that either uses a Win32-specific module for better multiplexing, that polls for input, or that uses blocking I/O watchers in separate threads.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Cygwin_Support"
>Cygwin Support</a></h2>

<p>Q: Why does POE::Wheel::ReadLine complain about my &#34;dumb&#34; terminal?</p>

<p>A: Do you have Strawberry Perl installed? Due to the way it works, on installation it sets a global environment variable in MSWin32 for TERM=dumb. ( it may be fixed in a future version, but it&#39;s here to stay for now, ha! ) In this case, logging into the Cygwin shell via the cygwin.bat launcher results in a nonfunctional readline.</p>

<p>Normally, Cygwin will set TERM=cygwin in the launcher. However, if the TERM was already set it will not alter the value. Hence, the &#34;bug&#34; appears! What you can do is to hack the cygwin.bat file to add this line:</p>

<pre>  SET TERM=cygwin</pre>

<p>Other users reported that you can have better results by editing the ~/.bash_profile file to set TERM=cygwin because on a Cygwin upgrade it overwrites the cygwin.bat file.</p>

<p>Alternatively, you could install different terminals like &#34;xterm&#34; or &#34;rxvt&#34; as shown here: <a href="http://c2.com/cgi/wiki?BetterCygwinTerminal" class="podlinkurl"
>http://c2.com/cgi/wiki?BetterCygwinTerminal</a>. Please let us know if you encounter problems using any terminal other than &#34;dumb&#34;.</p>

<p>If you feel brave, you can peruse the RT ticket at <a href="http://rt.cpan.org/Ticket/Display.html?id=55365" class="podlinkurl"
>http://rt.cpan.org/Ticket/Display.html?id=55365</a> for more information on this problem.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS_&#38;_COPYRIGHTS"
>AUTHORS &#38; COPYRIGHTS</a></h1>

<p>POE::Wheel::ReadLine was originally written by Rocco Caputo.</p>

<p>Nick Williams virtually rewrote it to support a larger subset of GNU readline.</p>

<p>Please see <a href="../../POE.html" class="podlinkpod"
>POE</a> for more information about other authors and contributors.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
