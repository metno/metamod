<html><head><title>POE::Wheel::ReadWrite</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:26 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#PUBLIC_METHODS'>PUBLIC METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Constructor'>Constructor</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#new'>new</a>
      <ul   class='indexList indexList4'>
        <li class='indexItem indexItem4'><a href='#Handle'>Handle</a>
        <li class='indexItem indexItem4'><a href='#InputHandle'>InputHandle</a>
        <li class='indexItem indexItem4'><a href='#OutputHandle'>OutputHandle</a>
        <li class='indexItem indexItem4'><a href='#Driver'>Driver</a>
        <li class='indexItem indexItem4'><a href='#Filter'>Filter</a>
        <li class='indexItem indexItem4'><a href='#InputFilter'>InputFilter</a>
        <li class='indexItem indexItem4'><a href='#OutputFilter'>OutputFilter</a>
        <li class='indexItem indexItem4'><a href='#InputEvent'>InputEvent</a>
        <li class='indexItem indexItem4'><a href='#FlushedEvent'>FlushedEvent</a>
        <li class='indexItem indexItem4'><a href='#ErrorEvent'>ErrorEvent</a>
        <li class='indexItem indexItem4'><a href='#HighEvent'>HighEvent</a>
        <li class='indexItem indexItem4'><a href='#LowEvent'>LowEvent</a>
      </ul>
    </ul>
    <li class='indexItem indexItem2'><a href='#put_RECORDS'>put RECORDS</a>
    <li class='indexItem indexItem2'><a href='#event_EVENT_TYPE_%3D%3E_EVENT_NAME%2C_...'>event EVENT_TYPE =&#62; EVENT_NAME, ...</a>
    <li class='indexItem indexItem2'><a href='#set_filter_POE_FILTER'>set_filter POE_FILTER</a>
    <li class='indexItem indexItem2'><a href='#set_input_filter_POE_FILTER'>set_input_filter POE_FILTER</a>
    <li class='indexItem indexItem2'><a href='#set_output_filter_POE_FILTER'>set_output_filter POE_FILTER</a>
    <li class='indexItem indexItem2'><a href='#get_input_filter'>get_input_filter</a>
    <li class='indexItem indexItem2'><a href='#get_output_filter'>get_output_filter</a>
    <li class='indexItem indexItem2'><a href='#set_high_mark_HIGH_MARK_OCTETS'>set_high_mark HIGH_MARK_OCTETS</a>
    <li class='indexItem indexItem2'><a href='#set_low_mark_LOW_MARK_OCTETS'>set_low_mark LOW_MARK_OCTETS</a>
    <li class='indexItem indexItem2'><a href='#ID'>ID</a>
    <li class='indexItem indexItem2'><a href='#pause_input'>pause_input</a>
    <li class='indexItem indexItem2'><a href='#resume_input'>resume_input</a>
    <li class='indexItem indexItem2'><a href='#get_input_handle'>get_input_handle</a>
    <li class='indexItem indexItem2'><a href='#get_output_handle'>get_output_handle</a>
    <li class='indexItem indexItem2'><a href='#shutdown_input'>shutdown_input</a>
    <li class='indexItem indexItem2'><a href='#shutdown_output'>shutdown_output</a>
    <li class='indexItem indexItem2'><a href='#get_driver_out_octets'>get_driver_out_octets</a>
    <li class='indexItem indexItem2'><a href='#get_driver_out_messages'>get_driver_out_messages</a>
    <li class='indexItem indexItem2'><a href='#flush'>flush</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS_%26_COPYRIGHTS'>AUTHORS &#38; COPYRIGHTS</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>POE::Wheel::ReadWrite - non-blocking buffered I/O mix-in for POE::Session</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  #!perl

  use warnings;
  use strict;

  use IO::Socket::INET;
  use POE qw(Wheel::ReadWrite);

  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub {
        # Note: IO::Socket::INET will block.  We recommend
        # POE::Wheel::SocketFactory or POE::Component::Client::TCP if
        # blocking is contraindicated.
        $_[HEAP]{client} = POE::Wheel::ReadWrite-&#62;new(
          Handle =&#62; IO::Socket::INET-&#62;new(
            PeerHost =&#62; &#39;www.yahoo.com&#39;,
            PeerPort =&#62; 80,
          ),
          InputEvent =&#62; &#39;on_remote_data&#39;,
          ErrorEvent =&#62; &#39;on_remote_fail&#39;,
        );

        print &#34;Connected.  Sending request...\n&#34;;
        $_[HEAP]{client}-&#62;put(
          &#34;GET / HTTP/0.9&#34;,
          &#34;Host: www.yahoo.com&#34;,
          &#34;&#34;,
        );
      },
      on_remote_data =&#62; sub {
        print &#34;Received: $_[ARG0]\n&#34;;
      },
      on_remote_fail =&#62; sub {
        print &#34;Connection failed or ended.  Shutting down...\n&#34;;
        delete $_[HEAP]{client};
      },
    },
  );

  POE::Kernel-&#62;run();
  exit;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>POE::Wheel::ReadWrite encapsulates a common design pattern: dealing with buffered I/O in a non-blocking, event driven fashion.</p>

<p>The pattern goes something like this:</p>

<p>Given a filehandle, watch it for incoming data. When notified of incoming data, read it, buffer it, and parse it according to some low-level protocol (such as line-by-line). Generate higher-level &#34;here be lines&#34; events, one per parsed line.</p>

<p>In the other direction, accept whole chunks of data (such as lines) for output. Reformat them according to some low-level protocol (such as by adding newlines), and buffer them for output. Flush the buffered data when the filehandle is ready to transmit it.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PUBLIC_METHODS"
>PUBLIC METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Constructor"
>Constructor</a></h2>

<p>POE::Wheel subclasses tend to perform a lot of setup so that they run lighter and faster. POE::Wheel::ReadWrite&#39;s constructor is no exception.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="new"
>new</a></h3>

<p>new() creates and returns a new POE:Wheel::ReadWrite instance. Under most circumstances, the wheel will continue to read/write to one or more filehandles until it&#39;s destroyed.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="Handle"
>Handle</a></h4>

<p>Handle defines the filehandle that a POE::Wheel::ReadWrite object will read from and write to. The <a href="#SYNOPSIS" class="podlinkpod"
>&#34;SYNOPSIS&#34;</a> includes an example using Handle.</p>

<p>A single POE::Wheel::ReadWrite object can read from and write to different filehandles. See <a href="#InputHandle" class="podlinkpod"
>&#34;InputHandle&#34;</a> for more information and an example.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="InputHandle"
>InputHandle</a></h4>

<p>InputHandle and OutputHandle may be used to specify different handles for input and output. For example, input may be from STDIN and output may go to STDOUT:</p>

<pre>  $_[HEAP]{console} = POE::Wheel::ReadWrite-&#62;new(
    InputHandle =&#62; \*STDIN,
    OutputHandle =&#62; \*STDOUT,
    InputEvent =&#62; &#34;console_input&#34;,
  );</pre>

<p>InputHandle and OutputHandle may not be used with Handle.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="OutputHandle"
>OutputHandle</a></h4>

<p>InputHandle and OutputHandle may be used to specify different handles for input and output. Please see <a href="#InputHandle" class="podlinkpod"
>&#34;InputHandle&#34;</a> for more information and an example.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="Driver"
>Driver</a></h4>

<p>Driver specifies how POE::Wheel::ReadWrite will actually read from and write to its filehandle or filehandles. Driver must be an object that inherits from <a href="../../POE/Driver.html" class="podlinkpod"
>POE::Driver</a>.</p>

<p><a href="../../POE/Driver/SysRW.html" class="podlinkpod"
>POE::Driver::SysRW</a>, which implements sysread() and syswrite(), is the default. It&#39;s used in nearly all cases, so there&#39;s no point in specifying it.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="Filter"
>Filter</a></h4>

<p>Filter is the parser that POE::Wheel::ReadWrite will used to recognize input data and the serializer it uses to prepare data for writing. It defaults to a new <a href="../../POE/Filter/Line.html" class="podlinkpod"
>POE::Filter::Line</a> instance since many network protocols are line based.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="InputFilter"
>InputFilter</a></h4>

<p>InputFilter and OutputFilter may be used to specify different filters for input and output.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="OutputFilter"
>OutputFilter</a></h4>

<p>InputFilter and OutputFilter may be used to specify different filters for input and output. Please see <a href="#InputFilter" class="podlinkpod"
>&#34;InputFilter&#34;</a> for more information and an example.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="InputEvent"
>InputEvent</a></h4>

<p>InputEvent specifies the name of the event that will be sent for every complete input unit (as parsed by InputFilter or Filter).</p>

<p>Every input event includes two parameters:</p>

<p><code>ARG0</code> contains the parsed input unit, and <code>ARG1</code> contains the unique ID for the POE::Wheel::ReadWrite object that generated the event.</p>

<p>InputEvent is optional. If omitted, the POE::Wheel::ReadWrite object will not watch its Handle or InputHandle for input, and no input events will be generated.</p>

<p>A sample InputEvent handler:</p>

<pre>  sub handle_input {
    my ($heap, $input, $wheel_id) = @_[HEAP, ARG0, ARG1];
    print &#34;Echoing input from wheel $wheel_id: $input\n&#34;;
    $heap-&#62;{wheel}-&#62;put($input); # Put... the input... beck!
  }</pre>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="FlushedEvent"
>FlushedEvent</a></h4>

<p>FlushedEvent specifies the event that a POE::Wheel::ReadWrite object will emit whenever its output buffer transitions from containing data to becoming empty.</p>

<p>FlushedEvent comes with a single parameter: <code>ARG0</code> contains the unique ID for the POE::Wheel::ReadWrite object that generated the event. This may be used to match the event to a particular wheel.</p>

<p>&#34;Flushed&#34; events are often used to shut down I/O after a &#34;goodbye&#34; message has been sent. For example, the following input_handler() responds to &#34;quit&#34; by instructing the wheel to say &#34;Goodbye.&#34; and then to send a &#34;shutdown&#34; event when that has been flushed to the socket.</p>

<pre>  sub handle_input {
    my ($input, $wheel_id) = @_[ARG0, ARG1];
    my $wheel = $_[HEAP]{wheel}{$wheel_id};

    if ($input eq &#34;quit&#34;) {
      $wheel-&#62;event( FlushedEvent =&#62; &#34;shutdown&#34; );
      $wheel-&#62;put(&#34;Goodbye.&#34;);
    }
    else {
      $wheel-&#62;put(&#34;Echo: $input&#34;);
    }
  }</pre>

<p>Here&#39;s the shutdown handler. It just destroys the wheel to end the connection:</p>

<pre>  sub handle_flushed {
    my $wheel_id = $_[ARG0];
    delete $_[HEAP]{wheel}{$wheel_id};
  }</pre>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="ErrorEvent"
>ErrorEvent</a></h4>

<p>ErrorEvent names the event that a POE::Wheel::ReadWrite object will emit whenever an error occurs. Every ErrorEvent includes four parameters:</p>

<p><code>ARG0</code> describes what failed, either &#34;read&#34; or &#34;write&#34;. It doesn&#39;t name a particular function since POE::Wheel::ReadWrite delegates actual reading and writing to a <a href="../../POE/Driver.html" class="podlinkpod"
>POE::Driver</a> object.</p>

<p><code>ARG1</code> and <code>ARG2</code> hold numeric and string values for <code>$!</code> at the time of failure. Applicatin code cannot test <code>$!</code> directly since its value may have changed between the time of the error and the time the error event is dispatched.</p>

<p><code>ARG3</code> contains the wheel&#39;s unique ID. The wheel&#39;s ID is used to differentiate between many wheels managed by a single session.</p>

<p>ErrorEvent may also indicate EOF on a FileHandle by returning operation &#34;read&#34; error 0. For sockets, this means the remote end has closed the connection.</p>

<p>A sample ErrorEvent handler:</p>

<pre>  sub error_state {
    my ($operation, $errnum, $errstr, $id) = @_[ARG0..ARG3];
    if ($operation eq &#34;read&#34; and $errnum == 0) {
      print &#34;EOF from wheel $id\n&#34;;
    }
    else {
      warn &#34;Wheel $id encountered $operation error $errnum: $errstr\n&#34;;
    }
    delete $_[HEAP]{wheels}{$id}; # shut down that wheel
  }</pre>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="HighEvent"
>HighEvent</a></h4>

<p>HighEvent and LowEvent are used along with HighMark and LowMark to control the flow of streamed output.</p>

<p>A HighEvent is sent when the output buffer of a POE::Wheel::ReadWrite object exceeds a certain size (the &#34;high water&#34; mark, or HighMark). This advises an application to stop streaming output. POE and Perl really don&#39;t care if the application continues, but it&#39;s possible that the process may run out of memory if a buffer grows without bounds.</p>

<p>A POE::Wheel::ReadWrite object will continue to flush its buffer even after an application stops streaming data, until the buffer is empty. Some streaming applications may require the buffer to always be primed with data, however. For example, a media server would encounter stutters if it waited for a FlushedEvent before sending more data.</p>

<p>LowEvent solves the stutter problem. A POE::Wheel::ReadWrite object will send a LowEvent when its output buffer drains below a certain level (the &#34;low water&#34; mark, or LowMark). This notifies an application that the buffer is small enough that it may resume streaming.</p>

<p>The stutter problem is solved because the output buffer never quite reaches empty.</p>

<p>HighEvent and LowEvent are edge-triggered, not level-triggered. This means they are emitted once whenever a POE::Wheel::ReadWrite object&#39;s output buffer crosses the HighMark or LowMark. If an application continues to put() data after the HighMark is reached, it will not cause another HighEvent to be sent.</p>

<p>HighEvent is generally not needed. The put() method will return the high watermark state: true if the buffer is at or above the high watermark, or false if the buffer has room for more data. Here&#39;s a quick way to prime a POE::Wheel::ReadWrite object&#39;s output buffer:</p>

<pre>  1 while not $_[HEAP]{readwrite}-&#62;put(get_next_data());</pre>

<p>POE::Wheel::ReadWrite objects always start in a low-water state.</p>

<p>HighEvent and LowEvent are optional. Omit them if flow control is not needed.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="LowEvent"
>LowEvent</a></h4>

<p>HighEvent and LowEvent are used along with HighMark and LowMark to control the flow of streamed output. Please see <a href="#HighEvent" class="podlinkpod"
>&#34;HighEvent&#34;</a> for more information and examples.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="put_RECORDS"
>put RECORDS</a></h2>

<p>put() accepts a list of RECORDS, which will be serialized by the wheel&#39;s Filter and buffered and written by its Driver.</p>

<p>put() returns true if a HighMark has been set and the Driver&#39;s output buffer has reached or exceeded the limit. False is returned if HighMark has not been set, or if the Driver&#39;s buffer is smaller than that limit.</p>

<p>put()&#39;s return value is purely advisory; an application may continue buffering data beyond the HighMark---at the risk of exceeding the process&#39; memory limits. Do not use <code>&#60;1 while not $wheel-</code>put()&#62;&#62; syntax if HighMark isn&#39;t set: the application will fail spectacularly!</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="event_EVENT_TYPE_=&#62;_EVENT_NAME,_..."
>event EVENT_TYPE =&#62; EVENT_NAME, ...</a></h2>

<p>event() allows an application to modify the events emitted by a POE::Wheel::ReadWrite object. All constructor parameters ending in &#34;Event&#34; may be changed at run time: <a href="#InputEvent" class="podlinkpod"
>&#34;InputEvent&#34;</a>, <a href="#FlushedEvent" class="podlinkpod"
>&#34;FlushedEvent&#34;</a>, <a href="#ErrorEvent" class="podlinkpod"
>&#34;ErrorEvent&#34;</a>, <a href="#HighEvent" class="podlinkpod"
>&#34;HighEvent&#34;</a>, and <a href="#LowEvent" class="podlinkpod"
>&#34;LowEvent&#34;</a>.</p>

<p>Setting an event to undef will disable the code within the wheel that generates the event. So for example, stopping InputEvent will also stop reading from the filehandle. <a href="#pause_input" class="podlinkpod"
>&#34;pause_input&#34;</a> and <a href="#resume_input" class="podlinkpod"
>&#34;resume_input&#34;</a> may be a better way to manage input events, however.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="set_filter_POE_FILTER"
>set_filter POE_FILTER</a></h2>

<p>set_filter() changes the way a POE::Wheel::ReadWrite object parses input and serializes output. Any pending data that has not been dispatched to the application will be parsed with the new POE_FILTER. Information that has been put() but not flushed will not be reserialized.</p>

<p>set_filter() performs the same act as calling set_input_filter() and set_output_filter() with the same POE::Filter object.</p>

<p>Switching filters can be tricky. Please see the discussion of get_pending() in <a href="../../POE/Filter.html" class="podlinkpod"
>POE::Filter</a>. Some filters may not support being dynamically loaded or unloaded.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="set_input_filter_POE_FILTER"
>set_input_filter POE_FILTER</a></h2>

<p>set_input_filter() changes a POE::Wheel::ReadWrite object&#39;s input filter while leaving the output filter unchanged. This alters the way data is parsed without affecting how it&#39;s serialized for output.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="set_output_filter_POE_FILTER"
>set_output_filter POE_FILTER</a></h2>

<p>set_output_filter() changes how a POE::Wheel::ReadWrite object serializes its output but does not affect the way data is parsed.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_input_filter"
>get_input_filter</a></h2>

<p>get_input_filter() returns the POE::Filter object currently used by a POE::Wheel::ReadWrite object to parse incoming data. The returned object may be introspected or altered via its own methods.</p>

<p>There is no get_filter() method because there is no sane return value when input and output filters differ.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_output_filter"
>get_output_filter</a></h2>

<p>get_output_filter() returns the <a href="../../POE/Filter.html" class="podlinkpod"
>POE::Filter</a> object currently used by a POE::Wheel::ReadWrite object to serialize outgoing data. The returned object may be introspected or altered via its own methods.</p>

<p>There is no get_filter() method because there is no sane return value when input and output filters differ.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="set_high_mark_HIGH_MARK_OCTETS"
>set_high_mark HIGH_MARK_OCTETS</a></h2>

<p>Sets the high water mark---the number of octets that designates a &#34;full enough&#34; output buffer. A POE::Wheel::ReadWrite object will emit a HighEvent when its output buffer expands to reach this point. All put() calls will return true when the output buffer is equal or greater than HIGH_MARK_OCTETS.</p>

<p>Both HighEvent and put() indicate that it&#39;s unsafe to continue writing when the output buffer expands to at least HIGH_MARK_OCTETS.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="set_low_mark_LOW_MARK_OCTETS"
>set_low_mark LOW_MARK_OCTETS</a></h2>

<p>Sets the low water mark---the number of octets that designates an &#34;empty enough&#34; output buffer. This event lets an application know that it&#39;s safe to resume writing again.</p>

<p>POE::Wheel::ReadWrite objects will emit a LowEvent when their output buffers shrink to LOW_MARK_OCTETS after having reached HIGH_MARK_OCTETS.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ID"
>ID</a></h2>

<p>ID() returns a POE::Wheel::ReadWrite object&#39;s unique ID. ID() is usually called after the object is created so that the object may be stashed by its ID. Events generated by the POE::Wheel::ReadWrite object will include the ID of the object, so that they may be matched back to their sources.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="pause_input"
>pause_input</a></h2>

<p>pause_input() instructs a POE::Wheel::ReadWrite object to stop watching for input, and thus stop emitting InputEvent events. It&#39;s much more efficient than destroying the object outright, especially if an application intends to resume_input() later.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="resume_input"
>resume_input</a></h2>

<p>resume_input() turns a POE::Wheel::ReadWrite object&#39;s input watcher back on. It&#39;s used to resume watching for input, and thus resume sending InputEvent events. pause_input() and resume_input() implement a form of input flow control, driven by the application itself.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_input_handle"
>get_input_handle</a></h2>

<p>get_input_handle() returns the filehandle being watched for input.</p>

<p>Manipulating filehandles that are managed by POE may cause nasty side effects, which may change from one POE release to the next. Please use caution.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_output_handle"
>get_output_handle</a></h2>

<p>get_output_handle() returns the filehandle being watched for output.</p>

<p>Manipulating filehandles that are managed by POE may cause nasty side effects, which may change from one POE release to the next. Please use caution.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="shutdown_input"
>shutdown_input</a></h2>

<p>Call shutdown($fh,0) on a POE::Wheel::ReadWrite object&#39;s input filehandle. This only works for sockets; nothing will happen for other types of filehandle.</p>

<p>Occasionally, the POE::Wheel::ReadWrite object will stop monitoring its input filehandle for new data. This occurs regardless of the filehandle type.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="shutdown_output"
>shutdown_output</a></h2>

<p>Call shutdown($fh,1) on a POE::Wheel::ReadWrite object&#39;s output filehandle. This only works for sockets; nothing will happen for other types of filehandle.</p>

<p>Occasionally, the POE::Wheel::ReadWrite object will stop monitoring its output filehandle for new data. This occurs regardless of the filehandle type.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_driver_out_octets"
>get_driver_out_octets</a></h2>

<p><a href="../../POE/Driver.html" class="podlinkpod"
>POE::Driver</a> objects contain output buffers that are flushed asynchronously. get_driver_out_octets() returns the number of octets remaining in the wheel&#39;s driver&#39;s output buffer.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_driver_out_messages"
>get_driver_out_messages</a></h2>

<p><a href="../../POE/Driver.html" class="podlinkpod"
>POE::Driver</a> objects&#39; output buffers may be message based. Every put() call may be buffered individually. get_driver_out_messages() will return the number of pending put() messages that remain to be sent.</p>

<p>Stream-based drivers will simply return 1 if any data remains to be flushed. This is because they operate with one potentially large message.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="flush"
>flush</a></h2>

<p>flush() manually attempts to flush a wheel&#39;s output in a synchronous fashion. This can be used to flush small messages. Note, however, that complete flushing is not guaranteed---to do so would mean potentially blocking indefinitely, which is undesirable in most POE applications.</p>

<p>If an application must guarantee a full buffer flush, it may loop flush() calls:</p>

<pre>  $wheel-&#62;flush() while $wheel-&#62;get_driver_out_octets();</pre>

<p>However it would be prudent to check for errors as well. A flush() failure may be permanent, and an infinite loop is probably not what most developers have in mind here.</p>

<p>It should be obvious by now that <b>this method is experimental</b>. Its behavior may change or it may disappear outright. Please let us know whether it&#39;s useful.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../../POE/Wheel.html" class="podlinkpod"
>POE::Wheel</a> describes wheels in general.</p>

<p>The SEE ALSO section in <a href="../../POE.html" class="podlinkpod"
>POE</a> contains a table of contents covering the entire POE distribution.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>None known.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS_&#38;_COPYRIGHTS"
>AUTHORS &#38; COPYRIGHTS</a></h1>

<p>Please see <a href="../../POE.html" class="podlinkpod"
>POE</a> for more information about authors and contributors.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
