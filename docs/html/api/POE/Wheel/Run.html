<html><head><title>POE::Wheel::Run</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:26 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#PUBLIC_METHODS'>PUBLIC METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Constructor'>Constructor</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#new'>new</a>
      <ul   class='indexList indexList4'>
        <li class='indexItem indexItem4'><a href='#Conduit'>Conduit</a>
        <li class='indexItem indexItem4'><a href='#Winsize'>Winsize</a>
        <li class='indexItem indexItem4'><a href='#CloseOnCall'>CloseOnCall</a>
        <li class='indexItem indexItem4'><a href='#StdioDriver'>StdioDriver</a>
        <li class='indexItem indexItem4'><a href='#StdinDriver'>StdinDriver</a>
        <li class='indexItem indexItem4'><a href='#StdoutDriver'>StdoutDriver</a>
        <li class='indexItem indexItem4'><a href='#StderrDriver'>StderrDriver</a>
        <li class='indexItem indexItem4'><a href='#CloseEvent'>CloseEvent</a>
        <li class='indexItem indexItem4'><a href='#ErrorEvent'>ErrorEvent</a>
        <li class='indexItem indexItem4'><a href='#StdinEvent'>StdinEvent</a>
        <li class='indexItem indexItem4'><a href='#StdoutEvent'>StdoutEvent</a>
        <li class='indexItem indexItem4'><a href='#StderrEvent'>StderrEvent</a>
        <li class='indexItem indexItem4'><a href='#RedirectStdout'>RedirectStdout</a>
        <li class='indexItem indexItem4'><a href='#RedirectStderr'>RedirectStderr</a>
        <li class='indexItem indexItem4'><a href='#RedirectStdin'>RedirectStdin</a>
        <li class='indexItem indexItem4'><a href='#RedirectOutput'>RedirectOutput</a>
        <li class='indexItem indexItem4'><a href='#NoStdin'>NoStdin</a>
        <li class='indexItem indexItem4'><a href='#StdioFilter'>StdioFilter</a>
        <li class='indexItem indexItem4'><a href='#StdinFilter'>StdinFilter</a>
        <li class='indexItem indexItem4'><a href='#StdoutFilter'>StdoutFilter</a>
        <li class='indexItem indexItem4'><a href='#StderrFilter'>StderrFilter</a>
        <li class='indexItem indexItem4'><a href='#Group'>Group</a>
        <li class='indexItem indexItem4'><a href='#User'>User</a>
        <li class='indexItem indexItem4'><a href='#NoSetSid'>NoSetSid</a>
        <li class='indexItem indexItem4'><a href='#NoSetPgrp'>NoSetPgrp</a>
        <li class='indexItem indexItem4'><a href='#Priority'>Priority</a>
        <li class='indexItem indexItem4'><a href='#Program'>Program</a>
        <li class='indexItem indexItem4'><a href='#ProgramArgs'>ProgramArgs</a>
      </ul>
    </ul>
    <li class='indexItem indexItem2'><a href='#event_EVENT_TYPE_%3D%3E_EVENT_NAME%2C_...'>event EVENT_TYPE =&#62; EVENT_NAME, ...</a>
    <li class='indexItem indexItem2'><a href='#put_RECORDS'>put RECORDS</a>
    <li class='indexItem indexItem2'><a href='#get_stdin_filter'>get_stdin_filter</a>
    <li class='indexItem indexItem2'><a href='#get_stdout_filter'>get_stdout_filter</a>
    <li class='indexItem indexItem2'><a href='#get_stderr_filter'>get_stderr_filter</a>
    <li class='indexItem indexItem2'><a href='#set_stdio_filter_FILTER_OBJECT'>set_stdio_filter FILTER_OBJECT</a>
    <li class='indexItem indexItem2'><a href='#set_stdin_filter_FILTER_OBJECT'>set_stdin_filter FILTER_OBJECT</a>
    <li class='indexItem indexItem2'><a href='#set_stdout_filter_FILTER_OBJECT'>set_stdout_filter FILTER_OBJECT</a>
    <li class='indexItem indexItem2'><a href='#set_stderr_filter_FILTER_OBJECT'>set_stderr_filter FILTER_OBJECT</a>
    <li class='indexItem indexItem2'><a href='#pause_stdout'>pause_stdout</a>
    <li class='indexItem indexItem2'><a href='#pause_stderr'>pause_stderr</a>
    <li class='indexItem indexItem2'><a href='#resume_stdout'>resume_stdout</a>
    <li class='indexItem indexItem2'><a href='#resume_stderr'>resume_stderr</a>
    <li class='indexItem indexItem2'><a href='#shutdown_stdin'>shutdown_stdin</a>
    <li class='indexItem indexItem2'><a href='#ID'>ID</a>
    <li class='indexItem indexItem2'><a href='#PID'>PID</a>
    <li class='indexItem indexItem2'><a href='#kill_SIGNAL'>kill SIGNAL</a>
    <li class='indexItem indexItem2'><a href='#get_driver_out_messages'>get_driver_out_messages</a>
    <li class='indexItem indexItem2'><a href='#get_driver_out_octets'>get_driver_out_octets</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#TIPS_AND_TRICKS'>TIPS AND TRICKS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#MSWin32_Support'>MSWin32 Support</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#kill()_and_ClosedEvent_on_Windows'>kill() and ClosedEvent on Windows</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Execution_Environment'>Execution Environment</a>
    <li class='indexItem indexItem2'><a href='#Coderef_Execution_Side_Effects'>Coderef Execution Side Effects</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#DESTROY_and_END_Blocks_Run_Twice'>DESTROY and END Blocks Run Twice</a>
      <li class='indexItem indexItem3'><a href='#POE%3A%3AKernel%27s_run()_method_was_never_called'>POE::Kernel&#39;s run() method was never called</a>
      <li class='indexItem indexItem3'><a href='#Running_POE%3A%3AKernel_in_the_Child'>Running POE::Kernel in the Child</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#CAVEATS_%26_TODOS'>CAVEATS &#38; TODOS</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS_%26_COPYRIGHTS'>AUTHORS &#38; COPYRIGHTS</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>POE::Wheel::Run - portably run blocking code and programs in subprocesses</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  #!/usr/bin/perl

  use warnings;
  use strict;

  use POE qw( Wheel::Run );

  POE::Session-&#62;create(
    inline_states =&#62; {
      _start           =&#62; \&#38;on_start,
      got_child_stdout =&#62; \&#38;on_child_stdout,
      got_child_stderr =&#62; \&#38;on_child_stderr,
      got_child_close  =&#62; \&#38;on_child_close,
      got_child_signal =&#62; \&#38;on_child_signal,
    }
  );

  POE::Kernel-&#62;run();
  exit 0;

  sub on_start {
    my $child = POE::Wheel::Run-&#62;new(
      Program =&#62; [ &#34;/bin/ls&#34;, &#34;-1&#34;, &#34;/&#34; ],
      StdoutEvent  =&#62; &#34;got_child_stdout&#34;,
      StderrEvent  =&#62; &#34;got_child_stderr&#34;,
      CloseEvent   =&#62; &#34;got_child_close&#34;,
    );

    $_[KERNEL]-&#62;sig_child($child-&#62;PID, &#34;got_child_signal&#34;);

    # Wheel events include the wheel&#39;s ID.
    $_[HEAP]{children_by_wid}{$child-&#62;ID} = $child;

    # Signal events include the process ID.
    $_[HEAP]{children_by_pid}{$child-&#62;PID} = $child;

    print(
      &#34;Child pid &#34;, $child-&#62;PID,
      &#34; started as wheel &#34;, $child-&#62;ID, &#34;.\n&#34;
    );
  }

  # Wheel event, including the wheel&#39;s ID.
  sub on_child_stdout {
    my ($stdout_line, $wheel_id) = @_[ARG0, ARG1];
    my $child = $_[HEAP]{children_by_wid}{$wheel_id};
    print &#34;pid &#34;, $child-&#62;PID, &#34; STDOUT: $stdout_line\n&#34;;
  }

  # Wheel event, including the wheel&#39;s ID.
  sub on_child_stderr {
    my ($stderr_line, $wheel_id) = @_[ARG0, ARG1];
    my $child = $_[HEAP]{children_by_wid}{$wheel_id};
    print &#34;pid &#34;, $child-&#62;PID, &#34; STDERR: $stderr_line\n&#34;;
  }

  # Wheel event, including the wheel&#39;s ID.
  sub on_child_close {
    my $wheel_id = $_[ARG0];
    my $child = delete $_[HEAP]{children_by_wid}{$wheel_id};

    # May have been reaped by on_child_signal().
    unless (defined $child) {
      print &#34;wid $wheel_id closed all pipes.\n&#34;;
      return;
    }

    print &#34;pid &#34;, $child-&#62;PID, &#34; closed all pipes.\n&#34;;
    delete $_[HEAP]{children_by_pid}{$child-&#62;PID};
  }

  sub on_child_signal {
    print &#34;pid $_[ARG1] exited with status $_[ARG2].\n&#34;;
    my $child = delete $_[HEAP]{children_by_pid}{$_[ARG1]};

    # May have been reaped by on_child_close().
    return unless defined $child;

    delete $_[HEAP]{children_by_wid}{$child-&#62;ID};
  }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>POE::Wheel::Run executes a program or block of code in a subprocess, created the usual way: using fork(). The parent process may exchange information with the child over the child&#39;s STDIN, STDOUT and STDERR filehandles.</p>

<p>In the parent process, the POE::Wheel::Run object represents the child process. It has methods such as PID() and kill() to query and manage the child process.</p>

<p>POE::Wheel::Run&#39;s put() method sends data to the child&#39;s STDIN. Child output on STDOUT and STDERR may be dispatched as events within the parent, if requested.</p>

<p>POE::Wheel::Run can also notify the parent when the child has closed its output filehandles. Some programs remain active, but they close their output filehandles to indicate they are done writing.</p>

<p>A more reliable way to detect child exit is to use POE::Kernel&#39;s sig_child() method to wait for the wheel&#39;s process to be reaped. It is in fact vital to use sig_child() in all circumstances since without it, POE will not try to reap child processes.</p>

<p>Failing to use sig_child() has in the past led to wedged machines. Long-running programs have leaked processes, eventually consuming all available slots in the process table and requiring reboots.</p>

<p>Because process leaks are so severe, POE::Kernel will check for this condition on exit and display a notice if it finds that processes are leaking. Developers should heed these warnings.</p>

<p>POE::Wheel::Run communicates with the child process in a line-based fashion by default. Programs may override this by specifying some other POE::Filter object in <a href="#StdinFilter" class="podlinkpod"
>&#34;StdinFilter&#34;</a>, <a href="#StdoutFilter" class="podlinkpod"
>&#34;StdoutFilter&#34;</a>, <a href="#StdioFilter" class="podlinkpod"
>&#34;StdioFilter&#34;</a> and/or <a href="#StderrFilter" class="podlinkpod"
>&#34;StderrFilter&#34;</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PUBLIC_METHODS"
>PUBLIC METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Constructor"
>Constructor</a></h2>

<p>POE::Wheel subclasses tend to perform a lot of setup so that they run lighter and faster. POE::Wheel::Run&#39;s constructor is no exception.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="new"
>new</a></h3>

<p>new() creates and returns a new POE::Wheel::Run object. If it&#39;s successful, the object will represent a child process with certain specified qualities. It also provides an OO- and event-based interface for asynchronously interacting with the process.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="Conduit"
>Conduit</a></h4>

<p>Conduit specifies the inter-process communications mechanism that will be used to pass data between the parent and child process. Conduit may be one of &#34;pipe&#34;, &#34;socketpair&#34;, &#34;inet&#34;, &#34;pty&#34;, or &#34;pty-pipe&#34;. POE::Wheel::Run will use the most appropriate Conduit for the run-time (not the compile-time) operating system, but this varies from one OS to the next.</p>

<p>Internally, POE::Wheel::Run passes the Conduit type to <a href="../../POE/Pipe/OneWay.html" class="podlinkpod"
>POE::Pipe::OneWay</a> and <a href="../../POE/Pipe/TwoWay.html" class="podlinkpod"
>POE::Pipe::TwoWay</a>. These helper classes were created to make IPC portable and reusable. They do not require the rest of POE.</p>

<p>Three Conduit types use pipes or pipelike inter-process communication: &#34;pipe&#34;, &#34;socketpair&#34; and &#34;inet&#34;. They determine whether the internal IPC uses pipe(), socketpair() or Internet sockets. These Conduit values are passed through to <a href="../../POE/Pipe/OneWay.html" class="podlinkpod"
>POE::Pipe::OneWay</a> or <a href="../../POE/Pipe/TwoWay.html" class="podlinkpod"
>POE::Pipe::TwoWay</a> internally.</p>

<p>The &#34;pty&#34; conduit type runs the child process under a pseudo-tty, which is created by <a href="../../IO/Pty.html" class="podlinkpod"
>IO::Pty</a>. Pseudo-ttys (ptys) convince child processes that they are interacting with terminals rather than pipes. This may be used to trick programs like ssh into believing it&#39;s secure to prompt for a password, although passphraseless identities might be better for that.</p>

<p>The &#34;pty&#34; conduit cannot separate STDERR from STDOUT, but the &#34;pty-pipe&#34; mode can.</p>

<p>The &#34;pty-pipe&#34; conduit uses a pty for STDIN and STDOUT and a one-way pipe for STDERR. The additional pipe keeps STDERR output separate from STDOUT.</p>

<p>The <a href="../../IO/Pty.html" class="podlinkpod"
>IO::Pty</a> module is only loaded if &#34;pty&#34; or &#34;pty-pipe&#34; is used. It&#39;s not a dependency until it&#39;s actually needed.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="Winsize"
>Winsize</a></h4>

<p>Winsize sets the child process&#39; terminal size. Its value should be an arrayref with four elements. The first two elements must be the number of lines and columns for the child&#39;s terminal window, respectively. The second pair of elements describe the terminal&#39;s X and Y dimensions in pixels:</p>

<pre>  $_[HEAP]{child} = POE::Wheel::Run-&#62;new(
    # ... among other things ...
    Winsize =&#62; [ 25, 80, 1024, 768 ],
  );</pre>

<p>Winsize is only valid for conduits that use pseudo-ttys: &#34;pty&#34; and &#34;pty-pipe&#34;. Other conduits don&#39;t simulate terminals, so they don&#39;t have window sizes.</p>

<p>Winsize defaults to the parent process&#39; window size, assuming the parent process has a terminal to query.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="CloseOnCall"
>CloseOnCall</a></h4>

<p>CloseOnCall, when true, turns on close-on-exec emulation for subprocesses that don&#39;t actually call exec(). These would be instances when the child is running a block of code rather than executing an external program. For example:</p>

<pre>  $_[HEAP]{child} = POE::Wheel::Run-&#62;new(
    # ... among other things ...
    CloseOnCall =&#62; 1,
    Program =&#62; \&#38;some_function,
  );</pre>

<p>CloseOnCall is off (0) by default.</p>

<p>CloseOnCall works by closing all file descriptors greater than $^F in the child process before calling the application&#39;s code. For more details, please the discussion of $^F in <a href="../../perlvar.html" class="podlinkpod"
>perlvar</a>.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="StdioDriver"
>StdioDriver</a></h4>

<p>StdioDriver specifies a single <a href="../../POE/Driver.html" class="podlinkpod"
>POE::Driver</a> object to be used for both STDIN and STDOUT. It&#39;s equivalent to setting <a href="#StdinDriver" class="podlinkpod"
>&#34;StdinDriver&#34;</a> and <a href="#StdoutDriver" class="podlinkpod"
>&#34;StdoutDriver&#34;</a> to the same <a href="../../POE/Driver.html" class="podlinkpod"
>POE::Driver</a> object.</p>

<p>POE::Wheel::Run will create and use a <a href="../../POE/Driver/SysRW.html" class="podlinkpod"
>POE::Driver::SysRW</a> driver of one isn&#39;t specified. This is by far the most common use case, so it&#39;s the default.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="StdinDriver"
>StdinDriver</a></h4>

<p><code>StdinDriver</code> sets the <a href="../../POE/Driver.html" class="podlinkpod"
>POE::Driver</a> used to write to the child process&#39; STDIN IPC conduit. It is almost never needed. Omitting it will allow POE::Wheel::Run to use an internally created <a href="../../POE/Driver/SysRW.html" class="podlinkpod"
>POE::Driver::SysRW</a> object.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="StdoutDriver"
>StdoutDriver</a></h4>

<p><code>StdoutDriver</code> sets the <a href="../../POE/Driver.html" class="podlinkpod"
>POE::Driver</a> object that will be used to read from the child process&#39; STDOUT conduit. It&#39;s almost never needed. If omitted, POE::Wheel::Run will internally create and use a <a href="../../POE/Driver/SysRW.html" class="podlinkpod"
>POE::Driver::SysRW</a> object.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="StderrDriver"
>StderrDriver</a></h4>

<p><code>StderrDriver</code> sets the driver that will be used to read from the child process&#39; STDERR conduit. As with <a href="#StdoutDriver" class="podlinkpod"
>&#34;StdoutDriver&#34;</a>, it&#39;s almost always preferable to let POE::Wheel::Run instantiate its own driver.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="CloseEvent"
>CloseEvent</a></h4>

<p>CloseEvent contains the name of an event that the wheel will emit when the child process closes its last open output handle. This is a consistent notification that the child is done sending output. Please note that it does not signal when the child process has exited. Programs should use sig_child() to detect that.</p>

<p>While it is impossible for ErrorEvent or StdoutEvent to happen after CloseEvent, there is no such guarantee for CHLD, which may happen before or after CloseEvent.</p>

<p>In addition to the usual POE parameters, each CloseEvent comes with one of its own:</p>

<p><code>ARG0</code> contains the wheel&#39;s unique ID. This can be used to keep several child processes separate when they&#39;re managed by the same session.</p>

<p>A sample close event handler:</p>

<pre>  sub close_state {
    my ($heap, $wheel_id) = @_[HEAP, ARG0];

    my $child = delete $heap-&#62;{child}-&#62;{$wheel_id};
    print &#34;Child &#34;, $child-&#62;PID, &#34; has finished.\n&#34;;
  }</pre>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="ErrorEvent"
>ErrorEvent</a></h4>

<p>ErrorEvent contains the name of an event to emit if something fails. It is optional; if omitted, the wheel will not notify its session if any errors occur. However, POE::Wheel::Run-&#62;new() will still throw an exception if it fails.</p>

<p><code>ARG0</code> contains the name of the operation that failed. It may be &#39;read&#39;, &#39;write&#39;, &#39;fork&#39;, &#39;exec&#39; or the name of some other function or task. The actual values aren&#39;t yet defined. They will probably not correspond so neatly to Perl builtin function names.</p>

<p><code>ARG1</code> and <code>ARG2</code> hold numeric and string values for <code>$!</code>, respectively. <code>&#34;$!&#34;</code> will eq <code>&#34;&#34;</code> for read error 0 (child process closed the file handle).</p>

<p><code>ARG3</code> contains the wheel&#39;s unique ID.</p>

<p><code>ARG4</code> contains the name of the child filehandle that has the error. It may be &#34;STDIN&#34;, &#34;STDOUT&#34;, or &#34;STDERR&#34;. The sense of <code>ARG0</code> will be the opposite of what you might normally expect for these handles. For example, POE::Wheel::Run will report a &#34;read&#34; error on &#34;STDOUT&#34; because it tried to read data from the child&#39;s STDOUT handle.</p>

<p>A sample error event handler:</p>

<pre>  sub error_state {
    my ($operation, $errnum, $errstr, $wheel_id) = @_[ARG0..ARG3];
    $errstr = &#34;remote end closed&#34; if $operation eq &#34;read&#34; and !$errnum;
    warn &#34;Wheel $wheel_id generated $operation error $errnum: $errstr\n&#34;;
  }</pre>

<p>Note that unless you deactivate the signal pipe, you might also see <code>EIO</code> (5) error during read operations.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="StdinEvent"
>StdinEvent</a></h4>

<p>StdinEvent contains the name of an event that Wheel::Run emits whenever everything queued by its put() method has been flushed to the child&#39;s STDIN handle. It is the equivalent to POE::Wheel::ReadWrite&#39;s FlushedEvent.</p>

<p>StdinEvent comes with only one additional parameter: <code>ARG0</code> contains the unique ID for the wheel that sent the event.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="StdoutEvent"
>StdoutEvent</a></h4>

<p>StdoutEvent contains the name of an event that Wheel::Run emits whenever the child process writes something to its STDOUT filehandle. In other words, whatever the child prints to STDOUT, the parent receives a StdoutEvent---provided that the child prints something compatible with the parent&#39;s StdoutFilter.</p>

<p>StdoutEvent comes with two parameters. <code>ARG0</code> contains the information that the child wrote to STDOUT. <code>ARG1</code> holds the unique ID of the wheel that read the output.</p>

<pre>  sub stdout_state {
    my ($heap, $input, $wheel_id) = @_[HEAP, ARG0, ARG1];
    print &#34;Child process in wheel $wheel_id wrote to STDOUT: $input\n&#34;;
  }</pre>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="StderrEvent"
>StderrEvent</a></h4>

<p>StderrEvent behaves exactly as StdoutEvent, except for data the child process writes to its STDERR filehandle.</p>

<p>StderrEvent comes with two parameters. <code>ARG0</code> contains the information that the child wrote to STDERR. <code>ARG1</code> holds the unique ID of the wheel that read the output.</p>

<pre>  sub stderr_state {
    my ($heap, $input, $wheel_id) = @_[HEAP, ARG0, ARG1];
    print &#34;Child process in wheel $wheel_id wrote to STDERR: $input\n&#34;;
  }</pre>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="RedirectStdout"
>RedirectStdout</a></h4>

<p>This is a filehandle or filename to which standard output will be redirected. It is an error to use this option together with StdoutEvent. This is useful in case your program needs to have standard I/O, but do not actually care for its contents to be visible to the parent.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="RedirectStderr"
>RedirectStderr</a></h4>

<p>Just like RedirectStdout, but with standard error. It is an error to use this together with StderrEvent</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="RedirectStdin"
>RedirectStdin</a></h4>

<p>This is a filehandle or filename which the child process will use as its standard input. It is an error to use this option with StdinEvent</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="RedirectOutput"
>RedirectOutput</a></h4>

<p>This will redirect stderr and stdout to the same filehandle. This is equivalent to do doing something like</p>

<pre>  $ something &#62; /path/to/output 2&#62;&#38;1</pre>

<p>in bourne shell.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="NoStdin"
>NoStdin</a></h4>

<p>While output filehandles will be closed if there are no events to be received on them, stdin is open by default - because lack of an event handler does not necessarily mean there is no desired input stream. This option explicitly disables the creation of an IPC stdin conduit.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="StdioFilter"
>StdioFilter</a></h4>

<p>StdioFilter, if used, must contain an instance of a POE::Filter subclass. This filter describes how the parent will format put() data for the child&#39;s STDIN, and how the parent will parse the child&#39;s STDOUT.</p>

<p>If STDERR will also be parsed, then a separate StderrFilter will also be needed.</p>

<p>StdioFilter defaults to a POE::Filter::Line instance, but only if both StdinFilter and StdoutFilter are not specified. If either StdinFilter or StdoutFilter is used, then StdioFilter is illegal.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="StdinFilter"
>StdinFilter</a></h4>

<p>StdinFilter may be used to specify a particular STDIN serializer that is different from the STDOUT parser. If specified, it conflicts with StdioFilter. StdinFilter&#39;s value, if specified, must be an instance of a POE::Filter subclass.</p>

<p>Without a StdinEvent, StdinFilter is illegal.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="StdoutFilter"
>StdoutFilter</a></h4>

<p>StdoutFilter may be used to specify a particular STDOUT parser that is different from the STDIN serializer. If specified, it conflicts with StdioFilter. StdoutFilter&#39;s value, if specified, must be an instance of a POE::Filter subclass.</p>

<p>Without a StdoutEvent, StdoutFilter is illegal.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="StderrFilter"
>StderrFilter</a></h4>

<p>StderrFilter may be used to specify a filter for a child process&#39; STDERR output. If omitted, POE::Wheel::Run will create and use its own POE::Filter::Line instance, but only if a StderrEvent is specified.</p>

<p>Without a StderrEvent, StderrFilter is illegal.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="Group"
>Group</a></h4>

<p>Group contains a numeric group ID that the child process should run within. By default, the child process will run in the same group as the parent.</p>

<p>Group is not fully portable. It may not work on systems that have no concept of user groups. Also, the parent process may need to run with elevated privileges for the child to be able to change groups.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="User"
>User</a></h4>

<p>User contains a numeric user ID that should own the child process. By default, the child process will run as the same user as the parent.</p>

<p>User is not fully portable. It may not work on systems that have no concept of users. Also, the parent process may need to run with elevated privileges for the child to be able to change users.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="NoSetSid"
>NoSetSid</a></h4>

<p>When true, NoSetSid disables setsid() in the child process. By default, the child process calls setsid() is called so that it may execute in a separate UNIX session.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="NoSetPgrp"
>NoSetPgrp</a></h4>

<p>When true, NoSetPgrp disables setprgp() in the child process. By default, the child process calls setpgrp() to change its process group, if the OS supports that.</p>

<p>setsid() is used instead of setpgrp() if Conduit is pty or pty-pipe. See <a href="#NoSetSid" class="podlinkpod"
>&#34;NoSetSid&#34;</a>.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="Priority"
>Priority</a></h4>

<p>Priority adjusts the child process&#39; niceness or priority level, depending on which (if any) the underlying OS supports. Priority contains a numeric offset which will be added to the parent&#39;s priority to determine the child&#39;s.</p>

<p>The priority offset may be negative, which in UNIX represents a higher priority. However UNIX requires elevated privileges to increase a process&#39; priority.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="Program"
>Program</a></h4>

<p>Program specifies the program to exec() or the block of code to run in the child process. Program&#39;s type is significant.</p>

<p>If Program holds a scalar, its value will be executed as exec($program). Shell metacharacters are significant, per exec(SCALAR) semantics.</p>

<p>If Program holds an array reference, it will executed as exec(@$program). As per exec(ARRAY), shell metacharacters will not be significant.</p>

<p>If Program holds a code reference, that code will be called in the child process. This mode allows POE::Wheel::Run to execute long-running internal code asynchronously, while the usual modes execute external programs. The child process will exit after that code is finished, in such a way as to avoid DESTROY and END block execution. See <a href="#Coderef_Execution_Side_Effects" class="podlinkpod"
>&#34;Coderef Execution Side Effects&#34;</a> for more details.</p>

<p><a href="../../perlfunc.html" class="podlinkpod"
>perlfunc</a> has more information about exec() and the different ways to call it.</p>

<p>Please avoid calling exit() explicitly when executing a subroutine. The child process inherits all objects from the parent, including ones that may perform side effects. POE::Wheel::Run takes special care to avoid object destructors and END blocks in the child process, but calling exit() will trigger them.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="ProgramArgs"
>ProgramArgs</a></h4>

<p>If specified, ProgramArgs should refer to a list of parameters for the program being run.</p>

<pre>  my @parameters = qw(foo bar baz);  # will be passed to Program
  ProgramArgs =&#62; \@parameters;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="event_EVENT_TYPE_=&#62;_EVENT_NAME,_..."
>event EVENT_TYPE =&#62; EVENT_NAME, ...</a></h2>

<p>event() allows programs to change the events that Wheel::Run emits when certain activities occurs. EVENT_TYPE may be one of the event parameters described in POE::Wheel::Run&#39;s constructor.</p>

<p>This example changes the events that $wheel emits for STDIN flushing and STDOUT activity:</p>

<pre>  $wheel-&#62;event(
    StdinEvent  =&#62; &#39;new-stdin-event&#39;,
    StdoutEvent =&#62; &#39;new-stdout-event&#39;,
  );</pre>

<p>Undefined EVENT_NAMEs disable events.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="put_RECORDS"
>put RECORDS</a></h2>

<p>put() queues up a list of RECORDS that will be sent to the child process&#39; STDIN filehandle. These records will first be serialized according to the wheel&#39;s StdinFilter. The serialized RECORDS will be flushed asynchronously once the current event handler returns.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_stdin_filter"
>get_stdin_filter</a></h2>

<p>get_stind_filter() returns the POE::Filter object currently being used to serialize put() records for the child&#39;s STDIN filehandle. The return object may be used according to its own interface.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_stdout_filter"
>get_stdout_filter</a></h2>

<p>get_stdout_filter() returns the POE::Filter object currently being used to parse what the child process writes to STDOUT.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_stderr_filter"
>get_stderr_filter</a></h2>

<p>get_stderr_filter() returns the POE::Filter object currently being used to parse what the child process writes to STDERR.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="set_stdio_filter_FILTER_OBJECT"
>set_stdio_filter FILTER_OBJECT</a></h2>

<p>Set StdinFilter and StdoutFilter to the same new FILTER_OBJECT. Unparsed STDOUT data will be parsed later by the new FILTER_OBJECT. However, data already put() will remain serialized by the old filter.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="set_stdin_filter_FILTER_OBJECT"
>set_stdin_filter FILTER_OBJECT</a></h2>

<p>Set StdinFilter to a new FILTER_OBJECT. Data already put() will remain serialized by the old filter.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="set_stdout_filter_FILTER_OBJECT"
>set_stdout_filter FILTER_OBJECT</a></h2>

<p>Set StdoutFilter to a new FILTER_OBJECT. Unparsed STDOUT data will be parsed later by the new FILTER_OBJECT.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="set_stderr_filter_FILTER_OBJECT"
>set_stderr_filter FILTER_OBJECT</a></h2>

<p>Set StderrFilter to a new FILTER_OBJECT. Unparsed STDERR data will be parsed later by the new FILTER_OBJECT.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="pause_stdout"
>pause_stdout</a></h2>

<p>Pause reading of STDOUT from the child. The child process may block if the STDOUT IPC conduit fills up. Reading may be resumed with resume_stdout().</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="pause_stderr"
>pause_stderr</a></h2>

<p>Pause reading of STDERR from the child. The child process may block if the STDERR IPC conduit fills up. Reading may be resumed with resume_stderr().</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="resume_stdout"
>resume_stdout</a></h2>

<p>Resume reading from the child&#39;s STDOUT filehandle. This is only meaningful if pause_stdout() has been called and remains in effect.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="resume_stderr"
>resume_stderr</a></h2>

<p>Resume reading from the child&#39;s STDERR filehandle. This is only meaningful if pause_stderr() has been called and remains in effect.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="shutdown_stdin"
>shutdown_stdin</a></h2>

<p>shutdown_stdin() closes the child process&#39; STDIN and stops the wheel from reporting StdinEvent. It is extremely useful for running utilities that expect to receive EOF on STDIN before they respond.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ID"
>ID</a></h2>

<p>ID() returns the wheel&#39;s unique ID. Every event generated by a POE::Wheel::Run object includes a wheel ID so that it can be matched to the wheel that emitted it. This lets a single session manage several wheels without becoming confused about which one generated what event.</p>

<p>ID() is not the same as PID().</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="PID"
>PID</a></h2>

<p>PID() returns the process ID for the child represented by the POE::Wheel::Run object. It&#39;s often used as a parameter to sig_child().</p>

<p>PID() is not the same as ID().</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="kill_SIGNAL"
>kill SIGNAL</a></h2>

<p>POE::Wheel::Run&#39;s kill() method sends a SIGNAL to the child process the object represents. kill() is often used to force a reluctant program to terminate. SIGNAL is one of the operating signal names present in %SIG.</p>

<p>kill() returns the number of processes successfully signaled: 1 on success, or 0 on failure, since the POE::Wheel::Run object only affects at most a single process.</p>

<p>kill() sends SIGTERM if SIGNAL is undef or omitted.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_driver_out_messages"
>get_driver_out_messages</a></h2>

<p>get_driver_out_messages() returns the number of put() records remaining in whole or in part in POE::Wheel::Run&#39;s POE::Driver output queue. It is often used to tell whether the wheel has more input for the child process.</p>

<p>In most cases, StdinEvent may be used to trigger activity when all data has been sent to the child process.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="get_driver_out_octets"
>get_driver_out_octets</a></h2>

<p>get_driver_out_octets() returns the number of serialized octets remaining in POE::Wheel::Run&#39;s POE::Driver output queue. It is often used to tell whether the wheel has more input for the child process.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TIPS_AND_TRICKS"
>TIPS AND TRICKS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="MSWin32_Support"
>MSWin32 Support</a></h2>

<p>In the past POE::Wheel::Run did not support MSWin32 and users had to use custom work-arounds. Then Chris Williams ( BINGOS ) arrived and saved the day with his <a href="../../POE/Wheel/Run/Win32.html" class="podlinkpod"
>POE::Wheel::Run::Win32</a> module. After some testing, it was decided to merge the win32 code into POE::Wheel::Run. Everyone was happy!</p>

<p>However, after some investigation Apocalypse ( APOCAL ) found out that in some situations it still didn&#39;t behave properly. The root cause was that the win32 code path in POE::Wheel::Run didn&#39;t exit cleanly. This means DESTROY and END blocks got executed! After talking with more people, the solution was not pretty.</p>

<p>The problem is that there is no equivalent of POSIX::_exit() for MSWin32. Hopefully, in a future version of Perl this can be fixed! In the meantime, POE::Wheel::Run will use CORE::kill() to terminate the child. However, this comes with a caveat: you will leak around 1KB per exec. The code has been improved so the chance of this happening has been reduced.</p>

<p>As of now the most reliable way to trigger this is to exec an invalid binary. The definition of &#34;invalid binary&#34; depends on different things, but what it means is that Win32::Job-&#62;spawn() failed to run. This will force POE::Wheel::Run to use the workaround to exit the child. If this happens, a very big warning will be printed to the STDERR of the child and the parent process will receive it.</p>

<p>If you are a Perl MSWin32 hacker, PLEASE help us with this situation! Go read rt.cpan.org bug #56417 and talk with us/p5p to see where you can contribute.</p>

<p>Thanks again for your patience as we continue to improve POE::Wheel::Run on MSWin32!</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="kill()_and_ClosedEvent_on_Windows"
>kill() and ClosedEvent on Windows</a></h3>

<p>Windows will often fail to report EOF on pipes when subprocesses are killed. The work-around is to catch the signal in the subprocess, and exit normally:</p>

<pre>  my $child = POE::Wheel::Run-&#62;new(
    Program =&#62; sub {
      $SIG{INT} = sub { exit };
      ...;
    },
    ...,
  );</pre>

<p>Be sure to kill() the subprocess using the same signal that it catches and exits upon. Remember, not all signals can be caught by user code.</p>

<pre>  $child-&#62;kill(&#34;INT&#34;);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Execution_Environment"
>Execution Environment</a></h2>

<p>It&#39;s common to scrub a child process&#39; environment, so that only required, secure values exist. This amounts to clearing the contents of %ENV and repopulating it.</p>

<p>Environment scrubbing is easy when the child process is running a subroutine, but it&#39;s not so easy---or at least not as intuitive---when executing external programs.</p>

<p>The way we do it is to run a small subroutine in the child process that performs the exec() call for us.</p>

<pre>  Program =&#62; \&#38;exec_with_scrubbed_env,

  sub exec_with_scrubbed_env {
    delete @ENV{keys @ENV};
    $ENV{PATH} = &#34;/bin&#34;;
    exec(@program_and_args);
  }</pre>

<p>That deletes everything from the environment and sets a simple, secure PATH before executing a program.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Coderef_Execution_Side_Effects"
>Coderef Execution Side Effects</a></h2>

<p>The child process is created by fork(), which duplicates the parent process including a copy of POE::Kernel, all running Session instances, events in the queue, watchers, open filehandles, and so on.</p>

<p>When executing an external program, the UNIX exec() call immediately replaces the copy of the parent with a completely new program.</p>

<p>When executing internal coderefs, however, we must preserve the code and any memory it might reference. This leads to some potential side effects.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="DESTROY_and_END_Blocks_Run_Twice"
>DESTROY and END Blocks Run Twice</a></h3>

<p>Objects that were created in the parent process are copied into the child. When the child exits normally, any DESTROY and END blocks are executed there. Later, when the parent exits, they may run again.</p>

<p>POE::Wheel::Run takes steps to avoid running DESTROY and END blocks in the child process. It uses POSIX::_exit() to bypass them. If that fails, it may even kill() itself.</p>

<p>If an application needs to exit explicitly, for example to return an error code to the parent process, then please use POSIX::_exit() rather than Perl&#39;s core exit().</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="POE::Kernel&#39;s_run()_method_was_never_called"
>POE::Kernel&#39;s run() method was never called</a></h3>

<p>This warning is displayed from POE::Kernel&#39;s DESTROY method. It&#39;s a side effect of calling exit() in a child process that was started before <code>POE::Kernel-&#62;run()</code> could be called. The child process receives a copy of POE::Kernel where run() wasn&#39;t called, even if it was called later in the parent process.</p>

<p>The most direct solution is to call POSIX::_exit() rather than exit(). This will bypass POE::Kernel&#39;s DESTROY, and the message it emits.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Running_POE::Kernel_in_the_Child"
>Running POE::Kernel in the Child</a></h3>

<p>Calling <code>POE::Kernel-&#62;run()</code> in the child process effectively resumes the copy of the parent process. This is rarely (if ever) desired.</p>

<p>More commonly, an application wants to run an entirely new POE::Kernel instance in the child process. This is supported by first stop()ping the copied instance, starting one or more new sessions, and calling run() again. For example:</p>

<pre>  Program =&#62; sub {
    # Wipe the existing POE::Kernel clean.
    $poe_kernel-&#62;stop();

    # Start a new session, or more.
    POE::Session-&#62;create(
      ...
    );

    # Run the new sessions.
    POE::Kernel-&#62;run();
  }</pre>

<p>Strange things are bound to happen if the program does not call <a href="../../POE/Kernel.html#stop" class="podlinkpod"
>&#34;stop&#34; in POE::Kernel</a> before <a href="../../POE/Kernel.html#run" class="podlinkpod"
>&#34;run&#34; in POE::Kernel</a>. However this is vaguely supported in case it&#39;s the right thing to do at the time.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../../POE/Wheel.html" class="podlinkpod"
>POE::Wheel</a> describes wheels in general.</p>

<p>The SEE ALSO section in <a href="../../POE.html" class="podlinkpod"
>POE</a> contains a table of contents covering the entire POE distribution.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CAVEATS_&#38;_TODOS"
>CAVEATS &#38; TODOS</a></h1>

<p>POE::Wheel::Run&#39;s constructor should emit proper events when it fails. Instead, it just dies, carps or croaks. This isn&#39;t necessarily bad; a program can trap the death in new() and move on.</p>

<p>Priority is a delta, not an absolute niceness value.</p>

<p>It might be nice to specify User by name rather than just UID.</p>

<p>It might be nice to specify Group by name rather than just GID.</p>

<p>POE::Pipe::OneWay and Two::Way don&#39;t require the rest of POE. They should be spun off into a separate distribution for everyone to enjoy.</p>

<p>If StdinFilter and StdoutFilter seem backwards, remember that it&#39;s the filters for the child process. StdinFilter is the one that dictates what the child receives on STDIN. StdoutFilter tells the parent how to parse the child&#39;s STDOUT.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS_&#38;_COPYRIGHTS"
>AUTHORS &#38; COPYRIGHTS</a></h1>

<p>Please see <a href="../../POE.html" class="podlinkpod"
>POE</a> for more information about authors and contributors.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
