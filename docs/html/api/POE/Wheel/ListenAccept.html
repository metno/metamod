<html><head><title>POE::Wheel::ListenAccept</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:26 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#PUBLIC_METHODS'>PUBLIC METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#new'>new</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Handle'>Handle</a>
      <li class='indexItem indexItem3'><a href='#AcceptEvent'>AcceptEvent</a>
      <li class='indexItem indexItem3'><a href='#ErrorEvent'>ErrorEvent</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#event'>event</a>
    <li class='indexItem indexItem2'><a href='#ID'>ID</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#PUBLIC_EVENTS'>PUBLIC EVENTS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#AcceptEvent'>AcceptEvent</a>
    <li class='indexItem indexItem2'><a href='#ErrorEvent'>ErrorEvent</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS_%26_COPYRIGHTS'>AUTHORS &#38; COPYRIGHTS</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>POE::Wheel::ListenAccept - accept connections from regular listening sockets</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<p>See <a href="../../POE/Wheel/SocketFactory.html#SYNOPSIS" class="podlinkpod"
>&#34;SYNOPSIS&#34; in POE::Wheel::SocketFactory</a> for a simpler version of this program.</p>

<pre>  #!perl

  use warnings;
  use strict;

  use IO::Socket;
  use POE qw(Wheel::ListenAccept Wheel::ReadWrite);

  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub {
        # Start the server.
        $_[HEAP]{server} = POE::Wheel::ListenAccept-&#62;new(
          Handle =&#62; IO::Socket::INET-&#62;new(
            LocalPort =&#62; 12345,
            Listen =&#62; 5,
          ),
          AcceptEvent =&#62; &#34;on_client_accept&#34;,
          ErrorEvent =&#62; &#34;on_server_error&#34;,
        );
      },
      on_client_accept =&#62; sub {
        # Begin interacting with the client.
        my $client_socket = $_[ARG0];
        my $io_wheel = POE::Wheel::ReadWrite-&#62;new(
          Handle =&#62; $client_socket,
          InputEvent =&#62; &#34;on_client_input&#34;,
          ErrorEvent =&#62; &#34;on_client_error&#34;,
        );
        $_[HEAP]{client}{ $io_wheel-&#62;ID() } = $io_wheel;
      },
      on_server_error =&#62; sub {
        # Shut down server.
        my ($operation, $errnum, $errstr) = @_[ARG0, ARG1, ARG2];
        warn &#34;Server $operation error $errnum: $errstr\n&#34;;
        delete $_[HEAP]{server};
      },
      on_client_input =&#62; sub {
        # Handle client input.
        my ($input, $wheel_id) = @_[ARG0, ARG1];
        $input =~ tr[a-zA-Z][n-za-mN-ZA-M]; # ASCII rot13
        $_[HEAP]{client}{$wheel_id}-&#62;put($input);
      },
      on_client_error =&#62; sub {
        # Handle client error, including disconnect.
        my $wheel_id = $_[ARG3];
        delete $_[HEAP]{client}{$wheel_id};
      },
    }
  );

  POE::Kernel-&#62;run();
  exit;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>POE::Wheel::ListenAccept implements non-blocking accept() calls for plain old listening server sockets. The application provides the socket, using some normal means such as socket(), IO::Socket::INET, or IO::Socket::UNIX. POE::Wheel::ListenAccept monitors the listening socket and emits events whenever a new client has been accepted.</p>

<p>Please see <a href="../../POE/Wheel/SocketFactory.html" class="podlinkpod"
>POE::Wheel::SocketFactory</a> if you need non-blocking connect() or a more featureful listen/accept solution.</p>

<p>POE::Wheel::ListenAccept only accepts client connections. It does not read or write data, so it neither needs nor includes a put() method. <a href="../../POE/Wheel/ReadWrite.html" class="podlinkpod"
>POE::Wheel::ReadWrite</a> generally handles the accepted client socket.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PUBLIC_METHODS"
>PUBLIC METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="new"
>new</a></h2>

<p>new() creates a new POE::Wheel::ListenAccept object for a given listening socket. The object will generate events relating to the socket for as long as it exists.</p>

<p>new() accepts two required named parameters:</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Handle"
>Handle</a></h3>

<p>The <code>Handle</code> constructor parameter must contain a listening socket handle. POE::Wheel::FollowTail will monitor this socket and accept() new connections as they arrive.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="AcceptEvent"
>AcceptEvent</a></h3>

<p><code>AcceptEvent</code> is a required event name that POE::Wheel::ListenAccept will emit for each accepted client socket. <a href="#PUBLIC_EVENTS" class="podlinkpod"
>&#34;PUBLIC EVENTS&#34;</a> describes it in detail</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="ErrorEvent"
>ErrorEvent</a></h3>

<p><code>ErrorEvent</code> is an optional event name that will be emitted whenever a serious problem occurs. Please see <a href="#PUBLIC_EVENTS" class="podlinkpod"
>&#34;PUBLIC EVENTS&#34;</a> for more details.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="event"
>event</a></h2>

<p>event() allows a session to change the events emitted by a wheel without destroying and re-creating the object. It accepts one or more of the events listed in <a href="#PUBLIC_EVENTS" class="podlinkpod"
>&#34;PUBLIC EVENTS&#34;</a>. Undefined event names disable those events.</p>

<p>Ignore connections:</p>

<pre>  sub ignore_new_connections {
    $_[HEAP]{tailor}-&#62;event( AcceptEvent =&#62; &#34;on_ignored_accept&#34; );
  }

  sub handle_ignored_accept {
    # does nothing
  }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ID"
>ID</a></h2>

<p>The ID() method returns the wheel&#39;s unique ID. It&#39;s useful for storing the wheel in a hash. All POE::Wheel events should be accompanied by a wheel ID, which allows the wheel to be referenced in their event handlers.</p>

<pre>  sub setup_listener {
    my $wheel = POE::Wheel::ListenAccept-&#62;new(... etc  ...);
    $_[HEAP]{listeners}{$wheel-&#62;ID} = $wheel;
  }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PUBLIC_EVENTS"
>PUBLIC EVENTS</a></h1>

<p>POE::Wheel::ListenAccept emits a couple events.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="AcceptEvent"
>AcceptEvent</a></h2>

<p><code>AcceptEvent</code> names the event that will be emitted for each newly accepted client socket. It is accompanied by three parameters:</p>

<p><code>$_[ARG0]</code> contains the newly accepted client socket handle. It&#39;s up to the application to do something with this socket. Most use cases involve passing the socket to a <a href="../../POE/Wheel/ReadWrite.html" class="podlinkpod"
>POE::Wheel::ReadWrite</a> constructor.</p>

<p><code>$_[ARG1]</code> contains the accept() call&#39;s return value, which is often the encoded remote end of the remote end of the socket.</p>

<p><code>$_[ARG2]</code> contains the POE::Wheel::ListenAccept object&#39;s unique ID. This is the same value as returned by the wheel&#39;s ID() method.</p>

<p>A sample <code>AcceptEvent</code> handler:</p>

<pre>  sub accept_state {
    my ($client_socket, $remote_addr, $wheel_id) = @_[ARG0..ARG2];

    # Make the remote address human readable.
    my ($port, $packed_ip) = sockaddr_in($remote_addr);
    my $dotted_quad = inet_ntoa($packed_ip);

    print(
      &#34;Wheel $wheel_id accepted a connection from &#34;,
      &#34;$dotted_quad port $port.\n&#34;
    );

    # Spawn off a session to interact with the socket.
    create_server_session($handle);
  }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ErrorEvent"
>ErrorEvent</a></h2>

<p><code>ErrorEvent</code> names the event that will be generated whenever a new connection could not be successfully accepted. This event is accompanied by four parameters:</p>

<p><code>$_[ARG0]</code> contains the name of the operation that failed. This usually is &#39;accept&#39;, but be aware that it&#39;s not necessarily a function name.</p>

<p><code>$_[ARG1]</code> and <code>$_[ARG2]</code> hold the numeric and stringified values of <code>$!</code>, respectively. POE::Wheel::ListenAccept knows how to handle EAGAIN (and system-dependent equivalents), so this error will never be returned.</p>

<p><code>$_[ARG3]</code> contains the wheel&#39;s unique ID, which may be useful for shutting down one particular wheel out of a group of them.</p>

<p>A sample <code>ErrorEvent</code> event handler. This assumes the wheels are saved as in the <a href="#ID" class="podlinkpod"
>&#34;ID&#34;</a> example.</p>

<pre>  sub error_state {
    my ($operation, $errnum, $errstr, $wheel_id) = @_[ARG0..ARG3];
    warn &#34;Wheel $wheel_id generated $operation error $errnum: $errstr\n&#34;;
    delete $_[HEAP]{listeners}{$wheel_id};
  }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../../POE/Wheel.html" class="podlinkpod"
>POE::Wheel</a> describes the basic operations of all wheels in more depth. You need to know this.</p>

<p><a href="../../POE/Wheel/ReadWrite.html" class="podlinkpod"
>POE::Wheel::ReadWrite</a> for one possible way to handle clients once you have their sockets.</p>

<p>The SEE ALSO section in <a href="../../POE.html" class="podlinkpod"
>POE</a> contains a table of contents covering the entire POE distribution.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>None known.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS_&#38;_COPYRIGHTS"
>AUTHORS &#38; COPYRIGHTS</a></h1>

<p>Please see <a href="../../POE.html" class="podlinkpod"
>POE</a> for more information about authors and contributors.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
