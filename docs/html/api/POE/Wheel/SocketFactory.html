<html><head><title>POE::Wheel::SocketFactory</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:26 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#PUBLIC_METHODS'>PUBLIC METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#new'>new</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Creating_the_Socket'>Creating the Socket</a>
      <ul   class='indexList indexList4'>
        <li class='indexItem indexItem4'><a href='#SocketDomain'>SocketDomain</a>
        <li class='indexItem indexItem4'><a href='#SocketType'>SocketType</a>
        <li class='indexItem indexItem4'><a href='#SocketProtocol'>SocketProtocol</a>
      </ul>
      <li class='indexItem indexItem3'><a href='#Setting_Socket_Options'>Setting Socket Options</a>
      <ul   class='indexList indexList4'>
        <li class='indexItem indexItem4'><a href='#Reuse'>Reuse</a>
      </ul>
      <li class='indexItem indexItem3'><a href='#Bind_the_Socket_to_an_Address_and_Port'>Bind the Socket to an Address and Port</a>
      <ul   class='indexList indexList4'>
        <li class='indexItem indexItem4'><a href='#BindAddress'>BindAddress</a>
        <li class='indexItem indexItem4'><a href='#BindPort'>BindPort</a>
      </ul>
      <li class='indexItem indexItem3'><a href='#Connectionless_Sockets'>Connectionless Sockets</a>
      <li class='indexItem indexItem3'><a href='#Connecting_the_Socket_to_a_Remote_Endpoint'>Connecting the Socket to a Remote Endpoint</a>
      <ul   class='indexList indexList4'>
        <li class='indexItem indexItem4'><a href='#RemoteAddress'>RemoteAddress</a>
        <li class='indexItem indexItem4'><a href='#RemotePort'>RemotePort</a>
      </ul>
      <li class='indexItem indexItem3'><a href='#Listening_for_Connections'>Listening for Connections</a>
      <ul   class='indexList indexList4'>
        <li class='indexItem indexItem4'><a href='#ListenQueue'>ListenQueue</a>
      </ul>
      <li class='indexItem indexItem3'><a href='#Emitting_Events'>Emitting Events</a>
      <ul   class='indexList indexList4'>
        <li class='indexItem indexItem4'><a href='#SuccessEvent'>SuccessEvent</a>
        <li class='indexItem indexItem4'><a href='#FailureEvent'>FailureEvent</a>
      </ul>
    </ul>
    <li class='indexItem indexItem2'><a href='#event'>event</a>
    <li class='indexItem indexItem2'><a href='#getsockname'>getsockname</a>
    <li class='indexItem indexItem2'><a href='#ID'>ID</a>
    <li class='indexItem indexItem2'><a href='#pause_accept'>pause_accept</a>
    <li class='indexItem indexItem2'><a href='#resume_accept'>resume_accept</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#PUBLIC_EVENTS'>PUBLIC EVENTS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#SuccessEvent'>SuccessEvent</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Common_SuccessEvent_Parameters'>Common SuccessEvent Parameters</a>
      <li class='indexItem indexItem3'><a href='#INET_SuccessEvent_Parameters'>INET SuccessEvent Parameters</a>
      <li class='indexItem indexItem3'><a href='#UNIX_Client_SuccessEvent_Parameters'>UNIX Client SuccessEvent Parameters</a>
      <li class='indexItem indexItem3'><a href='#UNIX_Server_SuccessEvent_Parameters'>UNIX Server SuccessEvent Parameters</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#FailureEvent'>FailureEvent</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS_%26_COPYRIGHTS'>AUTHORS &#38; COPYRIGHTS</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>POE::Wheel::SocketFactory - non-blocking socket creation</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<p>See <a href="../../POE/Component/Server/TCP.html#SYNOPSIS" class="podlinkpod"
>&#34;SYNOPSIS&#34; in POE::Component::Server::TCP</a> for a much simpler version of this program.</p>

<pre>  #!perl

  use warnings;
  use strict;

  use IO::Socket;
  use POE qw(Wheel::SocketFactory Wheel::ReadWrite);

  POE::Session-&#62;create(
    inline_states =&#62; {
      _start =&#62; sub {
        # Start the server.
        $_[HEAP]{server} = POE::Wheel::SocketFactory-&#62;new(
          BindPort =&#62; 12345,
          SuccessEvent =&#62; &#34;on_client_accept&#34;,
          FailureEvent =&#62; &#34;on_server_error&#34;,
        );
      },
      on_client_accept =&#62; sub {
        # Begin interacting with the client.
        my $client_socket = $_[ARG0];
        my $io_wheel = POE::Wheel::ReadWrite-&#62;new(
          Handle =&#62; $client_socket,
          InputEvent =&#62; &#34;on_client_input&#34;,
          ErrorEvent =&#62; &#34;on_client_error&#34;,
        );
        $_[HEAP]{client}{ $io_wheel-&#62;ID() } = $io_wheel;
      },
      on_server_error =&#62; sub {
        # Shut down server.
        my ($operation, $errnum, $errstr) = @_[ARG0, ARG1, ARG2];
        warn &#34;Server $operation error $errnum: $errstr\n&#34;;
        delete $_[HEAP]{server};
      },
      on_client_input =&#62; sub {
        # Handle client input.
        my ($input, $wheel_id) = @_[ARG0, ARG1];
        $input =~ tr[a-zA-Z][n-za-mN-ZA-M]; # ASCII rot13
        $_[HEAP]{client}{$wheel_id}-&#62;put($input);
      },
      on_client_error =&#62; sub {
        # Handle client error, including disconnect.
        my $wheel_id = $_[ARG3];
        delete $_[HEAP]{client}{$wheel_id};
      },
    }
  );

  POE::Kernel-&#62;run();
  exit;</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>POE::Wheel::SocketFactory creates sockets upon demand. It can create connectionless UDP sockets, but it really shines for client/server work where establishing connections normally would block.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PUBLIC_METHODS"
>PUBLIC METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="new"
>new</a></h2>

<p>new() creates a new POE::Wheel::SocketFactory object. For sockets which listen() for and accept() connections, the wheel will generate new sockets for each accepted client. Socket factories for one-shot sockets, such as UDP peers or clients established by connect() only emit a single socket and can be destroyed afterwards without ill effects.</p>

<p>new() always returns a POE::Wheel::SocketFactory object even if it fails to establish the socket. This allows the object to be queried after it has sent its session a <code>FailureEvent</code>.</p>

<p>new() accepts a healthy number of named parameters, each governing some aspect of socket creation.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Creating_the_Socket"
>Creating the Socket</a></h3>

<p>Socket creation is done with Perl&#39;s built-in socket() function. The new() parameters beginning with <code>Socket</code> determine how socket() will be called.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="SocketDomain"
>SocketDomain</a></h4>

<p><code>SocketDomain</code> instructs the wheel to create a socket within a particular domain. Supported domains are <code>AF_UNIX</code>, <code>AF_INET</code>, <code>AF_INET6</code>, <code>PF_UNIX</code>, <code>PF_INET</code>, and <code>PF_INET6</code>. If omitted, the socket will be created in the <code>AF_INET</code> domain.</p>

<p>POE::Wheel::SocketFactory contains a table of supported domains and the instructions needed to create them. Please send patches to support additional domains, as needed.</p>

<p>Note: <code>AF_INET6</code> and <code>PF_INET6</code> are supplied by the <a href="../../Socket.html" class="podlinkpod"
>Socket</a> module included in Perl 5.8.0 or later. Perl versions before 5.8.0 should not attempt to use IPv6 until someone contributes a workaround.</p>

<p>IPv6 support requires a 21st century Socket module and the presence of Socket::GetAddrInfo to resolve host names to IPv6 addresses.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="SocketType"
>SocketType</a></h4>

<p><code>SocketType</code> supplies the socket() call with a particular socket type, which may be <code>SOCK_STREAM</code> or <code>SOCK_DGRAM</code>. <code>SOCK_STREAM</code> is the default if <code>SocketType</code> is not supplied.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="SocketProtocol"
>SocketProtocol</a></h4>

<p><code>SocketProtocol</code> sets the socket() call&#39;s protocol. Protocols may be specified by number or name. <code>SocketProtocol</code> is ignored for UNIX domain sockets.</p>

<p>The protocol defaults to &#34;tcp&#34; for INET domain sockets. There is no default for other socket domains.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Setting_Socket_Options"
>Setting Socket Options</a></h3>

<p>POE::Wheel::SocketFactory uses ioctl(), fcntl() and setsockopt() to set socket options after the socket is created. All sockets are set non-blocking, and bound sockets may be made reusable.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="Reuse"
>Reuse</a></h4>

<p>When set, the <code>Reuse</code> parameter allows a bound port to be reused immediately. <code>Reuse</code> is considered enabled if it contains &#34;yes&#34;, &#34;on&#34;, or a true numeric value. All other values disable port reuse, as does omitting <code>Reuse</code> entirely.</p>

<p>For security purposes, a port cannot be reused for a minute or more after a server has released it. This gives clients time to realize the port has been abandoned. Otherwise a malicious service may snatch up the port and spoof the legitimate service.</p>

<p>It&#39;s also terribly annoying to wait a minute or more between server invocations, especially during development.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Bind_the_Socket_to_an_Address_and_Port"
>Bind the Socket to an Address and Port</a></h3>

<p>A socket may optionally be bound to a specific interface and port. The <code>INADDR_ANY</code> address may be used to bind to a specific port across all interfaces.</p>

<p>Sockets are bound using bind(). POE::Wheel::SocketFactory parameters beginning with <code>Bind</code> control how bind() is called.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="BindAddress"
>BindAddress</a></h4>

<p><code>BindAddress</code> sets an address to bind the socket&#39;s local endpoint to. <code>INADDR_ANY</code> will be used if <code>BindAddress</code> is not specified.</p>

<p><code>BindAddress</code> may contain either a string or a packed Internet address (for &#34;INET&#34; domain sockets). The string parameter should be a dotted numeric address or a resolvable host name. Note that the host name will be resolved with a blocking call. If this is not desired, use POE::Component::Client::DNS to perform a non-blocking name resolution.</p>

<p>When used to bind a &#34;UNIX&#34; domain socket, <code>BindAddress</code> should contain a path describing the socket&#39;s filename. This is required for server sockets and datagram client sockets. <code>BindAddress</code> has no default value for UNIX sockets.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="BindPort"
>BindPort</a></h4>

<p><code>BindPort</code> is only meaningful for &#34;INET&#34; domain sockets. It contains a port on the <code>BindAddress</code> interface where the socket will be bound. It defaults to 0 if omitted, which will cause the bind() call to choose an indeterminate unallocated port.</p>

<p><code>BindPort</code> may be a port number or a name that can be looked up in the system&#39;s services (or equivalent) database.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Connectionless_Sockets"
>Connectionless Sockets</a></h3>

<p>Connectionless sockets may interact with remote endpoints without needing to listen() for connections or connect() to remote addresses.</p>

<p>This class of sockets is complete after the bind() call.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Connecting_the_Socket_to_a_Remote_Endpoint"
>Connecting the Socket to a Remote Endpoint</a></h3>

<p>A socket may either listen for connections to arrive, initiate connections to a remote endpoint, or be connectionless (such as in the case of UDP sockets).</p>

<p>POE::Wheel::SocketFactory will initiate a client connection when new() is capped with parameters that describe a remote endpoint. In all other cases, the socket will either listen for connections or be connectionless depending on the socket type.</p>

<p>The following parameters describe a socket&#39;s remote endpoint. They determine how POE::Wheel::SocketFactory will call Perl&#39;s built-in connect() function.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="RemoteAddress"
>RemoteAddress</a></h4>

<p><code>RemoteAddress</code> specifies the remote address to which a socket should connect. If present, POE::Wheel::SocketFactory will create a client socket that attempts to collect to the <code>RemoteAddress</code>. Otherwise, if the protocol warrants it, the wheel will create a listening socket and attempt to accept connections.</p>

<p>As with the bind address, <code>RemoteAddress</code> may be a string containing a dotted quad or a resolvable host name. It may also be a packed Internet address, or a UNIX socket path. It will be packed, with or without an accompanying <code>RemotePort</code>, as necessary for the socket domain.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="RemotePort"
>RemotePort</a></h4>

<p><code>RemotePort</code> is the port to which the socket should connect. It is required for &#34;INET&#34; client sockets, since the remote endpoint must contain both an address and a port.</p>

<p>The remote port may be numeric, or it may be a symbolic name found in /etc/services or the equivalent for your operating system.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Listening_for_Connections"
>Listening for Connections</a></h3>

<p>Streaming sockets that have no remote endpoint are considered to be server sockets. POE::Wheel::SocketFactory will listen() for connections to these sockets, accept() the new clients, and send the application events with the new client sockets.</p>

<p>POE::Wheel::SocketFactory constructor parameters beginning with <code>Listen</code> control how the listen() function is called.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="ListenQueue"
>ListenQueue</a></h4>

<p><code>ListenQueue</code> specifies the length of the socket&#39;s listen() queue. It defaults to <code>SOMAXCONN</code> if omitted. <code>ListenQueue</code> values greater than <code>SOMAXCONN</code> will be clipped to <code>SOMAXCONN</code>. Excessively large <code>ListenQueue</code> values are not necessarily portable, and may cause errors in some rare cases.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Emitting_Events"
>Emitting Events</a></h3>

<p>POE::Wheel::SocketFactory emits a small number of events depending on what happens during socket setup or while listening for new connections.</p>

<p>See <a href="#PUBLIC_EVENTS" class="podlinkpod"
>&#34;PUBLIC EVENTS&#34;</a> for more details.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="SuccessEvent"
>SuccessEvent</a></h4>

<p><code>SuccessEvent</code> names the event that will be emitted whenever POE::Wheel::SocketFactory succeeds in creating a new socket.</p>

<p>For connectionless sockets, <code>SuccessEvent</code> happens just after the socket is created.</p>

<p>For client connections, <code>SuccessEvent</code> is fired when the connection has successfully been established with the remote endpoint.</p>

<p>Server sockets emit a <code>SuccessEvent</code> for every successfully accepted client.</p>

<h4><a class='u' href='#___top' title='click to go to top of document'
name="FailureEvent"
>FailureEvent</a></h4>

<p><code>FailureEvent</code> names the event POE::Wheel::SocketFactory will emit whenever something goes wrong. It usually represents some kind of built-in function call error. See <a href="#PUBLIC_EVENTS" class="podlinkpod"
>&#34;PUBLIC EVENTS&#34;</a> for details, as some errors are handled internally by this wheel.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="event"
>event</a></h2>

<p>event() allows a session to change the events emitted by a wheel without destroying and re-creating the wheel. It accepts one or more of the events listed in <a href="#PUBLIC_EVENTS" class="podlinkpod"
>&#34;PUBLIC EVENTS&#34;</a>. Undefined event names disable those events.</p>

<p>event() is described in more depth in <a href="../../POE/Wheel.html" class="podlinkpod"
>POE::Wheel</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="getsockname"
>getsockname</a></h2>

<p>getsockname() behaves like the built-in function of the same name. It returns the local endpoint information for POE::Wheel::SocketFactory&#39;s encapsulated listening socket.</p>

<p>getsockname() allows applications to determine the address and port to which POE::Wheel::SocketFactory has bound its listening socket.</p>

<p>Test applications may use getsockname() to find the server socket after POE::Wheel::SocketFactory has bound to INADDR_ANY port 0.</p>

<p>Since there is no event fired immediately after a successful creation of a listening socket, applications can use getsockname() to verify this.</p>

<pre> use Socket &#39;unpack_sockaddr_in&#39;;

 my $listener = POE::Wheel::SocketFactory-&#62;new(
     BindPort     =&#62; 123,
     SuccessEvent =&#62; &#39;got_client&#39;,
     FailureEvent =&#62; &#39;listener_failed&#39;,
     Reuse        =&#62; &#39;on&#39;,
 );

 my ($port, $addr) = unpack_sockaddr_in($listener-&#62;getsockname);
 print &#34;Socket successfully bound\n&#34; if $port;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="ID"
>ID</a></h2>

<p>ID() returns the wheel&#39;s unique ID. The ID will also be included in every event the wheel generates. Applications can match events back to the objects that generated them.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="pause_accept"
>pause_accept</a></h2>

<p>Applications may occasionally need to block incoming connections. pause_accept() pauses the event watcher that triggers accept(). New inbound connections will stack up in the socket&#39;s listen() queue until the queue overflows or the application calls resume_accept().</p>

<p>Pausing accept() can limit the amount of load a server generates. It&#39;s also useful in pre-forking servers when the master process shouldn&#39;t accept connections at all.</p>

<p>pause_accept() and resume_accept() is quicker and more reliable than dynamically destroying and re-creating a POE::Wheel::SocketFactory object.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="resume_accept"
>resume_accept</a></h2>

<p>resume_accept() resumes the watcher that triggers accept(). See <a href="#pause_accept" class="podlinkpod"
>&#34;pause_accept&#34;</a> for a more detailed discussion.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="PUBLIC_EVENTS"
>PUBLIC EVENTS</a></h1>

<p>POE::Wheel::SocketFactory emits two public events.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="SuccessEvent"
>SuccessEvent</a></h2>

<p><code>SuccessEvent</code> names an event that will be sent to the creating session whenever a POE::Wheel::SocketFactory has created a new socket. For connectionless sockets, it&#39;s when the socket is created. For connecting clients, it&#39;s after the connection has been established. And for listening servers, <code>SuccessEvent</code> is fired after each new client is accepted.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Common_SuccessEvent_Parameters"
>Common SuccessEvent Parameters</a></h3>

<p>In all cases, <code>$_[ARG0]</code> holds the new socket&#39;s filehandle, and <code>$_[ARG3]</code> contains the POE::Wheel::SocketFactory&#39;s ID. Other parameters vary depending on the socket&#39;s domain and whether it&#39;s listening or connecting. See below for the differences.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="INET_SuccessEvent_Parameters"
>INET SuccessEvent Parameters</a></h3>

<p>For INET sockets, <code>$_[ARG1]</code> and <code>$_[ARG2]</code> hold the socket&#39;s remote address and port, respectively. The address is packed; see <a href="../../Socket.html#inet_ntoa" class="podlinkpod"
>&#34;inet_ntoa&#34; in Socket</a> if a human-readable IPv4 address is needed. <a href="../../Socket/GetAddrInfo.html#getnameinfo" class="podlinkpod"
>&#34;getnameinfo&#34; in Socket::GetAddrInfo</a> provides numeric addresses for IPv4 and IPv6 addresses.</p>

<pre>  sub handle_new_client {
    my $accepted_socket = $_[ARG0];

    my $peer_host = inet_ntoa($_[ARG1]);
    print(
      &#34;Wheel $_[ARG3] accepted a connection from &#34;,
      &#34;$peer_host port $peer_port\n&#34;
    );

    spawn_connection_session($accepted_handle);
  }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="UNIX_Client_SuccessEvent_Parameters"
>UNIX Client SuccessEvent Parameters</a></h3>

<p>For UNIX client sockets, <code>$_[ARG1]</code> often (but not always) holds the server address. Some systems cannot retrieve a UNIX socket&#39;s remote address. <code>$_[ARG2]</code> is always undef for UNIX client sockets.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="UNIX_Server_SuccessEvent_Parameters"
>UNIX Server SuccessEvent Parameters</a></h3>

<p>According to <i>Perl Cookbook</i>, the remote address returned by accept() on UNIX sockets is undefined, so <code>$_[ARG1]</code> and <code>$_[ARG2]</code> are also undefined in this case.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="FailureEvent"
>FailureEvent</a></h2>

<p><code>FailureEvent</code> names the event that will be emitted when a socket error occurs. POE::Wheel::SocketFactory handles <code>EAGAIN</code> internally, so it doesn&#39;t count as an error.</p>

<p><code>FailureEvent</code> events include the standard error event parameters:</p>

<p><code>$_[ARG0]</code> describes which part of socket creation failed. It often holds a Perl built-in function name.</p>

<p><code>$_[ARG1]</code> and <code>$_[ARG2]</code> describe how the operation failed. They contain the numeric and stringified versions of <code>$!</code>, respectively. An application cannot merely check the global <code>$!</code> variable since it may change during event dispatch.</p>

<p>Finally, <code>$_[ARG3]</code> contains the ID for the POE::Wheel::SocketFactory instance that generated the event. See <a href="#ID" class="podlinkpod"
>&#34;ID&#34;</a> and <a href="../../POE/Wheel.html#ID" class="podlinkpod"
>&#34;ID&#34; in POE::Wheel</a> for uses for wheel IDs.</p>

<p>A sample FailureEvent handler:</p>

<pre>  sub handle_failure {
    my ($operation, $errnum, $errstr, $wheel_id) = @_[ARG0..ARG3];
    warn &#34;Wheel $wheel_id generated $operation error $errnum: $errstr\n&#34;;
    delete $_[HEAP]{wheels}{$wheel_id}; # shut down that wheel
  }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../../POE/Wheel.html" class="podlinkpod"
>POE::Wheel</a> describes the basic operations of all wheels in more depth. You need to know this.</p>

<p><a href="../../Socket/GetAddrInfo.html" class="podlinkpod"
>Socket::GetAddrInfo</a> is required for IPv6 work. POE::Wheel::SocketFactory will load it automatically if it&#39;s installed. SocketDomain =&#62; AF_INET6 is required to trigger IPv6 behaviors. AF_INET6 is exported by the Socket module on all but the oldest versions of Perl 5. If your Socket doesn&#39;t provide AF_INET6, try installing Socket6 instead.</p>

<p>The SEE ALSO section in <a href="../../POE.html" class="podlinkpod"
>POE</a> contains a table of contents covering the entire POE distribution.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>Many (if not all) of the croak/carp/warn/die statements should fire back <code>FailureEvent</code> instead.</p>

<p>SocketFactory is only tested with UNIX streams and INET sockets using the UDP and TCP protocols. Others should work after the module&#39;s internal configuration tables are updated. Please send patches.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS_&#38;_COPYRIGHTS"
>AUTHORS &#38; COPYRIGHTS</a></h1>

<p>Please see <a href="../../POE.html" class="podlinkpod"
>POE</a> for more information about authors and contributors.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
