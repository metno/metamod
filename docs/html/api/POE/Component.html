<html><head><title>POE::Component</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:25 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#OBJECT_ORIENTED_COMPONENTS'>OBJECT ORIENTED COMPONENTS</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#TO_DO'>TO DO</a>
  <li class='indexItem indexItem1'><a href='#AUTHORS_%26_COPYRIGHTS'>AUTHORS &#38; COPYRIGHTS</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>POE::Component - event driven objects or subsystems</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<p>See specific components.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>POE &#34;components&#34; are event-driven modules that generally encapsulate mid- to high-level program features.
For example,
POE::Component::Client::DNS performs message-based asynchronous resolver lookups.
POE::Component::Server::TCP is a basic asynchronous network server.</p>

<p>The POE::Component namespace was started as place for contributors to publish their POE-based modules without requiring coordination with the main POE distribution.
The namespace predates the -X convention,
otherwise you&#39;d be reading about POEx instead.</p>

<p>As with many things in Perl,
there is more than one way to implement component interfaces.
Newer components sport OO interfaces,
and some even use Moose,
but older ones are solely message driven.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="OBJECT_ORIENTED_COMPONENTS"
>OBJECT ORIENTED COMPONENTS</a></h1>

<p>One way to create object-oriented components is to embed a POE::Session instance within an object.
This is done by creating the session during the object&#39;s constructor,
setting the session&#39;s alias to something unique,
and saving a copy of the alias in the object.</p>

<pre>  package Asynchrotron;

  my $alias_index = 0;

  sub new {
    my $class = shift;
    my $self = bless {
      alias =&#62; __PACKAGE__ . &#34; &#34; . ++$alias_index;
    }, $class;

    POE::Session-&#62;create(
      object_states =&#62; [
        $self =&#62; {
          _start       =&#62; &#34;_poe_start&#34;,
          do_something =&#62; &#34;_poe_do_something&#34;,
        },
      ],
    );
    return $self;
  }

  sub _poe_start {
    $_[KERNEL]-&#62;alias_set($_[OBJECT]-&#62;{alias});
  }</pre>

<p>The alias allows object methods to pass events into the session without having to store something about the session. The POE::Kernel call() transfers execution from the caller session&#39;s context into the component&#39;s session.</p>

<pre>  sub do_something {
    my $self = shift;
    print &#34;Inside the caller&#39;s session right now: @_\n&#34;;
    $poe_kernel-&#62;call($self-&#62;{alias}, &#34;do_something&#34;, @_);
  }

  sub _poe_do_something {
    my @args = @_[ARG0..$#_];
    print &#34;Inside the component&#39;s session now: @args\n&#34;;
    $_[OBJECT]{count}++;
  }</pre>

<p>Both $_[HEAP] and $_[OBJECT] are visible within the component&#39;s session. $_[HEAP] can be used for ultra-private encapsulation, while $_[OBJECT] may be used for data visible by accessors.</p>

<pre>  sub get_count {
    my $self = shift;
    return $self-&#62;{count}; # $_[OBJECT]{count} above
  }</pre>

<p>Too many sessions may bog down object creation and destruction, so avoid creating them for every object.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>The SEE ALSO section in <a href="../POE.html" class="podlinkpod"
>POE</a> contains a table of contents covering the entire POE distribution.</p>

<p><a href="../POE/Stage.html" class="podlinkpod"
>POE::Stage</a> is a nascent project to formalize POE components, make POE::Kernel more object-oriented, and provide syntactic and semantic sugar for many common aspects of POE::Component development. It&#39;s also easier to type. Please investigate the project. Ideas and <i>tuits</i> are badly needed to help get the project off the ground.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="TO_DO"
>TO DO</a></h1>

<p>Document the customary (but not mandatory!) process of creating and publishing a component.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHORS_&#38;_COPYRIGHTS"
>AUTHORS &#38; COPYRIGHTS</a></h1>

<p>Each component is written and copyrighted separately.</p>

<p>Please see <a href="../POE.html" class="podlinkpod"
>POE</a> for more information about authors and contributors.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
