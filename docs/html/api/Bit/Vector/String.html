<html><head><title>Bit::Vector::String</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:02 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
  <li class='indexItem indexItem1'><a href='#LICENSE'>LICENSE</a>
  <li class='indexItem indexItem1'><a href='#DISCLAIMER'>DISCLAIMER</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Bit::Vector::String - Generic string import/export for Bit::Vector</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use Bit::Vector::String;

  to_Oct
      $string = $vector-&#62;to_Oct();

  from_Oct
      $vector-&#62;from_Oct($string);

  new_Oct
      $vector = Bit::Vector-&#62;new_Oct($bits,$string);

  String_Export
      $string = $vector-&#62;String_Export($type);

  String_Import
      $type = $vector-&#62;String_Import($string);

  new_String
      $vector = Bit::Vector-&#62;new_String($bits,$string);
      ($vector,$type) = Bit::Vector-&#62;new_String($bits,$string);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<ul>
<li><code>$string = $vector-&#62;to_Oct();</code>
<p>Returns an octal string representing the given bit vector.</p>

<p>Note that this method is not particularly efficient, since it is almost completely realized in Perl, and moreover internally operates on a Perl list of individual octal digits which it concatenates into the final string using &#34;<code>join(&#39;&#39;, ...)</code>&#34;.</p>

<p>A benchmark reveals that this method is about 40 times slower than the method &#34;<code>to_Bin()</code>&#34; (which is realized in C):</p>

<pre> Benchmark: timing 10000 iterations of to_Bin, to_Hex, to_Oct...
     to_Bin:  1 wallclock secs ( 1.09 usr +  0.00 sys =  1.09 CPU)
     to_Hex:  1 wallclock secs ( 0.53 usr +  0.00 sys =  0.53 CPU)
     to_Oct: 40 wallclock secs (40.16 usr +  0.05 sys = 40.21 CPU)</pre>

<p>Note that since an octal digit is always worth three bits, the length of the resulting string is always a multiple of three bits, regardless of the true length (in bits) of the given bit vector.</p>

<p>Also note that the <b>LEAST</b> significant octal digit is located at the <b>RIGHT</b> end of the resulting string, and the <b>MOST</b> significant digit at the <b>LEFT</b> end.</p>

<p>Finally, note that this method does <b>NOT</b> prepend any uniquely identifying format prefix (such as &#34;0o&#34;) to the resulting string (which means that the result of this method only contains valid octal digits, i.e., [0-7]).</p>

<p>However, this can of course most easily be done as needed, as follows:</p>

<pre>  $string = &#39;0o&#39; . $vector-&#62;to_Oct();</pre>
</li>

<li><code>$vector-&#62;from_Oct($string);</code>
<p>Allows to read in the contents of a bit vector from an octal string, such as returned by the method &#34;<code>to_Oct()</code>&#34; (see above).</p>

<p>Note that this method is not particularly efficient, since it is almost completely realized in Perl, and moreover chops the input string into individual characters using &#34;<code>split(//, $string)</code>&#34;.</p>

<p>Remember also that the least significant bits are always to the right of an octal string, and the most significant bits to the left. Therefore, the string is actually reversed internally before storing it in the given bit vector using the method &#34;<code>Chunk_List_Store()</code>&#34;, which expects the least significant chunks of data at the beginning of a list.</p>

<p>A benchmark reveals that this method is about 40 times slower than the method &#34;<code>from_Bin()</code>&#34; (which is realized in C):</p>

<pre> Benchmark: timing 10000 iterations of from_Bin, from_Hex, from_Oct...
   from_Bin:  1 wallclock secs ( 1.13 usr +  0.00 sys =  1.13 CPU)
   from_Hex:  1 wallclock secs ( 0.80 usr +  0.00 sys =  0.80 CPU)
   from_Oct: 46 wallclock secs (44.95 usr +  0.00 sys = 44.95 CPU)</pre>

<p>If the given string contains any character which is not an octal digit (i.e., [0-7]), a fatal syntax error ensues (&#34;unknown string type&#34;).</p>

<p>Note especially that this method does <b>NOT</b> accept any uniquely identifying format prefix (such as &#34;0o&#34;) in the given string; the presence of such a prefix will also lead to the fatal &#34;unknown string type&#34; error.</p>

<p>If the given string contains less octal digits than are needed to completely fill the given bit vector, the remaining (most significant) bits all remain cleared (i.e., set to zero).</p>

<p>This also means that, even if the given string does not contain enough digits to completely fill the given bit vector, the previous contents of the bit vector are erased completely.</p>

<p>If the given string is longer than it needs to fill the given bit vector, the superfluous characters are simply ignored.</p>

<p>This behaviour is intentional so that you may read in the string representing one bit vector into another bit vector of different size, i.e., as much of it as will fit.</p>
</li>

<li><code>$vector = Bit::Vector-&#62;new_Oct($bits,$string);</code>
<p>This method is an alternative constructor which allows you to create a new bit vector object (with &#34;<code>$bits</code>&#34; bits) and to initialize it all in one go.</p>

<p>The method internally first calls the bit vector constructor method &#34;<code>new()</code>&#34; and then stores the given string in the newly created bit vector using the same approach as the method &#34;<code>from_Oct()</code>&#34; (described above).</p>

<p>Note that this approach is not particularly efficient, since it is almost completely realized in Perl, and moreover chops the input string into individual characters using &#34;<code>split(//, $string)</code>&#34;.</p>

<p>An exception will be raised if the necessary memory cannot be allocated (see the description of the method &#34;<code>new()</code>&#34; in <a href="../../Bit/Vector(3).html" class="podlinkpod"
>Bit::Vector(3)</a> for possible causes) or if the given string cannot be converted successfully (see the description of the method &#34;<code>from_Oct()</code>&#34; above for details).</p>

<p>Note especially that this method does <b>NOT</b> accept any uniquely identifying format prefix (such as &#34;0o&#34;) in the given string and that such a prefix will lead to a fatal &#34;unknown string type&#34; error.</p>

<p>In case of an error, the memory occupied by the new bit vector is released again before the exception is actually thrown.</p>

<p>If the number of bits &#34;<code>$bits</code>&#34; given has the value &#34;<code>undef</code>&#34;, the method will automatically allocate a bit vector with a size (i.e., number of bits) of three times the length of the given string (since every octal digit is worth three bits).</p>

<p>Note that this behaviour is different from that of the methods &#34;<code>new_Hex()</code>&#34;, &#34;<code>new_Bin()</code>&#34;, &#34;<code>new_Dec()</code>&#34; and &#34;<code>new_Enum()</code>&#34; (which are realized in C, internally); these methods will silently assume a value of 0 bits if &#34;<code>undef</code>&#34; is given (and may warn about the &#34;Use of uninitialized value&#34; if warnings are enabled).</p>
</li>

<li><code>$string = $vector-&#62;String_Export($type);</code>
<p>Returns a string representing the given bit vector in the format specified by &#34;<code>$type</code>&#34;:</p>

<pre>  1 | b | bin      =&#62;  binary        (using &#34;to_Bin()&#34;)
  2 | o | oct      =&#62;  octal         (using &#34;to_Oct()&#34;)
  3 | d | dec      =&#62;  decimal       (using &#34;to_Dec()&#34;)
  4 | h | hex | x  =&#62;  hexadecimal   (using &#34;to_Hex()&#34;)
  5 | e | enum     =&#62;  enumeration   (using &#34;to_Enum()&#34;)
  6 | p | pack     =&#62;  packed binary (using &#34;Block_Read()&#34;)</pre>

<p>The case (lower/upper/mixed case) of &#34;<code>$type</code>&#34; is ignored.</p>

<p>If &#34;<code>$type</code>&#34; is omitted or &#34;<code>undef</code>&#34; or false (&#34;0&#34; or the empty string), a hexadecimal string is returned as the default format.</p>

<p>If &#34;<code>$type</code>&#34; does not have any of the values described above, a fatal &#34;unknown string type&#34; will occur.</p>

<p>Beware that in order to guarantee that the strings can be correctly parsed and read in by the methods &#34;<code>String_Import()</code>&#34; and &#34;<code>new_String()</code>&#34; (described below), the method &#34;<code>String_Export()</code>&#34; provides uniquely identifying prefixes (and, in one case, a suffix) as follows:</p>

<pre>  1 | b | bin      =&#62;  &#39;0b&#39; . $vector-&#62;to_Bin();
  2 | o | oct      =&#62;  &#39;0o&#39; . $vector-&#62;to_Oct();
  3 | d | dec      =&#62;         $vector-&#62;to_Dec(); # prefix is [+-]
  4 | h | hex | x  =&#62;  &#39;0x&#39; . $vector-&#62;to_Hex();
  5 | e | enum     =&#62;  &#39;{&#39;  . $vector-&#62;to_Enum() . &#39;}&#39;;
  6 | p | pack     =&#62;  &#39;:&#39;  . $vector-&#62;Size() .
                       &#39;:&#39;  . $vector-&#62;Block_Read();</pre>

<p>This is necessary because certain strings can be valid representations in more than one format.</p>

<p>All strings in binary format, i.e., which only contain &#34;0&#34; and &#34;1&#34;, are also valid number representations (of a different value, of course) in octal, decimal and hexadecimal.</p>

<p>Likewise, a string in octal format is also valid in decimal and hexadecimal, and a string in decimal format is also valid in hexadecimal.</p>

<p>Moreover, if the enumeration of set bits (as returned by &#34;<code>to_Enum()</code>&#34;) only contains one element, this element could be mistaken for a representation of the entire bit vector (instead of just one bit) in decimal.</p>

<p>Beware also that the string returned by format &#34;6&#34; (&#34;packed binary&#34;) will in general <b>NOT BE PRINTABLE</b>, because it will usually consist of many unprintable characters!</p>
</li>

<li><code>$type = $vector-&#62;String_Import($string);</code>
<p>Allows to read in the contents of a bit vector from a string which has previously been produced by &#34;<code>String_Export()</code>&#34;, &#34;<code>to_Bin()</code>&#34;, &#34;<code>to_Oct()</code>&#34;, &#34;<code>to_Dec()</code>&#34;, &#34;<code>to_Hex()</code>&#34;, &#34;<code>to_Enum()</code>&#34;, &#34;<code>Block_Read()</code>&#34; or manually or by another program.</p>

<p>Beware however that the string must have the correct format; otherwise a fatal &#34;unknown string type&#34; error will occur.</p>

<p>The correct format is the one returned by &#34;<code>String_Export()</code>&#34; (see immediately above).</p>

<p>The method will also try to automatically recognize formats without identifying prefix such as returned by the methods &#34;<code>to_Bin()</code>&#34;, &#34;<code>to_Oct()</code>&#34;, &#34;<code>to_Dec()</code>&#34;, &#34;<code>to_Hex()</code>&#34; and &#34;<code>to_Enum()</code>&#34;.</p>

<p>However, as explained above for the method &#34;<code>String_Export()</code>&#34;, due to the fact that a string may be a valid representation in more than one format, this may lead to unwanted results.</p>

<p>The method will try to match the format of the given string in the following order:</p>

<p>If the string consists only of [01], it will be considered to be in binary format (although it could be in octal, decimal or hexadecimal format or even be an enumeration with only one element as well).</p>

<p>If the string consists only of [0-7], it will be considered to be in octal format (although it could be in decimal or hexadecimal format or even be an enumeration with only one element as well).</p>

<p>If the string consists only of [0-9], it will be considered to be in decimal format (although it could be in hexadecimal format or even be an enumeration with only one element as well).</p>

<p>If the string consists only of [0-9A-Fa-f], it will be considered to be in hexadecimal format.</p>

<p>If the string only contains numbers in decimal format, separated by commas (&#34;,&#34;) or dashes (&#34;-&#34;), it is considered to be an enumeration (a single decimal number also qualifies).</p>

<p>And if the string starts with &#34;:[0-9]:&#34;, the remainder of the string is read in with &#34;<code>Block_Store()</code>&#34;.</p>

<p>To avoid misinterpretations, it is therefore recommendable to always either use the method &#34;<code>String_Export()</code>&#34; or to provide some uniquely identifying prefix (and suffix, in one case) yourself:</p>

<pre>  binary         =&#62;  &#39;0b&#39; . $string;
  octal          =&#62;  &#39;0o&#39; . $string;
  decimal        =&#62;  &#39;+&#39;  . $string; # in case &#34;$string&#34;
                 =&#62;  &#39;-&#39;  . $string; # has no sign yet
  hexadecimal    =&#62;  &#39;0x&#39; . $string;
                 =&#62;  &#39;0h&#39; . $string;
  enumeration    =&#62;  &#39;{&#39;  . $string . &#39;}&#39;;
                 =&#62;  &#39;[&#39;  . $string . &#39;]&#39;;
                 =&#62;  &#39;&#60;&#39;  . $string . &#39;&#62;&#39;;
                 =&#62;  &#39;(&#39;  . $string . &#39;)&#39;;
  packed binary  =&#62;  &#39;:&#39;  . $vector-&#62;Size() .
                     &#39;:&#39;  . $vector-&#62;Block_Read();</pre>

<p>Note that case (lower/upper/mixed case) is not important and will be ignored by this method.</p>

<p>Internally, the method uses the methods &#34;<code>from_Bin()</code>&#34;, &#34;<code>from_Oct()</code>&#34;, &#34;<code>from_Dec()</code>&#34;, &#34;<code>from_Hex()</code>&#34;, &#34;<code>from_Enum()</code>&#34; and &#34;<code>Block_Store()</code>&#34; for actually importing the contents of the string into the given bit vector. See their descriptions here in this document and in <a href="../../Bit/Vector(3).html" class="podlinkpod"
>Bit::Vector(3)</a> for any further conditions that must be met and corresponding possible fatal error messages.</p>

<p>The method returns the number of the format that has been recognized:</p>

<pre>                1    =&#62;    binary
                2    =&#62;    octal
                3    =&#62;    decimal
                4    =&#62;    hexadecimal
                5    =&#62;    enumeration
                6    =&#62;    packed binary</pre>
</li>

<li><code>$vector = Bit::Vector-&#62;new_String($bits,$string);</code>
<p><code>($vector,$type) = Bit::Vector-&#62;new_String($bits,$string);</code></p>

<p>This method is an alternative constructor which allows you to create a new bit vector object (with &#34;<code>$bits</code>&#34; bits) and to initialize it all in one go.</p>

<p>The method internally first calls the bit vector constructor method &#34;<code>new()</code>&#34; and then stores the given string in the newly created bit vector using the same approach as the method &#34;<code>String_Import()</code>&#34; (described immediately above).</p>

<p>An exception will be raised if the necessary memory cannot be allocated (see the description of the method &#34;<code>new()</code>&#34; in <a href="../../Bit/Vector(3).html" class="podlinkpod"
>Bit::Vector(3)</a> for possible causes) or if the given string cannot be converted successfully (see the description of the method &#34;<code>String_Import()</code>&#34; above for details).</p>

<p>In case of an error, the memory occupied by the new bit vector is released again before the exception is actually thrown.</p>

<p>If the number of bits &#34;<code>$bits</code>&#34; given has the value &#34;<code>undef</code>&#34;, the method will automatically determine this value for you and allocate a bit vector of the calculated size.</p>

<p>Note that this behaviour is different from that of the methods &#34;<code>new_Hex()</code>&#34;, &#34;<code>new_Bin()</code>&#34;, &#34;<code>new_Dec()</code>&#34; and &#34;<code>new_Enum()</code>&#34; (which are realized in C, internally); these methods will silently assume a value of 0 bits if &#34;<code>undef</code>&#34; is given (and may warn about the &#34;Use of uninitialized value&#34; if warnings are enabled).</p>

<p>The necessary number of bits is calculated as follows:</p>

<pre>  binary         =&#62;       length($string);
  octal          =&#62;   3 * length($string);
  decimal        =&#62;  int( length($string) * log(10) / log(2) + 1 );
  hexadecimal    =&#62;   4 * length($string);
  enumeration    =&#62;  maximum of values found in $string + 1
  packed binary  =&#62;  $string =~ /^:(\d+):/;</pre>

<p>If called in scalar context, the method returns the newly created bit vector object.</p>

<p>If called in list context, the method additionally returns the number of the format which has been recognized, as explained above for the method &#34;<code>String_Import()</code>&#34;.</p>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>Bit::Vector(3), Bit::Vector::Overload(3).</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>This man page documents &#34;Bit::Vector::String&#34; version 7.3.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<pre>  Steffen Beyer
  mailto:STBEY@cpan.org
  http://www.engelschall.com/u/sb/download/</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright (c) 2004 - 2013 by Steffen Beyer. All rights reserved.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENSE"
>LICENSE</a></h1>

<p>This package is free software; you can redistribute it and/or modify it under the same terms as Perl itself, i.e., under the terms of the &#34;Artistic License&#34; or the &#34;GNU General Public License&#34;.</p>

<p>The C library at the core of this Perl module can additionally be redistributed and/or modified under the terms of the &#34;GNU Library General Public License&#34;.</p>

<p>Please refer to the files &#34;Artistic.txt&#34;, &#34;GNU_GPL.txt&#34; and &#34;GNU_LGPL.txt&#34; in this distribution for details!</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DISCLAIMER"
>DISCLAIMER</a></h1>

<p>This package is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</p>

<p>See the &#34;GNU General Public License&#34; for more details.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
