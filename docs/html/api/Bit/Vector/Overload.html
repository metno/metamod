<html><head><title>Bit::Vector::Overload</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:02 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#USAGE'>USAGE</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#IMPORTANT_NOTES'>IMPORTANT NOTES</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
  <li class='indexItem indexItem1'><a href='#LICENSE'>LICENSE</a>
  <li class='indexItem indexItem1'><a href='#DISCLAIMER'>DISCLAIMER</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Bit::Vector::Overload - Overloaded operators add-on for Bit::Vector</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="USAGE"
>USAGE</a></h1>

<p>Note that you do not need to &#34;<code>use Bit::Vector;</code>&#34; in addition to this module.</p>

<p>Simply &#34;<code>use Bit::Vector::Overload;</code>&#34; <b>INSTEAD</b> of &#34;<code>use Bit::Vector;</code>&#34;.
You can still use all the methods from the &#34;Bit::Vector&#34; module in addition to the overloaded operators and methods provided here after that.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  Configuration
      $config = Bit::Vector-&#62;Configuration();
      Bit::Vector-&#62;Configuration($config);
      $oldconfig = Bit::Vector-&#62;Configuration($newconfig);

  String Conversion
      $string = &#34;$vector&#34;;             #  depending on configuration
      print &#34;\$vector = &#39;$vector&#39;\n&#34;;

  Emptyness
      if ($vector)  #  if not empty (non-zero)
      if (! $vector)  #  if empty (zero)
      unless ($vector)  #  if empty (zero)

  Complement (one&#39;s complement)
      $vector2 = ~$vector1;
      $vector = ~$vector;

  Negation (two&#39;s complement)
      $vector2 = -$vector1;
      $vector = -$vector;

  Norm
      $norm = abs($vector);  #  depending on configuration

  Absolute
      $vector2 = abs($vector1);  #  depending on configuration

  Concatenation
      $vector3 = $vector1 . $vector2;
      $vector1 .= $vector2;
      $vector1 = $vector2 . $vector1;
      $vector2 = $vector1 . $scalar;  #  depending on configuration
      $vector2 = $scalar . $vector1;
      $vector .= $scalar;

  Duplication
      $vector2 = $vector1 x $factor;
      $vector x= $factor;

  Shift Left
      $vector2 = $vector1 &#60;&#60; $bits;
      $vector &#60;&#60;= $bits;

  Shift Right
      $vector2 = $vector1 &#62;&#62; $bits;
      $vector &#62;&#62;= $bits;

  Union
      $vector3 = $vector1 | $vector2;
      $vector1 |= $vector2;
      $vector2 = $vector1 | $scalar;
      $vector |= $scalar;

      $vector3 = $vector1 + $vector2;  #  depending on configuration
      $vector1 += $vector2;
      $vector2 = $vector1 + $scalar;
      $vector += $scalar;

  Intersection
      $vector3 = $vector1 &#38; $vector2;
      $vector1 &#38;= $vector2;
      $vector2 = $vector1 &#38; $scalar;
      $vector &#38;= $scalar;

      $vector3 = $vector1 * $vector2;  #  depending on configuration
      $vector1 *= $vector2;
      $vector2 = $vector1 * $scalar;
      $vector *= $scalar;

  ExclusiveOr
      $vector3 = $vector1 ^ $vector2;
      $vector1 ^= $vector2;
      $vector2 = $vector1 ^ $scalar;
      $vector ^= $scalar;

  Set Difference
      $vector3 = $vector1 - $vector2;  #  depending on configuration
      $vector1 -= $vector2;
      $vector1 = $vector2 - $vector1;
      $vector2 = $vector1 - $scalar;
      $vector2 = $scalar - $vector1;
      $vector -= $scalar;

  Addition
      $vector3 = $vector1 + $vector2;  #  depending on configuration
      $vector1 += $vector2;
      $vector2 = $vector1 + $scalar;
      $vector += $scalar;

  Subtraction
      $vector3 = $vector1 - $vector2;  #  depending on configuration
      $vector1 -= $vector2;
      $vector1 = $vector2 - $vector1;
      $vector2 = $vector1 - $scalar;
      $vector2 = $scalar - $vector1;
      $vector -= $scalar;

  Multiplication
      $vector3 = $vector1 * $vector2;  #  depending on configuration
      $vector1 *= $vector2;
      $vector2 = $vector1 * $scalar;
      $vector *= $scalar;

  Division
      $vector3 = $vector1 / $vector2;
      $vector1 /= $vector2;
      $vector1 = $vector2 / $vector1;
      $vector2 = $vector1 / $scalar;
      $vector2 = $scalar / $vector1;
      $vector /= $scalar;

  Modulo
      $vector3 = $vector1 % $vector2;
      $vector1 %= $vector2;
      $vector1 = $vector2 % $vector1;
      $vector2 = $vector1 % $scalar;
      $vector2 = $scalar % $vector1;
      $vector %= $scalar;

  Exponentiation
      $vector3 = $vector1 ** $vector2;
      $vector1 **= $vector2;
      $vector2 = $vector1 ** $scalar;
      $vector2 = $scalar ** $vector1;
      $vector **= $scalar;

  Increment
      ++$vector;
      $vector++;

  Decrement
      --$vector;
      $vector--;

  Lexical Comparison (unsigned)
      $cmp = $vector1 cmp $vector2;
      if ($vector1 lt $vector2)
      if ($vector1 le $vector2)
      if ($vector1 gt $vector2)
      if ($vector1 ge $vector2)

      $cmp = $vector cmp $scalar;
      if ($vector lt $scalar)
      if ($vector le $scalar)
      if ($vector gt $scalar)
      if ($vector ge $scalar)

  Comparison (signed)
      $cmp = $vector1 &#60;=&#62; $vector2;
      if ($vector1 &#60; $vector2)  #  depending on configuration
      if ($vector1 &#60;= $vector2)
      if ($vector1 &#62; $vector2)
      if ($vector1 &#62;= $vector2)

      $cmp = $vector &#60;=&#62; $scalar;
      if ($vector &#60; $scalar)  #  depending on configuration
      if ($vector &#60;= $scalar)
      if ($vector &#62; $scalar)
      if ($vector &#62;= $scalar)

  Equality
      if ($vector1 eq $vector2)
      if ($vector1 ne $vector2)
      if ($vector eq $scalar)
      if ($vector ne $scalar)

      if ($vector1 == $vector2)
      if ($vector1 != $vector2)
      if ($vector == $scalar)
      if ($vector != $scalar)

  Subset Relationship
      if ($vector1 &#60;= $vector2)  #  depending on configuration

  True Subset Relationship
      if ($vector1 &#60; $vector2)  #  depending on configuration

  Superset Relationship
      if ($vector1 &#62;= $vector2)  #  depending on configuration

  True Superset Relationship
      if ($vector1 &#62; $vector2)  #  depending on configuration</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="IMPORTANT_NOTES"
>IMPORTANT NOTES</a></h1>

<ul>
<li>Boolean values
<p>Boolean values in this module are always a numeric zero (&#34;<code>0</code>&#34;) for &#34;false&#34; and a numeric one (&#34;<code>1</code>&#34;) for &#34;true&#34;.</p>
</li>

<li>Negative numbers
<p>Numeric factors (as needed for the &#34;<code>&#60;&#60;</code>&#34;, &#34;<code>&#62;&#62;</code>&#34; and &#34;<code>x</code>&#34; operators) and bit numbers are always regarded as being <b>UNSIGNED</b>.</p>

<p>As a consequence, whenever you pass a negative number for such a factor or bit number, it will be treated as a (usually very large) positive number due to its internal two&#39;s complement binary representation, usually resulting in malfunctions or an &#34;index out of range&#34; error message and program abortion.</p>

<p>Note that this does not apply to &#34;big integer&#34; decimal numbers, which are (usually) passed as strings, and which may of course be negative (see also the section &#34;Big integers&#34; a little further below).</p>
</li>

<li>Overloaded operators configuration
<p>Note that the behaviour of certain overloaded operators can be changed in various ways by means of the &#34;<code>Configuration()</code>&#34; method (for more details, see the description of this method further below).</p>

<p>For instance, scalars (i.e., numbers and strings) provided as operands to overloaded operators are automatically converted to bit vectors, internally.</p>

<p>These scalars are thereby automatically assumed to be indices or to be in hexadecimal, binary, decimal or enumeration format, depending on the configuration.</p>

<p>Similarly, when converting bit vectors to strings using double quotes (&#34;&#34;), the output format will also depend on the previously chosen configuration.</p>

<p>Finally, some overloaded operators may have different semantics depending on the proper configuration; for instance, the operator &#34;+&#34; can be the &#34;union&#34; operator from set theory or the arithmetic &#34;add&#34; operator.</p>

<p>In all cases (input, output and operator semantics), the defaults have been chosen in such a way so that the behaviour of the module is backward compatible with previous versions.</p>
</li>

<li>&#34;Big integers&#34;
<p>As long as &#34;big integers&#34; (for &#34;big integer&#34; arithmetic) are small enough so that Perl doesn&#39;t need scientific notation (exponents) to be able to represent them internally, you can provide these &#34;big integer&#34; constants to the overloaded operators of this module (or to the method &#34;<code>from_Dec()</code>&#34;) in numeric form (i.e., either as a numeric constant or expression or as a Perl variable containing a numeric value).</p>

<p>Note that you will get an error message (resulting in program abortion) if your &#34;big integer&#34; numbers exceed that limit.</p>

<p>Because this limit is machine-dependent and not obvious to find out, it is strongly recommended that you enclose <b>ALL</b> your &#34;big integer&#34; constants in your programs in (double or single) quotes.</p>

<p>Examples:</p>

<pre>    $vector /= 10;  #  ok because number is small

    $vector /= -10;  #  ok for same reason

    $vector /= &#34;10&#34;;  #  always correct

    $vector += &#34;1152921504606846976&#34;;  #  quotes probably required here</pre>

<p>All examples assume</p>

<pre>    Bit::Vector-&#62;Configuration(&#34;input=decimal&#34;);</pre>

<p>having been set beforehand.</p>

<p>Note also that this module does not support scientific notation (exponents) for &#34;big integer&#34; decimal numbers because you can always make the bit vector large enough for the whole number to fit without loss of precision (as it would occur if scientific notation were used).</p>

<p>Finally, note that the only characters allowed in &#34;big integer&#34; constant strings are the digits <code>0..9</code> and an optional leading sign (&#34;<code>+</code>&#34; or &#34;<code>-</code>&#34;).</p>

<p>All other characters produce a syntax error.</p>
</li>

<li>Valid operands for overloaded operators
<p>All overloaded operators expect at least one bit vector operand, in order for the operator to &#34;know&#34; that not the usual operation is to be carried out, but rather the overloaded variant.</p>

<p>This is especially true for all unary operators:</p>

<pre>                    &#34;$vector&#34;
                    if ($vector)
                    if (!$vector)
                    ~$vector
                    -$vector
                    abs($vector)
                    ++$vector
                    $vector++
                    --$vector
                    $vector--</pre>

<p>For obvious reasons the left operand (the &#34;lvalue&#34;) of all assignment operators is also required to be a bit vector:</p>

<pre>                        .=
                        x=
                        &#60;&#60;=
                        &#62;&#62;=
                        |=
                        &#38;=
                        ^=
                        +=
                        -=
                        *=
                        /=
                        %=
                       **=</pre>

<p>In the case of three special operators, namely &#34;<code>&#60;&#60;</code>&#34;, &#34;<code>&#62;&#62;</code>&#34; and &#34;<code>x</code>&#34;, as well as their related assignment variants, &#34;<code>&#60;&#60;=</code>&#34;, &#34;<code>&#62;&#62;=</code>&#34; and &#34;<code>x=</code>&#34;, the left operand is <b>ALWAYS</b> a bit vector and the right operand is <b>ALWAYS</b> a number (which is the factor indicating how many times the operator is to be applied).</p>

<p>In all truly binary operators, i.e.,</p>

<pre>                        .
                        |
                        &#38;
                        ^
                        +
                        -
                        *
                        /
                        %
                       **
                    &#60;=&#62;   cmp
                     ==    eq
                     !=    ne
                     &#60;     lt
                     &#60;=    le
                     &#62;     gt
                     &#62;=    ge</pre>

<p>one of either operands may be replaced by a Perl scalar, i.e., a number or a string, either as a Perl constant, a Perl expression or a Perl variable yielding a number or a string.</p>

<p>The same applies to the right side operand (the &#34;rvalue&#34;) of the remaining assignment operators, i.e.,</p>

<pre>                        .=
                        |=
                        &#38;=
                        ^=
                        +=
                        -=
                        *=
                        /=
                        %=
                       **=</pre>

<p>Note that this Perl scalar should be of the correct type, i.e., numeric or string, for the chosen configuration, because otherwise a warning message will occur if your program runs under the &#34;<code>-w</code>&#34; switch of Perl.</p>

<p>The acceptable scalar types for each possible configuration are the following:</p>

<pre>    input = bit indices    (default)  :    numeric
    input = hexadecimal               :    string
    input = binary                    :    string
    input = decimal                   :    string     (in general)
    input = decimal                   :    numeric    (if small enough)
    input = enumeration               :    string</pre>

<p>NOTE ALSO THAT THESE SCALAR OPERANDS ARE CONVERTED TO BIT VECTORS OF THE SAME SIZE AS THE BIT VECTOR WHICH IS THE OTHER OPERAND.</p>

<p>The only exception from this rule is the concatenation operator (&#34;<code>.</code>&#34;) and its assignment variant (&#34;<code>.=</code>&#34;):</p>

<p>If one of the two operands of the concatenation operator (&#34;<code>.</code>&#34;) is not a bit vector object but a Perl scalar, the contents of the remaining bit vector operand are converted into a string (the format of which depends on the configuration set with the &#34;<code>Configuration()</code>&#34; method), which is then concatenated in the proper order (i.e., as indicated by the order of the two operands) with the Perl scalar (in other words, a string is returned in such a case instead of a bit vector object!).</p>

<p>If the right side operand (the &#34;rvalue&#34;) of the assignment variant (&#34;<code>.=</code>&#34;) of the concatenation operator is a Perl scalar, it is converted internally to a bit vector of the same size as the left side operand provided that the configuration states that scalars are to be regarded as indices, decimal strings or enumerations.</p>

<p>If the configuration states that scalars are to be regarded as hexadecimal or boolean strings, however, these strings are converted to bit vectors of a size matching the length of the input string, i.e., four times the length for hexadecimal strings (because each hexadecimal digit is worth 4 bits) and once the length for binary strings.</p>

<p>If a decimal number (&#34;big integer&#34;) is too large to be stored in a bit vector of the given size, a &#34;numeric overflow error&#34; occurs.</p>

<p>If a bit index is out of range for the given bit vector, an &#34;index out of range&#34; error occurs.</p>

<p>If a scalar operand cannot be converted successfully due to invalid syntax, a fatal &#34;input string syntax error&#34; is issued.</p>

<p>If the two operands of the operator &#34;<code>&#60;&#60;</code>&#34;, &#34;<code>&#62;&#62;</code>&#34; or &#34;<code>x</code>&#34; are reversed, a fatal &#34;reversed operands error&#34; occurs.</p>

<p>If an operand is neither a bit vector nor a scalar, then a fatal &#34;illegal operand type error&#34; occurs.</p>
</li>

<li>Bit order
<p>Note that bit vectors are stored least order bit and least order word first internally.</p>

<p>I.e., bit #0 of any given bit vector corresponds to bit #0 of word #0 in the array of machine words representing the bit vector.</p>

<p>(Where word #0 comes first in memory, i.e., it is stored at the least memory address in the allocated block of memory holding the given bit vector.)</p>

<p>Note however that machine words can be stored least order byte first or last, depending on your system&#39;s implementation.</p>

<p>Note further that whenever bit vectors are converted to and from (binary or hexadecimal) strings, the <b>RIGHTMOST</b> bit is always the <b>LEAST SIGNIFICANT</b> one, and the <b>LEFTMOST</b> bit is always the <b>MOST SIGNIFICANT</b> bit.</p>

<p>This is because in our western culture, numbers are always represented in this way (least significant to most significant digits go from right to left).</p>

<p>Of course this requires an internal reversion of order, which the corresponding conversion methods perform automatically (without any additional overhead, it&#39;s just a matter of starting the internal loop at the bottom or the top end).</p>
</li>

<li>Matching sizes
<p>In general, for methods involving several bit vectors at the same time, all bit vector arguments must have identical sizes (number of bits), or a fatal &#34;size mismatch&#34; error will occur.</p>

<p>Exceptions from this rule are the methods &#34;<code>Concat()</code>&#34;, &#34;<code>Concat_List()</code>&#34;, &#34;<code>Copy()</code>&#34;, &#34;<code>Interval_Copy()</code>&#34; and &#34;<code>Interval_Substitute()</code>&#34;, where no conditions at all are imposed on the size of their bit vector arguments.</p>

<p>In method &#34;<code>Multiply()</code>&#34;, all three bit vector arguments must in principle obey the rule of matching sizes, but the bit vector in which the result of the multiplication is to be stored may be larger than the two bit vector arguments containing the factors for the multiplication.</p>

<p>In method &#34;<code>Power()</code>&#34;, the bit vector for the result must be the same size or greater than the base of the exponentiation term. The exponent can be any size.</p>

<p>The same applies to the corresponding overloaded operators.</p>
</li>

<li>Index ranges
<p>All indices for any given bits must lie between &#34;<code>0</code>&#34; and &#34;<code>$vector-&#62;Size()-1</code>&#34;, or a fatal &#34;index out of range&#34; error will occur.</p>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<ul>
<li><code>$config = Bit::Vector-&#62;Configuration();</code></li>

<li><code>Bit::Vector-&#62;Configuration($config);</code></li>

<li><code>$oldconfig = Bit::Vector-&#62;Configuration($newconfig);</code>
<p>This method serves to alter the semantics (i.e., behaviour) of certain overloaded operators (which are all implemented in Perl, by the way).</p>

<p>It does not have any effect whatsoever on anything else. In particular, it does not affect the methods implemented in C.</p>

<p>The method accepts an (optional) string as input in which certain keywords are expected, which influence some or almost all of the overloaded operators in several possible ways.</p>

<p>The method always returns a string (which you do not need to take care of, i.e., to store, in case you aren&#39;t interested in keeping it) which is a complete representation of the current configuration (i.e., <b>BEFORE</b> any modifications are applied) and which can be fed back to this method later in order to restore the previous configuration.</p>

<p>There are three aspects of the way certain overloaded operators behave which can be controlled with this method:</p>

<pre>  +  the way scalar operands (replacing one of the two
     bit vector object operands) are automatically
     converted internally into a bit vector object of
     their own,

  +  the operation certain overloaded operators perform,
     i.e., an operation with sets or an arithmetic
     operation,

  +  the format to which bit vectors are converted
     automatically when they are enclosed in double
     quotes.</pre>

<p>The input string may contain any number of assignments, each of which controls one of these three aspects.</p>

<p>Each assignment has the form &#34;<code>&#60;which&#62;=&#60;value&#62;</code>&#34;.</p>

<p>&#34;<code>&#60;which&#62;</code>&#34; and &#34;<code>&#60;value&#62;</code>&#34; thereby consist of letters (<code>[a-zA-Z]</code>) and white space.</p>

<p>Multiple assignments have to be separated by one or more comma (&#34;,&#34;), semi-colon (&#34;;&#34;), colon (&#34;:&#34;), vertical bar (&#34;|&#34;), slash (&#34;/&#34;), newline (&#34;\n&#34;), ampersand (&#34;&#38;&#34;), plus (&#34;+&#34;) or dash (&#34;-&#34;).</p>

<p>Empty lines or statements (only white space) are allowed but will be ignored.</p>

<p>&#34;<code>&#60;which&#62;</code>&#34; has to contain one or more keywords from one of three groups, each group representing one of the three aspects that the &#34;<code>Configuration()</code>&#34; method controls:</p>

<pre>  +  &#34;^scalar&#34;, &#34;^input&#34;, &#34;^in$&#34;

  +  &#34;^operator&#34;, &#34;^semantic&#34;, &#34;^ops$&#34;

  +  &#34;^string&#34;, &#34;^output&#34;, &#34;^out$&#34;</pre>

<p>The character &#34;^&#34; thereby denotes the beginning of a word, and &#34;$&#34; denotes the end. Case is ignored (!).</p>

<p>Using these keywords, you can build any phrase you like to select one of the three aspects (see also examples given below).</p>

<p>The only condition is that no other keyword from any of the other two groups may match - otherwise a syntax error will occur (i.e., ambiguities are forbidden). A syntax error also occurs if none of the keywords matches.</p>

<p>This same principle applies to &#34;<code>&#60;value&#62;</code>&#34;:</p>

<p>Depending on which aspect you specified for &#34;<code>&#60;which&#62;</code>&#34;, there are different groups of keywords that determine the value the selected aspect will be set to:</p>

<pre>  +  &#34;&#60;which&#62;&#34; = &#34;^scalar&#34;, &#34;^input&#34;, &#34;^in$&#34;:

       &#34;&#60;value&#62;&#34; =

       *  &#34;^bit$&#34;, &#34;^index&#34;, &#34;^indice&#34;
       *  &#34;^hex&#34;
       *  &#34;^bin&#34;
       *  &#34;^dec&#34;
       *  &#34;^enum&#34;

  +  &#34;&#60;which&#62;&#34; = &#34;^operator&#34;, &#34;^semantic&#34;, &#34;^ops$&#34;:

       &#34;&#60;value&#62;&#34; =

       *  &#34;^set$&#34;
       *  &#34;^arithmetic&#34;

  +  &#34;&#60;which&#62;&#34; = &#34;^string&#34;, &#34;^output&#34;, &#34;^out$&#34;:

       &#34;&#60;value&#62;&#34; =

       *  &#34;^hex&#34;
       *  &#34;^bin&#34;
       *  &#34;^dec&#34;
       *  &#34;^enum&#34;</pre>

<p>Examples:</p>

<pre>  &#34;Any scalar input I provide should be considered to be = a bit index&#34;

  &#34;I want to have operator semantics suitable for = arithmetics&#34;

  &#34;Any bit vector in double quotes is to be output as = an enumeration&#34;</pre>

<p><b>SCALAR INPUT:</b></p>

<p>In the case of scalar input, &#34;<code>^bit$</code>&#34;, &#34;<code>^index</code>&#34;, or &#34;<code>^indice</code>&#34; all cause scalar input to be considered to represent a bit index, i.e., &#34;<code>$vector ^= 5;</code>&#34; will flip bit #5 in the given bit vector (this is essentially the same as &#34;<code>$vector-&#62;bit_flip(5);</code>&#34;).</p>

<p>Note that &#34;bit indices&#34; is the default setting for &#34;scalar input&#34;.</p>

<p>The keyword &#34;<code>^hex</code>&#34; will cause scalar input to be considered as being in hexadecimal, i.e., &#34;<code>$vector ^= 5;</code>&#34; will flip bit #0 and bit #2 (because hexadecimal &#34;<code>5</code>&#34; is binary &#34;<code>0101</code>&#34;).</p>

<p>(Note though that hexadecimal input should always be enclosed in quotes, otherwise it will be interpreted as a decimal number by Perl! The example relies on the fact that hexadecimal <code>0-9</code> and decimal <code>0-9</code> are the same.)</p>

<p>The keyword &#34;<code>^bin</code>&#34; will cause scalar input to be considered as being in binary format. All characters except &#34;<code>0</code>&#34; and &#34;<code>1</code>&#34; are forbidden in this case (i.e., produce a syntax error).</p>

<p>&#34;<code>$vector ^= &#39;0101&#39;;</code>&#34;, for instance, will flip bit #0 and bit #2.</p>

<p>The keyword &#34;<code>^dec</code>&#34; causes scalar input to be considered as integers in decimal format, i.e., &#34;<code>$vector ^= 5;</code>&#34; will flip bit #0 and bit #2 (because decimal &#34;<code>5</code>&#34; is binary &#34;<code>0101</code>&#34;).</p>

<p>(Note though that all decimal input should be enclosed in quotes, because for large numbers, Perl will use scientific notation internally for representing them, which produces a syntax error because scientific notation is neither supported by this module nor needed.)</p>

<p>Finally, the keyword &#34;<code>^enum</code>&#34; causes scalar input to be considered as being a list (&#34;enumeration&#34;) of indices and ranges of (contiguous) indices, i.e., &#34;<code>$vector |= &#39;2,3,5,7-13,17-23&#39;;</code>&#34; will cause bits #2, #3, #5, #7 through #13 and #17 through #23 to be set.</p>

<p><b>OPERATOR SEMANTICS:</b></p>

<p>Several overloaded operators can have two distinct functions depending on this setting.</p>

<p>The affected operators are: &#34;<code>+</code>&#34;, &#34;<code>-</code>&#34;, &#34;<code>*</code>&#34;, &#34;<code>&#60;</code>&#34;, &#34;<code>&#60;=</code>&#34;, &#34;<code>&#62;</code>&#34; and &#34;<code>&#62;=</code>&#34;.</p>

<p>With the default setting, &#34;set operations&#34;, these operators perform:</p>

<pre>  +       set union                           ( set1  u   set2 )
  -       set difference                      ( set1  \   set2 )
  *       set intersection                    ( set1  n   set2 )
  &#60;       true subset relationship            ( set1  &#60;   set2 )
  &#60;=      subset relationship                 ( set1  &#60;=  set2 )
  &#62;       true superset relationship          ( set1  &#62;   set2 )
  &#62;=      superset relationship               ( set1  &#62;=  set2 )</pre>

<p>With the alternative setting, &#34;arithmetic operations&#34;, these operators perform:</p>

<pre>  +       addition                            ( num1  +   num2 )
  -       subtraction                         ( num1  -   num2 )
  *       multiplication                      ( num1  *   num2 )
  &#60;       &#34;less than&#34; comparison              ( num1  &#60;   num2 )
  &#60;=      &#34;less than or equal&#34; comparison     ( num1  &#60;=  num2 )
  &#62;       &#34;greater than&#34; comparison           ( num1  &#62;   num2 )
  &#62;=      &#34;greater than or equal&#34; comparison  ( num1  &#62;=  num2 )</pre>

<p>Note that these latter comparison operators (&#34;<code>&#60;</code>&#34;, &#34;<code>&#60;=</code>&#34;, &#34;<code>&#62;</code>&#34; and &#34;<code>&#62;=</code>&#34;) regard their operands as being <b>SIGNED</b>.</p>

<p>To perform comparisons with <b>UNSIGNED</b> operands, use the operators &#34;<code>lt</code>&#34;, &#34;<code>le</code>&#34;, &#34;<code>gt</code>&#34; and &#34;<code>ge</code>&#34; instead (in contrast to the operators above, these operators are <b>NOT</b> affected by the &#34;operator semantics&#34; setting).</p>

<p><b>STRING OUTPUT:</b></p>

<p>There are four methods which convert the contents of a given bit vector into a string: &#34;<code>to_Hex()</code>&#34;, &#34;<code>to_Bin()</code>&#34;, &#34;<code>to_Dec()</code>&#34; and &#34;<code>to_Enum()</code>&#34; (not counting &#34;<code>Block_Read()</code>&#34;, since this method does not return a human-readable string).</p>

<p>(For conversion to octal, see the description of the method &#34;<code>Chunk_List_Read()</code>&#34;.)</p>

<p>Therefore, there are four possible formats into which a bit vector can be converted when it is enclosed in double quotes, for example:</p>

<pre>  print &#34;\$vector = &#39;$vector&#39;\n&#34;;
  $string = &#34;$vector&#34;;</pre>

<p>Hence you can set &#34;string output&#34; to four different values: To &#34;hex&#34; for hexadecimal format (which is the default), to &#34;bin&#34; for binary format, to &#34;dec&#34; for conversion to decimal numbers and to &#34;enum&#34; for conversion to enumerations (&#34;.newsrc&#34; style sets).</p>

<p><b>BEWARE</b> that the conversion to decimal numbers is inherently slow; it can easily take up several seconds for a single large bit vector!</p>

<p>Therefore you should store the decimal strings returned to you rather than converting a given bit vector again.</p>

<p><b>EXAMPLES:</b></p>

<p>The default setting as returned by the method &#34;<code>Configuration()</code>&#34; is:</p>

<pre>        Scalar Input       = Bit Index
        Operator Semantics = Set Operators
        String Output      = Hexadecimal</pre>

<p>Performing a statement such as:</p>

<pre>  Bit::Vector-&#62;Configuration(&#34;in=bin,ops=arithmetic,out=bin&#34;);
  print Bit::Vector-&#62;Configuration(), &#34;\n&#34;;</pre>

<p>yields the following output:</p>

<pre>        Scalar Input       = Binary
        Operator Semantics = Arithmetic Operators
        String Output      = Binary</pre>

<p>Note that you can always feed this output back into the &#34;<code>Configuration()</code>&#34; method to restore that setting later.</p>

<p>This also means that you can enter the same given setting with almost any degree of verbosity you like (as long as the required keywords appear and no ambiguities arise).</p>

<p>Note further that any aspect you do not specify is not changed, i.e., the statement</p>

<pre>  Bit::Vector-&#62;Configuration(&#34;operators = arithmetic&#34;);</pre>

<p>leaves all other aspects unchanged.</p>
</li>

<li><code>&#34;$vector&#34;</code>
<p>Remember that variables enclosed in double quotes are always interpolated in Perl.</p>

<p>Whenever a Perl variable containing the reference of a &#34;Bit::Vector&#34; object is enclosed in double quotes (either alone or together with other text and/or variables), the contents of the corresponding bit vector are converted into a printable string.</p>

<p>Since there are several conversion methods available in this module (see the description of the methods &#34;<code>to_Hex()</code>&#34;, &#34;<code>to_Bin()</code>&#34;, &#34;<code>to_Dec()</code>&#34; and &#34;<code>to_Enum()</code>&#34;), it is of course desirable to be able to choose which of these methods should be applied in this case.</p>

<p>This can actually be done by changing the configuration of this module using the method &#34;<code>Configure()</code>&#34; (see the previous chapter, immediately above).</p>

<p>The default is conversion to hexadecimal.</p>
</li>

<li><code>if ($vector)</code>
<p>It is possible to use a Perl variable containing the reference of a &#34;Bit::Vector&#34; object as a boolean expression.</p>

<p>The condition above is true if the corresponding bit vector contains at least one set bit, and it is false if <b>ALL</b> bits of the corresponding bit vector are cleared.</p>
</li>

<li><code>if (!$vector)</code>
<p>Since it is possible to use a Perl variable containing the reference of a &#34;Bit::Vector&#34; object as a boolean expression, you can of course also negate this boolean expression.</p>

<p>The condition above is true if <b>ALL</b> bits of the corresponding bit vector are cleared, and it is false if the corresponding bit vector contains at least one set bit.</p>

<p>Note that this is <b>NOT</b> the same as using the method &#34;<code>is_full()</code>&#34;, which returns true if <b>ALL</b> bits of the corresponding bit vector are <b>SET</b>.</p>
</li>

<li><code>~$vector</code>
<p>This term returns a new bit vector object which is the one&#39;s complement of the given bit vector.</p>

<p>This is equivalent to inverting all bits.</p>
</li>

<li><code>-$vector</code> (unary minus)
<p>This term returns a new bit vector object which is the two&#39;s complement of the given bit vector.</p>

<p>This is equivalent to inverting all bits and incrementing the result by one.</p>

<p>(This is the same as changing the sign of a number in two&#39;s complement binary representation.)</p>
</li>

<li><code>abs($vector)</code>
<p>Depending on the configuration (see the description of the method &#34;<code>Configuration()</code>&#34; for more details), this term either returns the number of set bits in the given bit vector (this is the same as calculating the number of elements which are contained in the given set) - which is the default behaviour, or it returns a new bit vector object which contains the absolute value of the number stored in the given bit vector.</p>
</li>

<li><code>$vector1 . $vector2</code>
<p>This term usually returns a new bit vector object which is the result of the concatenation of the two bit vector operands.</p>

<p>The left operand becomes the most significant, and the right operand becomes the least significant part of the new bit vector object.</p>

<p>If one of the two operands is not a bit vector object but a Perl scalar, however, the contents of the remaining bit vector operand are converted into a string (the format of which depends on the configuration set with the &#34;<code>Configuration()</code>&#34; method), which is then concatenated in the proper order (i.e., as indicated by the order of the two operands) with the Perl scalar.</p>

<p>In other words, a string is returned in such a case instead of a bit vector object!</p>
</li>

<li><code>$vector x $factor</code>
<p>This term returns a new bit vector object which is the concatenation of as many copies of the given bit vector operand (the left operand) as the factor (the right operand) specifies.</p>

<p>If the factor is zero, a bit vector object with a length of zero bits is returned.</p>

<p>If the factor is one, just a new copy of the given bit vector is returned.</p>

<p>Note that a fatal &#34;reversed operands error&#34; occurs if the two operands are swapped.</p>
</li>

<li><code>$vector &#60;&#60; $bits</code>
<p>This term returns a new bit vector object which is a copy of the given bit vector (the left operand), which is then shifted left (towards the most significant bit) by as many places as the right operand, &#34;<code>$bits</code>&#34;, specifies.</p>

<p>This means that the &#34;<code>$bits</code>&#34; most significant bits are lost, all other bits move up by &#34;<code>$bits</code>&#34; positions, and the &#34;<code>$bits</code>&#34; least significant bits that have been left unoccupied by this shift are all set to zero.</p>

<p>If &#34;<code>$bits</code>&#34; is greater than the number of bits of the given bit vector, this term returns an empty bit vector (i.e., with all bits cleared) of the same size as the given bit vector.</p>

<p>Note that a fatal &#34;reversed operands error&#34; occurs if the two operands are swapped.</p>
</li>

<li><code>$vector &#62;&#62; $bits</code>
<p>This term returns a new bit vector object which is a copy of the given bit vector (the left operand), which is then shifted right (towards the least significant bit) by as many places as the right operand, &#34;<code>$bits</code>&#34;, specifies.</p>

<p>This means that the &#34;<code>$bits</code>&#34; least significant bits are lost, all other bits move down by &#34;<code>$bits</code>&#34; positions, and the &#34;<code>$bits</code>&#34; most significant bits that have been left unoccupied by this shift are all set to zero.</p>

<p>If &#34;<code>$bits</code>&#34; is greater than the number of bits of the given bit vector, this term returns an empty bit vector (i.e., with all bits cleared) of the same size as the given bit vector.</p>

<p>Note that a fatal &#34;reversed operands error&#34; occurs if the two operands are swapped.</p>
</li>

<li><code>$vector1 | $vector2</code>
<p>This term returns a new bit vector object which is the result of a bitwise OR operation between the two bit vector operands.</p>

<p>This is the same as calculating the union of two sets.</p>
</li>

<li><code>$vector1 &#38; $vector2</code>
<p>This term returns a new bit vector object which is the result of a bitwise AND operation between the two bit vector operands.</p>

<p>This is the same as calculating the intersection of two sets.</p>
</li>

<li><code>$vector1 ^ $vector2</code>
<p>This term returns a new bit vector object which is the result of a bitwise XOR (exclusive-or) operation between the two bit vector operands.</p>

<p>This is the same as calculating the symmetric difference of two sets.</p>
</li>

<li><code>$vector1 + $vector2</code>
<p>Depending on the configuration (see the description of the method &#34;<code>Configuration()</code>&#34; for more details), this term either returns a new bit vector object which is the result of a bitwise OR operation between the two bit vector operands (this is the same as calculating the union of two sets) - which is the default behaviour, or it returns a new bit vector object which contains the sum of the two numbers stored in the two bit vector operands.</p>
</li>

<li><code>$vector1 - $vector2</code>
<p>Depending on the configuration (see the description of the method &#34;<code>Configuration()</code>&#34; for more details), this term either returns a new bit vector object which is the set difference of the two sets represented in the two bit vector operands - which is the default behaviour, or it returns a new bit vector object which contains the difference of the two numbers stored in the two bit vector operands.</p>
</li>

<li><code>$vector1 * $vector2</code>
<p>Depending on the configuration (see the description of the method &#34;<code>Configuration()</code>&#34; for more details), this term either returns a new bit vector object which is the result of a bitwise AND operation between the two bit vector operands (this is the same as calculating the intersection of two sets) - which is the default behaviour, or it returns a new bit vector object which contains the product of the two numbers stored in the two bit vector operands.</p>
</li>

<li><code>$vector1 / $vector2</code>
<p>This term returns a new bit vector object containing the result of the division of the two numbers stored in the two bit vector operands.</p>
</li>

<li><code>$vector1 % $vector2</code>
<p>This term returns a new bit vector object containing the remainder of the division of the two numbers stored in the two bit vector operands.</p>
</li>

<li><code>$vector1 ** $vector2</code>
<p>This term returns a new bit vector object containing the result of the exponentiation of the left bit vector elevated to the right bit vector&#39;s power.</p>
</li>

<li><code>$vector1 .= $vector2;</code>
<p>This statement &#34;appends&#34; the right bit vector operand (the &#34;rvalue&#34;) to the left one (the &#34;lvalue&#34;).</p>

<p>The former contents of the left operand become the most significant part of the resulting bit vector, and the right operand becomes the least significant part.</p>

<p>Since bit vectors are stored in &#34;least order bit first&#34; order, this actually requires the left operand to be shifted &#34;up&#34; by the length of the right operand, which is then copied to the now freed least significant part of the left operand.</p>

<p>If the right operand is a Perl scalar, it is first converted to a bit vector of the same size as the left operand, provided that the configuration states that scalars are to be regarded as indices, decimal strings or enumerations.</p>

<p>If the configuration states that scalars are to be regarded as hexadecimal or boolean strings, however, these strings are converted to bit vectors of a size matching the length of the input string, i.e., four times the length for hexadecimal strings (because each hexadecimal digit is worth 4 bits) and once the length for binary strings.</p>
</li>

<li><code>$vector x= $factor;</code>
<p>This statement replaces the given bit vector by a concatenation of as many copies of the original contents of the given bit vector as the factor (the right operand) specifies.</p>

<p>If the factor is zero, the given bit vector is resized to a length of zero bits.</p>

<p>If the factor is one, the given bit vector is not changed at all.</p>
</li>

<li><code>$vector &#60;&#60;= $bits;</code>
<p>This statement moves the contents of the given bit vector left by &#34;<code>$bits</code>&#34; positions (towards the most significant bit).</p>

<p>This means that the &#34;<code>$bits</code>&#34; most significant bits are lost, all other bits move up by &#34;<code>$bits</code>&#34; positions, and the &#34;<code>$bits</code>&#34; least significant bits that have been left unoccupied by this shift are all set to zero.</p>

<p>If &#34;<code>$bits</code>&#34; is greater than the number of bits of the given bit vector, the given bit vector is erased completely (i.e., all bits are cleared).</p>
</li>

<li><code>$vector &#62;&#62;= $bits;</code>
<p>This statement moves the contents of the given bit vector right by &#34;<code>$bits</code>&#34; positions (towards the least significant bit).</p>

<p>This means that the &#34;<code>$bits</code>&#34; least significant bits are lost, all other bits move down by &#34;<code>$bits</code>&#34; positions, and the &#34;<code>$bits</code>&#34; most significant bits that have been left unoccupied by this shift are all set to zero.</p>

<p>If &#34;<code>$bits</code>&#34; is greater than the number of bits of the given bit vector, the given bit vector is erased completely (i.e., all bits are cleared).</p>
</li>

<li><code>$vector1 |= $vector2;</code>
<p>This statement performs a bitwise OR operation between the two bit vector operands and stores the result in the left operand.</p>

<p>This is the same as calculating the union of two sets.</p>
</li>

<li><code>$vector1 &#38;= $vector2;</code>
<p>This statement performs a bitwise AND operation between the two bit vector operands and stores the result in the left operand.</p>

<p>This is the same as calculating the intersection of two sets.</p>
</li>

<li><code>$vector1 ^= $vector2;</code>
<p>This statement performs a bitwise XOR (exclusive-or) operation between the two bit vector operands and stores the result in the left operand.</p>

<p>This is the same as calculating the symmetric difference of two sets.</p>
</li>

<li><code>$vector1 += $vector2;</code>
<p>Depending on the configuration (see the description of the method &#34;<code>Configuration()</code>&#34; for more details), this statement either performs a bitwise OR operation between the two bit vector operands (this is the same as calculating the union of two sets) - which is the default behaviour, or it calculates the sum of the two numbers stored in the two bit vector operands.</p>

<p>The result of this operation is stored in the left operand.</p>
</li>

<li><code>$vector1 -= $vector2;</code>
<p>Depending on the configuration (see the description of the method &#34;<code>Configuration()</code>&#34; for more details), this statement either calculates the set difference of the two sets represented in the two bit vector operands - which is the default behaviour, or it calculates the difference of the two numbers stored in the two bit vector operands.</p>

<p>The result of this operation is stored in the left operand.</p>
</li>

<li><code>$vector1 *= $vector2;</code>
<p>Depending on the configuration (see the description of the method &#34;<code>Configuration()</code>&#34; for more details), this statement either performs a bitwise AND operation between the two bit vector operands (this is the same as calculating the intersection of two sets) - which is the default behaviour, or it calculates the product of the two numbers stored in the two bit vector operands.</p>

<p>The result of this operation is stored in the left operand.</p>
</li>

<li><code>$vector1 /= $vector2;</code>
<p>This statement puts the result of the division of the two numbers stored in the two bit vector operands into the left operand.</p>
</li>

<li><code>$vector1 %= $vector2;</code>
<p>This statement puts the remainder of the division of the two numbers stored in the two bit vector operands into the left operand.</p>
</li>

<li><code>$vector1 **= $vector2;</code>
<p>This statement puts the result of the exponentiation of the left operand elevated to the right operand&#39;s power into the left operand.</p>
</li>

<li><code>++$vector</code>, <code>$vector++</code>
<p>This operator performs pre- and post-incrementation of the given bit vector.</p>

<p>The value returned by this term is a reference of the given bit vector object (after or before the incrementation, respectively).</p>
</li>

<li><code>--$vector</code>, <code>$vector--</code>
<p>This operator performs pre- and post-decrementation of the given bit vector.</p>

<p>The value returned by this term is a reference of the given bit vector object (after or before the decrementation, respectively).</p>
</li>

<li><code>($vector1 cmp $vector2)</code>
<p>This term returns &#34;<code>-1</code>&#34; if &#34;<code>$vector1</code>&#34; is less than &#34;<code>$vector2</code>&#34;, &#34;<code>0</code>&#34; if &#34;<code>$vector1</code>&#34; and &#34;<code>$vector2</code>&#34; are the same, and &#34;<code>1</code>&#34; if &#34;<code>$vector1</code>&#34; is greater than &#34;<code>$vector2</code>&#34;.</p>

<p>This comparison assumes <b>UNSIGNED</b> bit vectors.</p>
</li>

<li><code>($vector1 eq $vector2)</code>
<p>This term returns true (&#34;<code>1</code>&#34;) if the contents of the two bit vector operands are the same and false (&#34;<code>0</code>&#34;) otherwise.</p>
</li>

<li><code>($vector1 ne $vector2)</code>
<p>This term returns true (&#34;<code>1</code>&#34;) if the two bit vector operands differ and false (&#34;<code>0</code>&#34;) otherwise.</p>
</li>

<li><code>($vector1 lt $vector2)</code>
<p>This term returns true (&#34;<code>1</code>&#34;) if &#34;<code>$vector1</code>&#34; is less than &#34;<code>$vector2</code>&#34;, and false (&#34;<code>0</code>&#34;) otherwise.</p>

<p>This comparison assumes <b>UNSIGNED</b> bit vectors.</p>
</li>

<li><code>($vector1 le $vector2)</code>
<p>This term returns true (&#34;<code>1</code>&#34;) if &#34;<code>$vector1</code>&#34; is less than or equal to &#34;<code>$vector2</code>&#34;, and false (&#34;<code>0</code>&#34;) otherwise.</p>

<p>This comparison assumes <b>UNSIGNED</b> bit vectors.</p>
</li>

<li><code>($vector1 gt $vector2)</code>
<p>This term returns true (&#34;<code>1</code>&#34;) if &#34;<code>$vector1</code>&#34; is greater than &#34;<code>$vector2</code>&#34;, and false (&#34;<code>0</code>&#34;) otherwise.</p>

<p>This comparison assumes <b>UNSIGNED</b> bit vectors.</p>
</li>

<li><code>($vector1 ge $vector2)</code>
<p>This term returns true (&#34;<code>1</code>&#34;) if &#34;<code>$vector1</code>&#34; is greater than or equal to &#34;<code>$vector2</code>&#34;, and false (&#34;<code>0</code>&#34;) otherwise.</p>

<p>This comparison assumes <b>UNSIGNED</b> bit vectors.</p>
</li>

<li><code>($vector1 &#60;=&#62; $vector2)</code>
<p>This term returns &#34;<code>-1</code>&#34; if &#34;<code>$vector1</code>&#34; is less than &#34;<code>$vector2</code>&#34;, &#34;<code>0</code>&#34; if &#34;<code>$vector1</code>&#34; and &#34;<code>$vector2</code>&#34; are the same, and &#34;<code>1</code>&#34; if &#34;<code>$vector1</code>&#34; is greater than &#34;<code>$vector2</code>&#34;.</p>

<p>This comparison assumes <b>SIGNED</b> bit vectors.</p>
</li>

<li><code>($vector1 == $vector2)</code>
<p>This term returns true (&#34;<code>1</code>&#34;) if the contents of the two bit vector operands are the same and false (&#34;<code>0</code>&#34;) otherwise.</p>
</li>

<li><code>($vector1 != $vector2)</code>
<p>This term returns true (&#34;<code>1</code>&#34;) if the two bit vector operands differ and false (&#34;<code>0</code>&#34;) otherwise.</p>
</li>

<li><code>($vector1 &#60; $vector2)</code>
<p>Depending on the configuration (see the description of the method &#34;<code>Configuration()</code>&#34; for more details), this term either returns true (&#34;<code>1</code>&#34;) if &#34;<code>$vector1</code>&#34; is a true subset of &#34;<code>$vector2</code>&#34; (and false (&#34;<code>0</code>&#34;) otherwise) - which is the default behaviour, or it returns true (&#34;<code>1</code>&#34;) if &#34;<code>$vector1</code>&#34; is less than &#34;<code>$vector2</code>&#34; (and false (&#34;<code>0</code>&#34;) otherwise).</p>

<p>The latter comparison assumes <b>SIGNED</b> bit vectors.</p>
</li>

<li><code>($vector1 &#60;= $vector2)</code>
<p>Depending on the configuration (see the description of the method &#34;<code>Configuration()</code>&#34; for more details), this term either returns true (&#34;<code>1</code>&#34;) if &#34;<code>$vector1</code>&#34; is a subset of &#34;<code>$vector2</code>&#34; (and false (&#34;<code>0</code>&#34;) otherwise) - which is the default behaviour, or it returns true (&#34;<code>1</code>&#34;) if &#34;<code>$vector1</code>&#34; is less than or equal to &#34;<code>$vector2</code>&#34; (and false (&#34;<code>0</code>&#34;) otherwise).</p>

<p>The latter comparison assumes <b>SIGNED</b> bit vectors.</p>
</li>

<li><code>($vector1 &#62; $vector2)</code>
<p>Depending on the configuration (see the description of the method &#34;<code>Configuration()</code>&#34; for more details), this term either returns true (&#34;<code>1</code>&#34;) if &#34;<code>$vector1</code>&#34; is a true superset of &#34;<code>$vector2</code>&#34; (and false (&#34;<code>0</code>&#34;) otherwise) - which is the default behaviour, or it returns true (&#34;<code>1</code>&#34;) if &#34;<code>$vector1</code>&#34; is greater than &#34;<code>$vector2</code>&#34; (and false (&#34;<code>0</code>&#34;) otherwise).</p>

<p>The latter comparison assumes <b>SIGNED</b> bit vectors.</p>
</li>

<li><code>($vector1 &#62;= $vector2)</code>
<p>Depending on the configuration (see the description of the method &#34;<code>Configuration()</code>&#34; for more details), this term either returns true (&#34;<code>1</code>&#34;) if &#34;<code>$vector1</code>&#34; is a superset of &#34;<code>$vector2</code>&#34; (and false (&#34;<code>0</code>&#34;) otherwise) - which is the default behaviour, or it returns true (&#34;<code>1</code>&#34;) if &#34;<code>$vector1</code>&#34; is greater than or equal to &#34;<code>$vector2</code>&#34; (and false (&#34;<code>0</code>&#34;) otherwise).</p>

<p>The latter comparison assumes <b>SIGNED</b> bit vectors.</p>
</li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>Bit::Vector(3), Bit::Vector::String(3).</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>This man page documents &#34;Bit::Vector::Overload&#34; version 7.3.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<pre>  Steffen Beyer
  mailto:STBEY@cpan.org
  http://www.engelschall.com/u/sb/download/</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright (c) 2000 - 2013 by Steffen Beyer. All rights reserved.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LICENSE"
>LICENSE</a></h1>

<p>This package is free software; you can redistribute it and/or modify it under the same terms as Perl itself, i.e., under the terms of the &#34;Artistic License&#34; or the &#34;GNU General Public License&#34;.</p>

<p>The C library at the core of this Perl module can additionally be redistributed and/or modified under the terms of the &#34;GNU Library General Public License&#34;.</p>

<p>Please refer to the files &#34;Artistic.txt&#34;, &#34;GNU_GPL.txt&#34; and &#34;GNU_LGPL.txt&#34; in this distribution for details!</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DISCLAIMER"
>DISCLAIMER</a></h1>

<p>This package is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</p>

<p>See the &#34;GNU General Public License&#34; for more details.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
