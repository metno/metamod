<html><head><title>IO::HTML</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:19 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#SUBROUTINES'>SUBROUTINES</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#html_file'>html_file</a>
    <li class='indexItem indexItem2'><a href='#html_file_and_encoding'>html_file_and_encoding</a>
    <li class='indexItem indexItem2'><a href='#html_outfile'>html_outfile</a>
    <li class='indexItem indexItem2'><a href='#sniff_encoding'>sniff_encoding</a>
    <li class='indexItem indexItem2'><a href='#find_charset_in'>find_charset_in</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#EXPORTS'>EXPORTS</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#DIAGNOSTICS'>DIAGNOSTICS</a>
  <li class='indexItem indexItem1'><a href='#CONFIGURATION_AND_ENVIRONMENT'>CONFIGURATION AND ENVIRONMENT</a>
  <li class='indexItem indexItem1'><a href='#DEPENDENCIES'>DEPENDENCIES</a>
  <li class='indexItem indexItem1'><a href='#INCOMPATIBILITIES'>INCOMPATIBILITIES</a>
  <li class='indexItem indexItem1'><a href='#BUGS_AND_LIMITATIONS'>BUGS AND LIMITATIONS</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
  <li class='indexItem indexItem1'><a href='#DISCLAIMER_OF_WARRANTY'>DISCLAIMER OF WARRANTY</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>IO::HTML - Open an HTML file with automatic charset detection</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>This document describes version 0.04 of IO::HTML,
released February 4,
2012.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  use IO::HTML;                 # exports html_file by default
  use HTML::TreeBuilder;

  my $tree = HTML::TreeBuilder-&#62;new_from_file(
               html_file(&#39;foo.html&#39;)
             );

  # Alternative interface:
  open(my $in, &#39;&#60;:raw&#39;, &#39;bar.html&#39;);
  my $encoding = IO::HTML::sniff_encoding($in, &#39;bar.html&#39;);</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>IO::HTML provides an easy way to open a file containing HTML while automatically determining its encoding. It uses the HTML5 encoding sniffing algorithm specified in section 8.2.2.1 of the draft standard.</p>

<p>The algorithm as implemented here is:</p>

<ol>
<li>If the file begins with a byte order mark indicating UTF-16LE, UTF-16BE, or UTF-8, then that is the encoding.</li>

<li>If the first 1024 bytes of the file contain a <code>&#60;meta&#62;</code> tag that indicates the charset, and Encode recognizes the specified charset name, then that is the encoding. (This portion of the algorithm is implemented by <code>find_charset_in</code>.)
<p>The <code>&#60;meta&#62;</code> tag can be in one of two formats:</p>

<pre>  &#60;meta charset=&#34;...&#34;&#62;
  &#60;meta http-equiv=&#34;Content-Type&#34; content=&#34;...charset=...&#34;&#62;</pre>

<p>The search is case-insensitive, and the order of attributes within the tag is irrelevant. Any additional attributes of the tag are ignored. The first matching tag with a recognized encoding ends the search.</p>
</li>

<li>If the first 1024 bytes of the file are valid UTF-8 (with at least 1 non-ASCII character), then the encoding is UTF-8.</li>

<li>If all else fails, use the default character encoding. The HTML5 standard suggests the default encoding should be locale dependent, but currently it is always <code>cp1252</code> unless you set <code>$IO::HTML::default_encoding</code> to a different value. Note: <code>sniff_encoding</code> does not apply this step; only <code>html_file</code> does that.</li>
</ol>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SUBROUTINES"
>SUBROUTINES</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="html_file"
>html_file</a></h2>

<pre>  $filehandle = html_file($filename, \%options);</pre>

<p>This function (exported by default) is the primary entry point. It opens the file specified by <code>$filename</code> for reading, uses <code>sniff_encoding</code> to find a suitable encoding layer, and applies it. It also applies the <code>:crlf</code> layer. If the file begins with a BOM, the filehandle is positioned just after the BOM.</p>

<p>The optional second argument is a hashref containing options. The possible keys are described under <code>find_charset_in</code>.</p>

<p>If <code>sniff_encoding</code> is unable to determine the encoding, it defaults to <code>$IO::HTML::default_encoding</code>, which is set to <code>cp1252</code> (a.k.a. Windows-1252) by default. According to the standard, the default should be locale dependent, but that is not currently implemented.</p>

<p>It dies if the file cannot be opened.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="html_file_and_encoding"
>html_file_and_encoding</a></h2>

<pre>  ($filehandle, $encoding, $bom)
    = html_file_and_encoding($filename, \%options);</pre>

<p>This function (exported only by request) is just like <code>html_file</code>, but returns more information. In addition to the filehandle, it returns the name of the encoding used, and a flag indicating whether a byte order mark was found (if <code>$bom</code> is true, the file began with a BOM). This may be useful if you want to write the file out again (especially in conjunction with the <code>html_outfile</code> function).</p>

<p>The optional second argument is a hashref containing options. The possible keys are described under <code>find_charset_in</code>.</p>

<p>It dies if the file cannot be opened. The result of calling it in scalar context is undefined.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="html_outfile"
>html_outfile</a></h2>

<pre>  $filehandle = html_outfile($filename, $encoding, $bom);</pre>

<p>This function (exported only by request) opens <code>$filename</code> for output using <code>$encoding</code>, and writes a BOM to it if <code>$bom</code> is true. If <code>$encoding</code> is <code>undef</code>, it defaults to <code>$IO::HTML::default_encoding</code>. <code>$encoding</code> may be either an encoding name or an Encode::Encoding object.</p>

<p>It dies if the file cannot be opened.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="sniff_encoding"
>sniff_encoding</a></h2>

<pre>  ($encoding, $bom) = sniff_encoding($filehandle, $filename, \%options);</pre>

<p>This function (exported only by request) runs the HTML5 encoding sniffing algorithm on <code>$filehandle</code> (which must be seekable, and should have been opened in <code>:raw</code> mode). <code>$filename</code> is used only for error messages (if there&#39;s a problem using the filehandle), and defaults to &#34;file&#34; if omitted. The optional third argument is a hashref containing options. The possible keys are described under <code>find_charset_in</code>.</p>

<p>It returns Perl&#39;s canonical name for the encoding, which is not necessarily the same as the MIME or IANA charset name. It returns <code>undef</code> if the encoding cannot be determined. <code>$bom</code> is true if the file began with a byte order mark. In scalar context, it returns only <code>$encoding</code>.</p>

<p>Tip: If you want to run <code>sniff_encoding</code> on a file you&#39;ve already loaded into a string, open an in-memory file on the string, and pass that handle:</p>

<pre>  ($encoding, $bom) = do {
    open(my $fh, &#39;&#60;&#39;, \$string);  sniff_encoding($fh)
  };</pre>

<p>(This only makes sense if <code>utf8::is_utf8($string)</code> is false.)</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="find_charset_in"
>find_charset_in</a></h2>

<pre>  $encoding = find_charset_in($string_containing_HTML, \%options);</pre>

<p>This function (exported only by request) looks for charset information in a <code>&#60;meta&#62;</code> tag in a possibly incomplete HTML document using the &#34;two step&#34; algorithm specified by HTML5. It does not look for a BOM. Only the first 1024 bytes of the string are checked.</p>

<p>It returns Perl&#39;s canonical name for the encoding, which is not necessarily the same as the MIME or IANA charset name. It returns <code>undef</code> if no charset is specified or if the specified charset is not recognized by the Encode module.</p>

<p>The optional second argument is a hashref containing options. The following keys are recognized:</p>

<dl>
<dt><a name="encoding"
><code>encoding</code></a></dt>

<dd>
<p>If true, return the <a href="../Encode/Encoding.html" class="podlinkpod"
>Encode::Encoding</a> object instead of its name. Defaults to false.</p>

<dt><a name="need_pragma"
><code>need_pragma</code></a></dt>

<dd>
<p>If true (the default), follow the HTML5 spec and examine the <code>content</code> attribute only of <code>&#60;meta http-equiv=&#34;Content-Type&#34;</code>. If set to 0, relax the HTML5 spec, and look for &#34;charset=&#34; in the <code>content</code> attribute of <i>every</i> meta tag.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXPORTS"
>EXPORTS</a></h1>

<p>By default, only <code>html_file</code> is exported. Other functions may be exported on request.</p>

<p>For people who prefer not to export functions, all functions beginning with <code>html_</code> have an alias without that prefix (e.g. you can call <code>IO::HTML::file(...)</code> instead of <code>IO::HTML::html_file(...)</code>. These aliases are not exportable.</p>

<p>The following export tags are available:</p>

<dl>
<dt><a name=":all"
><code>:all</code></a></dt>

<dd>
<p>All exportable functions.</p>

<dt><a name=":rw"
><code>:rw</code></a></dt>

<dd>
<p><code>html_file</code>, <code>html_file_and_encoding</code>, <code>html_outfile</code>.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>The HTML5 specification, section 8.2.2.1 Determining the character encoding: <a href="http://www.w3.org/TR/html5/parsing.html#determining-the-character-encoding" class="podlinkurl"
>http://www.w3.org/TR/html5/parsing.html#determining-the-character-encoding</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DIAGNOSTICS"
>DIAGNOSTICS</a></h1>

<dl>
<dt><a name="Could_not_read_%s:_%s"
><code>Could not read %s: %s</code></a></dt>

<dd>
<p>The specified file could not be read from for the reason specified by <code>$!</code>.</p>

<dt><a name="Could_not_seek_%s:_%s"
><code>Could not seek %s: %s</code></a></dt>

<dd>
<p>The specified file could not be rewound for the reason specified by <code>$!</code>.</p>

<dt><a name="Failed_to_open_%s:_%s"
><code>Failed to open %s: %s</code></a></dt>

<dd>
<p>The specified file could not be opened for reading for the reason specified by <code>$!</code>.</p>

<dt><a name="No_default_encoding_specified"
><code>No default encoding specified</code></a></dt>

<dd>
<p>The <code>sniff_encoding</code> algorithm didn&#39;t find an encoding to use, and you set <code>$IO::HTML::default_encoding</code> to <code>undef</code>.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CONFIGURATION_AND_ENVIRONMENT"
>CONFIGURATION AND ENVIRONMENT</a></h1>

<p>IO::HTML requires no configuration files or environment variables.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DEPENDENCIES"
>DEPENDENCIES</a></h1>

<p>IO::HTML has no non-core dependencies for Perl 5.8.7+. With earlier versions of Perl 5.8, you need to upgrade <a href="../Encode.html" class="podlinkpod"
>Encode</a> to at least version 2.10, and you may need to upgrade <a href="../Exporter.html" class="podlinkpod"
>Exporter</a> to at least version 5.57.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="INCOMPATIBILITIES"
>INCOMPATIBILITIES</a></h1>

<p>None reported.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS_AND_LIMITATIONS"
>BUGS AND LIMITATIONS</a></h1>

<p>No bugs have been reported.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Christopher J. Madsen <code>&#60;perl&#160;AT&#160;cjmweb.net&#62;</code></p>

<p>Please report any bugs or feature requests to <code>&#60;bug-IO-HTML&#160;AT&#160;rt.cpan.org&#62;</code> or through the web interface at <a href="http://rt.cpan.org/Public/Bug/Report.html?Queue=IO-HTML" class="podlinkurl"
>http://rt.cpan.org/Public/Bug/Report.html?Queue=IO-HTML</a>.</p>

<p>You can follow or contribute to IO-HTML&#39;s development at <a href="http://github.com/madsen/io-html" class="podlinkurl"
>http://github.com/madsen/io-html</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>This software is copyright (c) 2012 by Christopher J. Madsen.</p>

<p>This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DISCLAIMER_OF_WARRANTY"
>DISCLAIMER OF WARRANTY</a></h1>

<p>BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE SOFTWARE &#34;AS IS&#34; WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR, OR CORRECTION.</p>

<p>IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENSE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
