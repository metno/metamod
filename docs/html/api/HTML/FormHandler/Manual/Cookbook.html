<html><head><title>HTML::FormHandler::Manual::Cookbook</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:18 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#No_form_file%2C_no_template_file...'>No form file, no template file...</a>
    <li class='indexItem indexItem2'><a href='#Dynamically_change_the_active_fields'>Dynamically change the active fields</a>
    <li class='indexItem indexItem2'><a href='#Add_custom_attributes_to_FormHandler_fields'>Add custom attributes to FormHandler fields</a>
    <li class='indexItem indexItem2'><a href='#Select_lists'>Select lists</a>
    <li class='indexItem indexItem2'><a href='#The_database_and_FormHandler_forms'>The database and FormHandler forms</a>
    <li class='indexItem indexItem2'><a href='#Set_up_form_base_classes_or_roles_for_your_application'>Set up form base classes or roles for your application</a>
    <li class='indexItem indexItem2'><a href='#Split_up_your_forms_into_reusable_pieces'>Split up your forms into reusable pieces</a>
    <li class='indexItem indexItem2'><a href='#Access_a_user_record_in_the_form'>Access a user record in the form</a>
    <li class='indexItem indexItem2'><a href='#Handle_extra_database_fields'>Handle extra database fields</a>
    <li class='indexItem indexItem2'><a href='#Additional_changes_to_the_database'>Additional changes to the database</a>
    <li class='indexItem indexItem2'><a href='#Doing_cross_validation_in_roles'>Doing cross validation in roles</a>
    <li class='indexItem indexItem2'><a href='#Changing_required_flag'>Changing required flag</a>
    <li class='indexItem indexItem2'><a href='#Supply_an_external_coderef_for_validation'>Supply an external coderef for validation</a>
    <li class='indexItem indexItem2'><a href='#Example_of_a_form_with_custom_database_interface'>Example of a form with custom database interface</a>
    <li class='indexItem indexItem2'><a href='#A_form_that_takes_a_resultset%2C_with_custom_update_model'>A form that takes a resultset, with custom update_model</a>
    <li class='indexItem indexItem2'><a href='#Server-provided_dynamic_value_for_field'>Server-provided dynamic value for field</a>
    <li class='indexItem indexItem2'><a href='#Static_form%2C_dynamic_field_IDs'>Static form, dynamic field IDs</a>
    <li class='indexItem indexItem2'><a href='#Create_different_field_IDs'>Create different field IDs</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>HTML::FormHandler::Manual::Cookbook - FormHandler use recipes</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>version 0.40028</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<p><a href="../../../HTML/FormHandler/Manual.html" class="podlinkpod"
>Manual Index</a></p>

<p>Collection of use recipes for <a href="../../../HTML/FormHandler.html" class="podlinkpod"
>HTML::FormHandler</a></p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="No_form_file,_no_template_file..."
>No form file,
no template file...</a></h2>

<p>I had to create a tiny little form this week for admins to enter a comment,
and it seemed silly to have to create a form file and a template file.
I remembered that you can set the TT &#39;template&#39; to a string reference and not use a template at all,
which is nice when FormHandler will create the form HTML for you anyway.</p>

<pre>    sub comment : Chained(&#39;base_sub&#39;) PathPart(&#39;comment&#39;) Args(0) {
        my ( $self, $c ) = @_;

        my $form = HTML::FormHandler-&#62;new( field_list =&#62;
            [ comment =&#62; { type =&#62; &#39;Text&#39;, size =&#62; 60 },
              submit =&#62; {type =&#62; &#39;Submit&#39;} ] );
        $form-&#62;process($c-&#62;req-&#62;params);
        if ( $form-&#62;validated ) {
            $self-&#62;admin_log( $c, &#34;Admin::Queue&#34;, &#34;admin comment&#34;,
                  $form-&#62;field(&#39;comment&#39;)-&#62;value );
            $c-&#62;flash( message =&#62; &#39;Comment added&#39; );
            $c-&#62;res-&#62;redirect( $c-&#62;stash-&#62;{urilist}-&#62;{view} );
        }
        my $rendered_form = $form-&#62;render;
        $c-&#62;stash( template =&#62; \$rendered_form );
    }</pre>

<p>This creates the form on the fly with a comment field and a submit button, renders it using the default TT wrappers, then logs the comment. No other files at all....</p>

<p>FormHandler isn&#39;t really necessary for validation here, but it does make it possible to have a simple, standalone method.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Dynamically_change_the_active_fields"
>Dynamically change the active fields</a></h2>

<p>A common use case is for forms with some fields that should be displayed in some circumstances and not in others. There are a number of ways to do this. One way is to use the &#39;field_list&#39; method:</p>

<pre>   sub field_list {
      my $self = shift;
      my @fields;
      &#60;build list of fields&#62;
      return \@fields;
   }</pre>

<p>This only happens at form construction time, however. Another method that works is to define all of the possible fields in your form, and mark some of them &#39;inactive&#39;;</p>

<pre>   package MyApp::Variable::Form;
   use HTML::FormHandler::Moose;
   extends &#39;HTML::FormHandler&#39;;

   has_field &#39;foo&#39;;
   has_field &#39;bar&#39; =&#62; ( inactive =&#62; 1 );
   1;</pre>

<p>Set to &#39;active&#39; or &#39;inactive&#39; on the &#39;process&#39; call:</p>

<pre>   $form-&#62;process( params =&#62; $params, active =&#62; [&#39;foo&#39;, &#39;bar&#39;] );
   ...
   $form-&#62;process( params =&#62; $params, inactive =&#62; [&#39;bar&#39;] );</pre>

<p>If you need to check some other state to determine whether or not a field should be active, you can do that using a Moose method modifier on &#39;set_active&#39;:</p>

<pre>   before &#39;set_active&#39; =&#62; sub {
      my $self = shift;
      $self-&#62;active([&#39;foo&#39;, bar&#39;]) if ( &#60;some_condition&#62; );
   };</pre>

<p>Fields set to active/inactive on the &#39;process&#39; call are automatically set back to inactive when the form is cleared, so there&#39;s no need to reset.</p>

<p>If you want the fields activated for the life of an object, set active on new:</p>

<pre>    my $form = MyApp::Form::User-&#62;new( active =&#62; [&#39;opt_in&#39;, &#39;active&#39;]);</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Add_custom_attributes_to_FormHandler_fields"
>Add custom attributes to FormHandler fields</a></h2>

<p>If you want to add custom attributes to the FormHandler fields but don&#39;t want to subclass all the fields, you can apply a role containing the new attributes to an <a href="../../../HTML/FormHandler/Field.html" class="podlinkpod"
>HTML::FormHandler::Field</a> in your form.</p>

<p>Use &#39;traits&#39; on the individual fields to apply a role to field instances. Use the form attribute &#39;field_traits&#39; to apply a role to all field instances in the form.</p>

<pre>    package MyApp::Form::Test;
    use HTML::FormHandler::Moose;
    extends &#39;HTML::FormHandler&#39;;

    has_field &#39;foo&#39; =&#62; ( traits =&#62; [&#39;MyApp::TraitFor::Test&#39;] );
    has &#39;+field_traits&#39; =&#62; ( default =&#62; sub { [&#39;Some::Trait&#39;, &#39;Another::Trait&#39;] } );</pre>

<p>Or set the traits on new:</p>

<pre>    my $form = MyApp::Form::User-&#62;new( field_traits =&#62; [&#39;MyApp::TraitFor::Test&#39;] );
    my $form = MyApp::Form::User-&#62;new(
             field_list =&#62; [ &#39;+foo&#39; =&#62; { traits =&#62; [...] } ]);</pre>

<p>To apply the role to a field base class, use &#39;apply_traits&#39; on that class:</p>

<pre>    HTML::FormHandler::Field-&#62;apply_traits( &#39;Some::Test&#39; );
    HTML::FormHandler::Field::Text-&#62;apply_traits( &#39;Another::Trait&#39; );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Select_lists"
>Select lists</a></h2>

<p>If you want to set the default value of a select field to 0, you can just use &#39;default&#39; on the field:</p>

<pre>   has_field &#39;license&#39; =&#62; ( default =&#62; 0 );</pre>

<p>If there is logic involved, you can use a &#39;default_&#60;field_name&#62;&#39; method:</p>

<pre>   sub default_license {
      my ( $self, $field, $item ) = @_;
      return 0 unless $item &#38;&#38; $item-&#62;license_id;
      return $item-&#62;license_id;
   }</pre>

<p>If the table defining the choices for a select list doesn&#39;t include a &#39;no choice&#39; choice, you can set &#39;empty_select&#39; in your field if you are using FormHandler rendering:</p>

<pre>   has_field &#39;subject_class&#39; =&#62; ( type =&#62; &#39;Select&#39;,
      empty_select =&#62; &#39;--- Choose Subject Class ---&#39; );</pre>

<p>Or you can do in a template:</p>

<pre>   [% f = form.field(&#39;subject_class&#39;) %]
   &#60;select id=&#34;select_sc&#34; name=&#34;[% f.name %]&#34;&#62;
     &#60;option value=&#34;&#34;&#62;--- Choose Subject Class---&#60;/option&#62;
     [% FOR option IN f.options %]
       &#60;option value=&#34;[% option.value %]&#34;
          [% IF option.value == f.fif %]selected=&#34;selected&#34;[% END %]&#62;
          [% option.label | html %]&#60;/option&#62;
     [% END %]
   &#60;/select&#62;</pre>

<p>You can create a custom select list in an &#39;options_&#39; method:</p>

<pre>   sub options_country {
      my $self = shift;
      return unless $self-&#62;schema;
      my @rows =
         $self-&#62;schema-&#62;resultset( &#39;Country&#39; )-&#62;
            search( {}, { order_by =&#62; [&#39;rank&#39;, &#39;country_name&#39;] } )-&#62;all;
      return [ map { $_-&#62;digraph, $_-&#62;country_name } @rows ];
   }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="The_database_and_FormHandler_forms"
>The database and FormHandler forms</a></h2>

<p>If you have to process the input data before saving to the database, and this is something that would be useful in other places besides your form, you should do that processing in the DBIx::Class result class.</p>

<p>If the pre-processing is only relevant to HTML form input, you might want to do it in the form by setting a flag to prevent database updates, performing the pre-processing, and then updating the database yourself.</p>

<pre>   has_field &#39;my_complex_field&#39; =&#62; ( type =&#62; &#39;Text&#39;, noupdate =&#62; 1 );</pre>

<p>The &#39;noupdate&#39; flag is set in order to skip an attempt to update the database for this field (it would not be necessary if the field doesn&#39;t actually exist in the database...). You can process the input for the non-updatable field field in a number of different places, depending on what is most logical. Some of the choices are:</p>

<pre>   1) validate (for the form or field)
   2) validate_model
   3) model_update</pre>

<p>When the field is flagged &#39;writeonly&#39;, the value from the database will not be used to fill in the form (put in the <code>$form-&#62;fif</code> hash, or the field <code>$field-&#62;fif</code>), but a value entered in the form WILL be used to update the database.</p>

<p>If you want to enter fields from an additional table that is related to this one in a &#39;single&#39; relationship, you can use the DBIx::Class &#39;proxy&#39; feature to create accessors for those fields.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Set_up_form_base_classes_or_roles_for_your_application"
>Set up form base classes or roles for your application</a></h2>

<p>You can add whatever attributes you want to your form classes. Maybe you want to save a title, or a particular navigation widget. You could even save bits of text, or retrieve them from the database.</p>

<pre>   package MyApp::Form::Base;
   use Moose;
   extends &#39;HTML::FormHandler::Model::DBIC&#39;;

   has &#39;title&#39; =&#62; ( isa =&#62; &#39;Str&#39;, is =&#62; &#39;rw&#39; );
   has &#39;nav_bar&#39; =&#62; ( isa =&#62; &#39;Str&#39;, is =&#62; &#39;rw&#39; );
   has_block &#39;reg_header&#39; =&#62; ( tag =&#62; &#39;fieldset&#39;, label =&#62; &#39;Registration form&#39;,
       content =&#62; &#39;We take your membership seriously...&#39; );

   sub summary {
      my $self = shift;
      my $schema = $self-&#62;schema;
      my $text = $schema-&#62;resultset(&#39;Summary&#39;)-&#62;find( ... )-&#62;text;
      return $text;
   }
   1;</pre>

<p>Then:</p>

<pre>   package MyApp::Form::Whatsup;
   use Moose;
   extends &#39;MyApp::Form::Base&#39;;

   has &#39;+title&#39; =&#62; ( default =&#62; &#39;This page is an example of what to expect...&#39; );
   has &#39;+nav_bar&#39; =&#62; ( default =&#62; ... );
   ...
   1;</pre>

<p>And in the template:</p>

<pre>   &#60;h1&#62;[% form.title %]&#60;/h1&#62;
   [% form.nav_bar %]
   [% form.block(&#39;reg_header&#39;)-&#62;render %]
   &#60;p&#62;&#60;b&#62;Summary: &#60;/b&#62;[% form.summary %]&#60;/p&#62;</pre>

<p>Or you can make these customizations Moose roles.</p>

<pre>   package MyApp::Form::Role::Base;
   use Moose::Role;
   ...

   package MyApp::Form::Whatsup;
   use Moose;
   with &#39;MyApp::Form::Role::Base&#39;;
   ...</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Split_up_your_forms_into_reusable_pieces"
>Split up your forms into reusable pieces</a></h2>

<p>An address field:</p>

<pre>   package Form::Field::Address;
   use HTML::FormHandler::Moose;
   extends &#39;HTML::FormHandler::Field::Compound&#39;;

   has_field &#39;street&#39;;
   has_field &#39;city&#39;;
   has_field &#39;state&#39; =&#62; ( type =&#62; &#39;Select&#39;, options_method =&#62; \&#38;options_state );
   has_field &#39;zip&#39; =&#62; ( type =&#62; &#39;+Zip&#39; );

   sub options_state {
     ...
   }

   no HTML::FormHandler::Moose;
   1;</pre>

<p>A person form that includes an address field:</p>

<pre>   package Form::Person;
   use HTML::FormHandler::Moose;
   extends &#39;HTML::FormHandler&#39;;

   has &#39;+widget_name_space&#39; =&#62; ( default =&#62; sub {[&#39;Form::Field&#39;]} );
   has_field &#39;name&#39;;
   has_field &#39;telephone&#39;;
   has_field &#39;email&#39; =&#62; ( type =&#62; &#39;Email&#39; );
   has_field &#39;address&#39; =&#62; ( type =&#62; &#39;Address&#39; );

   sub validate_name {
    ....
   }

   no HTML::FormHandler::Moose;
   1;</pre>

<p>Or you can use roles;</p>

<pre>   package Form::Role::Address;
   use HTML::FormHandler::Moose::Role;

   has_field &#39;street&#39;;
   has_field &#39;city&#39;;
   has_field &#39;state&#39; =&#62; ( type =&#62; &#39;Select&#39; );
   has_field &#39;zip&#39; =&#62; ( type =&#62; &#39;+Zip&#39; );

   sub options_state {
     ...
   }

   no HTML::FormHandler::Moose::Role;
   1;</pre>

<p>You could make roles that are collections of validations:</p>

<pre>   package Form::Role::Member;
   use Moose::Role;

   sub check_zip {
      ...
   }
   sub check_email {
      ...
   }

   1;</pre>

<p>And if the validations apply to fields with different names, specify the &#39;validate_method&#39; on the fields:</p>

<pre>   with &#39;Form::Role::Member&#39;;
   has_field &#39;zip&#39; =&#62; ( type =&#62; &#39;Integer&#39;, validate_method =&#62; \&#38;check_zip );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Access_a_user_record_in_the_form"
>Access a user record in the form</a></h2>

<p>You might need the user_id to create specialized select lists, or do other form processing. Add a user_id attribute to your form:</p>

<pre>  has &#39;user_id&#39; =&#62; ( isa =&#62; &#39;Int&#39;, is =&#62; &#39;rw&#39; );</pre>

<p>Then pass it in when you process the form:</p>

<pre>  $form-&#62;process( item =&#62; $item, params =&#62; $c-&#62;req-&#62;parameters, user_id =&#62; $c-&#62;user-&#62;user_id );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Handle_extra_database_fields"
>Handle extra database fields</a></h2>

<p>If there is another database field that needs to be updated when a row is created, add an attribute to the form, and then process it with <code> before &#39;update_model&#39; </code>.</p>

<p>In the form:</p>

<pre>    has &#39;hostname&#39; =&#62; ( isa =&#62; &#39;Int&#39;, is =&#62; &#39;rw&#39; );

    before &#39;update_model&#39; =&#62; sub {
       my $self = shift;
       $self-&#62;item-&#62;hostname( $self-&#62;hostname );
    };</pre>

<p>Then just use an additional parameter when you create/process your form:</p>

<pre>    $form-&#62;process( item =&#62; $item, params =&#62; $params, hostname =&#62; $c-&#62;req-&#62;host );</pre>

<p>Some kinds of DB relationships need to have primary keys which might be more easily set in the update_model method;</p>

<pre>    sub update_model {
        my $self = shift;
        my $values = $self-&#62;values;
        $values-&#62;{some_field}-&#62;{some_key} = &#39;some_value&#39;;
        $self-&#62;_set_value($values);
        $self-&#62;next::method;
    }</pre>

<p>If you need to access a database field in order to create the value for a form field you can use a <code> default_* </code> method.</p>

<pre>    sub default_myformfield {
        my ($self, $field, $item) = @_;
        return unless defined $item;
        my $databasefield =  $item-&#62;databasefield;
        my $value = ... # do stuff
        return $value;
    }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Additional_changes_to_the_database"
>Additional changes to the database</a></h2>

<p>If you want to do additional database updates besides the ones that FormHandler does for you, the best solution would generally be to add the functionality to your result source or resultset classes, but if you want to do additional updates in a form you should use an &#39;around&#39; method modifier and a transaction:</p>

<pre>  around &#39;update_model&#39; =&#62; sub {
      my $orig = shift;
      my $self = shift;
      my $item = $self-&#62;item;

      $self-&#62;schema-&#62;txn_do( sub {
          $self-&#62;$orig(@_);

          &#60;perform additional updates&#62;
      });
  };</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Doing_cross_validation_in_roles"
>Doing cross validation in roles</a></h2>

<p>In a role that handles a number of different fields, you may want to perform cross validation after the individual fields are validated. In the form you could use the &#39;validate&#39; method, but that doesn&#39;t help if you want to keep the functionality packaged in a role. Instead you can use the &#39;after&#39; method modifier on the &#39;validate&#39; method:</p>

<pre>   package MyApp::Form::Roles::DateFromTo;

   use HTML::FormHandler::Moose::Role;
   has_field &#39;date_from&#39; =&#62; ( type =&#62; &#39;Date&#39; );
   has_field &#39;date_to&#39;   =&#62; ( type =&#62; &#39;Date&#39; );

   after &#39;validate&#39; =&#62; sub {
      my $self = shift;
      $self-&#62;field(&#39;date_from&#39;)-&#62;add_error(&#39;From date must be before To date&#39;)
         if $self-&#62;field(&#39;date_from&#39;)-&#62;value gt $self-&#62;field(&#39;date_to&#39;)-&#62;value;
   };</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Changing_required_flag"
>Changing required flag</a></h2>

<p>Sometimes a field is required in one situation and not required in another. You can use a method modifier before &#39;validate_form&#39;:</p>

<pre>   before &#39;validate_form&#39; =&#62; sub {
      my $self = shift;
      my $required = 0;
      $required = 1
         if( $self-&#62;params-&#62;{field_name} eq &#39;something&#39; );
      $self-&#62;field(&#39;some_field&#39;)-&#62;required($required);
   };</pre>

<p>This happens before the fields contain input or values, so you would need to look at the param value. If you need the validated value, it might be better to do these sort of checks in the form&#39;s &#39;validate&#39; routine.</p>

<pre>   sub validate {
      my $self = shift;
      $self-&#62;field(&#39;dependent_field&#39;)-&#62;add_error(&#34;Field is required&#34;)
          if( $self-&#62;field(&#39;some_field&#39;)-&#62;value eq &#39;something&#39; &#38;&#38;
              !$self-&#62;field(&#39;dependent_field&#39;)-&#62;has_value);
   }</pre>

<p>In a Moose role you would need to use a method modifier instead.</p>

<pre>   after &#39;validate&#39; =&#62; sub { ... };</pre>

<p>Don&#39;t forget the dependency list, which is used for cases where if any of one of a group of fields has a value, all of the fields are required.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Supply_an_external_coderef_for_validation"
>Supply an external coderef for validation</a></h2>

<p>There are situations in which you need to use a subroutine for validation which is not logically part of the form. It&#39;s possible to pass in a context or other sort of pointer and call the routine in the form&#39;s validation routine, but that makes the architecture muddy and is not a clear separation of concerns.</p>

<p>This is an example of how to supply a coderef when constructing the form that performs validation and can be used to set an appropriate error using <a href="../../../Moose/Meta/Attribute/Native/Trait/Code.html" class="podlinkpod"
>Moose::Meta::Attribute::Native::Trait::Code</a>. (Thanks to Florian Ragwitz for this excellent idea...)</p>

<p>Here&#39;s the form:</p>

<pre>    package SignupForm;
    use HTML::FormHandler::Moose;
    extends &#39;HTML::FormHandler&#39;;

    has check_name_availability =&#62; (
        traits   =&#62; [&#39;Code&#39;],
        isa      =&#62; &#39;CodeRef&#39;,
        required =&#62; 1,
        handles  =&#62; { name_available =&#62; &#39;execute&#39;, },
    );

    has_field &#39;name&#39;;
    has_field &#39;email&#39;;

    sub validate {
        my $self = shift;
        my $name = $self-&#62;value-&#62;{name};
        if ( defined $name &#38;&#38; length $name &#38;&#38; !$self-&#62;name_available($name) ) {
            $self-&#62;field(&#39;name&#39;)-&#62;add_error(&#39;That name is taken already&#39;);
        }
    }
    1;</pre>

<p>And here&#39;s where the coderef is passed in to the form.</p>

<pre>    package MyApp::Signup;
    use Moose;

    has &#39;form&#39; =&#62; ( is =&#62; &#39;ro&#39;, builder =&#62; &#39;build_form&#39; );
    sub build_form {
        my $self = shift;
        return SignupForm-&#62;new(
            {
                check_name_availability =&#62; sub {
                    my $name = shift;
                    return $self-&#62;username_available($name);
                },
            }
        );

    }
    sub username_available {
        my ( $self, $name ) = @_;
        # perform some sort of username availability checks
    }
    1;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Example_of_a_form_with_custom_database_interface"
>Example of a form with custom database interface</a></h2>

<p>The default DBIC model requires that the form structure match the database structure. If that doesn&#39;t work - you need to present the form in a different way - you may need to fudge it by creating your own &#39;init_object&#39; and doing the database updates in the &#39;update_model&#39; method.</p>

<p>Here is a working example for a &#39;family&#39; object (equivalent to a &#39;user&#39; record&#39;) that has a relationship to permission type roles in a relationship &#39;user_roles&#39;.</p>

<pre>    package My::Form::AdminRoles;
    use HTML::FormHandler::Moose;
    extends &#39;HTML::FormHandler&#39;;

    has &#39;schema&#39; =&#62; ( is =&#62; &#39;ro&#39;, required =&#62; 1 );  # Note 1
    has &#39;+widget_wrapper&#39; =&#62; ( default =&#62; &#39;None&#39; ); # Note 2

    has_field &#39;admin_roles&#39; =&#62; ( type =&#62; &#39;Repeatable&#39; ); # Note 3
    has_field &#39;admin_roles.family&#39;    =&#62; ( type =&#62; &#39;Hidden&#39; ); # Note 4
    has_field &#39;admin_roles.family_id&#39; =&#62; ( type =&#62; &#39;PrimaryKey&#39; ); # Note 5
    has_field &#39;admin_roles.admin_flag&#39; =&#62; ( type =&#62; &#39;Boolean&#39;, label =&#62; &#39;Admin&#39; );

    # Note 6
    sub init_object {
        my $self = shift;

        my @is_admin;
        my @is_not_admin;
        my $active_families = $self-&#62;schema-&#62;resultset(&#39;Family&#39;)-&#62;search( { active =&#62; 1 } );
        while ( my $fam = $active_families-&#62;next ) {
            my $admin_flag =
                 $fam-&#62;search_related(&#39;user_roles&#39;, { role_id =&#62; 2 } )-&#62;count &#62; 0 ? 1 : 0;
            my $family_name = $fam-&#62;name1 . &#34;, &#34; . $fam-&#62;name2;
            my $elem =  { family =&#62; $family_name, family_id =&#62; $fam-&#62;family_id,
                 admin_flag =&#62; $admin_flag };
            if( $admin_flag ) {
                push @is_admin, $elem;
            }
            else {
                push @is_not_admin, $elem;
            }
        }
        # Note 7
        # sort into admin flag first, then family_name
        @is_admin = sort { $a-&#62;{family} cmp $b-&#62;{family} } @is_admin;
        @is_not_admin = sort { $a-&#62;{family} cmp $b-&#62;{family} } @is_not_admin;
        return { admin_roles =&#62; [@is_admin, @is_not_admin] };
    }

    # Note 8
    sub update_model {
        my $self = shift;

        my $families = $self-&#62;schema-&#62;resultset(&#39;Family&#39;);
        my $family_roles = $self-&#62;value-&#62;{admin_roles};
        foreach my $elem ( @{$family_roles} ) {
            my $fam = $families-&#62;find( $elem-&#62;{family_id} );
            my $has_admin_flag = $fam-&#62;search_related(&#39;user_roles&#39;, { role_id =&#62; 2 } )-&#62;count &#62; 0;
            if( $elem-&#62;{admin_flag} == 1 &#38;&#38; !$has_admin_flag ) {
                $fam-&#62;create_related(&#39;user_roles&#39;, { role_id =&#62; 2 } );
            }
            elsif( $elem-&#62;{admin_flag} == 0 &#38;&#38; $has_admin_flag ) {
                $fam-&#62;delete_related(&#39;user_roles&#39;, { role_id =&#62; 2 } );
            }
        }
    }</pre>

<p>Note 1: This form creates its own &#39;schema&#39; attribute. You could inherit from <a href="../../../HTML/FormHandler/Model/DBIC.html" class="podlinkpod"
>HTML::FormHandler::Model::DBIC</a>, but you won&#39;t be using its update code, so it wouldn&#39;t add much.</p>

<p>Note 2: The form will be displayed with a template that uses &#39;bare&#39; form input fields, so &#39;widget_wrapper&#39; is set to &#39;None&#39; to skip wrapping the form inputs with divs or table elements.</p>

<p>Note 3: This form consists of an array of elements, so there will be a single Repeatable form field with subfields. If you wanted to use automatic rendering, you would also need to create a &#39;submit&#39; field, but in this case it will just be done in the template.</p>

<p>Note 4: This field is actually going to be used for display purposes only, but it&#39;s a hidden field because otherwise the information would be lost when displaying the form from parameters. For this case there is no real &#39;validation&#39; so it might not be necessary, but it would be required if the form needed to be re-displayed with error messages.</p>

<p>Note 5: The &#39;family_id&#39; is the primary key field, necessary for updating the correct records.</p>

<p>Note 6: &#39;init_object&#39; method: This is where the initial object is created, which takes the place of a database row for form creation.</p>

<p>Note 7: The entries with the admin flag turned on are sorted into the beginning of the list. This is entirely a user interface choice.</p>

<p>Note 8: &#39;update_model&#39; method: This is where the database updates are performed.</p>

<p>The Template Toolkit template for this form:</p>

<pre>    &#60;h1&#62;Update admin status for members&#60;/h1&#62;
    &#60;form name=&#34;adminroles&#34; method=&#34;POST&#34; action=&#34;[% c.uri_for(&#39;admin_roles&#39;) %]&#34;&#62;
      &#60;input class=&#34;submit&#34; name=&#34;submit&#34; value=&#34;Save&#34; type=&#34;submit&#34;&#62;
    &#60;table border=&#34;1&#34;&#62;
      &#60;th&#62;Family&#60;/th&#62;&#60;th&#62;Admin&#60;/th&#62;
      [% FOREACH f IN form.field(&#39;admin_roles&#39;).sorted_fields %]
         &#60;tr&#62;
         &#60;td&#62;&#60;b&#62;[% f.field(&#39;family&#39;).fif %]&#60;/b&#62;[% f.field(&#39;family&#39;).render %]
         [% f.field(&#39;family_id&#39;).render %]&#60;/td&#62;&#60;td&#62; [% f.field(&#39;admin_flag&#39;).render %]&#60;/td&#62;
         &#60;/tr&#62;
      [% END %]
    &#60;/table&#62;
      &#60;input class=&#34;submit&#34; name=&#34;submit&#34; value=&#34;Save&#34; type=&#34;submit&#34;&#62;
    &#60;/form</pre>

<p>The form is rendered in a simple table, with each field rendered using the automatically installed rendering widgets with no wrapper (widget_wrapper =&#62; &#39;None&#39;). There are two hidden fields here, so what is actually seen is two columns, one with the user (family) name, the other with a checkbox showing whether the user has admin status. Notice that the &#39;family&#39; field information is rendered twice: once as a hidden field that will allow it to be preserved in params, once as a label.</p>

<p>The Catalyst controller action to execute the form:</p>

<pre>    sub admin_roles : Local {
        my ( $self, $c ) = @_;

        my $schema = $c-&#62;model(&#39;DB&#39;)-&#62;schema;
        my $form = My::Form::AdminRoles-&#62;new( schema =&#62; $schema );
        $form-&#62;process( params =&#62; $c-&#62;req-&#62;params );
        # re-process if form validated to reload from db and re-sort
        $form-&#62;process( params =&#62; {}) if $form-&#62;validated;
        $c-&#62;stash( form =&#62; $form, template =&#62; &#39;admin/admin_roles.tt&#39; );
        return;
    }</pre>

<p>Rather than redirect to some other page after saving the form, the form is redisplayed. If the form has been validated (i.e. the &#39;update_model&#39; method has been run), the &#39;process&#39; call is run again in order to re-sort the displayed list with admin users at the top. That could have also been done in the &#39;update_model&#39; method.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="A_form_that_takes_a_resultset,_with_custom_update_model"
>A form that takes a resultset, with custom update_model</a></h2>

<p>For updating a Repeatable field that is filled from a Resultset, and not a relationship on a single row. Creates a &#39;resultset&#39; attribute to pass in a resultset. Massages the data into an array that&#39;s pointed to by an &#39;employers&#39; hash key, and does the reverse in the &#39;update_model&#39; method. Yes, it&#39;s a kludge, but it could be worse. If you want to implement a more general solution, patches welcome.</p>

<pre>    package Test::Resultset;
    use HTML::FormHandler::Moose;
    extends &#39;HTML::FormHandler::Model::DBIC&#39;;

    has &#39;+item_class&#39; =&#62; ( default =&#62; &#39;Employer&#39; );
    has &#39;resultset&#39; =&#62; ( isa =&#62; &#39;DBIx::Class::ResultSet&#39;, is =&#62; &#39;rw&#39;,
            trigger =&#62; sub { shift-&#62;set_resultset(@_) } );
    sub set_resultset {
        my ( $self, $resultset ) = @_;
        $self-&#62;schema( $resultset-&#62;result_source-&#62;schema );
    }
    sub init_object {
        my $self = shift;
        my $rows = [$self-&#62;resultset-&#62;all];
        return { employers =&#62; $rows };
    }
    has_field &#39;employers&#39; =&#62; ( type =&#62; &#39;Repeatable&#39; );
    has_field &#39;employers.employer_id&#39; =&#62; ( type =&#62; &#39;PrimaryKey&#39; );
    has_field &#39;employers.name&#39;;
    has_field &#39;employers.category&#39;;
    has_field &#39;employers.country&#39;;

    sub update_model {
        my $self = shift;
        my $values = $self-&#62;values-&#62;{employers};
        foreach my $row (@$values) {
            delete $row-&#62;{employer_id} unless defined $row-&#62;{employer_id};
            $self-&#62;resultset-&#62;update_or_create( $row );
        }
    }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Server-provided_dynamic_value_for_field"
>Server-provided dynamic value for field</a></h2>

<p>There are many different ways to provide values for fields. Default values can be statically provided in the form with the &#39;default&#39; attribute on the field, with a default_&#60;field_name&#62; method in the form, with an init_object/item, and with &#39;default_over_obj&#39; if you have both an item/init_object and want to provide a default.</p>

<pre>    has_field &#39;foo&#39; =&#62; ( default =&#62; &#39;my_default&#39; );
    has_field &#39;foo&#39; =&#62; ( default_over_obj =&#62; &#39;my_default&#39; );
    sub default_foo { &#39;my_default&#39; }
    ..
    $form-&#62;process( init_object =&#62; { foo =&#62; &#39;my_default } );
    $form-&#62;process( item =&#62; &#60;object with $obj-&#62;foo method to provide default&#62; );</pre>

<p>If you want to change the default for the field at run time, there are a number of options.</p>

<p>You can set the value in the init_object or item before doing process:</p>

<pre>    my $foo_value = &#39;some calculated value&#39;;
    $form-&#62;process( init_object =&#62; { foo =&#62; $foo_value } );</pre>

<p>You can use &#39;update_field_list&#39; or &#39;defaults&#39; on the &#39;process&#39; call:</p>

<pre>    $form-&#62;process( update_field_list =&#62; { foo =&#62; { default =&#62; $foo_value } } );
    -- or --
    $form-&#62;process( defaults =&#62; { foo =&#62; $foo_value } );</pre>

<p>You can set a Moose attribute in the form class, and set the default in a default_&#60;field_name&#62; method:</p>

<pre>    package My::Form;
    use HTML::FormHandler::Moose;
    extends &#39;HTML::Formhandler&#39;;

    has &#39;form_id&#39; =&#62; ( isa =&#62; &#39;Str&#39;, is =&#62; &#39;rw&#39; );
    has_field &#39;foo&#39;;
    sub default_foo {
        my $self = shift;
        return $self-&#62;form_id;
    }
    ....
    $form-&#62;process( form_id =&#62; &#39;my_form&#39;, params =&#62; $params );</pre>

<p>You can set a Moose attribute in the form class and set it in an update_fields method:</p>

<pre>    sub update_fields {
        my $self = shift;
        $self-&#62;field(&#39;foo&#39;)-&#62;default(&#39;my_form&#39;);
    }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Static_form,_dynamic_field_IDs"
>Static form, dynamic field IDs</a></h2>

<p>The problem: you have a form that will be used in multiple places on a page, but you want to use a static form instead of doing &#39;new&#39; for each. You can pass a form name in on the process call and use &#39;html_prefix&#39; in the form:</p>

<pre>   $form-&#62;process( name =&#62; &#39;...&#39;, params =&#62; {} );</pre>

<p>But the field &#39;id&#39; attribute has already been constructed and doesn&#39;t change.</p>

<p>Solution: apply a role to the base field class to replace the &#39;id&#39; getter for the &#39;id&#39; attribute with a method which constructs the &#39;id&#39; dynamically. Since the role is being applied to the base field class, you can&#39;t just use &#39;sub id&#39;, because the &#39;id&#39; method defined by the &#39;id&#39; attribute has precedence. So create an &#39;around&#39; method modifier that replaces it in the role.</p>

<pre>    package My::DynamicFieldId;
    use Moose::Role;
    around &#39;id&#39; =&#62; sub {
        my $orig = shift;
        my $self = shift;
        my $form_name = $self-&#62;form-&#62;name;
        return $form_name . &#34;.&#34; . $self-&#62;full_name;
    };

    package My::CustomIdForm;
    use HTML::FormHandler::Moose;
    extends &#39;HTML::FormHandler&#39;;

    has &#39;+html_prefix&#39; =&#62; ( default =&#62; 1 );
    has &#39;+field_traits&#39; =&#62; ( default =&#62; sub { [&#39;My::DynamicFieldId&#39;] } );

    has_field &#39;foo&#39;;
    has_field &#39;bar&#39;;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Create_different_field_IDs"
>Create different field IDs</a></h2>

<p>Use &#39;build_id_method&#39; to give your fields a different format &#39;id&#39;:</p>

<pre>    package MyApp::CustomId;
    use HTML::FormHandler::Moose;
    extends &#39;HTML::FormHandler&#39;;

    has &#39;+update_field_list&#39; =&#62; ( default =&#62;
        sub { { all =&#62; { build_id_method =&#62; \&#38;custom_id } } } );
    has_field &#39;foo&#39; =&#62; ( type =&#62; &#39;Compound&#39; );
    has_field &#39;foo.one&#39;;
    has_field &#39;foo.two&#39;;
    has_field &#39;foo.three&#39;;
    sub custom_id {
        my $self = shift;
        my $full_name = $self-&#62;full_name;
        $full_name =~ s/\./_/g;
        return $full_name;
    }</pre>

<p>The above method provides IDs of &#34;foo_two&#34; and &#34;foo_three&#34; instead of &#34;foo.two&#34; and &#34;foo.three&#34;.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>FormHandler Contributors - see HTML::FormHandler</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>This software is copyright (c) 2013 by Gerda Shank.</p>

<p>This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
