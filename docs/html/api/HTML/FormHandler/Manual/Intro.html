<html><head><title>HTML::FormHandler::Manual::Intro</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:18 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#Basics'>Basics</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Create_a_form_class'>Create a form class</a>
    <li class='indexItem indexItem2'><a href='#Or_create_a_form_class_dynamically'>Or create a form class dynamically</a>
    <li class='indexItem indexItem2'><a href='#Process_the_form'>Process the form</a>
    <li class='indexItem indexItem2'><a href='#Or_process_a_database_form'>Or process a database form</a>
    <li class='indexItem indexItem2'><a href='#After_processing_the_form'>After processing the form</a>
    <li class='indexItem indexItem2'><a href='#Rendering_the_form'>Rendering the form</a>
    <li class='indexItem indexItem2'><a href='#Defaults_for_form_fields'>Defaults for form fields</a>
    <li class='indexItem indexItem2'><a href='#Validation'>Validation</a>
    <li class='indexItem indexItem2'><a href='#Organizing_your_form_code'>Organizing your form code</a>
    <li class='indexItem indexItem2'><a href='#Testing'>Testing</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Localization'>Localization</a>
  <li class='indexItem indexItem1'><a href='#Performance'>Performance</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>HTML::FormHandler::Manual::Intro - introduction to using FormHandler</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>version 0.40028</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<p><a href="../../../HTML/FormHandler/Manual.html" class="podlinkpod"
>Manual Index</a></p>

<p>HTML::FormHandler is a form handling package that validates HTML form data and,
for database forms,
saves it to the database on validation.
It has field classes that match various data types and HTML form elements,
and rendering roles that can be used to render forms in many different ways,
from hand-built forms to totally automated rendering.
It can,
of course,
be used to validate data even if you are not interested in the rendering capabilities.</p>

<p>A FormHandler &#39;form&#39; is a Perl subclass of <a href="../../../HTML/FormHandler.html" class="podlinkpod"
>HTML::FormHandler</a> for non-database forms,
or a subclass of <a href="../../../HTML/FormHandler/Model/DBIC.html" class="podlinkpod"
>HTML::FormHandler::Model::DBIC</a> for database forms,
and in it you define your fields and validation routines.
Because it&#39;s a Perl class written in Moose,
you have a lot of flexibility and control.</p>

<p>You can validate with Perl methods or Moose type constraints; you can use your own validation libraries.
You can define your own field classes that perform specialized validation.</p>

<p>When the form is validated,
you can get the validated values back with <code>$form-&#62;value</code>.</p>

<p>A working example of a Catalyst app using FormHandler forms is available on github at <a href="https://github.com/gshank/formhandler-example" class="podlinkurl"
>https://github.com/gshank/formhandler-example</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Basics"
>Basics</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Create_a_form_class"
>Create a form class</a></h2>

<p>The most common way of using FormHandler is to create a form package.
You must &#39;use&#39; &#34;HTML::FormHandler::Moose&#34; and &#39;extend&#39; FormHandler:</p>

<pre>    package MyApp::Form::Sample;
    use HTML::FormHandler::Moose;
    extends &#39;HTML::FormHandler&#39;;</pre>

<p>Then you add some fields with &#39;has_field&#39;, and a field &#39;type&#39; (the short name of the field package). (Fields with no type have type &#39;Text&#39;.)</p>

<pre>    has_field &#39;foo&#39;;
    has_field &#39;bar&#39; =&#62; ( type =&#62; &#39;Select&#39; );</pre>

<p>Basic field types are Text, Select, Checkbox, Submit, Hidden, Reset, TextArea, Password, Upload. See <a href="../../../HTML/FormHandler/Manual/Fields.html" class="podlinkpod"
>HTML::FormHandler::Manual::Fields</a> for more information.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Or_create_a_form_class_dynamically"
>Or create a form class dynamically</a></h2>

<p>You can also create a form class &#39;dynamically&#39;, by creating a &#39;new&#39; HTML::FormHandler object. Use a &#39;field_list&#39; parameter to create the fields instead of &#39;has_field&#39;.</p>

<pre>    my $form = HTML::FormHandler-&#62;new( field_list =&#62; [
            &#39;username&#39; =&#62; { type =&#62; &#39;Text&#39; },
            &#39;selections&#39; =&#62; { type =&#62; &#39;Select&#39; },
        ]
    );</pre>

<p>Some features will not be available using this method (like the automatic use of &#39;validate_&#60;field_name&#62;&#39; methods) and it&#39;s not as easy to test, of course.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Process_the_form"
>Process the form</a></h2>

<p>The form&#39;s &#39;process&#39; method should be run on each request, passing in the request parameters:</p>

<pre>    $form-&#62;process( params =&#62; $c-&#62;request-&#62;body_parameters,
        action =&#62; $action,
    );</pre>

<p>If the parameters are not empty, then validation will be performed. The corollary is that you should not pass in extra parameters when the form has not been posted. A special &#39;posted&#39; flag can be used if the form consists entirely of fields like checkboxes that do not include names in params if unchecked, and also works to prevent validation from being performed if there are extra params:</p>

<pre>    $form-&#62;process( posted =&#62; ( $c-&#62;req-&#62;method eq &#39;POST&#39; ),
        params =&#62; $c-&#62;request-&#62;parameters, action =&#62; $action );</pre>

<p>There is an alternative method for processing the form, which is sometimes preferred for persistent forms. It returns a &#39;result&#39; object, and clears the form:</p>

<pre>    my $result = $form-&#62;run( params =&#62; $c-&#62;request-&#62;body_parameters );</pre>

<p>You can also set most other FormHandler attributes on the &#39;process&#39; call., One useful feature is that you can activate or inactivate fields:</p>

<pre>    $form-&#62;process( params =&#62; $params, active =&#62; [&#39;field1&#39;, &#39;field2&#39;] );</pre>

<p>See also <a href="../../../HTML/FormHandler.html" class="podlinkpod"
>HTML::FormHandler</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Or_process_a_database_form"
>Or process a database form</a></h2>

<p>A database form inherits from <a href="../../../HTML/FormHandler/Model/DBIC.html" class="podlinkpod"
>HTML::FormHandler::Model::DBIC</a> instead of <a href="../../../HTML/FormHandler.html" class="podlinkpod"
>HTML::FormHandler</a>. You must either pass in the DBIC row object or give FormHandler information to retrieve the row object.</p>

<pre>    $form-&#62;process( item =&#62; $row, params =&#62; $params );
    -- or --
    $form-&#62;process( item_id =&#62; $id, schema =&#62; $schema,
        item_class =&#62; &#39;MyRow&#39;, params =&#62; $params );</pre>

<p>&#39;item_class&#39; is often set in the form class.</p>

<p>See also <a href="../../../HTML/FormHandler/Manual/Database.html" class="podlinkpod"
>HTML::FormHandler::Manual::Database</a> and <a href="../../../HTML/FormHandler/TraitFor/Model/DBIC.html" class="podlinkpod"
>HTML::FormHandler::TraitFor::Model::DBIC</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="After_processing_the_form"
>After processing the form</a></h2>

<p>A database form will have saved the data or created a new row, so often no more processing is necessary. You can get the structured field values from <code>$form-&#62;value</code>, and do whatever you want with them.</p>

<p>If the validation succeeded, you may want to redirect:</p>

<pre>    $form-&#62;process( params =&#62; $params );
    return unless $form-&#62;validated
    $c-&#62;res-&#62;redirect( .... );
    -- or --
    return unless $form-&#62;process( params =&#62; params );
    $c-&#62;res-&#62;redirect;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Rendering_the_form"
>Rendering the form</a></h2>

<p>At its simplest, all you need to do is <code>$form-&#62;render</code> in a template.</p>

<pre>    [% form.render %]</pre>

<p>The automatic rendering is powerful and flexible -- you can do almost anything with the right settings. Or you can render the form with a template.</p>

<p>The form object will give you a hashref of values suitable for filling in the form with <code>$form-&#62;fif</code>.</p>

<p>By default FormHandler structures fields (and renders them) in a way that matches the database. If you want to organize the rendering output in different ways, you can use blocks to organize your fields.</p>

<pre>   has_block &#39;fieldset1&#39; =&#62; ( render_list =&#62; [&#39;foo&#39;, &#39;bar&#39;] );</pre>

<p>For more rendering info, see <a href="../../../HTML/FormHandler/Manual/Rendering.html" class="podlinkpod"
>HTML::FormHandler::Manual::Rendering</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Defaults_for_form_fields"
>Defaults for form fields</a></h2>

<p>The simplest way to provide defaults is by setting the default attribute in a field definition:</p>

<pre>   has_field &#39;my_foo&#39; =&#62; ( default =&#62; &#39;my_foo&#39; );</pre>

<p>The database row (&#39;item&#39;) that is passed in will provide initial values for the form, of course. You can also provide default values with an &#39;init_object&#39;, which acts kind of like a database object:</p>

<pre>   $form-&#62;process( init_object =&#62; { foo =&#62; &#39;...&#39;, bar =&#62; &#39;...&#39; } );</pre>

<p>There are a number of other flags and methods for providing defaults. See <a href="../../../HTML/FormHandler/Manual/Defaults.html" class="podlinkpod"
>HTML::FormHandler::Manual::Defaults</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Validation"
>Validation</a></h2>

<p>You can validate a field with a method in the form &#39;validate_&#60;field_name&#62;&#39;:</p>

<pre>    has_field &#39;foo&#39;;
    sub validate_foo {
        my ( $self, $field ) = @_; # self is the form
        unless( $field-&#62;value == .... ) {
            $field-&#62;add_error( .... );
        }
    }</pre>

<p>You can provide a validation coderef that will be a field method:</p>

<pre>    has_field &#39;foo&#39; =&#62; ( validate_method =&#62; \&#38;check_foo );
    sub check_foo {
        my $self = shift; # self is field
        unless( $self-&#62;value == ... ) {
            $self-&#62;add_error( ... );
        }
    }</pre>

<p>You can use &#39;apply&#39; to use Moose types for validation, from <a href="../../../HTML/FormHandler/Types.html" class="podlinkpod"
>HTML::FormHandler::Types</a> or another Moose type collection:</p>

<pre>    use HTML::FormHandler::Types (&#39;NotAllDigits&#39;);
    ...
    has_field &#39;my_field&#39; =&#62; ( apply =&#62; [NotAllDigits] );</pre>

<p>Or create validators with check:</p>

<pre>    has_field &#39;quux&#39; =&#62; (
        apply =&#62; [ { check =&#62; qr/abc/, message =&#62; &#39;Not a valid quux&#39; } ] );</pre>

<p>Or use a validate coderef:</p>

<pre>    has_field &#39;foo&#39; =&#62; ( validate_method =&#62; \&#38;check_foo );
    sub check_foo {
        my $self = shift;
        if ( $self-&#62;value =~ s/..../ ) {
            $self-&#62;add_error(&#39;....&#39;);
        }
    }</pre>

<p>You can also create custom fields with custom validation, or use an existing field that does the validation you need.</p>

<p>See <a href="../../../HTML/FormHandler/Manual/Validation.html" class="podlinkpod"
>HTML::FormHandler::Manual::Validation</a> for more information on validation or <a href="../../../HTML/FormHandler/Manual/Fields.html" class="podlinkpod"
>HTML::FormHandler::Manual::Fields</a> for more information on fields.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Organizing_your_form_code"
>Organizing your form code</a></h2>

<p>You can use &#39;has_field&#39; and &#39;has_block&#39; in Moose roles:</p>

<pre>    package MyApp::Form::Role::Address;
    use HTML::FormHandler::Moose::Role;

    has_field &#39;foo&#39;;
    has_block &#39;bar&#39;;</pre>

<p>Your forms can inherit from base classes that set common application defaults. You can override field definitions with &#39;+&#39;.</p>

<p>You can create &#39;compound&#39; fields and include them in a form:</p>

<pre>    package MyApp::Form::Field::Complex;
    use HTML::FormHandler::Moose;
    extends &#39;HTML::FormHandler::Field::Compound&#39;;
    has_field &#39;field1&#39; =&#62; ( validate_method =&#62; \&#38;validate_field1 );
    has_field &#39;field2&#39; =&#62; ( type =&#62; &#39;Select&#39;,
        options_method =&#62; \&#38;options_field2 );
    sub validate_field1 { ... }
    sub options_field2 { ... }
    ...
    package MyApp::Form::Complex;
    use HTML::FormHandler::Moose;
    extends &#39;HTML::FormHandler&#39;;
    has &#39;+field_name_space&#39; =&#62; ( sub =&#62; {[&#39;MyApp::Form::Field&#39;]} );
    has_field &#39;compound1&#39; =&#62; ( type =&#62; &#39;Complex&#39; );
    has_field &#39;compound2&#39; =&#62; ( type =&#62; &#39;Complex&#39; );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Testing"
>Testing</a></h2>

<p>It&#39;s much easier to write unit tests for FormHandler forms than for Catalyst controllers. The &#39;t&#39; directory of the downloaded distribution has lots of examples. See <a href="../../../HTML/FormHandler/Manual/Testing.html" class="podlinkpod"
>HTML::FormHandler::Manual::Testing</a> for more information.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Localization"
>Localization</a></h1>

<p>FormHandler&#39;s built-in errors are added to the form fields with <code>$field-&#62;add_error</code>, and to the form with <code>$form-&#62;add_form_error</code>. These methods call a <code>$self-&#62;_localize</code> method which is a coderef set from the field&#39;s default_localize sub, the field&#39;s &#39;localize_meth&#39; attribute with <code>localize_meth =&#62; sub {}</code>, or a form&#39;s sub localize_meth. The default localize uses Locale::Maketext. You can also use duck_type classes for localization. See the documentation in <a href="../../../HTML/FormHandler/TraitFor/I18N.html" class="podlinkpod"
>HTML::FormHandler::TraitFor::I18N</a> and the tests in xt/locale.t.</p>

<p>If you wish to skip localization for a particular message (such as for system errors) you can use <code>$field-&#62;push_errors</code> or <code>$form-&#62;push_form_errors</code>.</p>

<p>See also <a href="../../../HTML/FormHandler/TraitFor/I18N.html" class="podlinkpod"
>HTML::FormHandler::TraitFor::I18N</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Performance"
>Performance</a></h1>

<p>FormHandler makes heavy use of Moose, so almost all of FormHandler&#39;s profiled time will actually be in Moose methods, mostly constructing form and field attributes. Some people prefer to use a persistent form class (in a Moose attribute) in order to skip the form building step on each call. Other people don&#39;t like that solution because state will remain in the form until the next process call. The &#39;clear&#39; method is called at the beginning of each &#39;process&#39;, but additional Moose attributes in the form, etc, will have to cleared by the programmer.</p>

<p>If you are loading options from the database and you don&#39;t need to have them refreshed each time, you can set the &#39;do_not_reload&#39; flag in the Select/Multiple field. If you&#39;re not using the field widget roles, you can set the &#39;no_widgets&#39; flag. If you always use &#39;process&#39; on each call (recommended) then you can set the &#39;no_preload&#39; flag in the form to skip building results in BUILD (new).</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>FormHandler Contributors - see HTML::FormHandler</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>This software is copyright (c) 2013 by Gerda Shank.</p>

<p>This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
