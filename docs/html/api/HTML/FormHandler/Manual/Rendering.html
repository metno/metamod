<html><head><title>HTML::FormHandler::Manual::Rendering</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:18 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Mostly_templates'>Mostly templates</a>
    <li class='indexItem indexItem2'><a href='#Automatic_rendering'>Automatic rendering</a>
    <li class='indexItem indexItem2'><a href='#HTML_attributes'>HTML attributes</a>
    <li class='indexItem indexItem2'><a href='#Form_settings'>Form settings</a>
    <li class='indexItem indexItem2'><a href='#Form_messages'>Form messages</a>
    <li class='indexItem indexItem2'><a href='#Field_settings'>Field settings</a>
    <li class='indexItem indexItem2'><a href='#html_attributes_callback'>html_attributes callback</a>
    <li class='indexItem indexItem2'><a href='#Field_tags'>Field tags</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Tag_types'>Tag types</a>
      <li class='indexItem indexItem3'><a href='#Tags_and_other_settings_for_all_fields'>Tags and other settings for all fields</a>
      <li class='indexItem indexItem3'><a href='#Repeatable_field_instances'>Repeatable field instances</a>
      <li class='indexItem indexItem3'><a href='#widget_and_widget_wrapper_set_to_%27None%27'>widget and widget_wrapper set to &#39;None&#39;</a>
      <li class='indexItem indexItem3'><a href='#Error_messages'>Error messages</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Blocks'>Blocks</a>
    <li class='indexItem indexItem2'><a href='#Twitter_Bootstrap_2.0_rendering'>Twitter Bootstrap 2.0 rendering</a>
    <li class='indexItem indexItem2'><a href='#Rendering_themes'>Rendering themes</a>
    <li class='indexItem indexItem2'><a href='#Rendering_fields'>Rendering fields</a>
    <li class='indexItem indexItem2'><a href='#Rendering_labels'>Rendering labels</a>
    <li class='indexItem indexItem2'><a href='#Rendering_filter'>Rendering filter</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#Special_rendering_pseudo-fields'>Special rendering pseudo-fields</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#NonEditable'>NonEditable</a>
    <li class='indexItem indexItem2'><a href='#Display'>Display</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>HTML::FormHandler::Manual::Rendering - how to render with FormHandler</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>version 0.40028</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<p><a href="../../../HTML/FormHandler/Manual.html" class="podlinkpod"
>Manual Index</a></p>

<p>Rendering can be done in many different ways,
from forms rendered entirely in templates with no information from FormHandler (except possibly the fill-in-the-form values) to forms that are completely rendered by FormHandler.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>For most situations,
something in between hand-built and completely generated will probably be the best solution.
For admin forms that don&#39;t need a lot of styling or special HTML,
FormHandler&#39;s automatic rendering may be appropriate.
FormHandler rendering may also be a good solution if you have enough forms that putting time into creating rendering widgets and themes is worthwhile.</p>

<p>The automatic rendering is also useful when developing a new form.
You can get an idea of what it looks like,
and then customize it.</p>

<p>Another situation in which FormHandler rendering may be useful is when the form is complex enough that working in Perl is a better idea than putting lots of logic into templates.</p>

<p>All of the rendering is designed to be easily replaced with elements of your own,
or to be replaced entirely.
You can create your own rendering &#39;widgets&#39; and load them into the fields by designating the directory in the &#39;widget_name_space&#39;.
You could also create a completely separate renderer that&#39;s a separate object or class that takes a form object,
or a role that is applied to your form.</p>

<p>Note that unless you set &#39;no_widgets&#39; in the form,
the rendering roles are automatically applied.
You don&#39;t need to include anything else,
unless you want to use a different renderer.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Mostly_templates"
>Mostly templates</a></h2>

<p>The names of your fields must match the names of your FormHandler fields.
If you use compound fields,
you must use the FormHandler naming convention.</p>

<p>Form used in examples:</p>

<pre>    package MyApp::Form::Example;
    use HTML::FormHandler::Moose;
    extends &#39;HTML::FormHandler&#39;;

    has_field &#39;foo&#39;;
    has_field &#39;bar&#39;;
    has_field &#39;save&#39; =&#62; ( type =&#62; &#39;Submit&#39; );</pre>

<p>If you have existing forms in templates or just prefer them, you can use the &#39;fill-in-form&#39; values provided with the form&#39;s &#39;fif&#39; function.</p>

<pre>    my $form = MyApp::Form::Example-&#62;new;
    $form-&#62;process( params =&#62; $params );
    $c-&#62;stash( fif =&#62; $form-&#62;fif );
    ...
    &#60;form id=&#34;myform&#34; action=&#34;/edit/example&#34; method=&#34;post&#34;&#62;
    &#60;label&#62;Foo&#60;/label&#62;
    &#60;input id=&#34;foo&#34; name=&#34;foo&#34; value=&#34;[% fif.foo %]&#34;&#62;
    &#60;label&#62;Bar&#60;/label&#62;
    &#60;input id=&#34;bar&#34; name=&#34;bar&#34; value=&#34;[% fif.bar %]&#34;&#62;
    &#60;input type=&#34;submit&#34; name=&#34;submit&#34; value=&#34;Save&#34;&#62;
    &#60;/form&#62;</pre>

<p>Going a little bit farther in using FormHandler rendering, you can render each of the fields individually:</p>

<pre>     &#60;form id=&#34;myform&#34; action=&#34;/edit/example&#34; method=&#34;post&#34;&#62;
     &#60;fieldset&#62;&#60;legend&#62;My Foo&#60;/legend&#62;
     [% form.field(&#39;foo&#39;).render %]
     &#60;/fieldset&#62;
     [% form.field(&#39;bar&#39;).render %]
     [% form.field(&#39;save&#39;).render %]
     &#60;/form&#62;</pre>

<p>If you don&#39;t want the wrappers, use a widget_wrapper of &#39;None&#39;.</p>

<pre>    has &#39;+widget_wrapper&#39; =&#62; ( default =&#62; &#39;None&#39; );</pre>

<p>Then you can provide the HTML in which the form elements are embedded:</p>

<pre>    &#60;div class=&#34;my_class&#34;&#62;
    [% form.field(&#39;foo&#39;).render %]
    &#60;/div&#62;
    &#60;div class=&#34;another_class&#34;&#62;
    [% form.field(&#39;bar&#39;).render %]
    &#60;/div&#62;</pre>

<p>You can also use the &#39;render_element&#39; method, if you want to leave the wrapper in place, but sometimes render &#39;bare&#39; html elements:</p>

<pre>    &#60;div class=&#34;my_class&#34;&#62;
    [% form.field(&#39;foo&#39;).render_element %]
    &#60;/div&#62;</pre>

<p>If you wish to loop through the fields yourself, use the &#39;sorted_fields&#39; method, since it skips inactive fields and handles the &#39;order&#39; attribute.</p>

<p>A set of Template Toolkit templates is also provided in the &#39;share&#39; directory. There are individual templates for each &#39;widget&#39;, such as a checkbox, and there is also an all-in-one template that includes blocks for the various &#39;widgets&#39;. If you want to use these templates you can just copy them to your template directory and specify the form template in your controller.</p>

<p>See also <a href="../../../HTML/FormHandler/Manual/Templates.html" class="podlinkpod"
>HTML::FormHandler::Manual::Templates</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Automatic_rendering"
>Automatic rendering</a></h2>

<p>If you take all the defaults, you can simply render a form with <code>$form-&#62;render</code>.</p>

<pre>    [% form.render %]</pre>

<p>This uses the <a href="../../../HTML/FormHandler/Widget/Form/Simple.html" class="podlinkpod"
>HTML::FormHandler::Widget::Form::Simple</a> role, which is applied to the form by default. You can use a different form rendering role by including it using &#39;with&#39;:</p>

<pre>    with &#39;HTML::FormHandler::Widget::Form::Table&#39;;
    has &#39;+widget_wrapper&#39; =&#62; ( default =&#62; &#39;Table&#39; );</pre>

<p>For the &#39;Table&#39; form widget, you will also need to set the matching Table widget_wrapper.</p>

<p>A widget role, providing the &#39;render&#39; method, and a widget wrapper role, providing the &#39;wrap_field&#39; method, are applied to each field when the form is built. Each field has a default widget, but you can change that by setting &#39;widget&#39; to a different widget role:</p>

<pre>    has_field &#39;foxy&#39; =&#62; ( widget =&#62; &#39;MyWidget&#39;, widget_wrapper =&#62; &#39;MyWrapper&#39; );</pre>

<p>Often if you need custom rendering what you need to provide is a custom widget_wrapper. The &#39;widgets&#39; render only the input elements, and that often doesn&#39;t need to be changed. If you have standard HTML that is used when rendering forms, making custom widget_wrappers is often the way to go.</p>

<p>Default widget roles are found in the HTML::FormHandler::Widget directory, in the &#39;Field&#39;, &#39;Form&#39;, and &#39;Wrapper subdirectories. The name space used to look for the widget roles can be specified on a form or field basis by setting &#39;widget_name_space&#39; to an arrayref of name spaces:</p>

<pre>   has &#39;+widget_name_space&#39; =&#62; ( default =&#62; sub { [&#39;MyApp::Form::Widget&#39; ] } );</pre>

<p>For the above widget (&#39;MyWidget&#39;) and widget_name_space, you need to have a package named &#39;MyApp::Form::Widget::Field::MyWidget&#39;.</p>

<p>The HTML::FormHandler::Widget name space is always searched as the last name space. This means that you can set up an application or form specific set of widgets. Widgets in a widget directory (specified in widget_name_space) are located in either a &#39;Field&#39;, &#39;Wrapper&#39;, or &#39;Form&#39; subdirectory. (Blocks are in a &#39;Blocks&#39; subdirectory.)</p>

<p>You can also create an &#39;all-in-one&#39; type rendering role, using <a href="../../../HTML/FormHandler/Render/Simple.html" class="podlinkpod"
>HTML::FormHandler::Render::Simple</a> as a basis. It used the method name &#39;render_field&#39; on the form ( <code>$form-&#62;render_field(&#39;field_name&#39;)</code> ) instead of the &#39;render&#39; method on the field.</p>

<p>In addition to the &#39;Simple&#39; wrapper, there is a &#39;Bootstrap&#39; wrapper which creates HTML formatted to use the Twitter Bootstrap 2.0 CSS. There&#39;s also a sample &#34;theme&#34;, <a href="../../../HTML/FormHandler/Widget/Theme/Bootstrap.html" class="podlinkpod"
>HTML::FormHandler::Widget::Theme::Bootstrap</a>, which is a role that sets the widget_wrapper to &#39;Bootstrap&#39;, and provides Bootstrap-type formatting of the form error message.</p>

<p>There are a lot of different settings that control the rendering. Some of them are attributes in the form or field, and some of them are set using the &#39;tags&#39; hashref in the field or the &#39;form_tags&#39; hashref in the form.</p>

<p>You can make your own copy of an existing wrapper and add features to it. However, there are so many different ways to render the HTML around a field, that it&#39;s very difficult to handle more than a short list of standard presentations in one &#39;wrapper&#39;. It may be better to make a number of more atomic widget wrappers and use those rather than complicate the already fairly complicated &#34;Simple&#34; and &#34;Bootstrap&#34; wrappers more.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="HTML_attributes"
>HTML attributes</a></h2>

<p>Arbitrary HTML attributes on form elements (such as &#39;input&#39; elements) can be specified with &#39;element_attr&#39; on the field. You can also set attributes for the label with &#39;label_attr&#39; and attributes for the wrapper with &#39;wrapper_attr&#39;. The &#39;class&#39; attributes are handled separately, and are arrayrefs (element_class, wrapper_class, label_class):</p>

<pre>    has_field &#39;foo&#39; =&#62; ( wrapper_class =&#62; [&#39;form&#39;, &#39;special&#39; ] );</pre>

<p>See the documentation on <a href="../../../HTML/FormHandler/Field.html#Attributes_for_creating_HTML" class="podlinkpod"
>&#34;Attributes_for_creating_HTML&#34; in HTML::FormHandler::Field</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Form_settings"
>Form settings</a></h2>

<dl>
<dt><a name="widget_wrapper"
>widget_wrapper</a></dt>

<dd>
<p>The short name of the rendering wrapper widget to be applied to the fields. When the fields are constructed this is merged into fields that do not already set a widget wrapper.</p>

<dt><a name="do_form_wrapper"
>do_form_wrapper</a></dt>

<dd>
<p>Flag set with &#39;sub build_do_form_wrapper{ 1 }&#39;. Default is no form wrapper.</p>

<dt><a name="form_tags"
>form_tags</a></dt>

<dd>
<p>Hashref of various tags used in rendering code. See the documentation for <a href="../../../HTML/FormHandler/Widget/Form/Simple.html" class="podlinkpod"
>HTML::FormHandler::Widget::Form::Simple</a>.</p>

<dt><a name="form_element_attr"
>form_element_attr</a></dt>

<dd>
<p>Hashref of arbitrary HTML attributes to be included in the form element.</p>

<pre>   sub build_form_element_attr { [ ... ] }</pre>

<dt><a name="form_element_class"
>form_element_class</a></dt>

<dd>
<p>Arrayref of classes to be included in the form element.</p>

<pre>   form_element_class =&#62; [&#39;hfh&#39;, &#39;admin&#39;]
   -- or in your class --
   sub build_form_element_class { [&#39;hfh&#39;, &#39;admin&#39;] }</pre>

<p>The above class would produce a form element:</p>

<pre>   &#60;form id=&#34;myform&#34; method=&#34;post&#34; class=&#34;hfh admin&#34;&#62;</pre>

<dt><a name="form_wrapper_attr"
>form_wrapper_attr</a></dt>

<dd>
<p>Hashref of arbitrary HTML attributes to be included in the form wrapper</p>

<pre>   sub build_form_wrapper_attr { { name =&#62; &#39;formname&#39; } }</pre>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Form_messages"
>Form messages</a></h2>

<p>Some messages are rendered at the top of the form (inside the form tag) by the &#39;render_form_messages&#39; method, which is implemented in <a href="../../../HTML/FormHandler/Widget/Form/Simple.html" class="podlinkpod"
>HTML::FormHandler::Widget::Form::Simple</a> and <a href="../../../HTML/FormHandler/Widget/Theme/BootstrapFormMessages.html" class="podlinkpod"
>HTML::FormHandler::Widget::Theme::BootstrapFormMessages</a> (which is included by the Bootstrap theme).</p>

<p>There are three types of form messages: &#39;error_message&#39;, &#39;success_message&#39;, and &#39;info_message&#39;. The &#39;error_message&#39; and &#39;success_message&#39; are set inside the form:</p>

<pre>    has &#39;+success_message&#39; =&#62; ( default =&#62; &#39;Form successfully submitted&#39; );
    has &#39;+error_message&#39; =&#62; ( default =&#62; &#39;There were errors in your form.&#39; );</pre>

<p>And then are displayed after the form is validated.</p>

<p>The &#39;info_message&#39; is cleared out when a form is re-processed, and so would normally be set on the process call, or between new &#38; process.</p>

<pre>    $form-&#62;process( params =&#62; {}, info_message =&#62; &#39;Fill in the form&#39; );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Field_settings"
>Field settings</a></h2>

<pre>    has_field &#39;foo&#39; =&#62; ( widget =&#62; &#39;MyWidget&#39;, widget_wrapper =&#62; &#39;SpecialWrapper&#39;,
        element_attr =&#62; { placeholder =&#62; &#39;enter a foo&#39; }, element_class =&#62; &#39;important&#39;,
        wrapper_class =&#62; [&#39;label&#39;], label_class =&#62; [&#39;major&#39;],
        tags =&#62; { wrapper_tag =&#62; &#39;fieldset&#39; } );</pre>

<dl>
<dt><a name="widget"
>widget</a></dt>

<dd>
<p>Short name of the rendering widget for this field.</p>

<dt><a name="widget_wrapper"
>widget_wrapper</a></dt>

<dd>
<p>Short name of the wrapping widget for this field.</p>

<dt><a name="do_wrapper"
>do_wrapper</a></dt>

<dd>
<p>Flag that indicates whether or not the &#39;wrapper&#39; should be rendered.</p>

<dt><a name="do_label"
>do_label</a></dt>

<dd>
<p>Flag that indicates whether or not a label should be rendered.</p>

<dt><a name="element_attr"
>element_attr</a></dt>

<dd>
<p>Hashref of arbitrary HTML attributes to include in the element. Note that this does not include the &#39;id&#39; and &#39;type&#39; attributes, which are handled separately. The &#39;id&#39; can be changed with the field&#39;s &#39;id&#39; attribute.</p>

<dt><a name="element_class"
>element_class</a></dt>

<dd>
<p>Arrayref of classes to include in the element.</p>

<dt><a name="wrapper_attr"
>wrapper_attr</a></dt>

<dd>
<p>Hashref of arbitrary HTML attributes to include in the wrapper.</p>

<dt><a name="wrapper_class"
>wrapper_class</a></dt>

<dd>
<p>Arrayref of classes to include in the wrapper.</p>

<dt><a name="label_attr"
>label_attr</a></dt>

<dd>
<p>Hashref of arbitrary HTML attributes to include in the label.</p>

<dt><a name="label_class"
>label_class</a></dt>

<dd>
<p>Arrayref of classes to include in the label.</p>

<dt><a name="build_id_method"
>build_id_method</a></dt>

<dd>
<p>Coderef to construct the &#39;id&#39;. Useful if your javascript needs a different format for the &#39;id&#39;.</p>

<dt><a name="build_label_method"
>build_label_method</a></dt>

<dd>
<p>Coderef to construct the label.</p>

<dt><a name="wrap_label_method"
>wrap_label_method</a></dt>

<dd>
<p>Coderef to wrap the label. Used by the Simple and Bootstrap wrappers. Useful if your label contains HTML or a link. You must do your own localization and filtering if you use a &#39;wrap_label&#39; method.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="html_attributes_callback"
>html_attributes callback</a></h2>

<p>The form has an &#39;html_attributes&#39; callback which can be used to customize, localize, or modify the various attributes when used. Types: element, wrapper, label, form_element, form_wrapper, checkbox_label</p>

<pre>   sub html_attributes {
       my ( $self, $obj, $type, $attrs, $result ) = @_;
       # obj is either form or field
       $attr-&#62;{class} = &#39;label&#39; if $type eq &#39;label&#39;;
       $attr-&#62;{placeholder} = $self-&#62;_localize($attr-&#62;{placeholder})
           if exists $attr-&#62;{placeholder};
       return $attr;
   }</pre>

<p>This callback is called in the methods that wrap the various &#39;_attr&#39; attributes, i.e. element_attributes, label_attributes, wrapper_attributes, form_element_attributes, form_wrapper_attributes.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Field_tags"
>Field tags</a></h2>

<p>The &#39;tags&#39; are settings and strings which may vary by the particular widget that implements them. The best place to look for documentation on them is in the field widget, field wrapper, and form widgets that you are using. The &#39;tags&#39; allow customizing rendering behavior on a per-field basis. FormHandler has a number of flags/settings that it uses; you can add your own for your custom rendering code.</p>

<pre>    wrapper_tag    -- the tag to use in the wrapper, default &#39;div&#39;
    label_tag      -- tag to use for label (default &#39;label&#39;)
    label_after    -- string to append to label, for example &#39;: &#39; to append a colon</pre>

<p>Tags can be used to switch the Simple wrapper from divs to using paragraphs instead, or to add a colon in label formatting:</p>

<pre>   has_field &#39;my_field&#39; =&#62; (
       tags =&#62; {wrapper_tag =&#62; &#39;p&#39;, label_after =&#62; &#39;: &#39;  } );</pre>

<p>Most of the tags are implemented by the &#39;wrapper&#39; widget, so see that documentation for more details: <a href="../../../HTML/FormHandler/Widget/Wrapper/Simple.html" class="podlinkpod"
>HTML::FormHandler::Widget::Wrapper::Simple</a>, <a href="../../../HTML/FormHandler/Widget/Wrapper/Bootstrap.html" class="podlinkpod"
>HTML::FormHandler::Widget::Wrapper::Bootstrap</a>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Tag_types"
>Tag types</a></h3>

<p>The &#39;get_tag&#39; method will check for these three types of tags and perform the appropriate action.</p>

<dl>
<dt><a name="String"
>String</a></dt>

<dd>
<p>Standard, most common type of value for a tag.</p>

<pre>    has_field &#39;bar&#39; =&#62; ( tags =&#62; { before_element =&#62; &#39;&#60;span&#62;...&#60;/span&#62;&#39; } );</pre>

<p>Some tags are true/false also:</p>

<pre>    has_field &#39;foo&#39; =&#62; ( type =&#62; &#39;CheckBox&#39;,
        tags =&#62; { no_wrapped_label =&#62; 1 } );</pre>

<dt><a name="CodeRef"
>CodeRef</a></dt>

<dd>
<p>You can supply a coderef to a tag, and it will be executed as a method on the field. This is useful for localization or other sorts of runtime changes.</p>

<pre>    has_field &#39;bar&#39; =&#62; ( tags =&#62; { before_element =&#62; \&#38;bar_element } );
    sub bar_element {
        my $self = shift; # $self is the &#39;bar&#39; field
        return &#39;&#60;div&#62;In a Sub&#60;/div&#62;&#39;;
    }</pre>

<dt><a name="Block"
>Block</a></dt>

<dd>
<p>You can supply a block by giving a string that consists of a &#39;%&#39; followed by the block name:</p>

<pre>    has_block &#39;comment&#39; =&#62; ( tag =&#62; &#39;a&#39;, content =&#62; &#39;This is a comment from a block&#39;,
        class =&#62; [&#39;comment&#39; ] );
    has_field &#39;foo&#39; =&#62; ( tags =&#62; { before_element =&#62; &#39;%comment&#39; } );</pre>
</dd>
</dl>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Tags_and_other_settings_for_all_fields"
>Tags and other settings for all fields</a></h3>

<p>Tags can be set for all fields in the form by using a &#39;build_update_subfields&#39; sub, or &#39;widget_tags&#39;. The &#39;update_subfields&#39; hashref takes general-purpose keys &#39;all&#39;, &#39;by_flag&#39; (compound, repeatable, contains), and &#39;by_type&#39;. You can also set specific field attributes by using the field name as a key. For example, if you don&#39;t want errors to be displayed next to the fields, you need to set the &#39;no_errors&#39; tag:</p>

<pre>   sub build_update_subfields {{
       all =&#62; { tags =&#62; { no_errors =&#62; 1 }, wrapper_class =&#62; [&#39;myapp&#39;] },
       by_type =&#62; { Text =&#62; { element_class =&#62; [&#39;text&#39;] } },
       by_flag =&#62; { compound =&#62; { do_wrapper =&#62; 1 } },
       foo =&#62; { label =&#62; &#39;My Foo&#39; },
   }}
   -- or --
   &#39;+widget_tags&#39; =&#62; ( default =&#62; sub { { no_errors =&#62; 1 } } );</pre>

<p>The &#39;widget_tags&#39; attribute only handles the &#39;tags&#39; hashref, so if you also want to set classes or attributes, then build_update_subfields is more useful. You can also use &#39;build_update_subfields&#39; in a custom compound field class.</p>

<p>If you have defaults that are set in &#39;build_update_subfields&#39; in a base class, in order to use hashrefs from both base and current classes, you will need to merge the hashes:</p>

<pre>    use HTML::FormHandler::Merge (&#39;merge&#39;);
    sub build_update_subfields {
        my $self = shift;
        my $new = { all =&#62; { tags =&#62; { wrapper_tag =&#62; &#39;p&#39; } } };
        return merge( $new, $self-&#62;next::method(@_) );
    }</pre>

<p>In a role you would have to do the equivalent with an &#39;around&#39; method modifier.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Repeatable_field_instances"
>Repeatable field instances</a></h3>

<p>The repeatable field instances are constructed internally, so it&#39;s trickier to set things like wrapper tags. There are two ways to do it, using the &#39;init_contains&#39; attribute on the repeatable field, and using the &#39;update_subfields&#39; builder:</p>

<pre>    has_field &#39;records&#39; =&#62; ( type =&#62; &#39;Repeatable&#39;, num_when_empty =&#62; 2,
        init_contains =&#62; { tags =&#62; { wrapper_tag =&#62; &#39;fieldset&#39; } } );
    -- or --
    sub build_update_subfields { { by_flag =&#62; {
        contains =&#62; { tags =&#62; { wrapper_tag =&#62; &#39;fieldset&#39; }}}}}</pre>

<p>The &#39;build_update_subfields&#39; option is mainly useful if you have multiple repeatable fields that you want to set, or if you want defaults in a base class.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="widget_and_widget_wrapper_set_to_&#39;None&#39;"
>widget and widget_wrapper set to &#39;None&#39;</a></h3>

<p>If you want to implement the &#39;render&#39; method in a custom field, you can set &#39;widget&#39; to &#39;None&#39; and no widget will be applied. Setting the &#39;widget_wrapper&#39; to &#39;None&#39; will apply the &#39;None&#39; wrapper, which simply returns the widget rendering.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Error_messages"
>Error messages</a></h3>

<p>The default is currently to display error messages next to the rendered fields, if you&#39;re doing <code>$form-&#62;render</code>. If you don&#39;t want messages next to fields, you can set the &#39;no_errors&#39; tag, as discussed in the section on &#39;Tags and other settings...&#39;.</p>

<p>Note that the &#39;None&#39; widget wrapper, since it doesn&#39;t render anything except the form element (input, select, etc), will not render errors next to the field. Setting the &#39;do_wrapper&#39; and &#39;do_label&#39; flags to 0 will still render errors.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Blocks"
>Blocks</a></h2>

<p>When rendering, FormHandler loops through the sorted fields in the form and executes the &#39;render&#39; method on each field. Fields in FormHandler forms, particularly those that interface with a database, are usually structured in a way that matches the data structure. This doesn&#39;t always fit with the way that you want to display the form.</p>

<p>&#39;Blocks&#39; provide an alternative way of structuring the display. A &#39;block&#39; is a fairly basic object that contains a &#39;render&#39; method. The standard block class, <a href="../../../HTML/FormHandler/Widget/Block.html" class="podlinkpod"
>HTML::FormHandler::Widget::Block</a>, has Moose attributes to set the HTML tag, the label, the classes, etc, plus a &#39;render_list&#39; which contains the names of a list of fields or other blocks to render.</p>

<p>Here is the definition of a fieldset block that contains two fields:</p>

<pre>   has_field &#39;foo&#39;;
   has_field &#39;bar&#39;;
   has_block &#39;first_fset&#39; =&#62; ( tag =&#62; &#39;fieldset, label =&#62; &#39;Two Fields&#39;,
       render_list =&#62; [&#39;foo&#39;, &#39;bar&#39;] );</pre>

<p>The &#39;first_fset&#39; block will render like this:</p>

<pre>    &#60;fieldset&#62;&#60;legend&#62;Two Fields&#60;/legend&#62;
        &#60;div&#62;
           &#60;label&#62;Foo&#60;/label&#62;
           &#60;input type=&#34;text&#34; name=&#34;foo&#34; id=&#34;foo&#34; value=&#34;&#34; /&#62;
        &#60;div&#62;
        &#60;div&#62;
           &#60;label&#62;Bar&#60;/label&#62;
           &#60;input type=&#34;text&#34; name=&#34;bar&#34; id=&#34;bar&#34; value=&#34;&#34; /&#62;
        &#60;div&#62;
    &#60;/fieldset&#62;</pre>

<p>In order to actually get this block to be used when you render with <code>$form-&#62;render</code>, you need to supply a &#39;render_list&#39; on the form level:</p>

<pre>   sub build_render_list { [&#39;first_fset&#39;, &#39;submit_btn&#39;] }</pre>

<p>You could also render it with <code>$form-&#62;block(&#39;first_fset&#39;)-&#62;render</code>.</p>

<p>Blocks should be located in a widget name space, in a &#39;Block&#39; directory, or else the name should be prefixed with a &#39;+&#39;.</p>

<pre>    has &#39;+widget_name_space&#39; =&#62; ( default =&#62; sub { [&#39;MyApp::Form::Widget&#39;] };
    has_block &#39;first&#39; =&#62; ( type =&#62; &#39;MyBlock&#39;, ... );</pre>

<p>The &#39;MyBlock&#39; above will be found in &#39;MyApp::Form::Widget::Block::MyBlock&#39;.</p>

<pre>    has_block &#39;intro&#39; =&#62; ( type =&#62; &#39;+MyApp::Form::Component::Intro&#39; );</pre>

<p>A block can inherit from <a href="../../../HTML/FormHandler/Widget/Block.html" class="podlinkpod"
>HTML::FormHandler::Widget::Block</a>, but it doesn&#39;t have to. At a minimum it must provide &#39;new&#39; and &#39;render&#39; methods. If no &#39;type&#39; is specified, the block is created from the <a href="../../../HTML/FormHandler/Widget/Block.html" class="podlinkpod"
>HTML::FormHandler::Widget::Block</a> package.</p>

<p>The following package provides a functional block:</p>

<pre>    package MyApp::Component::Section;
    sub new {
        my ( $class, %args ) = @_;
        return bless \%args, $class;
    }
    sub form {
        my $self = shift;
        return $self-&#62;{form};
    }
    sub render {
        return
        &#39;&#60;div class=&#34;intro&#34;&#62;
          &#60;h3&#62;Please enter the relevant details&#60;/h3&#62;
        &#60;/div&#62;&#39;;
    }
    1;</pre>

<p>When a form is rendered, it will either loop through all of the sorted_fields OR loop through the fields and blocks listed in the &#39;render_list&#39;. A render_list can contain a mix of fields and blocks.</p>

<p>Note that you must be rendering with widgets to use block rendering.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Twitter_Bootstrap_2.0_rendering"
>Twitter Bootstrap 2.0 rendering</a></h2>

<p>The main component of Bootstrap rendering is <a href="../../../HTML/FormHandler/Widget/Wrapper/Bootstrap.html" class="podlinkpod"
>HTML::FormHandler::Widget::Wrapper::Bootstrap</a>. It produces the standard Bootstrap-style HTML such as:</p>

<pre>    &#60;div class=&#34;control-group&#34;&#62;
      &#60;label class=&#34;control-label&#34; for=&#34;input01&#34;&#62;Text input&#60;/label&#62;
      &#60;div class=&#34;controls&#34;&#62;
        &#60;input type=&#34;text&#34; class=&#34;input-xlarge&#34; id=&#34;input01&#34; name=&#34;input01&#34; value=&#34;&#34; /&#62;
      &#60;/div&#62;
    &#60;/div&#62;</pre>

<p>These are the standard &#39;control&#39; blocks for Bootstrap vertical and horizontal forms. You can apply this wrapper to all of your fields by setting the widget_wrapper in the form:</p>

<pre>   has &#39;+widget_wrapper&#39; =&#62; ( default =&#62; &#39;Bootstrap&#39; );</pre>

<p>There is also a sample &#34;theme&#34;: <a href="../../../HTML/FormHandler/Widget/Theme/Bootstrap.html" class="podlinkpod"
>HTML::FormHandler::Widget::Theme::Bootstrap</a>. It sets the widget_wrapper for you and provides a &#39;render_form_messages&#39; method to render a success/error messages section.</p>

<p>There are a couple of examples in the t/bootstrap directory of Bootstrap inline and search forms, which don&#39;t use exactly the same kind of control HTML.</p>

<p>You can always copy the existing wrapper and add your own features, with settings provided by the &#39;tags&#39; hashref.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Rendering_themes"
>Rendering themes</a></h2>

<p>Many of the flags and settings necessary for rendering can now be moved out into a role. Whether you want to do that or not is a matter of style and preference. The advantage is that it leaves the form class itself cleaner and easier to read. The disadvantage is that your settings come from more different places.</p>

<p>Here&#39;s an example of a form rendering &#39;theme&#39;, taken from the t/bootstrap/basic.t test:</p>

<pre>    package MyApp::Form::Basic::Theme;
    use Moose::Role;

    # make a wrapper around the form
    sub build_do_form_wrapper {1}
    # set the class for the form wrapper
    sub build_form_wrapper_class { [&#39;span9&#39;] }
    # set the class for the form element
    sub build_form_element_class { [&#39;well&#39;] }
    # set various rendering tags
    sub build_form_tags {
        {   wrapper_tag =&#62; &#39;div&#39;,
            before =&#62; qq{&#60;div class=&#34;row&#34;&#62;&#60;div class=&#34;span3&#34;&#62;&#60;p&#62;With v2.0, we have
               lighter and smarter defaults for form styles. No extra markup, just
               form controls.&#60;/p&#62;&#60;/div&#62;\n},
            after =&#62; &#39;&#60;/div&#62;&#39;,
        }
    }

    # the settings in &#39;build_update_subfields&#39; are merged with the field
    # definitions before they are constructed
    sub build_update_subfields {{
       # all fields have a label but no wrapper
       all =&#62; { do_wrapper =&#62; 0, do_label =&#62; 1 },
       # set the element class, a placeholder in element_attr
       foo =&#62; { element_class =&#62; [&#39;span3&#39;],
           element_attr =&#62; { placeholder =&#62; &#39;Type something&#226;&#128;&#166;&#39; },
           tags =&#62; { after_element =&#62;
              qq{\n&#60;span class=&#34;help-inline&#34;&#62;Associated help text!&#60;/span&#62;} } },
       bar =&#62; { option_label =&#62; &#39;Check me out&#39;,
          label_class =&#62; [&#39;checkbox&#39;], do_label =&#62; 0 },
       submit_btn =&#62; { element_class =&#62; [&#39;btn&#39;] },
    }}</pre>

<p>Note that the value &#39;all&#39; key in the update_subfields hashref will be merged into the attributes used when building all of the fields.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Rendering_fields"
>Rendering fields</a></h2>

<p>The default for most fields is a &#39;div&#39; wrapper and a label. If you don&#39;t want the wrapper, set <code>do_wrapper =&#62; 0</code>. If you don&#39;t want the label, set <code>do_label =&#62; 0</code>.</p>

<p>Checkboxes are most complicated, in that the default is to have two labels. The outer label, the one that&#39;s in the same place as the label for other input elements, is set with <code>label =&#62; &#39;...&#39;</code>. The inner label, which is the equivalent of the <code>label =&#62; &#39;...&#39;</code> in the options array used for selects and checkbox groups, is set with <code>option_label =&#62; &#39;...&#39;</code>. There are a number of other &#39;tags&#39; to control the presentation. See <a href="../../../HTML/FormHandler/Widget/Field/Checkbox.html" class="podlinkpod"
>HTML::FormHandler::Widget::Field::Checkbox</a> for more information, and t/render/checkbox.t for examples.</p>

<p>Some fields by default do not render a label: Button, Submit, Reset, ButtonTag. If you do want a label with these fields, you must set the &#39;do_label&#39; flag to 1:</p>

<pre>   has_field &#39;foo&#39; ( type =&#62; &#39;Button&#39;, do_label =&#62; 1 );</pre>

<p>Select fields are also fairly complicated. They can be rendered with the &#39;Select&#39;, &#39;RadioGroup&#39;, and &#39;CheckboxGroup&#39; widgets. Option groups are also supported. See <a href="../../../HTML/FormHandler/Field/Select.html" class="podlinkpod"
>HTML::FormHandler::Field::Select</a>;</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Rendering_labels"
>Rendering labels</a></h2>

<p>A &#39;standard&#39; label is built in the field if you don&#39;t supply one. The label can be provided in the field definition:</p>

<pre>    has_field &#39;foo&#39; =&#62; ( label =&#62; &#39;My Foo&#39; );</pre>

<p>You can also provide a method to &#39;build&#39; the label:</p>

<pre>    has_field &#39;foo&#39; =&#62; ( build_label_method =&#62; \&#38;build_label );
    sub build_label {
        my $self = shift; # field method
        return &#39;...&#39;;
    }</pre>

<p>And a method to &#39;wrap&#39; the label (used by the Simple and Bootstrap wrappers):</p>

<pre>    has_field &#39;foo&#39; =&#62; ( label =&#62; &#39;My Foo&#39;, wrap_label_method =&#62; \&#38;wrap_label );
    sub wrap_label {
        my ( $self, $label ) = @_;
        # or: my $label = $self-&#62;label;
        return qq{&#60;a href=&#34;...&#34;&#62;$label&#60;/a&#62;};
    }</pre>

<p>This is particularly useful for creating labels that have links or other HTML. The &#39;wrap_label_method&#39; does no filtering or localization, so you must do that yourself in the method if you need it.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Rendering_filter"
>Rendering filter</a></h2>

<p>The base field class has a &#39;render_filter&#39; attribute which is a coderef used to clean the values used to fill in the form for Render::Simple and the Widgets, and for some of the labels.. The default filter changes quote, ampersand, &#60;, and &#62; to the equivalent html entities. If you wish to use some other sort of filtering, you can use the &#39;render_filter&#39; method in your form, or set a coderef on individual field objects. A &#39;render_filter&#39; function in your form will be used by all fields. Setting it for a field will just be for that field.</p>

<pre>    sub render_filter {
        my $string = shift;
        $string =~ s/my/MY/g; # perform some kind of transformation
        return $string;
    }
    -- or --
    has_field &#39;foo&#39; =&#62; ( render_filter =&#62; sub { ... } );</pre>

<p>The filter is called in Render::Simple and in the widgets with <code>$self-&#62;html_filter( $fif )</code> or <code>$field-&#62;html_filter( $fif )</code>.</p>

<p>If you want to turn off the filter for a particular field, you can set it to a sub that just returns the value:</p>

<pre>    has_field &#39;bar&#39; =&#62; ( render_filter =&#62; sub { shift } );</pre>

<p>If you want a label that is unfiltered, see &#39;wrap_label_method&#39;.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="Special_rendering_pseudo-fields"
>Special rendering pseudo-fields</a></h1>

<p>Also see <a href="../../../HTML/FormHandler/Widget/Block.html" class="podlinkpod"
>HTML::FormHandler::Widget::Block</a>. Blocks may be a better solution than pseudo-fields (i.e. fields that aren&#39;t actual form elements).</p>

<p>Various &#39;tags&#39; used for rendering can also be used for similar purposes.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="NonEditable"
>NonEditable</a></h2>

<p>Like a Bootstrap &#39;non_editable&#39; field. Displays the field&#39;s value as a span.</p>

<pre>    has_field &#39;non_edit&#39; =&#62; ( type =&#62; &#39;NonEditable&#39;, value =&#62; &#39;This is a Test&#39; );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Display"
>Display</a></h2>

<p><a href="../../../HTML/FormHandler/Field/Display.html" class="podlinkpod"
>HTML::FormHandler::Field::Display</a></p>

<p>You can supply an HTML string to this field, to be displayed directly. There is no &#39;value&#39; associated with this field; it&#39;s a field for rendering only. The HTML string can be built with a form or field method.</p>

<p>Blocks or tags will often be a better solution.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>FormHandler Contributors - see HTML::FormHandler</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>This software is copyright (c) 2013 by Gerda Shank.</p>

<p>This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
