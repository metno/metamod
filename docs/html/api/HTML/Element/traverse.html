<html><head><title>HTML::Element::traverse</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:17 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#EXAMPLES'>EXAMPLES</a>
  <li class='indexItem indexItem1'><a href='#THE_TRAVERSE_METHOD'>THE TRAVERSE METHOD</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Traversing_with_Recursive_Anonymous_Routines'>Traversing with Recursive Anonymous Routines</a>
    <li class='indexItem indexItem2'><a href='#Doing_Recursive_Things_Iteratively'>Doing Recursive Things Iteratively</a>
    <li class='indexItem indexItem2'><a href='#Pruning_and_Whatnot'>Pruning and Whatnot</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT'>COPYRIGHT</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>HTML::Element::traverse - discussion of HTML::Element&#39;s traverse method</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>This document describes version 5.03 of HTML::Element::traverse,
released September 22,
2012 as part of <a href="../../HTML/Tree.html" class="podlinkpod"
>HTML-Tree</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  # $element-&#62;traverse is unnecessary and obscure.
  #   Don&#39;t use it in new code.</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p><code>HTML::Element</code> provides a method <code>traverse</code> that traverses the tree and calls user-specified callbacks for each node, in pre- or post-order. However, use of the method is quite superfluous: if you want to recursively visit every node in the tree, it&#39;s almost always simpler to write a subroutine does just that, than it is to bundle up the pre- and/or post-order code in callbacks for the <code>traverse</code> method.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="EXAMPLES"
>EXAMPLES</a></h1>

<p>Suppose you want to traverse at/under a node $tree and give elements an &#39;id&#39; attribute unless they already have one.</p>

<p>You can use the <code>traverse</code> method:</p>

<pre>  {
    my $counter = &#39;x0000&#39;;
    $start_node-&#62;traverse(
      [ # Callbacks;
        # pre-order callback:
        sub {
          my $x = $_[0];
          $x-&#62;attr(&#39;id&#39;, $counter++) unless defined $x-&#62;attr(&#39;id&#39;);
          return HTML::Element::OK; # keep traversing
        },
        # post-order callback:
        undef
      ],
      1, # don&#39;t call the callbacks for text nodes
    );
  }</pre>

<p>or you can just be simple and clear (and not have to understand the calling format for <code>traverse</code>) by writing a sub that traverses the tree by just calling itself:</p>

<pre>  {
    my $counter = &#39;x0000&#39;;
    sub give_id {
      my $x = $_[0];
      $x-&#62;attr(&#39;id&#39;, $counter++) unless defined $x-&#62;attr(&#39;id&#39;);
      foreach my $c ($x-&#62;content_list) {
        give_id($c) if ref $c; # ignore text nodes
      }
    };
    give_id($start_node);
  }</pre>

<p>See, isn&#39;t that nice and clear?</p>

<p>But, if you really need to know:</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="THE_TRAVERSE_METHOD"
>THE TRAVERSE METHOD</a></h1>

<p>The <code>traverse()</code> method is a general object-method for traversing a tree or subtree and calling user-specified callbacks. It accepts the following syntaxes:</p>

<dl>
<dt><a name="$h-&#62;traverse(\&#38;callback)"
>$h-&#62;traverse(\&#38;callback)</a></dt>

<dd>
<dt><a name="or_$h-&#62;traverse(\&#38;callback,_$ignore_text)"
>or $h-&#62;traverse(\&#38;callback, $ignore_text)</a></dt>

<dd>
<dt><a name="or_$h-&#62;traverse(_[\&#38;pre_callback,\&#38;post_callback]_,_$ignore_text)"
>or $h-&#62;traverse( [\&#38;pre_callback,\&#38;post_callback] , $ignore_text)</a></dt>
</dl>

<p>These all mean to traverse the element and all of its children. That is, this method starts at node $h, &#34;pre-order visits&#34; $h, traverses its children, and then will &#34;post-order visit&#34; $h. &#34;Visiting&#34; means that the callback routine is called, with these arguments:</p>

<pre>    $_[0] : the node (element or text segment),
    $_[1] : a startflag, and
    $_[2] : the depth</pre>

<p>If the $ignore_text parameter is given and true, then the pre-order call <i>will not</i> be happen for text content.</p>

<p>The startflag is 1 when we enter a node (i.e., in pre-order calls) and 0 when we leave the node (in post-order calls).</p>

<p>Note, however, that post-order calls don&#39;t happen for nodes that are text segments or are elements that are prototypically empty (like &#34;br&#34;, &#34;hr&#34;, etc.).</p>

<p>If we visit text nodes (i.e., unless $ignore_text is given and true), then when text nodes are visited, we will also pass two extra arguments to the callback:</p>

<pre>    $_[3] : the element that&#39;s the parent
             of this text node
    $_[4] : the index of this text node
             in its parent&#39;s content list</pre>

<p>Note that you can specify that the pre-order routine can be a different routine from the post-order one:</p>

<pre>    $h-&#62;traverse( [\&#38;pre_callback,\&#38;post_callback], ...);</pre>

<p>You can also specify that no post-order calls are to be made, by providing a false value as the post-order routine:</p>

<pre>    $h-&#62;traverse([ \&#38;pre_callback,0 ], ...);</pre>

<p>And similarly for suppressing pre-order callbacks:</p>

<pre>    $h-&#62;traverse([ 0,\&#38;post_callback ], ...);</pre>

<p>Note that these two syntaxes specify the same operation:</p>

<pre>    $h-&#62;traverse([\&#38;foo,\&#38;foo], ...);
    $h-&#62;traverse( \&#38;foo       , ...);</pre>

<p>The return values from calls to your pre- or post-order routines are significant, and are used to control recursion into the tree.</p>

<p>These are the values you can return, listed in descending order of my estimation of their usefulness:</p>

<dl>
<dt><a name="HTML::Element::OK,_1,_or_any_other_true_value"
>HTML::Element::OK, 1, or any other true value</a></dt>

<dd>
<p>...to keep on traversing.</p>

<p>Note that <code>HTML::Element::OK</code> et al are constants. So if you&#39;re running under <code>use strict</code> (as I hope you are), and you say: <code>return HTML::Element::PRUEN</code> the compiler will flag this as an error (an unallowable bareword, specifically), whereas if you spell PRUNE correctly, the compiler will not complain.</p>

<dt><a name="undef,_0,_&#39;0&#39;,_&#39;&#39;,_or_HTML::Element::PRUNE"
>undef, 0, &#39;0&#39;, &#39;&#39;, or HTML::Element::PRUNE</a></dt>

<dd>
<p>...to block traversing under the current element&#39;s content. (This is ignored if received from a post-order callback, since by then the recursion has already happened.) If this is returned by a pre-order callback, no post-order callback for the current node will happen. (Recall that if your callback exits with just <code>return;</code>, it is returning undef -- at least in scalar context, and <code>traverse</code> always calls your callbacks in scalar context.)</p>

<dt><a name="HTML::Element::ABORT"
>HTML::Element::ABORT</a></dt>

<dd>
<p>...to abort the whole traversal immediately. This is often useful when you&#39;re looking for just the first node in the tree that meets some criterion of yours.</p>

<dt><a name="HTML::Element::PRUNE_UP"
>HTML::Element::PRUNE_UP</a></dt>

<dd>
<p>...to abort continued traversal into this node and its parent node. No post-order callback for the current or parent node will happen.</p>

<dt><a name="HTML::Element::PRUNE_SOFTLY"
>HTML::Element::PRUNE_SOFTLY</a></dt>

<dd>
<p>Like PRUNE, except that the post-order call for the current node is not blocked.</p>
</dd>
</dl>

<p>Almost every task to do with extracting information from a tree can be expressed in terms of traverse operations (usually in only one pass, and usually paying attention to only pre-order, or to only post-order), or operations based on traversing. (In fact, many of the other methods in this class are basically calls to traverse() with particular arguments.)</p>

<p>The source code for HTML::Element and HTML::TreeBuilder contain several examples of the use of the &#34;traverse&#34; method to gather information about the content of trees and subtrees.</p>

<p>(Note: you should not change the structure of a tree <i>while</i> you are traversing it.)</p>

<p>[End of documentation for the <code>traverse()</code> method]</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Traversing_with_Recursive_Anonymous_Routines"
>Traversing with Recursive Anonymous Routines</a></h2>

<p>Now, if you&#39;ve been reading <i>Structure and Interpretation of Computer Programs</i> too much, maybe you even want a recursive lambda. Go ahead:</p>

<pre>  {
    my $counter = &#39;x0000&#39;;
    my $give_id;
    $give_id = sub {
      my $x = $_[0];
      $x-&#62;attr(&#39;id&#39;, $counter++) unless defined $x-&#62;attr(&#39;id&#39;);
      foreach my $c ($x-&#62;content_list) {
        $give_id-&#62;($c) if ref $c; # ignore text nodes
      }
    };
    $give_id-&#62;($start_node);
    undef $give_id;
  }</pre>

<p>It&#39;s a bit nutty, and it&#39;s <i>still</i> more concise than a call to the <code>traverse</code> method!</p>

<p>It is left as an exercise to the reader to figure out how to do the same thing without using a <code>$give_id</code> symbol at all.</p>

<p>It is also left as an exercise to the reader to figure out why I undefine <code>$give_id</code>, above; and why I could achieved the same effect with any of:</p>

<pre>    $give_id = &#39;I like pie!&#39;;
   # or...
    $give_id = [];
   # or even;
    $give_id = sub { print &#34;Mmmm pie!\n&#34; };</pre>

<p>But not:</p>

<pre>    $give_id = sub { print &#34;I&#39;m $give_id and I like pie!\n&#34; };
   # nor...
    $give_id = \$give_id;
   # nor...
    $give_id = { &#39;pie&#39; =&#62; \$give_id, &#39;mode&#39; =&#62; &#39;a la&#39; };</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Doing_Recursive_Things_Iteratively"
>Doing Recursive Things Iteratively</a></h2>

<p>Note that you may at times see an iterative implementation of pre-order traversal, like so:</p>

<pre>   {
     my @to_do = ($tree); # start-node
     while(@to_do) {
       my $this = shift @to_do;

       # &#34;Visit&#34; the node:
       $this-&#62;attr(&#39;id&#39;, $counter++)
        unless defined $this-&#62;attr(&#39;id&#39;);

       unshift @to_do, grep ref $_, $this-&#62;content_list;
        # Put children on the stack -- they&#39;ll be visited next
     }
   }</pre>

<p>This can <i>under certain circumstances</i> be more efficient than just a normal recursive routine, but at the cost of being rather obscure. It gains efficiency by avoiding the overhead of function-calling, but since there are several method dispatches however you do it (to <code>attr</code> and <code>content_list</code>), the overhead for a simple function call is insignificant.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Pruning_and_Whatnot"
>Pruning and Whatnot</a></h2>

<p>The <code>traverse</code> method does have the fairly neat features of the <code>ABORT</code>, <code>PRUNE_UP</code> and <code>PRUNE_SOFTLY</code> signals. None of these can be implemented <i>totally</i> straightforwardly with recursive routines, but it is quite possible. <code>ABORT</code>-like behavior can be implemented either with using non-local returning with <code>eval</code>/<code>die</code>:</p>

<pre>  my $died_on; # if you need to know where...
  sub thing {
    ... visits $_[0]...
    ... maybe set $died_on to $_[0] and die &#34;ABORT_TRAV&#34; ...
    ... else call thing($child) for each child...
    ...any post-order visiting $_[0]...
  }
  eval { thing($node) };
  if($@) {
    if($@ =~ m&#60;^ABORT_TRAV&#62;) {
      ...it died (aborted) on $died_on...
    } else {
      die $@; # some REAL error happened
    }
  }</pre>

<p>or you can just do it with flags:</p>

<pre>  my($abort_flag, $died_on);
  sub thing {
    ... visits $_[0]...
    ... maybe set $abort_flag = 1; $died_on = $_[0]; return;
    foreach my $c ($_[0]-&#62;content_list) {
      thing($c);
      return if $abort_flag;
    }
    ...any post-order visiting $_[0]...
    return;
  }

  $abort_flag = $died_on = undef;
  thing($node);
  ...if defined $abort_flag, it died on $died_on</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../../HTML/Element.html" class="podlinkpod"
>HTML::Element</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Current maintainers:</p>

<ul>
<li>Christopher J. Madsen <code>&#60;perl&#160;AT&#160;cjmweb.net&#62;</code></li>

<li>Jeff Fearn <code>&#60;jfearn&#160;AT&#160;cpan.org&#62;</code></li>
</ul>

<p>Original HTML-Tree author:</p>

<ul>
<li>Gisle Aas</li>
</ul>

<p>Former maintainers:</p>

<ul>
<li>Sean M. Burke</li>

<li>Andy Lester</li>

<li>Pete Krawczyk <code>&#60;petek&#160;AT&#160;cpan.org&#62;</code></li>
</ul>

<p>You can follow or contribute to HTML-Tree&#39;s development at <a href="http://github.com/madsen/HTML-Tree" class="podlinkurl"
>http://github.com/madsen/HTML-Tree</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT"
>COPYRIGHT</a></h1>

<p>Copyright 2000,2001 Sean M. Burke</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
