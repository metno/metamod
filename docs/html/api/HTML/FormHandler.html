<html><head><title>HTML::FormHandler</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:17 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#ATTRIBUTES_and_METHODS'>ATTRIBUTES and METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Creating_a_form_with_%27new%27'>Creating a form with &#39;new&#39;</a>
    <li class='indexItem indexItem2'><a href='#Processing_the_form'>Processing the form</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#process'>process</a>
      <li class='indexItem indexItem3'><a href='#params'>params</a>
      <li class='indexItem indexItem3'><a href='#posted'>posted</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Getting_data_out'>Getting data out</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#fif_(fill_in_form)'>fif (fill in form)</a>
      <li class='indexItem indexItem3'><a href='#value'>value</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Accessing_and_setting_up_fields'>Accessing and setting up fields</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#has_field'>has_field</a>
      <li class='indexItem indexItem3'><a href='#field_list'>field_list</a>
      <li class='indexItem indexItem3'><a href='#update_field_list'>update_field_list</a>
      <li class='indexItem indexItem3'><a href='#update_subfields'>update_subfields</a>
      <li class='indexItem indexItem3'><a href='#defaults'>defaults</a>
      <li class='indexItem indexItem3'><a href='#active%2Finactive'>active/inactive</a>
      <li class='indexItem indexItem3'><a href='#field_name_space'>field_name_space</a>
      <li class='indexItem indexItem3'><a href='#fields'>fields</a>
      <li class='indexItem indexItem3'><a href='#sorted_fields'>sorted_fields</a>
      <li class='indexItem indexItem3'><a href='#field(%24name)%2C_subfield(%24name)'>field($name), subfield($name)</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Constraints_and_validation'>Constraints and validation</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Form_class_validation_for_individual_fields'>Form class validation for individual fields</a>
      <li class='indexItem indexItem3'><a href='#validate'>validate</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Accessing_errors'>Accessing errors</a>
    <li class='indexItem indexItem2'><a href='#Clear_form_state'>Clear form state</a>
    <li class='indexItem indexItem2'><a href='#Miscellaneous_attributes'>Miscellaneous attributes</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#name'>name</a>
      <li class='indexItem indexItem3'><a href='#init_object'>init_object</a>
      <li class='indexItem indexItem3'><a href='#ctx'>ctx</a>
      <li class='indexItem indexItem3'><a href='#language_handle'>language_handle</a>
      <li class='indexItem indexItem3'><a href='#dependency'>dependency</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Flags'>Flags</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#validated%2C_is_valid'>validated, is_valid</a>
      <li class='indexItem indexItem3'><a href='#ran_validation'>ran_validation</a>
      <li class='indexItem indexItem3'><a href='#verbose%2C_dump%2C_peek'>verbose, dump, peek</a>
      <li class='indexItem indexItem3'><a href='#html_prefix'>html_prefix</a>
      <li class='indexItem indexItem3'><a href='#is_html5'>is_html5</a>
      <li class='indexItem indexItem3'><a href='#use_defaults_over_obj'>use_defaults_over_obj</a>
      <li class='indexItem indexItem3'><a href='#use_init_obj_over_item'>use_init_obj_over_item</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#For_use_in_HTML'>For use in HTML</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#SUPPORT'>SUPPORT</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#CONTRIBUTORS'>CONTRIBUTORS</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>HTML::FormHandler - HTML forms using Moose</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>version 0.40028</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<p>See the manual at <a href="../HTML/FormHandler/Manual.html" class="podlinkpod"
>HTML::FormHandler::Manual</a>.</p>

<pre>    use HTML::FormHandler; # or a custom form: use MyApp::Form::User;
    my $form = HTML::FormHandler-&#62;new( .... );
    $form-&#62;process( params =&#62; $params );
    my $rendered_form = $form-&#62;render;
    if( $form-&#62;validated ) {
        # perform validated form actions
    }
    else {
        # perform non-validated actions
    }</pre>

<p>Or, if you want to use a form &#39;result&#39; (which contains only the form values and error messages) instead:</p>

<pre>    use MyApp::Form; # or a generic form: use HTML::FormHandler;
    my $form = MyApp::Form-&#62;new( .... );
    my $result = $form-&#62;run( params =&#62; $params );
    if( $result-&#62;validated ) {
        # perform validated form actions
    }
    else {
        # perform non-validated actions
        $result-&#62;render;
    }</pre>

<p>An example of a custom form class:</p>

<pre>    package MyApp::Form::User;

    use HTML::FormHandler::Moose;
    extends &#39;HTML::FormHandler&#39;;
    use Moose::Util::TypeConstraints;

    has &#39;+item_class&#39; =&#62; ( default =&#62; &#39;User&#39; );

    has_field &#39;name&#39; =&#62; ( type =&#62; &#39;Text&#39; );
    has_field &#39;age&#39; =&#62; ( type =&#62; &#39;PosInteger&#39;, apply =&#62; [ &#39;MinimumAge&#39; ] );
    has_field &#39;birthdate&#39; =&#62; ( type =&#62; &#39;DateTime&#39; );
    has_field &#39;birthdate.month&#39; =&#62; ( type =&#62; &#39;Month&#39; );
    has_field &#39;birthdate.day&#39; =&#62; ( type =&#62; &#39;MonthDay&#39; );
    has_field &#39;birthdate.year&#39; =&#62; ( type =&#62; &#39;Year&#39; );
    has_field &#39;hobbies&#39; =&#62; ( type =&#62; &#39;Multiple&#39; );
    has_field &#39;address&#39; =&#62; ( type =&#62; &#39;Text&#39; );
    has_field &#39;city&#39; =&#62; ( type =&#62; &#39;Text&#39; );
    has_field &#39;state&#39; =&#62; ( type =&#62; &#39;Select&#39; );
    has_field &#39;email&#39; =&#62; ( type =&#62; &#39;Email&#39; );

    has &#39;+dependency&#39; =&#62; ( default =&#62; sub {
          [ [&#39;address&#39;, &#39;city&#39;, &#39;state&#39;], ]
       }
    );

    subtype &#39;MinimumAge&#39;
       =&#62; as &#39;Int&#39;
       =&#62; where { $_ &#62; 13 }
       =&#62; message { &#34;You are not old enough to register&#34; };

    no HTML::FormHandler::Moose;
    1;</pre>

<p>A dynamic form - one that does not use a custom form class - may be created using the &#39;field_list&#39; attribute to set fields:</p>

<pre>    my $form = HTML::FormHandler-&#62;new(
        name =&#62; &#39;user_form&#39;,
        item =&#62; $user,
        field_list =&#62; [
            &#39;username&#39; =&#62; {
                type  =&#62; &#39;Text&#39;,
                apply =&#62; [ { check =&#62; qr/^[0-9a-z]*\z/,
                   message =&#62; &#39;Contains invalid characters&#39; } ],
            },
            &#39;select_bar&#39; =&#62; {
                type     =&#62; &#39;Select&#39;,
                options  =&#62; \@select_options,
                multiple =&#62; 1,
                size     =&#62; 4,
            },
        ],
    );</pre>

<p>FormHandler does not provide a custom controller for Catalyst because it isn&#39;t necessary. Interfacing to FormHandler is only a couple of lines of code. See <a href="../HTML/FormHandler/Manual/Catalyst.html" class="podlinkpod"
>HTML::FormHandler::Manual::Catalyst</a> for more details, or <a href="../Catalyst/Manual/Tutorial/09_AdvancedCRUD/09_FormHandler.html" class="podlinkpod"
>Catalyst::Manual::Tutorial::09_AdvancedCRUD::09_FormHandler</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>*** Although documentation in this file provides some overview, it is mainly intended for API documentation. See <a href="../HTML/FormHandler/Manual/Intro.html" class="podlinkpod"
>HTML::FormHandler::Manual::Intro</a> for an introduction, with links to other documentation.</p>

<p>HTML::FormHandler maintains a clean separation between form construction and form rendering. It allows you to define your forms and fields in a number of flexible ways. Although it provides renderers for HTML, you can define custom renderers for any kind of presentation.</p>

<p>HTML::FormHandler allows you to define form fields and validators. It can be used for both database and non-database forms, and will automatically update or create rows in a database. It can be used to process structured data that doesn&#39;t come from an HTML form.</p>

<p>One of its goals is to keep the controller/application program interface as simple as possible, and to minimize the duplication of code. In most cases, interfacing your controller to your form is only a few lines of code.</p>

<p>With FormHandler you shouldn&#39;t have to spend hours trying to figure out how to make a simple HTML change that would take one minute by hand. Because you _can_ do it by hand. Or you can automate HTML generation as much as you want, with template widgets or pure Perl rendering classes, and stay completely in control of what, where, and how much is done automatically. You can define custom renderers and display your rendered forms however you want.</p>

<p>You can split the pieces of your forms up into logical parts and compose complete forms from FormHandler classes, roles, fields, collections of validations, transformations and Moose type constraints. You can write custom methods to process forms, add any attribute you like, and use Moose method modifiers. FormHandler forms are Perl classes, so there&#39;s a lot of flexibility in what you can do.</p>

<p>HTML::FormHandler provides rendering through roles which are applied to form and field classes (although there&#39;s no reason you couldn&#39;t write a renderer as an external object either). There are currently two flavors: all-in-one solutions like <a href="../HTML/FormHandler/Render/Simple.html" class="podlinkpod"
>HTML::FormHandler::Render::Simple</a> and <a href="../HTML/FormHandler/Render/Table.html" class="podlinkpod"
>HTML::FormHandler::Render::Table</a> that contain methods for rendering field widget classes, and the <a href="../HTML/FormHandler/Widget.html" class="podlinkpod"
>HTML::FormHandler::Widget</a> roles, which are more atomic roles which are automatically applied to fields and form. See <a href="../HTML/FormHandler/Manual/Rendering.html" class="podlinkpod"
>HTML::FormHandler::Manual::Rendering</a> for more details. (And you can easily use hand-built forms - FormHandler doesn&#39;t care.)</p>

<p>The typical application for FormHandler would be in a Catalyst, DBIx::Class, Template Toolkit web application, but use is not limited to that. FormHandler can be used in any Perl application.</p>

<p>More Formhandler documentation and a tutorial can be found in the manual at <a href="../HTML/FormHandler/Manual.html" class="podlinkpod"
>HTML::FormHandler::Manual</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ATTRIBUTES_and_METHODS"
>ATTRIBUTES and METHODS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Creating_a_form_with_&#39;new&#39;"
>Creating a form with &#39;new&#39;</a></h2>

<p>The new constructor takes name/value pairs:</p>

<pre>    MyForm-&#62;new(
        item    =&#62; $item,
    );</pre>

<p>No attributes are required on new. The form&#39;s fields will be built from the form definitions. If no initial data object or defaults have been provided, the form will be empty. Most attributes can be set on either &#39;new&#39; or &#39;process&#39;. The common attributes to be passed in to the constructor for a database form are either item_id and schema or item:</p>

<pre>   item_id  - database row primary key
   item     - database row object
   schema   - (for DBIC) the DBIx::Class schema</pre>

<p>The following are sometimes passed in, but are also often set in the form class:</p>

<pre>   item_class  - source name of row
   dependency  - (see dependency)
   field_list  - an array of field definitions
   init_object - a hashref or object to provide initial values</pre>

<p>Examples of creating a form object with new:</p>

<pre>    my $form = MyApp::Form::User-&#62;new;

    # database form using a row object
    my $form = MyApp::Form::Member-&#62;new( item =&#62; $row );

    # a dynamic form (no form class has been defined)
    my $form = HTML::FormHandler::Model::DBIC-&#62;new(
        item_id         =&#62; $id,
        item_class    =&#62; &#39;User&#39;,
        schema          =&#62; $schema,
        field_list         =&#62; [
                name    =&#62; &#39;Text&#39;,
                active  =&#62; &#39;Boolean&#39;,
                submit_btn =&#62; &#39;Submit&#39;,
        ],
    );</pre>

<p>See the model class for more information about &#39;item&#39;, &#39;item_id&#39;, &#39;item_class&#39;, and &#39;schema&#39; (for the DBIC model). <a href="../HTML/FormHandler/Model/DBIC.html" class="podlinkpod"
>HTML::FormHandler::Model::DBIC</a>.</p>

<p>FormHandler forms are handled in two steps: 1) create with &#39;new&#39;, 2) handle with &#39;process&#39;. FormHandler doesn&#39;t care whether most parameters are set on new or process or update, but a &#39;field_list&#39; argument must be passed in on &#39;new&#39; since the fields are built at construction time.</p>

<p>If you want to update field attributes on the &#39;process&#39; call, you can use an &#39;update_field_list&#39; or &#39;defaults&#39; hashref attribute , or subclass update_fields in your form. The &#39;update_field_list&#39; hashref can be used to set any field attribute. The &#39;defaults&#39; hashref will update only the &#39;default&#39; attribute in the field. (There are a lot of ways to set defaults. See <a href="../HTML/FormHandler/Manual/Defaults.html" class="podlinkpod"
>HTML::FormHandler::Manual::Defaults</a>.)</p>

<pre>   $form-&#62;process( defaults =&#62; { foo =&#62; &#39;foo_def&#39;, bar =&#62; &#39;bar_def&#39; } );
   $form-&#62;process( update_field_list =&#62; { foo =&#62; { label =&#62; &#39;New Label&#39; } });</pre>

<p>Field results are built on the &#39;new&#39; call, but will then be re-built on the process call. If you always use &#39;process&#39; before rendering the form, accessing fields, etc, you can set the &#39;no_preload&#39; flag to skip this step.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Processing_the_form"
>Processing the form</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="process"
>process</a></h3>

<p>Call the &#39;process&#39; method on your form to perform validation and update. A database form must have either an item (row object) or a schema, item_id (row primary key), and item_class (usually set in the form). A non-database form requires only parameters.</p>

<pre>   $form-&#62;process( item =&#62; $book, params =&#62; $c-&#62;req-&#62;parameters );
   $form-&#62;process( item_id =&#62; $item_id,
       schema =&#62; $schema, params =&#62; $c-&#62;req-&#62;parameters );
   $form-&#62;process( params =&#62; $c-&#62;req-&#62;parameters );</pre>

<p>This process method returns the &#39;validated&#39; flag (<code>$form-&#62;validated</code>). If it is a database form and the form validates, the database row will be updated.</p>

<p>After the form has been processed, you can get a parameter hashref suitable for using to fill in the form from <code>$form-&#62;fif</code>. A hash of inflated values (that would be used to update the database for a database form) can be retrieved with <code>$form-&#62;value</code>.</p>

<p>If you don&#39;t want to update the database on this process call, you can set the &#39;no_update&#39; flag:</p>

<pre>   $form-&#62;process( item =&#62; $book, params =&#62; $params, no_update =&#62; 1 );</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="params"
>params</a></h3>

<p>Parameters are passed in when you call &#39;process&#39;. HFH gets data to validate and store in the database from the params hash. If the params hash is empty, no validation is done, so it is not necessary to check for POST before calling <code>$form-&#62;process</code>. (Although see the &#39;posted&#39; option for complications.)</p>

<p>Params can either be in the form of CGI/HTTP style params:</p>

<pre>   {
      user_name =&#62; &#34;Joe Smith&#34;,
      occupation =&#62; &#34;Programmer&#34;,
      &#39;addresses.0.street&#39; =&#62; &#34;999 Main Street&#34;,
      &#39;addresses.0.city&#39; =&#62; &#34;Podunk&#34;,
      &#39;addresses.0.country&#39; =&#62; &#34;UT&#34;,
      &#39;addresses.0.address_id&#39; =&#62; &#34;1&#34;,
      &#39;addresses.1.street&#39; =&#62; &#34;333 Valencia Street&#34;,
      &#39;addresses.1.city&#39; =&#62; &#34;San Francisco&#34;,
      &#39;addresses.1.country&#39; =&#62; &#34;UT&#34;,
      &#39;addresses.1.address_id&#39; =&#62; &#34;2&#34;,
   }</pre>

<p>or as structured data in the form of hashes and lists:</p>

<pre>   {
      addresses =&#62; [
         {
            city =&#62; &#39;Middle City&#39;,
            country =&#62; &#39;GK&#39;,
            address_id =&#62; 1,
            street =&#62; &#39;101 Main St&#39;,
         },
         {
            city =&#62; &#39;DownTown&#39;,
            country =&#62; &#39;UT&#39;,
            address_id =&#62; 2,
            street =&#62; &#39;99 Elm St&#39;,
         },
      ],
      &#39;occupation&#39; =&#62; &#39;management&#39;,
      &#39;user_name&#39; =&#62; &#39;jdoe&#39;,
   }</pre>

<p>CGI style parameters will be converted to hashes and lists for HFH to operate on.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="posted"
>posted</a></h3>

<p>Note that FormHandler by default uses empty params as a signal that the form has not actually been posted, and so will not attempt to validate a form with empty params. Most of the time this works OK, but if you have a small form with only the controls that do not return a post parameter if unselected (checkboxes and select lists), then the form will not be validated if everything is unselected. For this case you can either add a hidden field as an &#39;indicator&#39;, or use the &#39;posted&#39; flag:</p>

<pre>   $form-&#62;process( posted =&#62; ($c-&#62;req-&#62;method eq &#39;POST&#39;), params =&#62; ... );</pre>

<p>The &#39;posted&#39; flag also works to prevent validation from being performed if there are extra params in the params hash and it is not a &#39;POST&#39; request.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Getting_data_out"
>Getting data out</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="fif_(fill_in_form)"
>fif (fill in form)</a></h3>

<p>If you don&#39;t use FormHandler rendering and want to fill your form values in using some other method (such as with HTML::FillInForm or using a template) this returns a hash of values that are equivalent to params which you may use to fill in your form.</p>

<p>The fif value for a &#39;title&#39; field in a TT form:</p>

<pre>   [% form.fif.title %]</pre>

<p>Or you can use the &#39;fif&#39; method on individual fields:</p>

<pre>   [% form.field(&#39;title&#39;).fif %]</pre>

<p>If you use FormHandler to render your forms or field you probably won&#39;t use these methods.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="value"
>value</a></h3>

<p>Returns a hashref of all field values. Useful for non-database forms, or if you want to update the database yourself. The &#39;fif&#39; method returns a hashref with the field names for the keys and the field&#39;s &#39;fif&#39; for the values; &#39;value&#39; returns a hashref with the field accessors for the keys, and the field&#39;s &#39;value&#39; (possibly inflated) for the values.</p>

<p>Forms containing arrays to be processed with <a href="../HTML/FormHandler/Field/Repeatable.html" class="podlinkpod"
>HTML::FormHandler::Field::Repeatable</a> will have parameters with dots and numbers, like &#39;addresses.0.city&#39;, while the values hash will transform the fields with numbers to arrays.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Accessing_and_setting_up_fields"
>Accessing and setting up fields</a></h2>

<p>Fields are declared with a number of attributes which are defined in <a href="../HTML/FormHandler/Field.html" class="podlinkpod"
>HTML::FormHandler::Field</a>. If you want additional attributes you can define your own field classes (or apply a role to a field class - see <a href="../HTML/FormHandler/Manual/Cookbook.html" class="podlinkpod"
>HTML::FormHandler::Manual::Cookbook</a>). The field &#39;type&#39; (used in field definitions) is the short class name of the field class, used when searching the &#39;field_name_space&#39; for the field class.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="has_field"
>has_field</a></h3>

<p>The most common way of declaring fields is the &#39;has_field&#39; syntax. Using the &#39;has_field&#39; syntax sugar requires <code> use HTML::FormHandler::Moose; </code> or <code> use HTML::FormHandler::Moose::Role; </code> in a role. See <a href="../HTML/FormHandler/Manual/Intro.html" class="podlinkpod"
>HTML::FormHandler::Manual::Intro</a></p>

<pre>   use HTML::FormHandler::Moose;
   has_field &#39;field_name&#39; =&#62; ( type =&#62; &#39;FieldClass&#39;, .... );</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="field_list"
>field_list</a></h3>

<p>A &#39;field_list&#39; is an array of field definitions which can be used as an alternative to &#39;has_field&#39; in small, dynamic forms to create fields.</p>

<pre>    field_list =&#62; [
       field_one =&#62; {
          type =&#62; &#39;Text&#39;,
          required =&#62; 1
       },
       field_two =&#62; &#39;Text,
    ]</pre>

<p>The field_list array takes elements which are either a field_name key pointing to a &#39;type&#39; string or a field_name key pointing to a hashref of field attributes. You can also provide an array of hashref elements with the name as an additional attribute. The field list can be set inside a form class, when you want to add fields to the form depending on some other state, although you can also create all the fields and set some of them inactive.</p>

<pre>   sub field_list {
      my $self = shift;
      my $fields = $self-&#62;schema-&#62;resultset(&#39;SomeTable&#39;)-&#62;
                          search({user_id =&#62; $self-&#62;user_id, .... });
      my @field_list;
      while ( my $field = $fields-&#62;next )
      {
         &#60; create field list &#62;
      }
      return \@field_list;
   }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="update_field_list"
>update_field_list</a></h3>

<p>Used to dynamically set particular field attributes on the &#39;process&#39; (or &#39;run&#39;) call. (Will not create fields.)</p>

<pre>    $form-&#62;process( update_field_list =&#62; {
       foo_date =&#62; { format =&#62; &#39;%m/%e/%Y&#39;, date_start =&#62; &#39;10-01-01&#39; } },
       params =&#62; $params );</pre>

<p>The &#39;update_field_list&#39; is processed by the &#39;update_fields&#39; form method, which can also be used in a form to do specific field updates:</p>

<pre>    sub update_fields {
        my $self = shift;
        $self-&#62;field(&#39;foo&#39;)-&#62;temp( &#39;foo_temp&#39; );
        $self-&#62;field(&#39;bar&#39;)-&#62;default( &#39;foo_value&#39; );
        $self-&#62;next::method();
    }</pre>

<p>(Note that you although you can set a field&#39;s &#39;default&#39;, you can&#39;t set a field&#39;s &#39;value&#39; directly here, since it will be overwritten by the validation process. Set the value in a field validation method.)</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="update_subfields"
>update_subfields</a></h3>

<p>Yet another way to provide settings for the field, except this one is intended for use in roles and compound fields, and is only executed when the form is initially built. It takes the same field name keys as &#39;update_field_list&#39;, plus &#39;all&#39;, &#39;by_flag&#39;, and &#39;by_type&#39;.</p>

<pre>    sub build_update_subfields {{
        all =&#62; { tags =&#62; { wrapper_tag =&#62; &#39;p&#39; } },
        foo =&#62; { element_class =&#62; &#39;blue&#39; },
    }}</pre>

<p>The &#39;all&#39; hash key will apply updates to all fields. (Conflicting attributes in a field definition take precedence.)</p>

<p>The &#39;by_flag&#39; hash key will apply updates to fields with a particular flag. The currently supported subkeys are &#39;compound&#39;, &#39;contains&#39;, and &#39;repeatable&#39;. (For repeatable instances, in addition to &#39;contains&#39; you can also use the &#39;repeatable&#39; key and the &#39;init_contains&#39; attribute.) This is useful for turning on the rendering wrappers for compounds and repeatables, which are off by default. (The repeatable instances are wrapped by default.)</p>

<pre>    sub build_update_subfields {{
        by_flag =&#62; { compound =&#62; { do_wrapper =&#62; 1 } },
        by_type =&#62; { Select =&#62; { element_class =&#62; [&#39;sel_elem&#39;] } },
    }}</pre>

<p>The &#39;by_type&#39; hash key will provide values to all fields of a particular type.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="defaults"
>defaults</a></h3>

<p>This is a more specialized version of the &#39;update_field_list&#39;. It can be used to provide &#39;default&#39; settings for fields, in a shorthand way (you don&#39;t have to say &#39;default&#39; for every field).</p>

<pre>   $form-&#62;process( defaults =&#62; { foo =&#62; &#39;this_foo&#39;, bar =&#62; &#39;this_bar&#39; }, ... );</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="active/inactive"
>active/inactive</a></h3>

<p>A field can be marked &#39;inactive&#39; and set to active at new or process time by specifying the field name in the &#39;active&#39; array:</p>

<pre>   has_field &#39;foo&#39; =&#62; ( type =&#62; &#39;Text&#39;, inactive =&#62; 1 );
   ...
   my $form = MyApp::Form-&#62;new( active =&#62; [&#39;foo&#39;] );
   ...
   $form-&#62;process( active =&#62; [&#39;foo&#39;] );</pre>

<p>Or a field can be a normal active field and set to inactive at new or process time:</p>

<pre>   has_field &#39;bar&#39;;
   ...
   my $form = MyApp::Form-&#62;new( inactive =&#62; [&#39;foo&#39;] );
   ...
   $form-&#62;process( inactive =&#62; [&#39;foo&#39;] );</pre>

<p>Fields specified as active/inactive on new will have the form&#39;s inactive/active arrayref cleared and the field&#39;s inactive flag set appropriately, so that the state will be effective for the life of the form object. Fields specified as active/inactive on &#39;process&#39; will have the field&#39;s &#39;_active&#39; flag set for the life of the request (the _active flag will be cleared when the form is cleared).</p>

<p>The &#39;sorted_fields&#39; method returns only active fields, sorted according to the &#39;order&#39; attribute. The &#39;fields&#39; method returns all fields.</p>

<pre>   foreach my $field ( $self-&#62;sorted_fields ) { ... }</pre>

<p>You can test whether a field is active by using the field &#39;is_active&#39; and &#39;is_inactive&#39; methods.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="field_name_space"
>field_name_space</a></h3>

<p>Use to look for field during form construction. If a field is not found with the field_name_space (or HTML::FormHandler/HTML::FormHandlerX), the &#39;type&#39; must start with a &#39;+&#39; and be the complete package name.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="fields"
>fields</a></h3>

<p>The array of fields, objects of <a href="../HTML/FormHandler/Field.html" class="podlinkpod"
>HTML::FormHandler::Field</a> or its subclasses. A compound field will itself have an array of fields, so this is a tree structure.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="sorted_fields"
>sorted_fields</a></h3>

<p>Returns those fields from the fields array which are currently active. This is the method that returns the fields that are looped through when rendering.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="field($name),_subfield($name)"
>field($name), subfield($name)</a></h3>

<p>&#39;field&#39; is the method that is usually called to access a field:</p>

<pre>    my $title = $form-&#62;field(&#39;title&#39;)-&#62;value;
    [% f = form.field(&#39;title&#39;) %]

    my $city = $form-&#62;field(&#39;addresses.0.city&#39;)-&#62;value;</pre>

<p>Pass a second true value to die on errors.</p>

<p>Since fields are searched for using the form as a base, if you want to find a sub field in a compound field method, the &#39;subfield&#39; method may be more useful, since you can search starting at the current field. The &#39;chained&#39; method also works:</p>

<pre>    -- in a compound field --
    $self-&#62;field(&#39;media.caption&#39;); # fails
    $self-&#62;field(&#39;media&#39;)-&#62;field(&#39;caption&#39;); # works
    $self-&#62;subfield(&#39;media.caption&#39;); # works</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Constraints_and_validation"
>Constraints and validation</a></h2>

<p>Most validation is performed on a per-field basis, and there are a number of different places in which validation can be performed.</p>

<p>See also <a href="../HTML/FormHandler/Manual/Validation.html" class="podlinkpod"
>HTML::FormHandler::Manual::Validation</a>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Form_class_validation_for_individual_fields"
>Form class validation for individual fields</a></h3>

<p>You can define a method in your form class to perform validation on a field. This method is the equivalent of the field class validate method except it is in the form class, so you might use this validation method if you don&#39;t want to create a field subclass.</p>

<p>It has access to the form ($self) and the field. This method is called after the field class &#39;validate&#39; method, and is not called if the value for the field is empty (&#39;&#39;, undef). (If you want an error message when the field is empty, use the &#39;required&#39; flag and message or the form &#39;validate&#39; method.) The name of this method can be set with &#39;set_validate&#39; on the field. The default is &#39;validate_&#39; plus the field name:</p>

<pre>   sub validate_testfield { my ( $self, $field ) = @_; ... }</pre>

<p>If the field name has dots they should be replaced with underscores.</p>

<p>Note that you can also provide a coderef which will be a method on the field:</p>

<pre>   has_field &#39;foo&#39; =&#62; ( validate_method =&#62; \&#38;validate_foo );</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="validate"
>validate</a></h3>

<p>This is a form method that is useful for cross checking values after they have been saved as their final validated value, and for performing more complex dependency validation. It is called after all other field validation is done, and whether or not validation has succeeded, so it has access to the post-validation values of all the fields.</p>

<p>This is the best place to do validation checks that depend on the values of more than one field.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Accessing_errors"
>Accessing errors</a></h2>

<p>Also see <a href="../HTML/FormHandler/Manual/Errors.html" class="podlinkpod"
>HTML::FormHandler::Manual::Errors</a>.</p>

<p>Set an error in a field with <code>$field-&#62;add_error(&#39;some error string&#39;);</code>. Set a form error not tied to a specific field with <code>$self-&#62;add_form_error(&#39;another error string&#39;);</code>. The &#39;add_error&#39; and &#39;add_form_error&#39; methods call localization. If you want to skip localization for a particular error, you can use &#39;push_errors&#39; or &#39;push_form_errors&#39; instead.</p>

<pre>  has_errors - returns true or false
  error_fields - returns list of fields with errors
  errors - returns array of error messages for the entire form
  num_errors - number of errors in form</pre>

<p>Each field has an array of error messages. (errors, has_errors, num_errors, clear_errors)</p>

<pre>  $form-&#62;field(&#39;title&#39;)-&#62;errors;</pre>

<p>Compound fields also have an array of error_fields.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Clear_form_state"
>Clear form state</a></h2>

<p>The clear method is called at the beginning of &#39;process&#39; if the form object is reused, such as when it is persistent in a Moose attribute, or in tests. If you add other attributes to your form that are set on each request, you may need to clear those yourself.</p>

<p>If you do not call the form&#39;s &#39;process&#39; method on a persistent form, such as in a REST controller&#39;s non-POST method, or if you only call process when the form is posted, you will also need to call <code>$form-&#62;clear</code>.</p>

<p>The &#39;run&#39; method which returns a result object always performs &#39;clear&#39;, to keep the form object clean.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Miscellaneous_attributes"
>Miscellaneous attributes</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="name"
>name</a></h3>

<p>The form&#39;s name. Useful for multiple forms. Used for the form element &#39;id&#39;. When &#39;html_prefix&#39; is set it is used to construct the field &#39;id&#39; and &#39;name&#39;. The default is &#34;form&#34; + a one to three digit random number. Because the HTML standards have flip-flopped on whether the HTML form element can contain a &#39;name&#39; attribute, please set a name attribute using &#39;form_element_attr&#39;.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="init_object"
>init_object</a></h3>

<p>An &#39;init_object&#39; may be used instead of the &#39;item&#39; to pre-populate the values in the form. This can be useful when populating a form from default values stored in a similar but different object than the one the form is creating. The &#39;init_object&#39; should be either a hash or the same type of object that the model uses (a DBIx::Class row for the DBIC model). It can be set in a variety of ways:</p>

<pre>   my $form = MyApp::Form-&#62;new( init_object =&#62; { .... } );
   $form-&#62;process( init_object =&#62; {...}, ... );
   has &#39;+init_object&#39; =&#62; ( default =&#62; sub { { .... } } );
   sub init_object { my $self = shift; .... }</pre>

<p>The method version is useful if the organization of data in your form does not map to an existing or database object in an automatic way, and you need to create a different type of object for initialization. (You might also want to do &#39;update_model&#39; yourself.)</p>

<p>Also see the &#39;use_init_obj_over_item&#39; and the &#39;use_init_obj_when_no_accessor_in_item&#39; flags, if you want to provide both an item and an init_object, and use the values from the init_object.</p>

<p>The &#39;use_init_obj_when_no_accessor_in_item&#39; flag is particularly useful when some of the fields in your form come from the database and some are process or environment type flags that are not in the database. You can provide defaults from both a database row and an &#39;init_object.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="ctx"
>ctx</a></h3>

<p>Place to store application context for your use in your form&#39;s methods.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="language_handle"
>language_handle</a></h3>

<p>See &#39;language_handle&#39; and &#39;_build_language_handle&#39; in <a href="../HTML/FormHandler/TraitFor/I18N.html" class="podlinkpod"
>HTML::FormHandler::TraitFor::I18N</a>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="dependency"
>dependency</a></h3>

<p>Arrayref of arrayrefs of fields. If one of a group of fields has a value, then all of the group are set to &#39;required&#39;.</p>

<pre>  has &#39;+dependency&#39; =&#62; ( default =&#62; sub { [
     [&#39;street&#39;, &#39;city&#39;, &#39;state&#39;, &#39;zip&#39; ],] }
  );</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Flags"
>Flags</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="validated,_is_valid"
>validated, is_valid</a></h3>

<p>Flag that indicates if form has been validated. You might want to use this flag if you&#39;re doing something in between process and returning, such as setting a stash key. (&#39;is_valid&#39; is a synonym for this flag)</p>

<pre>   $form-&#62;process( ... );
   $c-&#62;stash-&#62;{...} = ...;
   return unless $form-&#62;validated;</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="ran_validation"
>ran_validation</a></h3>

<p>Flag to indicate that validation has been run. This flag will be false when the form is initially loaded and displayed, since validation is not run until FormHandler has params to validate.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="verbose,_dump,_peek"
>verbose, dump, peek</a></h3>

<p>Flag to dump diagnostic information. See &#39;dump_fields&#39; and &#39;dump_validated&#39;. &#39;Peek&#39; can be useful in diagnosing bugs. It will dump a brief listing of the fields and results.</p>

<pre>   $form-&#62;process( ... );
   $form-&#62;peek;</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="html_prefix"
>html_prefix</a></h3>

<p>Flag to indicate that the form name is used as a prefix for fields in an HTML form. Useful for multiple forms on the same HTML page. The prefix is stripped off of the fields before creating the internal field name, and added back in when returning a parameter hash from the &#39;fif&#39; method. For example, the field name in the HTML form could be &#34;book.borrower&#34;, and the field name in the FormHandler form (and the database column) would be just &#34;borrower&#34;.</p>

<pre>   has &#39;+name&#39; =&#62; ( default =&#62; &#39;book&#39; );
   has &#39;+html_prefix&#39; =&#62; ( default =&#62; 1 );</pre>

<p>Also see the Field attribute &#34;html_name&#34;, a convenience function which will return the form name + &#34;.&#34; + field full_name</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="is_html5"
>is_html5</a></h3>

<p>Flag to indicate the fields will render using specialized attributes for html5. Set to 0 by default.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="use_defaults_over_obj"
>use_defaults_over_obj</a></h3>

<p>The &#39;normal&#39; precedence is that if there is an accessor in the item/init_object that value is used and not the &#39;default&#39;. This flag makes the defaults of higher precedence. Mainly useful if providing an empty row on create.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="use_init_obj_over_item"
>use_init_obj_over_item</a></h3>

<p>If you are providing both an item and an init_object, and want the init_object to be used for defaults instead of the item.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="For_use_in_HTML"
>For use in HTML</a></h2>

<pre>   form_element_attr - hashref for setting arbitrary HTML attributes
      set in form with: sub build_form_element_attr {...}
   form_element_class - arrayref for setting form tag class
   form_wrapper_attr - hashref for form wrapper element attributes
      set in form with: sub build_form_wrapper_attr {...}
   form_wrapper_class - arrayref for setting wrapper class
   do_form_wrapper - flag to wrap the form
   http_method - For storing &#39;post&#39; or &#39;get&#39;
   action - Store the form &#39;action&#39; on submission. No default value.
   uuid - generates a string containing an HTML field with UUID
   form_tags - hashref of tags for use in rendering code
   widget_tags - rendering tags to be transferred to fields</pre>

<p>Discouraged (use form_element_attr instead):</p>

<pre>   css_class - adds a &#39;class&#39; attribute to the form tag
   style - adds a &#39;style&#39; attribute to the form tag
   enctype - Request enctype</pre>

<p>Note that the form tag contains an &#39;id&#39; attribute which is set to the form name. The standards have been flip-flopping over whether a &#39;name&#39; attribute is valid. It can be set with &#39;form_element_attr&#39;.</p>

<p>The rendering of the HTML attributes is done using the &#39;process_attrs&#39; function and the &#39;element_attributes&#39; or &#39;wrapper_attributes&#39; method, which adds other attributes in for backward compatibility, and calls the &#39;html_attributes&#39; hook.</p>

<p>For HTML attributes, there is a form method hook, &#39;html_attributes&#39;, which can be used to customize/modify/localize form &#38; field HTML attributes. Types: element, wrapper, label, form_element, form_wrapper, checkbox_label</p>

<pre>   sub html_attributes {
       my ( $self, $obj, $type, $attrs, $result ) = @_;

       # obj is either form or field
       $attr-&#62;{class} = &#39;label&#39; if $type eq &#39;label&#39;;
       $attr-&#62;{placeholder} = $self-&#62;_localize($attr-&#62;{placeholder})
           if exists $attr-&#62;{placeholder};
       return $attr;
   }</pre>

<p>Also see the documentation in <a href="../HTML/FormHandler/Field.html" class="podlinkpod"
>HTML::FormHandler::Field</a> and in <a href="../HTML/FormHandler/Manual/Rendering.html" class="podlinkpod"
>HTML::FormHandler::Manual::Rendering</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SUPPORT"
>SUPPORT</a></h1>

<p>IRC:</p>

<pre>  Join #formhandler on irc.perl.org</pre>

<p>Mailing list:</p>

<pre>  http://groups.google.com/group/formhandler</pre>

<p>Code repository:</p>

<pre>  http://github.com/gshank/html-formhandler/tree/master</pre>

<p>Bug tracker:</p>

<pre>  https://rt.cpan.org/Dist/Display.html?Name=HTML-FormHandler</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../HTML/FormHandler/Manual.html" class="podlinkpod"
>HTML::FormHandler::Manual</a></p>

<p><a href="../HTML/FormHandler/Manual/Tutorial.html" class="podlinkpod"
>HTML::FormHandler::Manual::Tutorial</a></p>

<p><a href="../HTML/FormHandler/Manual/Intro.html" class="podlinkpod"
>HTML::FormHandler::Manual::Intro</a></p>

<p><a href="../HTML/FormHandler/Manual/Templates.html" class="podlinkpod"
>HTML::FormHandler::Manual::Templates</a></p>

<p><a href="../HTML/FormHandler/Manual/Cookbook.html" class="podlinkpod"
>HTML::FormHandler::Manual::Cookbook</a></p>

<p><a href="../HTML/FormHandler/Manual/Rendering.html" class="podlinkpod"
>HTML::FormHandler::Manual::Rendering</a></p>

<p><a href="../HTML/FormHandler/Manual/Reference.html" class="podlinkpod"
>HTML::FormHandler::Manual::Reference</a></p>

<p><a href="../HTML/FormHandler/Field.html" class="podlinkpod"
>HTML::FormHandler::Field</a></p>

<p><a href="../HTML/FormHandler/Model/DBIC.html" class="podlinkpod"
>HTML::FormHandler::Model::DBIC</a></p>

<p><a href="../HTML/FormHandler/Render/Simple.html" class="podlinkpod"
>HTML::FormHandler::Render::Simple</a></p>

<p><a href="../HTML/FormHandler/Render/Table.html" class="podlinkpod"
>HTML::FormHandler::Render::Table</a></p>

<p><a href="../HTML/FormHandler/Moose.html" class="podlinkpod"
>HTML::FormHandler::Moose</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CONTRIBUTORS"
>CONTRIBUTORS</a></h1>

<p>gshank: Gerda Shank &#60;gshank@cpan.org&#62;</p>

<p>zby: Zbigniew Lukasiak &#60;zby@cpan.org&#62;</p>

<p>t0m: Tomas Doran &#60;bobtfish@bobtfish.net&#62;</p>

<p>augensalat: Bernhard Graf &#60;augensalat@gmail.com&#62;</p>

<p>cubuanic: Oleg Kostyuk &#60;cub.uanic@gmail.com&#62;</p>

<p>rafl: Florian Ragwitz &#60;rafl@debian.org&#62;</p>

<p>mazpe: Lester Ariel Mesa</p>

<p>dew: Dan Thomas</p>

<p>koki: Klaus Ita</p>

<p>jnapiorkowski: John Napiorkowski</p>

<p>lestrrat: Daisuke Maki</p>

<p>hobbs: Andrew Rodland</p>

<p>Andy Clayton</p>

<p>boghead: Bryan Beeley</p>

<p>Csaba Hetenyi</p>

<p>Eisuke Oishi</p>

<p>Lian Wan Situ</p>

<p>Murray</p>

<p>Nick Logan</p>

<p>Vladimir Timofeev</p>

<p>diegok: Diego Kuperman</p>

<p>ijw: Ian Wells</p>

<p>amiri: Amiri Barksdale</p>

<p>ozum: Ozum Eldogan</p>

<p>lukast: Lukas Thiemeier</p>

<p>Initially based on the source code of <a href="../Form/Processor.html" class="podlinkpod"
>Form::Processor</a> by Bill Moseley</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>FormHandler Contributors - see HTML::FormHandler</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>This software is copyright (c) 2013 by Gerda Shank.</p>

<p>This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
