<html><head><title>Class::XSAccessor::Array</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:03 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#OPTIONS'>OPTIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#replace'>replace</a>
    <li class='indexItem indexItem2'><a href='#chained'>chained</a>
    <li class='indexItem indexItem2'><a href='#class'>class</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#LVALUES'>LVALUES</a>
  <li class='indexItem indexItem1'><a href='#CAVEATS'>CAVEATS</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Class::XSAccessor::Array - Generate fast XS accessors without runtime compilation</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  package MyClassUsingArraysAsInternalStorage;
  use Class::XSAccessor::Array
    constructor =&#62; &#39;new&#39;,
    getters =&#62; {
      get_foo =&#62; 0, # 0 is the array index to access
      get_bar =&#62; 1,
    },
    setters =&#62; {
      set_foo =&#62; 0,
      set_bar =&#62; 1,
    },
    accessors =&#62; { # a mutator
      buz =&#62; 2,
    },
    predicates =&#62; { # test for definedness
      has_buz =&#62; 2,
    },
    lvalue_accessors =&#62; { # see below
      baz =&#62; 3,
    },
    true =&#62; [ &#39;is_token&#39;, &#39;is_whitespace&#39; ],
    false =&#62; [ &#39;significant&#39; ];
  
  # The imported methods are implemented in fast XS.
  
  # normal class code here.</pre>

<p>As of version 1.05, some alternative syntax forms are available:</p>

<pre>  package MyClass;
  
  # Options can be passed as a HASH reference if you prefer it,
  # which can also help PerlTidy to flow the statement correctly.
  use Class::XSAccessor {
    getters =&#62; {
      get_foo =&#62; 0,
      get_bar =&#62; 1,
    },
  };</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>The module implements fast XS accessors both for getting at and setting an object attribute. Additionally, the module supports mutators and simple predicates (<code>has_foo()</code> like tests for definedness of an attributes). The module works only with objects that are implemented as <b>arrays</b>. Using it on hash-based objects is bound to make your life miserable. Refer to <a href="../../Class/XSAccessor.html" class="podlinkpod"
>Class::XSAccessor</a> for an implementation that works with hash-based objects.</p>

<p>A simple benchmark showed a significant performance advantage over writing accessors in Perl.</p>

<p>Since version 0.10, the module can also generate simple constructors (implemented in XS) for you. Simply supply the <code>constructor =&#62; &#39;constructor_name&#39;</code> option or the <code>constructors =&#62; [&#39;new&#39;, &#39;create&#39;, &#39;spawn&#39;]</code> option. These constructors do the equivalent of the following Perl code:</p>

<pre>  sub new {
    my $class = shift;
    return bless [], ref($class)||$class;
  }</pre>

<p>That means they can be called on objects and classes but will not clone objects entirely. Note that any parameters to new() will be discarded! If there is a better idiom for array-based objects, let me know.</p>

<p>While generally more obscure than hash-based objects, objects using blessed arrays as internal representation are a bit faster as its somewhat faster to access arrays than hashes. Accordingly, this module is slightly faster (~10-15%) than <a href="../../Class/XSAccessor.html" class="podlinkpod"
>Class::XSAccessor</a>, which works on hash-based objects.</p>

<p>The method names may be fully qualified. In the example of the synopsis, you could have written <code>MyClass::get_foo</code> instead of <code>get_foo</code>. This way, you can install methods in classes other than the current class. See also: The <code>class</code> option below.</p>

<p>Since version 1.01, you can generate extremely simple methods which just return true or false (and always do so). If that seems like a really superfluous thing to you, then think of a large class hierarchy with interfaces such as PPI. This is implemented as the <code>true</code> and <code>false</code> options, see synopsis.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="OPTIONS"
>OPTIONS</a></h1>

<p>In addition to specifying the types and names of accessors, you can add options which modify behaviour. The options are specified as key/value pairs just as the accessor declaration. Example:</p>

<pre>  use Class::XSAccessor::Array
    getters =&#62; {
      get_foo =&#62; 0,
    },
    replace =&#62; 1;</pre>

<p>The list of available options is:</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="replace"
>replace</a></h2>

<p>Set this to a true value to prevent <code>Class::XSAccessor::Array</code> from complaining about replacing existing subroutines.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="chained"
>chained</a></h2>

<p>Set this to a true value to change the return value of setters and mutators (when called with an argument). If <code>chained</code> is enabled, the setters and accessors/mutators will return the object. Mutators called without an argument still return the value of the associated attribute.</p>

<p>As with the other options, <code>chained</code> affects all methods generated in the same <code>use Class::XSAccessor::Array ...</code> statement.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="class"
>class</a></h2>

<p>By default, the accessors are generated in the calling class. Using the <code>class</code> option, you can explicitly specify where the methods are to be generated.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LVALUES"
>LVALUES</a></h1>

<p>Support for lvalue accessors via the keyword <code>lvalue_accessors</code> was added in version 1.08. At this point, <b>THEY ARE CONSIDERED HIGHLY EXPERIMENTAL</b>. Furthermore, their performance hasn&#39;t been benchmarked yet.</p>

<p>The following example demonstrates an lvalue accessor:</p>

<pre>  package Address;
  use Class::XSAccessor
    constructor =&#62; &#39;new&#39;,
    lvalue_accessors =&#62; { zip_code =&#62; 0 };
  
  package main;
  my $address = Address-&#62;new(2);
  print $address-&#62;zip_code, &#34;\n&#34;; # prints 2
  $address-&#62;zip_code = 76135; # &#60;--- This is it!
  print $address-&#62;zip_code, &#34;\n&#34;; # prints 76135</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CAVEATS"
>CAVEATS</a></h1>

<p>Probably wouldn&#39;t work if your objects are <i>tied</i>. But that&#39;s a strange thing to do anyway.</p>

<p>Scary code exploiting strange XS features.</p>

<p>If you think writing an accessor in XS should be a laughably simple exercise, then please contemplate how you could instantiate a new XS accessor for a new hash key or array index that&#39;s only known at run-time. Note that compiling C code at run-time a la Inline::C is a no go.</p>

<p>Threading. With version 1.00, a memory leak has been <b>fixed</b> that would leak a small amount of memory if you loaded <code>Class::XSAccessor</code>-based classes in a subthread that hadn&#39;t been loaded in the &#34;main&#34; thread before. If the subthread then terminated, a hash key and an int per associated method used ot be lost. Note that this mattered only if classes were <b>only</b> loaded in a sort of throw-away thread.</p>

<p>In the new implementation as of 1.00, the memory will not be released again either in the above situation. But it will be recycled when the same class or a similar class is loaded again in <b>any</b> thread.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../../Class/XSAccessor.html" class="podlinkpod"
>Class::XSAccessor</a></p>

<p><a href="../../AutoXS.html" class="podlinkpod"
>AutoXS</a></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Steffen Mueller &#60;smueller@cpan.org&#62;</p>

<p>chocolateboy &#60;chocolate@cpan.org&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>Copyright (C) 2008, 2009, 2010, 2011, 2012 by Steffen Mueller</p>

<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself, either Perl version 5.8 or, at your option, any later version of Perl 5 you may have available.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
