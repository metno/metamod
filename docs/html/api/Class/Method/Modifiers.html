<html><head><title>Class::Method::Modifiers</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../../_grygrnw.css" media="all" >

<script type="text/javascript" src="../../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:03 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#MODIFIERS'>MODIFIERS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#before_method(s)_%3D%3E_sub_%7B_..._%7D'>before method(s) =&#62; sub { ... }</a>
    <li class='indexItem indexItem2'><a href='#after_method(s)_%3D%3E_sub_%7B_..._%7D'>after method(s) =&#62; sub { ... }</a>
    <li class='indexItem indexItem2'><a href='#around_method(s)_%3D%3E_sub_%7B_..._%7D'>around method(s) =&#62; sub { ... }</a>
    <li class='indexItem indexItem2'><a href='#fresh_method(s)_%3D%3E_sub_%7B_..._%7D%3B'>fresh method(s) =&#62; sub { ... };</a>
    <li class='indexItem indexItem2'><a href='#install_modifier_%24package%2C_%24type%2C_%40names%2C_sub_%7B_..._%7D'>install_modifier $package, $type, @names, sub { ... }</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#NOTES'>NOTES</a>
  <li class='indexItem indexItem1'><a href='#CAVEATS'>CAVEATS</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#ACKNOWLEDGEMENTS'>ACKNOWLEDGEMENTS</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Class::Method::Modifiers - provides Moose-like method modifiers</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>    package Child;
    use parent &#39;Parent&#39;;
    use Class::Method::Modifiers;

    sub new_method { }

    before &#39;old_method&#39; =&#62; sub {
        carp &#34;old_method is deprecated, use new_method&#34;;
    };

    around &#39;other_method&#39; =&#62; sub {
        my $orig = shift;
        my $ret = $orig-&#62;(@_);
        return $ret =~ /\d/ ? $ret : lc $ret;
    };

    after &#39;private&#39;, &#39;protected&#39; =&#62; sub {
        debug &#34;finished calling a dangerous method&#34;;
    };

    use Class::Method::Modifiers qw(fresh);

    fresh &#39;not_in_hierarchy&#39; =&#62; sub {
        warn &#34;freshly added method\n&#34;;
    };</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Method modifiers are a convenient feature from the CLOS (Common Lisp Object System) world.</p>

<p>In its most basic form, a method modifier is just a method that calls <code>$self-&#62;SUPER::foo(@_)</code>. I for one have trouble remembering that exact invocation, so my classes seldom re-dispatch to their base classes. Very bad!</p>

<p><code>Class::Method::Modifiers</code> provides three modifiers: <code>before</code>, <code>around</code>, and <code>after</code>. <code>before</code> and <code>after</code> are run just before and after the method they modify, but can not really affect that original method. <code>around</code> is run in place of the original method, with a hook to easily call that original method. See the <code>MODIFIERS</code> section for more details on how the particular modifiers work.</p>

<p>One clear benefit of using <code>Class::Method::Modifiers</code> is that you can define multiple modifiers in a single namespace. These separate modifiers don&#39;t need to know about each other. This makes top-down design easy. Have a base class that provides the skeleton methods of each operation, and have plugins modify those methods to flesh out the specifics.</p>

<p>Parent classes need not know about <code>Class::Method::Modifiers</code>. This means you should be able to modify methods in <i>any</i> subclass. See <a href="../../Term/VT102/ZeroBased.html" class="podlinkpod"
>Term::VT102::ZeroBased</a> for an example of subclassing with CMM.</p>

<p>In short, <code>Class::Method::Modifiers</code> solves the problem of making sure you call <code>$self-&#62;SUPER::foo(@_)</code>, and provides a cleaner interface for it.</p>

<p>As of version 1.00, <code>Class::Method::Modifiers</code> is faster in some cases than <a href="../../Moose.html" class="podlinkpod"
>Moose</a>. See <code>benchmark/method_modifiers.pl</code> in the <a href="../../Moose.html" class="podlinkpod"
>Moose</a> distribution.</p>

<p><code>Class::Method::Modifiers</code> also provides an additional &#34;modifier&#34; type, <code>fresh</code>; see below.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="MODIFIERS"
>MODIFIERS</a></h1>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="before_method(s)_=&#62;_sub_{_..._}"
>before method(s) =&#62; sub { ... }</a></h2>

<p><code>before</code> is called before the method it is modifying. Its return value is totally ignored. It receives the same <code>@_</code> as the the method it is modifying would have received. You can modify the <code>@_</code> the original method will receive by changing <code>$_[0]</code> and friends (or by changing anything inside a reference). This is a feature!</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="after_method(s)_=&#62;_sub_{_..._}"
>after method(s) =&#62; sub { ... }</a></h2>

<p><code>after</code> is called after the method it is modifying. Its return value is totally ignored. It receives the same <code>@_</code> as the the method it is modifying received, mostly. The original method can modify <code>@_</code> (such as by changing <code>$_[0]</code> or references) and <code>after</code> will see the modified version. If you don&#39;t like this behavior, specify both a <code>before</code> and <code>after</code>, and copy the <code>@_</code> during <code>before</code> for <code>after</code> to use.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="around_method(s)_=&#62;_sub_{_..._}"
>around method(s) =&#62; sub { ... }</a></h2>

<p><code>around</code> is called instead of the method it is modifying. The method you&#39;re overriding is passed in as the first argument (called <code>$orig</code> by convention). Watch out for contextual return values of <code>$orig</code>.</p>

<p>You can use <code>around</code> to:</p>

<dl>
<dt><a name="Pass_$orig_a_different_@_"
>Pass <code>$orig</code> a different <code>@_</code></a></dt>

<dd>
<pre>    around &#39;method&#39; =&#62; sub {
        my $orig = shift;
        my $self = shift;
        $orig-&#62;($self, reverse @_);
    };</pre>

<dt><a name="Munge_the_return_value_of_$orig"
>Munge the return value of <code>$orig</code></a></dt>

<dd>
<pre>    around &#39;method&#39; =&#62; sub {
        my $orig = shift;
        ucfirst $orig-&#62;(@_);
    };</pre>

<dt><a name="Avoid_calling_$orig_--_conditionally"
>Avoid calling <code>$orig</code> -- conditionally</a></dt>

<dd>
<pre>    around &#39;method&#39; =&#62; sub {
        my $orig = shift;
        return $orig-&#62;(@_) if time() % 2;
        return &#34;no dice, captain&#34;;
    };</pre>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="fresh_method(s)_=&#62;_sub_{_..._};"
>fresh method(s) =&#62; sub { ... };</a></h2>

<p>Unlike the other modifiers, this does not modify an existing method. Ordinarily, <code>fresh</code> merely installs the coderef as a method in the appropriate class; but if the class hierarchy already contains a method of the same name, an exception is thrown. The idea of this &#34;modifier&#34; is to increase safety when subclassing. Suppose you&#39;re writing a subclass of a class Some::Base, and adding a new method:</p>

<pre>    package My::SubclassOf::C;
    use base &#39;Some::Base&#39;;

    sub foo { ... }</pre>

<p>If a later version of Some::Base also adds a new method named <code>foo</code>, your method will shadow that method. Alternatively, you can use <code>fresh</code> to install the additional method into your subclass:</p>

<pre>    package My::SubclassOf::C;
    use base &#39;Some::Base&#39;;

    use Class::Method::Modifiers &#39;fresh&#39;;

    fresh &#39;foo&#39; =&#62; sub { ... };</pre>

<p>Now upgrading Some::Base to a version with a conflicting <code>foo</code> method will cause an exception to be thrown; seeing that error will give you the opportunity to fix the problem (perhaps by picking a different method name in your subclass, or similar).</p>

<p>Creating fresh methods with <code>install_modifier</code> (see below) provides a way to get similar safety benefits when adding local monkeypatches to existing classes; see <a href="http://aaroncrane.co.uk/talks/monkey_patching_subclassing/" class="podlinkurl"
>http://aaroncrane.co.uk/talks/monkey_patching_subclassing/</a>.</p>

<p>For API compatibility reasons, this function is exported only when you ask for it specifically, or for <code>:all</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="install_modifier_$package,_$type,_@names,_sub_{_..._}"
>install_modifier $package, $type, @names, sub { ... }</a></h2>

<p><code>install_modifier</code> is like <code>before</code>, <code>after</code>, <code>around</code>, and <code>fresh</code> but it also lets you dynamically select the modifier type (&#39;before&#39;, &#39;after&#39;, &#39;around&#39;, &#39;fresh&#39;) and package that the method modifiers are installed into. This expert-level function is exported only when you ask for it specifically, or for <code>:all</code>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NOTES"
>NOTES</a></h1>

<p>All three normal modifiers; <code>before</code>, <code>after</code>, and <code>around</code>; are exported into your namespace by default. You may <code>use Class::Method::Modifiers ()</code> to avoid thrashing your namespace. I may steal more features from <a href="../../Moose.html" class="podlinkpod"
>Moose</a>, namely <code>super</code>, <code>override</code>, <code>inner</code>, <code>augment</code>, and whatever the <a href="../../Moose.html" class="podlinkpod"
>Moose</a> folks come up with next.</p>

<p>Note that the syntax and semantics for these modifiers is directly borrowed from <a href="../../Moose.html" class="podlinkpod"
>Moose</a> (the implementations, however, are not).</p>

<p><a href="../../Class/Trigger.html" class="podlinkpod"
>Class::Trigger</a> shares a few similarities with <code>Class::Method::Modifiers</code>, and they even have some overlap in purpose -- both can be used to implement highly pluggable applications. The difference is that <a href="../../Class/Trigger.html" class="podlinkpod"
>Class::Trigger</a> provides a mechanism for easily letting parent classes to invoke hooks defined by other code. <code>Class::Method::Modifiers</code> provides a way of overriding/augmenting methods safely, and the parent class need not know about it.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CAVEATS"
>CAVEATS</a></h1>

<p>It is erroneous to modify a method that doesn&#39;t exist in your class&#39;s inheritance hierarchy. If this occurs, an exception will be thrown when the modifier is defined.</p>

<p>It doesn&#39;t yet play well with <code>caller</code>. There are some todo tests for this. Don&#39;t get your hopes up though!</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>This module was bumped to 1.00 following a complete reimplementation, to indicate breaking backwards compatibility. The &#34;guard&#34; modifier was removed, and the internals are completely different.</p>

<p>The new version is a few times faster with half the code. It&#39;s now even faster than Moose.</p>

<p>Any code that just used modifiers should not change in behavior, except to become more correct. And, of course, faster. :)</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p><a href="../../Class/Method/Modifiers/Fast.html" class="podlinkpod"
>Class::Method::Modifiers::Fast</a> <a href="../../Moose.html" class="podlinkpod"
>Moose</a>, <a href="../../Class/Trigger.html" class="podlinkpod"
>Class::Trigger</a>, <a href="../../Class/MOP/Method/Wrapped.html" class="podlinkpod"
>Class::MOP::Method::Wrapped</a>, <a href="../../MRO/Compat.html" class="podlinkpod"
>MRO::Compat</a>, CLOS</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Shawn M Moore, <code>sartak@gmail.com</code></p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ACKNOWLEDGEMENTS"
>ACKNOWLEDGEMENTS</a></h1>

<p>Thanks to Stevan Little for <a href="../../Moose.html" class="podlinkpod"
>Moose</a>, I would never have known about method modifiers otherwise.</p>

<p>Thanks to Matt Trout and Stevan Little for their advice.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>Copyright 2007-2009 Shawn M Moore.</p>

<p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
