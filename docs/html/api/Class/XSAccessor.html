<html><head><title>Class::XSAccessor</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Tue Mar 25 17:14:03 2014 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#OPTIONS'>OPTIONS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#replace'>replace</a>
    <li class='indexItem indexItem2'><a href='#chained'>chained</a>
    <li class='indexItem indexItem2'><a href='#class'>class</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#LVALUES'>LVALUES</a>
  <li class='indexItem indexItem1'><a href='#CAVEATS'>CAVEATS</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Class::XSAccessor - Generate fast XS accessors without runtime compilation</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>  package MyClass;
  use Class::XSAccessor
    replace     =&#62; 1,   # Replace existing methods (if any)
    constructor =&#62; &#39;new&#39;,
    getters     =&#62; {
      get_foo =&#62; &#39;foo&#39;, # &#39;foo&#39; is the hash key to access
      get_bar =&#62; &#39;bar&#39;,
    },
    setters =&#62; {
      set_foo =&#62; &#39;foo&#39;,
      set_bar =&#62; &#39;bar&#39;,
    },
    accessors =&#62; {
      foo =&#62; &#39;foo&#39;,
      bar =&#62; &#39;bar&#39;,
    },
    predicates =&#62; {
      has_foo =&#62; &#39;foo&#39;,
      has_bar =&#62; &#39;bar&#39;,
    },
    lvalue_accessors =&#62; { # see below
      baz =&#62; &#39;baz&#39;, # ...
    },
    true  =&#62; [ &#39;is_token&#39;, &#39;is_whitespace&#39; ],
    false =&#62; [ &#39;significant&#39; ];
  
  # The imported methods are implemented in fast XS.
  
  # normal class code here.</pre>

<p>As of version 1.05, some alternative syntax forms are available:</p>

<pre>  package MyClass;
  
  # Options can be passed as a HASH reference, if preferred,
  # which can also help Perl::Tidy to format the statement correctly.
  use Class::XSAccessor {
     # If the name =&#62; key values are always identical,
     # the following shorthand can be used.
     accessors =&#62; [ &#39;foo&#39;, &#39;bar&#39; ],
  };</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>Class::XSAccessor implements fast read, write and read/write accessors in XS. Additionally, it can provide predicates such as <code>has_foo()</code> for testing whether the attribute <code>foo</code> is defined in the object. It only works with objects that are implemented as ordinary hashes. <a href="../Class/XSAccessor/Array.html" class="podlinkpod"
>Class::XSAccessor::Array</a> implements the same interface for objects that use arrays for their internal representation.</p>

<p>Since version 0.10, the module can also generate simple constructors (implemented in XS). Simply supply the <code>constructor =&#62; &#39;constructor_name&#39;</code> option or the <code>constructors =&#62; [&#39;new&#39;, &#39;create&#39;, &#39;spawn&#39;]</code> option. These constructors do the equivalent of the following Perl code:</p>

<pre>  sub new {
    my $class = shift;
    return bless { @_ }, ref($class)||$class;
  }</pre>

<p>That means they can be called on objects and classes but will not clone objects entirely. Parameters to <code>new()</code> are added to the object.</p>

<p>The XS accessor methods are between 3 and 4 times faster than typical pure-Perl accessors in some simple benchmarking. The lower factor applies to the potentially slightly obscure <code>sub set_foo_pp {$_[0]-&#62;{foo} = $_[1]}</code>, so if you usually write clear code, a factor of 3.5 speed-up is a good estimate. If in doubt, do your own benchmarking!</p>

<p>The method names may be fully qualified. The example in the synopsis could have been written as <code>MyClass::get_foo</code> instead of <code>get_foo</code>. This way, methods can be installed in classes other than the current class. See also: the <code>class</code> option below.</p>

<p>By default, the setters return the new value that was set, and the accessors (mutators) do the same. This behaviour can be changed with the <code>chained</code> option - see below. The predicates return a boolean.</p>

<p>Since version 1.01, <code>Class::XSAccessor</code> can generate extremely simple methods which just return true or false (and always do so). If that seems like a really superfluous thing to you, then consider a large class hierarchy with interfaces such as <a href="../PPI.html" class="podlinkpod"
>PPI</a>. These methods are provided by the <code>true</code> and <code>false</code> options - see the synopsis.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="OPTIONS"
>OPTIONS</a></h1>

<p>In addition to specifying the types and names of accessors, additional options can be supplied which modify behaviour. The options are specified as key/value pairs in the same manner as the accessor declaration. For example:</p>

<pre>  use Class::XSAccessor
    getters =&#62; {
      get_foo =&#62; &#39;foo&#39;,
    },
    replace =&#62; 1;</pre>

<p>The list of available options is:</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="replace"
>replace</a></h2>

<p>Set this to a true value to prevent <code>Class::XSAccessor</code> from complaining about replacing existing subroutines.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="chained"
>chained</a></h2>

<p>Set this to a true value to change the return value of setters and mutators (when called with an argument). If <code>chained</code> is enabled, the setters and accessors/mutators will return the object. Mutators called without an argument still return the value of the associated attribute.</p>

<p>As with the other options, <code>chained</code> affects all methods generated in the same <code>use Class::XSAccessor ...</code> statement.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="class"
>class</a></h2>

<p>By default, the accessors are generated in the calling class. The the <code>class</code> option allows the target class to be specified.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="LVALUES"
>LVALUES</a></h1>

<p>Support for lvalue accessors via the keyword <code>lvalue_accessors</code> was added in version 1.08. At this point, <b>THEY ARE CONSIDERED HIGHLY EXPERIMENTAL</b>. Furthermore, their performance hasn&#39;t been benchmarked yet.</p>

<p>The following example demonstrates an lvalue accessor:</p>

<pre>  package Address;
  use Class::XSAccessor
    constructor =&#62; &#39;new&#39;,
    lvalue_accessors =&#62; { zip_code =&#62; &#39;zip&#39; };
  
  package main;
  my $address = Address-&#62;new(zip =&#62; 2);
  print $address-&#62;zip_code, &#34;\n&#34;; # prints 2
  $address-&#62;zip_code = 76135; # &#60;--- This is it!
  print $address-&#62;zip_code, &#34;\n&#34;; # prints 76135</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CAVEATS"
>CAVEATS</a></h1>

<p>Probably won&#39;t work for objects based on <i>tied</i> hashes. But that&#39;s a strange thing to do anyway.</p>

<p>Scary code exploiting strange XS features.</p>

<p>If you think writing an accessor in XS should be a laughably simple exercise, then please contemplate how you could instantiate a new XS accessor for a new hash key that&#39;s only known at run-time. Note that compiling C code at run-time a la <a href="../Inline/C.html" class="podlinkpod"
>Inline::C</a> is a no go.</p>

<p>Threading. With version 1.00, a memory leak has been <b>fixed</b>. Previously, a small amount of memory would leak if <code>Class::XSAccessor</code>-based classes were loaded in a subthread without having been loaded in the &#34;main&#34; thread. If the subthread then terminated, a hash key and an int per associated method used to be lost. Note that this mattered only if classes were <b>only</b> loaded in a sort of throw-away thread.</p>

<p>In the new implementation, as of 1.00, the memory will still not be released, in the same situation, but it will be recycled when the same class, or a similar class, is loaded again in <b>any</b> thread.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<ul>
<li><a href="../Class/XSAccessor/Array.html" class="podlinkpod"
>Class::XSAccessor::Array</a></li>

<li><a href="../AutoXS.html" class="podlinkpod"
>AutoXS</a></li>
</ul>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Steffen Mueller &#60;smueller@cpan.org&#62;</p>

<p>chocolateboy &#60;chocolate@cpan.org&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>Copyright (C) 2008, 2009, 2010, 2011, 2012 by Steffen Mueller</p>

<p>This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself, either Perl version 5.8 or, at your option, any later version of Perl 5 you may have available.</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
